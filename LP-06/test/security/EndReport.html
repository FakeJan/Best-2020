<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ZAP Scanning Report</title>
<link
	href="2022-01-09-ZAP-Report-3/normalize/normalize.css" rel="stylesheet">
<link
	href="2022-01-09-ZAP-Report-3/themes/original/main.css" rel="stylesheet">
<link
	href="2022-01-09-ZAP-Report-3/themes/original/colors.css" rel="stylesheet">
</head>
<body>
	<header>
		<h1>ZAP Scanning Report</h1>
		<p>
			<span>Generated with</span> <a href="https://zaproxy.org"><img
				src="2022-01-09-ZAP-Report-3/zap32x32.png" alt="The ZAP logo" class="zap-logo">ZAP</a>
			<span>on Sun 9 Jan 2022, at 00:39:29</span>
		</p>
	</header>

	<main>

		<section id="contents" class="contents">
			<h2>Contents</h2>
			<nav>
				<ol>
					<li><a
						href="#about-this-report">About this report</a>
						<ol>
							
							<li><a
								href="#report-parameters">Report parameters</a></li>
						</ol></li>
					<data-th-block>
					<li><a
						href="#summaries">Summaries</a>
						<ol>
							<li><a
								href="#risk-confidence-counts">Alert counts by risk and confidence</a></li>
							<li><a
								href="#site-risk-counts">Alert counts by site and risk</a></li>
							<li><a
								href="#alert-type-counts">Alert counts by alert type</a></li>
						</ol></li>
					<li><a
						href="#alerts">Alerts</a>
						<ol>
							
							 
							 
							
							
							
							
							
							
							<li><a
								href="#alerts--risk-1-confidence-2"><span>Risk</span>=<span
									class="risk-level">Low</span>, <span>Confidence</span>=<span
									class="confidence-level">Medium</span> <span>(12)</span></a></li>
							
							<li><a
								href="#alerts--risk-1-confidence-1"><span>Risk</span>=<span
									class="risk-level">Low</span>, <span>Confidence</span>=<span
									class="confidence-level">Low</span> <span>(8)</span></a></li>
							  
							
							
							
							
							
							
							<li><a
								href="#alerts--risk-0-confidence-2"><span>Risk</span>=<span
									class="risk-level">Informational</span>, <span>Confidence</span>=<span
									class="confidence-level">Medium</span> <span>(1)</span></a></li>
							
							<li><a
								href="#alerts--risk-0-confidence-1"><span>Risk</span>=<span
									class="risk-level">Informational</span>, <span>Confidence</span>=<span
									class="confidence-level">Low</span> <span>(11)</span></a></li>
							  
						</ol></li>
					<li><a
						href="#appendix">Appendix</a>
						<ol>
							<li><a
								href="#alert-types">Alert types</a></li>
						</ol></li>
					</data-th-block>
				</ol>
			</nav>
		</section>

		<section
			id="about-this-report" class="about-this-report">
			<h2>About this report</h2>

			

			<section
				id="report-parameters">
				<h3>Report parameters</h3>
				<div class="report-parameters--container">
					<h4>Contexts</h4>
					
					
					<p>No contexts were selected, so all contexts were included by default.</p>
					  

					<h4>Sites</h4>
					
					<p>The following sites were included:</p>
					<ul class="sites-list">
						<li><span class="site">https://api.mapbox.com</span></li>
						<li><span class="site">http://localhost:3000</span></li>
					</ul>
					
					<p>(If no sites were selected, all sites were included by default.)</p>
					<p>An included site must also be within one of the included contexts for its data to be included in the report.</p>

					<h4>Risk levels</h4>
					<p>
						<span>Included</span>:
						 
						<span class="included-risk-codes"><span class="risk-level">High</span>, <span class="risk-level">Medium</span>, <span class="risk-level">Low</span>, <span class="risk-level">Informational</span></span>
					</p>
					<p>
						<span>Excluded</span>:
						 <span>None</span>
						
					</p>

					<h4>Confidence levels</h4>
					<p>
						<span>Included</span>:
						
						
						<span class="included-confidence-codes"><span class="confidence-level">User Confirmed</span>, <span class="confidence-level">High</span>, <span class="confidence-level">Medium</span>, <span class="confidence-level">Low</span></span>
					</p>
					<p>
						<span>Excluded</span>:
						
						
						<span class="included-confidence-codes"> <span class="confidence-level">User Confirmed</span>, <span class="confidence-level">High</span>, <span class="confidence-level">Medium</span>, <span class="confidence-level">Low</span>, <span class="confidence-level">False Positive</span></span>
					</p>
				</div>
			</section>
		</section>

		
		<section>
			
		</section>
		
		<section id="summaries" class="summaries">
			<h2>Summaries</h2>

			<section
				id="risk-confidence-counts">
				<h3>Alert counts by risk and confidence</h3>
				<table class="risk-confidence-counts-table">
					<caption>
						<p>This table shows the number of alerts for each level of risk and confidence included in the report.</p>
						<p>(The percentages in brackets represent the count as a percentage of the total number of alerts included in the report, rounded to one decimal place.)</p>
					</caption>
					<colgroup>
						<col>
						<col>
					</colgroup>
					<colgroup>
						<col
							style="width: 14.0%"><col
							style="width: 14.0%"><col
							style="width: 14.0%"><col
							style="width: 14.0%">
						<col style="width: 14.0%">
					</colgroup>
					<thead>
						<tr>
							<td colspan="2" rowspan="2"></td>
							<th scope="colgroup"
								colspan="5">Confidence</th>
						</tr>
						<tr>
							<th scope="col">User Confirmed</th>
							<th scope="col">High</th>
							<th scope="col">Medium</th>
							<th scope="col">Low</th>
							<th scope="col">Total</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<th scope="rowgroup"
								rowspan="5">Risk</th>
							<th scope="row">High</th>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span class="additional-info-percentages">(0.0%)</span></td>
						</tr>
						<tr>
							
							<th scope="row">Medium</th>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span class="additional-info-percentages">(0.0%)</span></td>
						</tr>
						<tr>
							
							<th scope="row">Low</th>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>12</span><br> <span
								class="additional-info-percentages">(37.5%)</span></td>
							<td><span>8</span><br> <span
								class="additional-info-percentages">(25.0%)</span></td>
							<td><span>20</span><br> <span class="additional-info-percentages">(62.5%)</span></td>
						</tr>
						<tr>
							
							<th scope="row">Informational</th>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>1</span><br> <span
								class="additional-info-percentages">(3.1%)</span></td>
							<td><span>11</span><br> <span
								class="additional-info-percentages">(34.4%)</span></td>
							<td><span>12</span><br> <span class="additional-info-percentages">(37.5%)</span></td>
						</tr>
						<tr>
							<th scope="row">Total</th>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0.0%)</span></td>
							<td><span>13</span><br> <span
								class="additional-info-percentages">(40.6%)</span></td>
							<td><span>19</span><br> <span
								class="additional-info-percentages">(59.4%)</span></td>
							<td><span>32</span><br> <span
								class="additional-info-percentages">(100%)</span></td>
						</tr>
					</tbody>
				</table>
			</section>

			<section
				id="site-risk-counts">
				<h3>Alert counts by site and risk</h3>
				<table class="site-risk-counts-table">
					<caption>
						<p>This table shows, for each site for which one or more alerts were raised, the number of alerts raised at each risk level.</p>
						<p>Alerts with a confidence level of &quot;False Positive&quot; have been excluded from these counts.</p>
						<p>(The numbers in brackets are the number of alerts raised for the site at or above that risk level.)</p>
					</caption>
					<colgroup>
						<col>
						<col>
					</colgroup>
					<colgroup>
						<col
							style="width: 16.25%"><col
							style="width: 16.25%"><col
							style="width: 16.25%"><col
							style="width: 16.25%">
					</colgroup>
					<thead>
						<tr>
							<td colspan="2" rowspan="2"></td>
							<th scope="colgroup" colspan="4">Risk</th>
						</tr>
						<tr>
							<th scope="col">
								<span>High</span><br>  <span
									class="additional-info-percentages">(= High)</span>  
							</th>
							<th scope="col">
								<span>Medium</span><br>   <span
									class="additional-info-percentages">(&gt;= Medium)</span> 
							</th>
							<th scope="col">
								<span>Low</span><br>   <span
									class="additional-info-percentages">(&gt;= Low)</span> 
							</th>
							<th scope="col">
								<span>Informational</span><br>   <span
									class="additional-info-percentages">(&gt;= Informational)</span> 
							</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<th scope="rowgroup"
								rowspan="1">Site</th>
							<th scope="row">http://localhost:3000</th>
							
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0)</span></td>
							<td><span>0</span><br> <span
								class="additional-info-percentages">(0)</span></td>
							<td><span>20</span><br> <span
								class="additional-info-percentages">(20)</span></td>
							<td><span>12</span><br> <span
								class="additional-info-percentages">(32)</span></td>
							
						</tr>
					</tbody>
				</table>
			</section>

			<section
				id="alert-type-counts">
				<h3>Alert counts by alert type</h3>
				<table class="alert-type-counts-table">
					<caption>
						<p>This table shows the number of alerts of each alert type, together with the alert type&#39;s risk level.</p>
						<p>(The percentages in brackets represent each count as a percentage, rounded to one decimal place, of the total number of alerts included in this report.)</p>
					</caption>
					<thead>
						<tr>
							<th scope="col">Alert type</th>
							<th scope="col">Risk</th>
							<th scope="col">Count</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<th scope="row"><a
								href="#alert-type-0">Cross-Domain JavaScript Source File Inclusion</a></th>
							<td class="risk-level">Low</td>
							<td><span>12</span><br> <span
								class="additional-info-percentages">(37.5%)</span></td>
						</tr>
						<tr>
							<th scope="row"><a
								href="#alert-type-1">Timestamp Disclosure - Unix</a></th>
							<td class="risk-level">Low</td>
							<td><span>8</span><br> <span
								class="additional-info-percentages">(25.0%)</span></td>
						</tr>
						<tr>
							<th scope="row"><a
								href="#alert-type-2">Information Disclosure - Sensitive Information in URL</a></th>
							<td class="risk-level">Informational</td>
							<td><span>1</span><br> <span
								class="additional-info-percentages">(3.1%)</span></td>
						</tr>
						<tr>
							<th scope="row"><a
								href="#alert-type-3">Information Disclosure - Suspicious Comments</a></th>
							<td class="risk-level">Informational</td>
							<td><span>11</span><br> <span
								class="additional-info-percentages">(34.4%)</span></td>
						</tr>
					</tbody>
					<tfoot>
						<tr>
							<th scope="row">Total</th>
							<td></td>
							<td>32</td>
						</tr>
					</tfoot>
				</table>
			</section>
		</section>

		<section id="alerts" class="alerts">
			<h2>Alerts</h2>
			<ol>
				
				 
				 
				 
				
				
				
				
				<li id="alerts--risk-1-confidence-2">
					<h3>
						<span>Risk</span>=<span
							class="risk-level">Low</span>, <span>Confidence</span>=<span
							class="confidence-level">Medium</span> <span>(12)</span>
					</h3>
					<ol>
						
						<li class="alerts--site-li">
							<h4>
								<span class="site">http://localhost:3000</span> <span>(12)</span>
							</h4>
							<ol>
								
								<li>
									<h5>
										<a
											href="#alert-type-0">Cross-Domain JavaScript Source File Inclusion</a> <span>(12)</span>
									</h5>
									<ol>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (438 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:37:51 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (438 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:37:51 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/index.html</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (364 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/index.html HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Referer: https://localhost:3000/ngsw-worker.js
Connection: keep-alive
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/index.html</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (364 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/index.html HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Referer: https://localhost:3000/ngsw-worker.js
Connection: keep-alive
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/index.html?ngsw-cache-bust=0.6599526791746044</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (399 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/index.html?ngsw-cache-bust=0.6599526791746044 HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Referer: https://localhost:3000/ngsw-worker.js
Connection: keep-alive
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/index.html?ngsw-cache-bust=0.6599526791746044</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (399 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/index.html?ngsw-cache-bust=0.6599526791746044 HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Referer: https://localhost:3000/ngsw-worker.js
Connection: keep-alive
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/index.html?ngsw-cache-bust=0.9871358339084383</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (399 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/index.html?ngsw-cache-bust=0.9871358339084383 HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Referer: https://localhost:3000/ngsw-worker.js
Connection: keep-alive
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:38:30 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/index.html?ngsw-cache-bust=0.9871358339084383</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (399 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/index.html?ngsw-cache-bust=0.9871358339084383 HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Referer: https://localhost:3000/ngsw-worker.js
Connection: keep-alive
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:38:30 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/robots.txt</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (206 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/robots.txt HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:39:01 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/robots.txt</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (206 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/robots.txt HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:39:01 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/sitemap.xml</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (207 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/sitemap.xml HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:39:01 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/sitemap.xml</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/">OWASP_2021_A08</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The page includes one or more script files from a third-party domain.</p>
 </td>
	</tr>
	
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (207 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/sitemap.xml HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:39:01 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Ensure JavaScript source files are loaded from only trusted sources, and the sources can&#39;t be controlled by end users of the application.</p>
 </td>
	</tr>
</table>

											</details></li>
									</ol>
								</li>
								
							</ol>
						</li>
						
					</ol>
				</li>
				
				<li id="alerts--risk-1-confidence-1">
					<h3>
						<span>Risk</span>=<span
							class="risk-level">Low</span>, <span>Confidence</span>=<span
							class="confidence-level">Low</span> <span>(8)</span>
					</h3>
					<ol>
						
						<li class="alerts--site-li">
							<h4>
								<span class="site">http://localhost:3000</span> <span>(8)</span>
							</h4>
							<ol>
								
								<li>
									<h5>
										<a
											href="#alert-type-1">Timestamp Disclosure - Unix</a> <span>(8)</span>
									</h5>
									<ol>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>A timestamp was disclosed by the application/web server - Unix</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>376430187, which evaluates to: 1981-12-05 20:56:27</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>376430187</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>A timestamp was disclosed by the application/web server - Unix</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>503637978, which evaluates to: 1985-12-17 04:26:18</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>503637978</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>A timestamp was disclosed by the application/web server - Unix</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>86400000, which evaluates to: 1972-09-27 01:00:00</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>86400000</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/styles.aed625f13435cbb527ed.css</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>A timestamp was disclosed by the application/web server - Unix</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>00000005, which evaluates to: 1970-01-01 01:00:05</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (389 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/styles.aed625f13435cbb527ed.css HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: text/css,*/*;q=0.1
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: style
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 17:37:48 GMT
ETag: W/&quot;11dde-17e3ac49546&quot;
Content-Type: text/css; charset=UTF-8
Content-Length: 73182
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (73182 bytes)</summary>
				
				<pre><code>.mat-badge-content{font-weight:600;font-size:12px;font-family:Roboto,Helvetica Neue,sans-serif}.mat-badge-small .mat-badge-content{font-size:9px}.mat-badge-large .mat-badge-content{font-size:24px}.mat-h1,.mat-headline,.mat-typography h1{font:400 24px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h2,.mat-title,.mat-typography h2{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h3,.mat-subheading-2,.mat-typography h3{font:400 16px/28px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h4,.mat-subheading-1,.mat-typography h4{font:400 15px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h5,.mat-typography h5{font:400 calc(14px * .83)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-h6,.mat-typography h6{font:400 calc(14px * .67)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-body-2,.mat-body-strong{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body,.mat-body-1,.mat-typography{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body-1 p,.mat-body p,.mat-typography p{margin:0 0 12px}.mat-caption,.mat-small{font:400 12px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-display-4,.mat-typography .mat-display-4{font:300 112px/112px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.05em;margin:0 0 56px}.mat-display-3,.mat-typography .mat-display-3{font:400 56px/56px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.02em;margin:0 0 64px}.mat-display-2,.mat-typography .mat-display-2{font:400 45px/48px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.005em;margin:0 0 64px}.mat-display-1,.mat-typography .mat-display-1{font:400 34px/40px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 64px}.mat-bottom-sheet-container{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button,.mat-stroked-button{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-button-toggle,.mat-card{font-family:Roboto,Helvetica Neue,sans-serif}.mat-card-title{font-size:24px;font-weight:500}.mat-card-header .mat-card-title{font-size:20px}.mat-card-content,.mat-card-subtitle{font-size:14px}.mat-checkbox{font-family:Roboto,Helvetica Neue,sans-serif}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-chip{font-size:14px;font-weight:500}.mat-chip .mat-chip-remove.mat-icon,.mat-chip .mat-chip-trailing-icon.mat-icon{font-size:18px}.mat-table{font-family:Roboto,Helvetica Neue,sans-serif}.mat-header-cell{font-size:12px;font-weight:500}.mat-cell,.mat-footer-cell{font-size:14px}.mat-calendar{font-family:Roboto,Helvetica Neue,sans-serif}.mat-calendar-body{font-size:13px}.mat-calendar-body-label,.mat-calendar-period-button{font-size:14px;font-weight:500}.mat-calendar-table-header th{font-size:11px;font-weight:400}.mat-dialog-title{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-expansion-panel-header{font-family:Roboto,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.mat-expansion-panel-content{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field{font-size:inherit;font-weight:400;line-height:1.125;font-family:Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field-wrapper{padding-bottom:1.34375em}.mat-form-field-prefix .mat-icon,.mat-form-field-suffix .mat-icon{font-size:150%;line-height:1.125}.mat-form-field-prefix .mat-icon-button,.mat-form-field-suffix .mat-icon-button{height:1.5em;width:1.5em}.mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-suffix .mat-icon-button .mat-icon{height:1.125em;line-height:1.125}.mat-form-field-infix{padding:.5em 0;border-top:.84375em solid #0000}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34375em) scale(.75);width:133.3333333333%}.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34374em) scale(.75);width:133.3333433333%}.mat-form-field-label-wrapper{top:-.84375em;padding-top:.84375em}.mat-form-field-label{top:1.34375em}.mat-form-field-underline{bottom:1.34375em}.mat-form-field-subscript-wrapper{font-size:75%;margin-top:.6666666667em;top:calc(100% - 1.7916666667em)}.mat-form-field-appearance-legacy .mat-form-field-wrapper{padding-bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-infix{padding:.4375em 0}.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.001px);-ms-transform:translateY(-1.28125em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00101px);-ms-transform:translateY(-1.28124em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00102px);-ms-transform:translateY(-1.28123em) scale(.75);width:133.3333533333%}.mat-form-field-appearance-legacy .mat-form-field-label{top:1.28125em}.mat-form-field-appearance-legacy .mat-form-field-underline{bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-subscript-wrapper{margin-top:.5416666667em;top:calc(100% - 1.6666666667em)}@media print{.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28122em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28121em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.2812em) scale(.75)}}.mat-form-field-appearance-fill .mat-form-field-infix{padding:.25em 0 .75em}.mat-form-field-appearance-fill .mat-form-field-label{top:1.09375em;margin-top:-.5em}.mat-form-field-appearance-fill.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59374em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-outline .mat-form-field-infix{padding:1em 0}.mat-form-field-appearance-outline .mat-form-field-label{top:1.84375em;margin-top:-.25em}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59374em) scale(.75);width:133.3333433333%}.mat-grid-tile-footer,.mat-grid-tile-header{font-size:14px}.mat-grid-tile-footer .mat-line,.mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}input.mat-input-element{margin-top:-.0625em}.mat-menu-item{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:400}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px}.mat-radio-button,.mat-select{font-family:Roboto,Helvetica Neue,sans-serif}.mat-select-trigger{height:1.125em}.mat-slide-toggle-content,.mat-slider-thumb-label-text{font-family:Roboto,Helvetica Neue,sans-serif}.mat-slider-thumb-label-text{font-size:12px;font-weight:500}.mat-stepper-horizontal,.mat-stepper-vertical{font-family:Roboto,Helvetica Neue,sans-serif}.mat-step-label{font-size:14px;font-weight:400}.mat-step-sub-label-error{font-weight:400}.mat-step-label-error{font-size:14px}.mat-step-label-selected{font-size:14px;font-weight:500}.mat-tab-group,.mat-tab-label,.mat-tab-link{font-family:Roboto,Helvetica Neue,sans-serif}.mat-tab-label,.mat-tab-link{font-size:14px;font-weight:500}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0}.mat-tooltip{font-family:Roboto,Helvetica Neue,sans-serif;font-size:10px;padding-top:6px;padding-bottom:6px}.mat-tooltip-handset{font-size:14px;padding-top:8px;padding-bottom:8px}.mat-list-item,.mat-list-option{font-family:Roboto,Helvetica Neue,sans-serif}.mat-list-base .mat-list-item{font-size:16px}.mat-list-base .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-list-option{font-size:16px}.mat-list-base .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-option .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-list-base[dense] .mat-list-item{font-size:12px}.mat-list-base[dense] .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-list-base[dense] .mat-list-option{font-size:12px}.mat-list-base[dense] .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-option .mat-line:nth-child(n+2){font-size:12px}.mat-list-base[dense] .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;font-weight:500}.mat-option{font-family:Roboto,Helvetica Neue,sans-serif;font-size:16px}.mat-optgroup-label{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-simple-snackbar{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px}.mat-simple-snackbar-action{line-height:1;font-family:inherit;font-size:inherit;font-weight:500}.mat-tree{font-family:Roboto,Helvetica Neue,sans-serif}.mat-nested-tree-node,.mat-tree-node{font-weight:400;font-size:14px}.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale(0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper,.cdk-overlay-pane{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{pointer-events:auto;box-sizing:border-box;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:#00000052}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:initial!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:initial!important;height:0!important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator,.mat-mdc-focus-indicator{position:relative}.mat-ripple-element{background-color:#0000001a}.mat-option{color:#000000de}.mat-option.mat-selected:not(.mat-option-multiple):not(.mat-option-disabled),.mat-option:focus:not(.mat-option-disabled),.mat-option:hover:not(.mat-option-disabled){background:#0000000a}.mat-option.mat-active{background:#0000000a;color:#000000de}.mat-option.mat-option-disabled{color:#00000061}.mat-primary .mat-option.mat-selected:not(.mat-option-disabled){color:#3f51b5}.mat-accent .mat-option.mat-selected:not(.mat-option-disabled){color:#ff4081}.mat-warn .mat-option.mat-selected:not(.mat-option-disabled){color:#f44336}.mat-optgroup-label{color:#0000008a}.mat-optgroup-disabled .mat-optgroup-label{color:#00000061}.mat-pseudo-checkbox{color:#0000008a}.mat-pseudo-checkbox:after{color:#fafafa}.mat-pseudo-checkbox-disabled{color:#b0b0b0}.mat-primary .mat-pseudo-checkbox-checked,.mat-primary .mat-pseudo-checkbox-indeterminate{background:#3f51b5}.mat-accent .mat-pseudo-checkbox-checked,.mat-accent .mat-pseudo-checkbox-indeterminate,.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-indeterminate{background:#ff4081}.mat-warn .mat-pseudo-checkbox-checked,.mat-warn .mat-pseudo-checkbox-indeterminate{background:#f44336}.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background:#b0b0b0}.mat-app-background{background-color:#fafafa;color:#000000de}.mat-elevation-z0{box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-elevation-z1{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-elevation-z2{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-elevation-z3{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-elevation-z4{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-elevation-z5{box-shadow:0 3px 5px -1px #0003,0 5px 8px 0 #00000024,0 1px 14px 0 #0000001f}.mat-elevation-z6{box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-elevation-z7{box-shadow:0 4px 5px -2px #0003,0 7px 10px 1px #00000024,0 2px 16px 1px #0000001f}.mat-elevation-z8{box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-elevation-z9{box-shadow:0 5px 6px -3px #0003,0 9px 12px 1px #00000024,0 3px 16px 2px #0000001f}.mat-elevation-z10{box-shadow:0 6px 6px -3px #0003,0 10px 14px 1px #00000024,0 4px 18px 3px #0000001f}.mat-elevation-z11{box-shadow:0 6px 7px -4px #0003,0 11px 15px 1px #00000024,0 4px 20px 3px #0000001f}.mat-elevation-z12{box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-elevation-z13{box-shadow:0 7px 8px -4px #0003,0 13px 19px 2px #00000024,0 5px 24px 4px #0000001f}.mat-elevation-z14{box-shadow:0 7px 9px -4px #0003,0 14px 21px 2px #00000024,0 5px 26px 4px #0000001f}.mat-elevation-z15{box-shadow:0 8px 9px -5px #0003,0 15px 22px 2px #00000024,0 6px 28px 5px #0000001f}.mat-elevation-z16{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-elevation-z17{box-shadow:0 8px 11px -5px #0003,0 17px 26px 2px #00000024,0 6px 32px 5px #0000001f}.mat-elevation-z18{box-shadow:0 9px 11px -5px #0003,0 18px 28px 2px #00000024,0 7px 34px 6px #0000001f}.mat-elevation-z19{box-shadow:0 9px 12px -6px #0003,0 19px 29px 2px #00000024,0 7px 36px 6px #0000001f}.mat-elevation-z20{box-shadow:0 10px 13px -6px #0003,0 20px 31px 3px #00000024,0 8px 38px 7px #0000001f}.mat-elevation-z21{box-shadow:0 10px 13px -6px #0003,0 21px 33px 3px #00000024,0 8px 40px 7px #0000001f}.mat-elevation-z22{box-shadow:0 10px 14px -6px #0003,0 22px 35px 3px #00000024,0 8px 42px 7px #0000001f}.mat-elevation-z23{box-shadow:0 11px 14px -7px #0003,0 23px 36px 3px #00000024,0 9px 44px 8px #0000001f}.mat-elevation-z24{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-theme-loaded-marker{display:none}.mat-autocomplete-panel{background:#fff;color:#000000de}.mat-autocomplete-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover){background:#fff}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover):not(.mat-option-disabled){color:#000000de}.mat-badge{position:relative}.mat-badge-hidden .mat-badge-content{display:none}.mat-badge-content{position:absolute;text-align:center;display:inline-block;border-radius:50%;transition:transform .2s ease-in-out;transform:scale(.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;pointer-events:none}.mat-badge-content._mat-animation-noopable,.ng-animate-disabled .mat-badge-content{transition:none}.mat-badge-content.mat-badge-active{transform:none}.mat-badge-small .mat-badge-content{width:16px;height:16px;line-height:16px}.mat-badge-small.mat-badge-above .mat-badge-content{top:-8px}.mat-badge-small.mat-badge-below .mat-badge-content{bottom:-8px}.mat-badge-small.mat-badge-before .mat-badge-content{left:-16px}[dir=rtl] .mat-badge-small.mat-badge-before .mat-badge-content{left:auto;right:-16px}.mat-badge-small.mat-badge-after .mat-badge-content{right:-16px}[dir=rtl] .mat-badge-small.mat-badge-after .mat-badge-content{right:auto;left:-16px}.mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-8px}.mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-8px}.mat-badge-medium .mat-badge-content{width:22px;height:22px;line-height:22px}.mat-badge-medium.mat-badge-above .mat-badge-content{top:-11px}.mat-badge-medium.mat-badge-below .mat-badge-content{bottom:-11px}.mat-badge-medium.mat-badge-before .mat-badge-content{left:-22px}[dir=rtl] .mat-badge-medium.mat-badge-before .mat-badge-content{left:auto;right:-22px}.mat-badge-medium.mat-badge-after .mat-badge-content{right:-22px}[dir=rtl] .mat-badge-medium.mat-badge-after .mat-badge-content{right:auto;left:-22px}.mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-11px}.mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-11px}.mat-badge-large .mat-badge-content{width:28px;height:28px;line-height:28px}.mat-badge-large.mat-badge-above .mat-badge-content{top:-14px}.mat-badge-large.mat-badge-below .mat-badge-content{bottom:-14px}.mat-badge-large.mat-badge-before .mat-badge-content{left:-28px}[dir=rtl] .mat-badge-large.mat-badge-before .mat-badge-content{left:auto;right:-28px}.mat-badge-large.mat-badge-after .mat-badge-content{right:-28px}[dir=rtl] .mat-badge-large.mat-badge-after .mat-badge-content{right:auto;left:-28px}.mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-14px}.mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-14px}.mat-badge-content{color:#fff;background:#3f51b5}.cdk-high-contrast-active .mat-badge-content{outline:1px solid;border-radius:0}.mat-badge-accent .mat-badge-content{background:#ff4081;color:#fff}.mat-badge-warn .mat-badge-content{color:#fff;background:#f44336}.mat-badge-disabled .mat-badge-content{background:#b9b9b9;color:#00000061}.mat-bottom-sheet-container{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f;background:#fff;color:#000000de}.mat-button,.mat-icon-button,.mat-stroked-button{color:inherit;background:#0000}.mat-button.mat-primary,.mat-icon-button.mat-primary,.mat-stroked-button.mat-primary{color:#3f51b5}.mat-button.mat-accent,.mat-icon-button.mat-accent,.mat-stroked-button.mat-accent{color:#ff4081}.mat-button.mat-warn,.mat-icon-button.mat-warn,.mat-stroked-button.mat-warn{color:#f44336}.mat-button.mat-accent.mat-button-disabled,.mat-button.mat-button-disabled.mat-button-disabled,.mat-button.mat-primary.mat-button-disabled,.mat-button.mat-warn.mat-button-disabled,.mat-icon-button.mat-accent.mat-button-disabled,.mat-icon-button.mat-button-disabled.mat-button-disabled,.mat-icon-button.mat-primary.mat-button-disabled,.mat-icon-button.mat-warn.mat-button-disabled,.mat-stroked-button.mat-accent.mat-button-disabled,.mat-stroked-button.mat-button-disabled.mat-button-disabled,.mat-stroked-button.mat-primary.mat-button-disabled,.mat-stroked-button.mat-warn.mat-button-disabled{color:#00000042}.mat-button.mat-primary .mat-button-focus-overlay,.mat-icon-button.mat-primary .mat-button-focus-overlay,.mat-stroked-button.mat-primary .mat-button-focus-overlay{background-color:#3f51b5}.mat-button.mat-accent .mat-button-focus-overlay,.mat-icon-button.mat-accent .mat-button-focus-overlay,.mat-stroked-button.mat-accent .mat-button-focus-overlay{background-color:#ff4081}.mat-button.mat-warn .mat-button-focus-overlay,.mat-icon-button.mat-warn .mat-button-focus-overlay,.mat-stroked-button.mat-warn .mat-button-focus-overlay{background-color:#f44336}.mat-button.mat-button-disabled .mat-button-focus-overlay,.mat-icon-button.mat-button-disabled .mat-button-focus-overlay,.mat-stroked-button.mat-button-disabled .mat-button-focus-overlay{background-color:initial}.mat-button .mat-ripple-element,.mat-icon-button .mat-ripple-element,.mat-stroked-button .mat-ripple-element{opacity:.1;background-color:currentColor}.mat-button-focus-overlay{background:#000}.mat-stroked-button:not(.mat-button-disabled){border-color:#0000001f}.mat-fab,.mat-flat-button,.mat-mini-fab,.mat-raised-button{color:#000000de;background-color:#fff}.mat-fab.mat-accent,.mat-fab.mat-primary,.mat-fab.mat-warn,.mat-flat-button.mat-accent,.mat-flat-button.mat-primary,.mat-flat-button.mat-warn,.mat-mini-fab.mat-accent,.mat-mini-fab.mat-primary,.mat-mini-fab.mat-warn,.mat-raised-button.mat-accent,.mat-raised-button.mat-primary,.mat-raised-button.mat-warn{color:#fff}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{color:#00000042}.mat-fab.mat-primary,.mat-flat-button.mat-primary,.mat-mini-fab.mat-primary,.mat-raised-button.mat-primary{background-color:#3f51b5}.mat-fab.mat-accent,.mat-flat-button.mat-accent,.mat-mini-fab.mat-accent,.mat-raised-button.mat-accent{background-color:#ff4081}.mat-fab.mat-warn,.mat-flat-button.mat-warn,.mat-mini-fab.mat-warn,.mat-raised-button.mat-warn{background-color:#f44336}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{background-color:#0000001f}.mat-fab.mat-accent .mat-ripple-element,.mat-fab.mat-primary .mat-ripple-element,.mat-fab.mat-warn .mat-ripple-element,.mat-flat-button.mat-accent .mat-ripple-element,.mat-flat-button.mat-primary .mat-ripple-element,.mat-flat-button.mat-warn .mat-ripple-element,.mat-mini-fab.mat-accent .mat-ripple-element,.mat-mini-fab.mat-primary .mat-ripple-element,.mat-mini-fab.mat-warn .mat-ripple-element,.mat-raised-button.mat-accent .mat-ripple-element,.mat-raised-button.mat-primary .mat-ripple-element,.mat-raised-button.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-flat-button:not([class*=mat-elevation-z]),.mat-stroked-button:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-raised-button:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-raised-button:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-raised-button.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-fab:not([class*=mat-elevation-z]),.mat-mini-fab:not([class*=mat-elevation-z]){box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]),.mat-mini-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-fab.mat-button-disabled:not([class*=mat-elevation-z]),.mat-mini-fab.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-button-toggle-group,.mat-button-toggle-standalone{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{box-shadow:none}.mat-button-toggle{color:#00000061}.mat-button-toggle .mat-button-toggle-focus-overlay{background-color:#0000001f}.mat-button-toggle-appearance-standard{color:#000000de;background:#fff}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:#000}.mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:1px solid #0000001f}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:1px solid #0000001f}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:none;border-top:1px solid #0000001f}.mat-button-toggle-checked{background-color:#e0e0e0;color:#0000008a}.mat-button-toggle-checked.mat-button-toggle-appearance-standard{color:#000000de}.mat-button-toggle-disabled{color:#00000042;background-color:#eee}.mat-button-toggle-disabled.mat-button-toggle-appearance-standard{background:#fff}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:#bdbdbd}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border:1px solid #0000001f}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px}.mat-card{background:#fff;color:#000000de}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-card.mat-card-flat:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-card-subtitle{color:#0000008a}.mat-checkbox-frame{border-color:#0000008a}.mat-checkbox-checkmark{fill:#fafafa}.mat-checkbox-checkmark-path{stroke:#fafafa!important}.mat-checkbox-mixedmark{background-color:#fafafa}.mat-checkbox-checked.mat-primary .mat-checkbox-background,.mat-checkbox-indeterminate.mat-primary .mat-checkbox-background{background-color:#3f51b5}.mat-checkbox-checked.mat-accent .mat-checkbox-background,.mat-checkbox-indeterminate.mat-accent .mat-checkbox-background{background-color:#ff4081}.mat-checkbox-checked.mat-warn .mat-checkbox-background,.mat-checkbox-indeterminate.mat-warn .mat-checkbox-background{background-color:#f44336}.mat-checkbox-disabled.mat-checkbox-checked .mat-checkbox-background,.mat-checkbox-disabled.mat-checkbox-indeterminate .mat-checkbox-background{background-color:#b0b0b0}.mat-checkbox-disabled:not(.mat-checkbox-checked) .mat-checkbox-frame{border-color:#b0b0b0}.mat-checkbox-disabled .mat-checkbox-label{color:#0000008a}.mat-checkbox .mat-ripple-element{background-color:#000}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element{background:#3f51b5}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element{background:#ff4081}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element{background:#f44336}.mat-chip.mat-standard-chip{background-color:#e0e0e0;color:#000000de}.mat-chip.mat-standard-chip .mat-chip-remove{color:#000000de;opacity:.4}.mat-chip.mat-standard-chip:not(.mat-chip-disabled):active{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-chip.mat-standard-chip:not(.mat-chip-disabled) .mat-chip-remove:hover{opacity:.54}.mat-chip.mat-standard-chip.mat-chip-disabled{opacity:.4}.mat-chip.mat-standard-chip:after{background:#000}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary{background-color:#3f51b5;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn{background-color:#f44336;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent{background-color:#ff4081;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-ripple-element{background-color:#ffffff1a}.mat-table{background:#fff}.mat-table-sticky,.mat-table tbody,.mat-table tfoot,.mat-table thead,[mat-footer-row],[mat-header-row],[mat-row],mat-footer-row,mat-header-row,mat-row{background:inherit}mat-footer-row,mat-header-row,mat-row,td.mat-cell,td.mat-footer-cell,th.mat-header-cell{border-bottom-color:#0000001f}.mat-header-cell{color:#0000008a}.mat-cell,.mat-footer-cell{color:#000000de}.mat-calendar-arrow{border-top-color:#0000008a}.mat-datepicker-content .mat-calendar-next-button,.mat-datepicker-content .mat-calendar-previous-button,.mat-datepicker-toggle{color:#0000008a}.mat-calendar-table-header-divider:after{background:#0000001f}.mat-calendar-body-label,.mat-calendar-table-header{color:#0000008a}.mat-calendar-body-cell-content,.mat-date-range-input-separator{color:#000000de;border-color:#0000}.mat-calendar-body-disabled&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-form-field-disabled .mat-date-range-input-separator{color:#00000061}.mat-calendar-body-in-preview{color:#0000003d}.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#00000061}.mat-calendar-body-disabled&gt;.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#0000002e}.mat-calendar-body-in-range:before{background:#3f51b533}.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-calendar-body-comparison-bridge-start:before,[dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-comparison-bridge-end:before,[dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-calendar-body-selected{background-color:#3f51b5;color:#fff}.mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#3f51b566}.mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#3f51b54d}.mat-datepicker-content{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f;background-color:#fff;color:#000000de}.mat-datepicker-content.mat-accent .mat-calendar-body-in-range:before{background:#ff408133}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-accent .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-accent .mat-calendar-body-selected{background-color:#ff4081;color:#fff}.mat-datepicker-content.mat-accent .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#ff408166}.mat-datepicker-content.mat-accent .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-accent .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#ff40814d}.mat-datepicker-content.mat-warn .mat-calendar-body-in-range:before{background:#f4433633}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-warn .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-warn .mat-calendar-body-selected{background-color:#f44336;color:#fff}.mat-datepicker-content.mat-warn .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#f4433666}.mat-datepicker-content.mat-warn .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-warn .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#f443364d}.mat-datepicker-content-touch{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-datepicker-toggle-active{color:#3f51b5}.mat-datepicker-toggle-active.mat-accent{color:#ff4081}.mat-datepicker-toggle-active.mat-warn{color:#f44336}.mat-date-range-input-inner[disabled]{color:#00000061}.mat-dialog-container{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f;background:#fff;color:#000000de}.mat-divider{border-top-color:#0000001f}.mat-divider-vertical{border-right-color:#0000001f}.mat-expansion-panel{background:#fff;color:#000000de}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-action-row{border-top-color:#0000001f}.mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true]),.mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true]),.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true]){background:#0000000a}@media(hover: none){.mat-expansion-panel:not(.mat-expanded):not([aria-disabled=true]) .mat-expansion-panel-header:hover{background:#fff}}.mat-expansion-panel-header-title{color:#000000de}.mat-expansion-indicator:after,.mat-expansion-panel-header-description{color:#0000008a}.mat-expansion-panel-header[aria-disabled=true]{color:#00000042}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title{color:inherit}.mat-expansion-panel-header{height:48px}.mat-expansion-panel-header.mat-expanded{height:64px}.mat-form-field-label,.mat-hint{color:#0009}.mat-form-field.mat-focused .mat-form-field-label{color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-label.mat-accent{color:#ff4081}.mat-form-field.mat-focused .mat-form-field-label.mat-warn{color:#f44336}.mat-focused .mat-form-field-required-marker{color:#ff4081}.mat-form-field-ripple{background-color:#000000de}.mat-form-field.mat-focused .mat-form-field-ripple{background-color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-ripple.mat-accent{background-color:#ff4081}.mat-form-field.mat-focused .mat-form-field-ripple.mat-warn{background-color:#f44336}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid) .mat-form-field-infix:after{color:#3f51b5}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-accent .mat-form-field-infix:after{color:#ff4081}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-warn .mat-form-field-infix:after,.mat-form-field.mat-form-field-invalid .mat-form-field-label,.mat-form-field.mat-form-field-invalid .mat-form-field-label.mat-accent,.mat-form-field.mat-form-field-invalid .mat-form-field-label .mat-form-field-required-marker{color:#f44336}.mat-form-field.mat-form-field-invalid .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple.mat-accent{background-color:#f44336}.mat-error{color:#f44336}.mat-form-field-appearance-legacy .mat-form-field-label,.mat-form-field-appearance-legacy .mat-hint{color:#0000008a}.mat-form-field-appearance-legacy .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-standard .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-fill .mat-form-field-flex{background-color:#0000000a}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{background-color:#00000005}.mat-form-field-appearance-fill .mat-form-field-underline:before{background-color:#0000006b}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-underline:before{background-color:initial}.mat-form-field-appearance-outline .mat-form-field-outline{color:#0000001f}.mat-form-field-appearance-outline .mat-form-field-outline-thick{color:#000000de}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{color:#3f51b5}.mat-form-field-appearance-outline.mat-focused.mat-accent .mat-form-field-outline-thick{color:#ff4081}.mat-form-field-appearance-outline.mat-focused.mat-warn .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid.mat-form-field-invalid .mat-form-field-outline-thick{color:#f44336}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:#0000000f}.mat-icon.mat-primary{color:#3f51b5}.mat-icon.mat-accent{color:#ff4081}.mat-icon.mat-warn{color:#f44336}.mat-form-field-type-mat-native-select .mat-form-field-infix:after{color:#0000008a}.mat-form-field-type-mat-native-select.mat-form-field-disabled .mat-form-field-infix:after,.mat-input-element:disabled{color:#00000061}.mat-input-element{caret-color:#3f51b5}.mat-input-element::placeholder{color:#0000006b}.mat-input-element::-moz-placeholder{color:#0000006b}.mat-input-element::-webkit-input-placeholder{color:#0000006b}.mat-input-element:-ms-input-placeholder{color:#0000006b}.mat-form-field.mat-accent .mat-input-element{caret-color:#ff4081}.mat-form-field-invalid .mat-input-element,.mat-form-field.mat-warn .mat-input-element{caret-color:#f44336}.mat-form-field-type-mat-native-select.mat-form-field-invalid .mat-form-field-infix:after{color:#f44336}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{color:#000000de}.mat-list-base .mat-subheader{color:#0000008a}.mat-list-item-disabled{background-color:#eee}.mat-action-list .mat-list-item:focus,.mat-action-list .mat-list-item:hover,.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover{background:#0000000a}.mat-list-single-selected-option,.mat-list-single-selected-option:focus,.mat-list-single-selected-option:hover{background:#0000001f}.mat-menu-panel{background:#fff}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-menu-item{background:#0000;color:#000000de}.mat-menu-item[disabled],.mat-menu-item[disabled] .mat-icon-no-color,.mat-menu-item[disabled] .mat-menu-submenu-icon{color:#00000061}.mat-menu-item .mat-icon-no-color,.mat-menu-submenu-icon{color:#0000008a}.mat-menu-item-highlighted:not([disabled]),.mat-menu-item.cdk-keyboard-focused:not([disabled]),.mat-menu-item.cdk-program-focused:not([disabled]),.mat-menu-item:hover:not([disabled]){background:#0000000a}.mat-paginator{background:#fff}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{color:#0000008a}.mat-paginator-decrement,.mat-paginator-increment{border-top:2px solid #0000008a;border-right:2px solid #0000008a}.mat-paginator-first,.mat-paginator-last{border-top:2px solid #0000008a}.mat-icon-button[disabled] .mat-paginator-decrement,.mat-icon-button[disabled] .mat-paginator-first,.mat-icon-button[disabled] .mat-paginator-increment,.mat-icon-button[disabled] .mat-paginator-last{border-color:#00000061}.mat-paginator-container{min-height:56px}.mat-progress-bar-background{fill:#cbd0e9}.mat-progress-bar-buffer{background-color:#cbd0e9}.mat-progress-bar-fill:after{background-color:#3f51b5}.mat-progress-bar.mat-accent .mat-progress-bar-background{fill:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-buffer{background-color:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-fill:after{background-color:#ff4081}.mat-progress-bar.mat-warn .mat-progress-bar-background{fill:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-buffer{background-color:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-fill:after{background-color:#f44336}.mat-progress-spinner circle,.mat-spinner circle{stroke:#3f51b5}.mat-progress-spinner.mat-accent circle,.mat-spinner.mat-accent circle{stroke:#ff4081}.mat-progress-spinner.mat-warn circle,.mat-spinner.mat-warn circle{stroke:#f44336}.mat-radio-outer-circle{border-color:#0000008a}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-outer-circle{border-color:#3f51b5}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-primary .mat-radio-inner-circle,.mat-radio-button.mat-primary .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-primary:active .mat-radio-persistent-ripple{background-color:#3f51b5}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-outer-circle{border-color:#ff4081}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-accent .mat-radio-inner-circle,.mat-radio-button.mat-accent .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-accent:active .mat-radio-persistent-ripple{background-color:#ff4081}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-outer-circle{border-color:#f44336}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-warn .mat-radio-inner-circle,.mat-radio-button.mat-warn .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-warn:active .mat-radio-persistent-ripple{background-color:#f44336}.mat-radio-button.mat-radio-disabled.mat-radio-checked .mat-radio-outer-circle,.mat-radio-button.mat-radio-disabled .mat-radio-outer-circle{border-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-inner-circle,.mat-radio-button.mat-radio-disabled .mat-radio-ripple .mat-ripple-element{background-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-label-content{color:#00000061}.mat-radio-button .mat-ripple-element{background-color:#000}.mat-select-value{color:#000000de}.mat-select-placeholder{color:#0000006b}.mat-select-disabled .mat-select-value{color:#00000061}.mat-select-arrow{color:#0000008a}.mat-select-panel{background:#fff}.mat-select-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-select-panel .mat-option.mat-selected:not(.mat-option-multiple){background:#0000001f}.mat-form-field.mat-focused.mat-primary .mat-select-arrow{color:#3f51b5}.mat-form-field.mat-focused.mat-accent .mat-select-arrow{color:#ff4081}.mat-form-field.mat-focused.mat-warn .mat-select-arrow,.mat-form-field .mat-select.mat-select-invalid .mat-select-arrow{color:#f44336}.mat-form-field .mat-select.mat-select-disabled .mat-select-arrow{color:#00000061}.mat-drawer-container{background-color:#fafafa;color:#000000de}.mat-drawer{color:#000000de}.mat-drawer,.mat-drawer.mat-drawer-push{background-color:#fff}.mat-drawer:not(.mat-drawer-side){box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-drawer-side{border-right:1px solid #0000001f}.mat-drawer-side.mat-drawer-end,[dir=rtl] .mat-drawer-side{border-left:1px solid #0000001f;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-left:none;border-right:1px solid #0000001f}.mat-drawer-backdrop.mat-drawer-shown{background-color:#0009}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#ff4081}.mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:#ff40818a}.mat-slide-toggle.mat-checked .mat-ripple-element{background-color:#ff4081}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-thumb{background-color:#3f51b5}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-bar{background-color:#3f51b58a}.mat-slide-toggle.mat-primary.mat-checked .mat-ripple-element{background-color:#3f51b5}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-thumb{background-color:#f44336}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-bar{background-color:#f443368a}.mat-slide-toggle.mat-warn.mat-checked .mat-ripple-element{background-color:#f44336}.mat-slide-toggle:not(.mat-checked) .mat-ripple-element{background-color:#000}.mat-slide-toggle-thumb{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f;background-color:#fafafa}.mat-slide-toggle-bar{background-color:#00000061}.mat-slider-track-background{background-color:#00000042}.mat-primary .mat-slider-thumb,.mat-primary .mat-slider-thumb-label,.mat-primary .mat-slider-track-fill{background-color:#3f51b5}.mat-primary .mat-slider-thumb-label-text{color:#fff}.mat-primary .mat-slider-focus-ring{background-color:#3f51b533}.mat-accent .mat-slider-thumb,.mat-accent .mat-slider-thumb-label,.mat-accent .mat-slider-track-fill{background-color:#ff4081}.mat-accent .mat-slider-thumb-label-text{color:#fff}.mat-accent .mat-slider-focus-ring{background-color:#ff408133}.mat-warn .mat-slider-thumb,.mat-warn .mat-slider-thumb-label,.mat-warn .mat-slider-track-fill{background-color:#f44336}.mat-warn .mat-slider-thumb-label-text{color:#fff}.mat-warn .mat-slider-focus-ring{background-color:#f4433633}.mat-slider.cdk-focused .mat-slider-track-background,.mat-slider:hover .mat-slider-track-background{background-color:#00000061}.mat-slider-disabled .mat-slider-thumb,.mat-slider-disabled .mat-slider-track-background,.mat-slider-disabled .mat-slider-track-fill,.mat-slider-disabled:hover .mat-slider-track-background{background-color:#00000042}.mat-slider-min-value .mat-slider-focus-ring{background-color:#0000001f}.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb-label{background-color:#000000de}.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb-label{background-color:#00000042}.mat-slider-min-value:not(.mat-slider-thumb-label-showing) .mat-slider-thumb{border-color:#00000042;background-color:initial}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover .mat-slider-thumb{border-color:#00000061}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused.mat-slider-disabled .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover.mat-slider-disabled .mat-slider-thumb{border-color:#00000042}.mat-slider-has-ticks .mat-slider-wrapper:after{border-color:#000000b3}.mat-slider-horizontal .mat-slider-ticks{background-image:repeating-linear-gradient(90deg,#000000b3,#000000b3 2px,#0000 0,#0000);background-image:-moz-repeating-linear-gradient(.0001deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-slider-vertical .mat-slider-ticks{background-image:repeating-linear-gradient(180deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused,.mat-step-header:hover:not([aria-disabled]),.mat-step-header:hover[aria-disabled=false]{background-color:#0000000a}.mat-step-header:hover[aria-disabled=true]{cursor:default}@media(hover: none){.mat-step-header:hover{background:none}}.mat-step-header .mat-step-label,.mat-step-header .mat-step-optional{color:#0000008a}.mat-step-header .mat-step-icon{background-color:#0000008a;color:#fff}.mat-step-header .mat-step-icon-selected,.mat-step-header .mat-step-icon-state-done,.mat-step-header .mat-step-icon-state-edit{background-color:#3f51b5;color:#fff}.mat-step-header.mat-accent .mat-step-icon{color:#fff}.mat-step-header.mat-accent .mat-step-icon-selected,.mat-step-header.mat-accent .mat-step-icon-state-done,.mat-step-header.mat-accent .mat-step-icon-state-edit{background-color:#ff4081;color:#fff}.mat-step-header.mat-warn .mat-step-icon{color:#fff}.mat-step-header.mat-warn .mat-step-icon-selected,.mat-step-header.mat-warn .mat-step-icon-state-done,.mat-step-header.mat-warn .mat-step-icon-state-edit{background-color:#f44336;color:#fff}.mat-step-header .mat-step-icon-state-error{background-color:initial;color:#f44336}.mat-step-header .mat-step-label.mat-step-label-active{color:#000000de}.mat-step-header .mat-step-label.mat-step-label-error{color:#f44336}.mat-stepper-horizontal,.mat-stepper-vertical{background-color:#fff}.mat-stepper-vertical-line:before{border-left-color:#0000001f}.mat-horizontal-stepper-header:after,.mat-horizontal-stepper-header:before,.mat-stepper-horizontal-line{border-top-color:#0000001f}.mat-horizontal-stepper-header{height:72px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header,.mat-vertical-stepper-header{padding:24px}.mat-stepper-vertical-line:before{top:-16px;bottom:-16px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:after,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:before,.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{top:36px}.mat-sort-header-arrow{color:#757575}.mat-tab-header,.mat-tab-nav-bar{border-bottom:1px solid #0000001f}.mat-tab-group-inverted-header .mat-tab-header,.mat-tab-group-inverted-header .mat-tab-nav-bar{border-top:1px solid #0000001f;border-bottom:none}.mat-tab-label,.mat-tab-link{color:#000000de}.mat-tab-label.mat-tab-disabled,.mat-tab-link.mat-tab-disabled{color:#00000061}.mat-tab-header-pagination-chevron{border-color:#000000de}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#00000061}.mat-tab-group[class*=mat-background-]&gt;.mat-tab-header,.mat-tab-nav-bar[class*=mat-background-]{border-bottom:none;border-top:none}.mat-tab-group.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-primary .mat-ink-bar,.mat-tab-nav-bar.mat-primary .mat-ink-bar{background-color:#3f51b5}.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-accent .mat-ink-bar,.mat-tab-nav-bar.mat-accent .mat-ink-bar{background-color:#ff4081}.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-warn .mat-ink-bar,.mat-tab-nav-bar.mat-warn .mat-ink-bar{background-color:#f44336}.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-background-primary&gt;.mat-tab-header,.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container{background-color:#3f51b5}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-background-accent&gt;.mat-tab-header,.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container{background-color:#ff4081}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-background-warn&gt;.mat-tab-header,.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container{background-color:#f44336}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-toolbar{background:#f5f5f5;color:#000000de}.mat-toolbar.mat-primary{background:#3f51b5;color:#fff}.mat-toolbar.mat-accent{background:#ff4081;color:#fff}.mat-toolbar.mat-warn{background:#f44336;color:#fff}.mat-toolbar .mat-focused .mat-form-field-ripple,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-form-field-underline{background-color:currentColor}.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-select-value{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}.mat-tooltip{background:#616161e6}.mat-tree{background:#fff}.mat-nested-tree-node,.mat-tree-node{color:#000000de}.mat-tree-node{min-height:48px}.mat-snack-bar-container{color:#ffffffb3;background:#323232;box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-simple-snackbar-action{color:#ff4081}body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>00000005</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/styles.aed625f13435cbb527ed.css</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>A timestamp was disclosed by the application/web server - Unix</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>00000024, which evaluates to: 1970-01-01 01:00:24</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (389 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/styles.aed625f13435cbb527ed.css HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: text/css,*/*;q=0.1
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: style
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 17:37:48 GMT
ETag: W/&quot;11dde-17e3ac49546&quot;
Content-Type: text/css; charset=UTF-8
Content-Length: 73182
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (73182 bytes)</summary>
				
				<pre><code>.mat-badge-content{font-weight:600;font-size:12px;font-family:Roboto,Helvetica Neue,sans-serif}.mat-badge-small .mat-badge-content{font-size:9px}.mat-badge-large .mat-badge-content{font-size:24px}.mat-h1,.mat-headline,.mat-typography h1{font:400 24px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h2,.mat-title,.mat-typography h2{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h3,.mat-subheading-2,.mat-typography h3{font:400 16px/28px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h4,.mat-subheading-1,.mat-typography h4{font:400 15px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h5,.mat-typography h5{font:400 calc(14px * .83)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-h6,.mat-typography h6{font:400 calc(14px * .67)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-body-2,.mat-body-strong{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body,.mat-body-1,.mat-typography{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body-1 p,.mat-body p,.mat-typography p{margin:0 0 12px}.mat-caption,.mat-small{font:400 12px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-display-4,.mat-typography .mat-display-4{font:300 112px/112px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.05em;margin:0 0 56px}.mat-display-3,.mat-typography .mat-display-3{font:400 56px/56px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.02em;margin:0 0 64px}.mat-display-2,.mat-typography .mat-display-2{font:400 45px/48px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.005em;margin:0 0 64px}.mat-display-1,.mat-typography .mat-display-1{font:400 34px/40px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 64px}.mat-bottom-sheet-container{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button,.mat-stroked-button{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-button-toggle,.mat-card{font-family:Roboto,Helvetica Neue,sans-serif}.mat-card-title{font-size:24px;font-weight:500}.mat-card-header .mat-card-title{font-size:20px}.mat-card-content,.mat-card-subtitle{font-size:14px}.mat-checkbox{font-family:Roboto,Helvetica Neue,sans-serif}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-chip{font-size:14px;font-weight:500}.mat-chip .mat-chip-remove.mat-icon,.mat-chip .mat-chip-trailing-icon.mat-icon{font-size:18px}.mat-table{font-family:Roboto,Helvetica Neue,sans-serif}.mat-header-cell{font-size:12px;font-weight:500}.mat-cell,.mat-footer-cell{font-size:14px}.mat-calendar{font-family:Roboto,Helvetica Neue,sans-serif}.mat-calendar-body{font-size:13px}.mat-calendar-body-label,.mat-calendar-period-button{font-size:14px;font-weight:500}.mat-calendar-table-header th{font-size:11px;font-weight:400}.mat-dialog-title{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-expansion-panel-header{font-family:Roboto,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.mat-expansion-panel-content{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field{font-size:inherit;font-weight:400;line-height:1.125;font-family:Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field-wrapper{padding-bottom:1.34375em}.mat-form-field-prefix .mat-icon,.mat-form-field-suffix .mat-icon{font-size:150%;line-height:1.125}.mat-form-field-prefix .mat-icon-button,.mat-form-field-suffix .mat-icon-button{height:1.5em;width:1.5em}.mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-suffix .mat-icon-button .mat-icon{height:1.125em;line-height:1.125}.mat-form-field-infix{padding:.5em 0;border-top:.84375em solid #0000}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34375em) scale(.75);width:133.3333333333%}.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34374em) scale(.75);width:133.3333433333%}.mat-form-field-label-wrapper{top:-.84375em;padding-top:.84375em}.mat-form-field-label{top:1.34375em}.mat-form-field-underline{bottom:1.34375em}.mat-form-field-subscript-wrapper{font-size:75%;margin-top:.6666666667em;top:calc(100% - 1.7916666667em)}.mat-form-field-appearance-legacy .mat-form-field-wrapper{padding-bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-infix{padding:.4375em 0}.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.001px);-ms-transform:translateY(-1.28125em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00101px);-ms-transform:translateY(-1.28124em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00102px);-ms-transform:translateY(-1.28123em) scale(.75);width:133.3333533333%}.mat-form-field-appearance-legacy .mat-form-field-label{top:1.28125em}.mat-form-field-appearance-legacy .mat-form-field-underline{bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-subscript-wrapper{margin-top:.5416666667em;top:calc(100% - 1.6666666667em)}@media print{.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28122em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28121em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.2812em) scale(.75)}}.mat-form-field-appearance-fill .mat-form-field-infix{padding:.25em 0 .75em}.mat-form-field-appearance-fill .mat-form-field-label{top:1.09375em;margin-top:-.5em}.mat-form-field-appearance-fill.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59374em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-outline .mat-form-field-infix{padding:1em 0}.mat-form-field-appearance-outline .mat-form-field-label{top:1.84375em;margin-top:-.25em}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59374em) scale(.75);width:133.3333433333%}.mat-grid-tile-footer,.mat-grid-tile-header{font-size:14px}.mat-grid-tile-footer .mat-line,.mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}input.mat-input-element{margin-top:-.0625em}.mat-menu-item{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:400}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px}.mat-radio-button,.mat-select{font-family:Roboto,Helvetica Neue,sans-serif}.mat-select-trigger{height:1.125em}.mat-slide-toggle-content,.mat-slider-thumb-label-text{font-family:Roboto,Helvetica Neue,sans-serif}.mat-slider-thumb-label-text{font-size:12px;font-weight:500}.mat-stepper-horizontal,.mat-stepper-vertical{font-family:Roboto,Helvetica Neue,sans-serif}.mat-step-label{font-size:14px;font-weight:400}.mat-step-sub-label-error{font-weight:400}.mat-step-label-error{font-size:14px}.mat-step-label-selected{font-size:14px;font-weight:500}.mat-tab-group,.mat-tab-label,.mat-tab-link{font-family:Roboto,Helvetica Neue,sans-serif}.mat-tab-label,.mat-tab-link{font-size:14px;font-weight:500}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0}.mat-tooltip{font-family:Roboto,Helvetica Neue,sans-serif;font-size:10px;padding-top:6px;padding-bottom:6px}.mat-tooltip-handset{font-size:14px;padding-top:8px;padding-bottom:8px}.mat-list-item,.mat-list-option{font-family:Roboto,Helvetica Neue,sans-serif}.mat-list-base .mat-list-item{font-size:16px}.mat-list-base .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-list-option{font-size:16px}.mat-list-base .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-option .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-list-base[dense] .mat-list-item{font-size:12px}.mat-list-base[dense] .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-list-base[dense] .mat-list-option{font-size:12px}.mat-list-base[dense] .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-option .mat-line:nth-child(n+2){font-size:12px}.mat-list-base[dense] .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;font-weight:500}.mat-option{font-family:Roboto,Helvetica Neue,sans-serif;font-size:16px}.mat-optgroup-label{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-simple-snackbar{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px}.mat-simple-snackbar-action{line-height:1;font-family:inherit;font-size:inherit;font-weight:500}.mat-tree{font-family:Roboto,Helvetica Neue,sans-serif}.mat-nested-tree-node,.mat-tree-node{font-weight:400;font-size:14px}.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale(0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper,.cdk-overlay-pane{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{pointer-events:auto;box-sizing:border-box;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:#00000052}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:initial!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:initial!important;height:0!important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator,.mat-mdc-focus-indicator{position:relative}.mat-ripple-element{background-color:#0000001a}.mat-option{color:#000000de}.mat-option.mat-selected:not(.mat-option-multiple):not(.mat-option-disabled),.mat-option:focus:not(.mat-option-disabled),.mat-option:hover:not(.mat-option-disabled){background:#0000000a}.mat-option.mat-active{background:#0000000a;color:#000000de}.mat-option.mat-option-disabled{color:#00000061}.mat-primary .mat-option.mat-selected:not(.mat-option-disabled){color:#3f51b5}.mat-accent .mat-option.mat-selected:not(.mat-option-disabled){color:#ff4081}.mat-warn .mat-option.mat-selected:not(.mat-option-disabled){color:#f44336}.mat-optgroup-label{color:#0000008a}.mat-optgroup-disabled .mat-optgroup-label{color:#00000061}.mat-pseudo-checkbox{color:#0000008a}.mat-pseudo-checkbox:after{color:#fafafa}.mat-pseudo-checkbox-disabled{color:#b0b0b0}.mat-primary .mat-pseudo-checkbox-checked,.mat-primary .mat-pseudo-checkbox-indeterminate{background:#3f51b5}.mat-accent .mat-pseudo-checkbox-checked,.mat-accent .mat-pseudo-checkbox-indeterminate,.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-indeterminate{background:#ff4081}.mat-warn .mat-pseudo-checkbox-checked,.mat-warn .mat-pseudo-checkbox-indeterminate{background:#f44336}.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background:#b0b0b0}.mat-app-background{background-color:#fafafa;color:#000000de}.mat-elevation-z0{box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-elevation-z1{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-elevation-z2{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-elevation-z3{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-elevation-z4{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-elevation-z5{box-shadow:0 3px 5px -1px #0003,0 5px 8px 0 #00000024,0 1px 14px 0 #0000001f}.mat-elevation-z6{box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-elevation-z7{box-shadow:0 4px 5px -2px #0003,0 7px 10px 1px #00000024,0 2px 16px 1px #0000001f}.mat-elevation-z8{box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-elevation-z9{box-shadow:0 5px 6px -3px #0003,0 9px 12px 1px #00000024,0 3px 16px 2px #0000001f}.mat-elevation-z10{box-shadow:0 6px 6px -3px #0003,0 10px 14px 1px #00000024,0 4px 18px 3px #0000001f}.mat-elevation-z11{box-shadow:0 6px 7px -4px #0003,0 11px 15px 1px #00000024,0 4px 20px 3px #0000001f}.mat-elevation-z12{box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-elevation-z13{box-shadow:0 7px 8px -4px #0003,0 13px 19px 2px #00000024,0 5px 24px 4px #0000001f}.mat-elevation-z14{box-shadow:0 7px 9px -4px #0003,0 14px 21px 2px #00000024,0 5px 26px 4px #0000001f}.mat-elevation-z15{box-shadow:0 8px 9px -5px #0003,0 15px 22px 2px #00000024,0 6px 28px 5px #0000001f}.mat-elevation-z16{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-elevation-z17{box-shadow:0 8px 11px -5px #0003,0 17px 26px 2px #00000024,0 6px 32px 5px #0000001f}.mat-elevation-z18{box-shadow:0 9px 11px -5px #0003,0 18px 28px 2px #00000024,0 7px 34px 6px #0000001f}.mat-elevation-z19{box-shadow:0 9px 12px -6px #0003,0 19px 29px 2px #00000024,0 7px 36px 6px #0000001f}.mat-elevation-z20{box-shadow:0 10px 13px -6px #0003,0 20px 31px 3px #00000024,0 8px 38px 7px #0000001f}.mat-elevation-z21{box-shadow:0 10px 13px -6px #0003,0 21px 33px 3px #00000024,0 8px 40px 7px #0000001f}.mat-elevation-z22{box-shadow:0 10px 14px -6px #0003,0 22px 35px 3px #00000024,0 8px 42px 7px #0000001f}.mat-elevation-z23{box-shadow:0 11px 14px -7px #0003,0 23px 36px 3px #00000024,0 9px 44px 8px #0000001f}.mat-elevation-z24{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-theme-loaded-marker{display:none}.mat-autocomplete-panel{background:#fff;color:#000000de}.mat-autocomplete-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover){background:#fff}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover):not(.mat-option-disabled){color:#000000de}.mat-badge{position:relative}.mat-badge-hidden .mat-badge-content{display:none}.mat-badge-content{position:absolute;text-align:center;display:inline-block;border-radius:50%;transition:transform .2s ease-in-out;transform:scale(.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;pointer-events:none}.mat-badge-content._mat-animation-noopable,.ng-animate-disabled .mat-badge-content{transition:none}.mat-badge-content.mat-badge-active{transform:none}.mat-badge-small .mat-badge-content{width:16px;height:16px;line-height:16px}.mat-badge-small.mat-badge-above .mat-badge-content{top:-8px}.mat-badge-small.mat-badge-below .mat-badge-content{bottom:-8px}.mat-badge-small.mat-badge-before .mat-badge-content{left:-16px}[dir=rtl] .mat-badge-small.mat-badge-before .mat-badge-content{left:auto;right:-16px}.mat-badge-small.mat-badge-after .mat-badge-content{right:-16px}[dir=rtl] .mat-badge-small.mat-badge-after .mat-badge-content{right:auto;left:-16px}.mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-8px}.mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-8px}.mat-badge-medium .mat-badge-content{width:22px;height:22px;line-height:22px}.mat-badge-medium.mat-badge-above .mat-badge-content{top:-11px}.mat-badge-medium.mat-badge-below .mat-badge-content{bottom:-11px}.mat-badge-medium.mat-badge-before .mat-badge-content{left:-22px}[dir=rtl] .mat-badge-medium.mat-badge-before .mat-badge-content{left:auto;right:-22px}.mat-badge-medium.mat-badge-after .mat-badge-content{right:-22px}[dir=rtl] .mat-badge-medium.mat-badge-after .mat-badge-content{right:auto;left:-22px}.mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-11px}.mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-11px}.mat-badge-large .mat-badge-content{width:28px;height:28px;line-height:28px}.mat-badge-large.mat-badge-above .mat-badge-content{top:-14px}.mat-badge-large.mat-badge-below .mat-badge-content{bottom:-14px}.mat-badge-large.mat-badge-before .mat-badge-content{left:-28px}[dir=rtl] .mat-badge-large.mat-badge-before .mat-badge-content{left:auto;right:-28px}.mat-badge-large.mat-badge-after .mat-badge-content{right:-28px}[dir=rtl] .mat-badge-large.mat-badge-after .mat-badge-content{right:auto;left:-28px}.mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-14px}.mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-14px}.mat-badge-content{color:#fff;background:#3f51b5}.cdk-high-contrast-active .mat-badge-content{outline:1px solid;border-radius:0}.mat-badge-accent .mat-badge-content{background:#ff4081;color:#fff}.mat-badge-warn .mat-badge-content{color:#fff;background:#f44336}.mat-badge-disabled .mat-badge-content{background:#b9b9b9;color:#00000061}.mat-bottom-sheet-container{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f;background:#fff;color:#000000de}.mat-button,.mat-icon-button,.mat-stroked-button{color:inherit;background:#0000}.mat-button.mat-primary,.mat-icon-button.mat-primary,.mat-stroked-button.mat-primary{color:#3f51b5}.mat-button.mat-accent,.mat-icon-button.mat-accent,.mat-stroked-button.mat-accent{color:#ff4081}.mat-button.mat-warn,.mat-icon-button.mat-warn,.mat-stroked-button.mat-warn{color:#f44336}.mat-button.mat-accent.mat-button-disabled,.mat-button.mat-button-disabled.mat-button-disabled,.mat-button.mat-primary.mat-button-disabled,.mat-button.mat-warn.mat-button-disabled,.mat-icon-button.mat-accent.mat-button-disabled,.mat-icon-button.mat-button-disabled.mat-button-disabled,.mat-icon-button.mat-primary.mat-button-disabled,.mat-icon-button.mat-warn.mat-button-disabled,.mat-stroked-button.mat-accent.mat-button-disabled,.mat-stroked-button.mat-button-disabled.mat-button-disabled,.mat-stroked-button.mat-primary.mat-button-disabled,.mat-stroked-button.mat-warn.mat-button-disabled{color:#00000042}.mat-button.mat-primary .mat-button-focus-overlay,.mat-icon-button.mat-primary .mat-button-focus-overlay,.mat-stroked-button.mat-primary .mat-button-focus-overlay{background-color:#3f51b5}.mat-button.mat-accent .mat-button-focus-overlay,.mat-icon-button.mat-accent .mat-button-focus-overlay,.mat-stroked-button.mat-accent .mat-button-focus-overlay{background-color:#ff4081}.mat-button.mat-warn .mat-button-focus-overlay,.mat-icon-button.mat-warn .mat-button-focus-overlay,.mat-stroked-button.mat-warn .mat-button-focus-overlay{background-color:#f44336}.mat-button.mat-button-disabled .mat-button-focus-overlay,.mat-icon-button.mat-button-disabled .mat-button-focus-overlay,.mat-stroked-button.mat-button-disabled .mat-button-focus-overlay{background-color:initial}.mat-button .mat-ripple-element,.mat-icon-button .mat-ripple-element,.mat-stroked-button .mat-ripple-element{opacity:.1;background-color:currentColor}.mat-button-focus-overlay{background:#000}.mat-stroked-button:not(.mat-button-disabled){border-color:#0000001f}.mat-fab,.mat-flat-button,.mat-mini-fab,.mat-raised-button{color:#000000de;background-color:#fff}.mat-fab.mat-accent,.mat-fab.mat-primary,.mat-fab.mat-warn,.mat-flat-button.mat-accent,.mat-flat-button.mat-primary,.mat-flat-button.mat-warn,.mat-mini-fab.mat-accent,.mat-mini-fab.mat-primary,.mat-mini-fab.mat-warn,.mat-raised-button.mat-accent,.mat-raised-button.mat-primary,.mat-raised-button.mat-warn{color:#fff}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{color:#00000042}.mat-fab.mat-primary,.mat-flat-button.mat-primary,.mat-mini-fab.mat-primary,.mat-raised-button.mat-primary{background-color:#3f51b5}.mat-fab.mat-accent,.mat-flat-button.mat-accent,.mat-mini-fab.mat-accent,.mat-raised-button.mat-accent{background-color:#ff4081}.mat-fab.mat-warn,.mat-flat-button.mat-warn,.mat-mini-fab.mat-warn,.mat-raised-button.mat-warn{background-color:#f44336}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{background-color:#0000001f}.mat-fab.mat-accent .mat-ripple-element,.mat-fab.mat-primary .mat-ripple-element,.mat-fab.mat-warn .mat-ripple-element,.mat-flat-button.mat-accent .mat-ripple-element,.mat-flat-button.mat-primary .mat-ripple-element,.mat-flat-button.mat-warn .mat-ripple-element,.mat-mini-fab.mat-accent .mat-ripple-element,.mat-mini-fab.mat-primary .mat-ripple-element,.mat-mini-fab.mat-warn .mat-ripple-element,.mat-raised-button.mat-accent .mat-ripple-element,.mat-raised-button.mat-primary .mat-ripple-element,.mat-raised-button.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-flat-button:not([class*=mat-elevation-z]),.mat-stroked-button:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-raised-button:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-raised-button:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-raised-button.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-fab:not([class*=mat-elevation-z]),.mat-mini-fab:not([class*=mat-elevation-z]){box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]),.mat-mini-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-fab.mat-button-disabled:not([class*=mat-elevation-z]),.mat-mini-fab.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-button-toggle-group,.mat-button-toggle-standalone{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{box-shadow:none}.mat-button-toggle{color:#00000061}.mat-button-toggle .mat-button-toggle-focus-overlay{background-color:#0000001f}.mat-button-toggle-appearance-standard{color:#000000de;background:#fff}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:#000}.mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:1px solid #0000001f}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:1px solid #0000001f}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:none;border-top:1px solid #0000001f}.mat-button-toggle-checked{background-color:#e0e0e0;color:#0000008a}.mat-button-toggle-checked.mat-button-toggle-appearance-standard{color:#000000de}.mat-button-toggle-disabled{color:#00000042;background-color:#eee}.mat-button-toggle-disabled.mat-button-toggle-appearance-standard{background:#fff}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:#bdbdbd}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border:1px solid #0000001f}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px}.mat-card{background:#fff;color:#000000de}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-card.mat-card-flat:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-card-subtitle{color:#0000008a}.mat-checkbox-frame{border-color:#0000008a}.mat-checkbox-checkmark{fill:#fafafa}.mat-checkbox-checkmark-path{stroke:#fafafa!important}.mat-checkbox-mixedmark{background-color:#fafafa}.mat-checkbox-checked.mat-primary .mat-checkbox-background,.mat-checkbox-indeterminate.mat-primary .mat-checkbox-background{background-color:#3f51b5}.mat-checkbox-checked.mat-accent .mat-checkbox-background,.mat-checkbox-indeterminate.mat-accent .mat-checkbox-background{background-color:#ff4081}.mat-checkbox-checked.mat-warn .mat-checkbox-background,.mat-checkbox-indeterminate.mat-warn .mat-checkbox-background{background-color:#f44336}.mat-checkbox-disabled.mat-checkbox-checked .mat-checkbox-background,.mat-checkbox-disabled.mat-checkbox-indeterminate .mat-checkbox-background{background-color:#b0b0b0}.mat-checkbox-disabled:not(.mat-checkbox-checked) .mat-checkbox-frame{border-color:#b0b0b0}.mat-checkbox-disabled .mat-checkbox-label{color:#0000008a}.mat-checkbox .mat-ripple-element{background-color:#000}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element{background:#3f51b5}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element{background:#ff4081}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element{background:#f44336}.mat-chip.mat-standard-chip{background-color:#e0e0e0;color:#000000de}.mat-chip.mat-standard-chip .mat-chip-remove{color:#000000de;opacity:.4}.mat-chip.mat-standard-chip:not(.mat-chip-disabled):active{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-chip.mat-standard-chip:not(.mat-chip-disabled) .mat-chip-remove:hover{opacity:.54}.mat-chip.mat-standard-chip.mat-chip-disabled{opacity:.4}.mat-chip.mat-standard-chip:after{background:#000}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary{background-color:#3f51b5;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn{background-color:#f44336;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent{background-color:#ff4081;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-ripple-element{background-color:#ffffff1a}.mat-table{background:#fff}.mat-table-sticky,.mat-table tbody,.mat-table tfoot,.mat-table thead,[mat-footer-row],[mat-header-row],[mat-row],mat-footer-row,mat-header-row,mat-row{background:inherit}mat-footer-row,mat-header-row,mat-row,td.mat-cell,td.mat-footer-cell,th.mat-header-cell{border-bottom-color:#0000001f}.mat-header-cell{color:#0000008a}.mat-cell,.mat-footer-cell{color:#000000de}.mat-calendar-arrow{border-top-color:#0000008a}.mat-datepicker-content .mat-calendar-next-button,.mat-datepicker-content .mat-calendar-previous-button,.mat-datepicker-toggle{color:#0000008a}.mat-calendar-table-header-divider:after{background:#0000001f}.mat-calendar-body-label,.mat-calendar-table-header{color:#0000008a}.mat-calendar-body-cell-content,.mat-date-range-input-separator{color:#000000de;border-color:#0000}.mat-calendar-body-disabled&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-form-field-disabled .mat-date-range-input-separator{color:#00000061}.mat-calendar-body-in-preview{color:#0000003d}.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#00000061}.mat-calendar-body-disabled&gt;.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#0000002e}.mat-calendar-body-in-range:before{background:#3f51b533}.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-calendar-body-comparison-bridge-start:before,[dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-comparison-bridge-end:before,[dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-calendar-body-selected{background-color:#3f51b5;color:#fff}.mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#3f51b566}.mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#3f51b54d}.mat-datepicker-content{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f;background-color:#fff;color:#000000de}.mat-datepicker-content.mat-accent .mat-calendar-body-in-range:before{background:#ff408133}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-accent .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-accent .mat-calendar-body-selected{background-color:#ff4081;color:#fff}.mat-datepicker-content.mat-accent .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#ff408166}.mat-datepicker-content.mat-accent .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-accent .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#ff40814d}.mat-datepicker-content.mat-warn .mat-calendar-body-in-range:before{background:#f4433633}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-warn .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-warn .mat-calendar-body-selected{background-color:#f44336;color:#fff}.mat-datepicker-content.mat-warn .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#f4433666}.mat-datepicker-content.mat-warn .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-warn .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#f443364d}.mat-datepicker-content-touch{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-datepicker-toggle-active{color:#3f51b5}.mat-datepicker-toggle-active.mat-accent{color:#ff4081}.mat-datepicker-toggle-active.mat-warn{color:#f44336}.mat-date-range-input-inner[disabled]{color:#00000061}.mat-dialog-container{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f;background:#fff;color:#000000de}.mat-divider{border-top-color:#0000001f}.mat-divider-vertical{border-right-color:#0000001f}.mat-expansion-panel{background:#fff;color:#000000de}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-action-row{border-top-color:#0000001f}.mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true]),.mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true]),.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true]){background:#0000000a}@media(hover: none){.mat-expansion-panel:not(.mat-expanded):not([aria-disabled=true]) .mat-expansion-panel-header:hover{background:#fff}}.mat-expansion-panel-header-title{color:#000000de}.mat-expansion-indicator:after,.mat-expansion-panel-header-description{color:#0000008a}.mat-expansion-panel-header[aria-disabled=true]{color:#00000042}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title{color:inherit}.mat-expansion-panel-header{height:48px}.mat-expansion-panel-header.mat-expanded{height:64px}.mat-form-field-label,.mat-hint{color:#0009}.mat-form-field.mat-focused .mat-form-field-label{color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-label.mat-accent{color:#ff4081}.mat-form-field.mat-focused .mat-form-field-label.mat-warn{color:#f44336}.mat-focused .mat-form-field-required-marker{color:#ff4081}.mat-form-field-ripple{background-color:#000000de}.mat-form-field.mat-focused .mat-form-field-ripple{background-color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-ripple.mat-accent{background-color:#ff4081}.mat-form-field.mat-focused .mat-form-field-ripple.mat-warn{background-color:#f44336}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid) .mat-form-field-infix:after{color:#3f51b5}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-accent .mat-form-field-infix:after{color:#ff4081}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-warn .mat-form-field-infix:after,.mat-form-field.mat-form-field-invalid .mat-form-field-label,.mat-form-field.mat-form-field-invalid .mat-form-field-label.mat-accent,.mat-form-field.mat-form-field-invalid .mat-form-field-label .mat-form-field-required-marker{color:#f44336}.mat-form-field.mat-form-field-invalid .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple.mat-accent{background-color:#f44336}.mat-error{color:#f44336}.mat-form-field-appearance-legacy .mat-form-field-label,.mat-form-field-appearance-legacy .mat-hint{color:#0000008a}.mat-form-field-appearance-legacy .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-standard .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-fill .mat-form-field-flex{background-color:#0000000a}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{background-color:#00000005}.mat-form-field-appearance-fill .mat-form-field-underline:before{background-color:#0000006b}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-underline:before{background-color:initial}.mat-form-field-appearance-outline .mat-form-field-outline{color:#0000001f}.mat-form-field-appearance-outline .mat-form-field-outline-thick{color:#000000de}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{color:#3f51b5}.mat-form-field-appearance-outline.mat-focused.mat-accent .mat-form-field-outline-thick{color:#ff4081}.mat-form-field-appearance-outline.mat-focused.mat-warn .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid.mat-form-field-invalid .mat-form-field-outline-thick{color:#f44336}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:#0000000f}.mat-icon.mat-primary{color:#3f51b5}.mat-icon.mat-accent{color:#ff4081}.mat-icon.mat-warn{color:#f44336}.mat-form-field-type-mat-native-select .mat-form-field-infix:after{color:#0000008a}.mat-form-field-type-mat-native-select.mat-form-field-disabled .mat-form-field-infix:after,.mat-input-element:disabled{color:#00000061}.mat-input-element{caret-color:#3f51b5}.mat-input-element::placeholder{color:#0000006b}.mat-input-element::-moz-placeholder{color:#0000006b}.mat-input-element::-webkit-input-placeholder{color:#0000006b}.mat-input-element:-ms-input-placeholder{color:#0000006b}.mat-form-field.mat-accent .mat-input-element{caret-color:#ff4081}.mat-form-field-invalid .mat-input-element,.mat-form-field.mat-warn .mat-input-element{caret-color:#f44336}.mat-form-field-type-mat-native-select.mat-form-field-invalid .mat-form-field-infix:after{color:#f44336}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{color:#000000de}.mat-list-base .mat-subheader{color:#0000008a}.mat-list-item-disabled{background-color:#eee}.mat-action-list .mat-list-item:focus,.mat-action-list .mat-list-item:hover,.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover{background:#0000000a}.mat-list-single-selected-option,.mat-list-single-selected-option:focus,.mat-list-single-selected-option:hover{background:#0000001f}.mat-menu-panel{background:#fff}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-menu-item{background:#0000;color:#000000de}.mat-menu-item[disabled],.mat-menu-item[disabled] .mat-icon-no-color,.mat-menu-item[disabled] .mat-menu-submenu-icon{color:#00000061}.mat-menu-item .mat-icon-no-color,.mat-menu-submenu-icon{color:#0000008a}.mat-menu-item-highlighted:not([disabled]),.mat-menu-item.cdk-keyboard-focused:not([disabled]),.mat-menu-item.cdk-program-focused:not([disabled]),.mat-menu-item:hover:not([disabled]){background:#0000000a}.mat-paginator{background:#fff}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{color:#0000008a}.mat-paginator-decrement,.mat-paginator-increment{border-top:2px solid #0000008a;border-right:2px solid #0000008a}.mat-paginator-first,.mat-paginator-last{border-top:2px solid #0000008a}.mat-icon-button[disabled] .mat-paginator-decrement,.mat-icon-button[disabled] .mat-paginator-first,.mat-icon-button[disabled] .mat-paginator-increment,.mat-icon-button[disabled] .mat-paginator-last{border-color:#00000061}.mat-paginator-container{min-height:56px}.mat-progress-bar-background{fill:#cbd0e9}.mat-progress-bar-buffer{background-color:#cbd0e9}.mat-progress-bar-fill:after{background-color:#3f51b5}.mat-progress-bar.mat-accent .mat-progress-bar-background{fill:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-buffer{background-color:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-fill:after{background-color:#ff4081}.mat-progress-bar.mat-warn .mat-progress-bar-background{fill:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-buffer{background-color:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-fill:after{background-color:#f44336}.mat-progress-spinner circle,.mat-spinner circle{stroke:#3f51b5}.mat-progress-spinner.mat-accent circle,.mat-spinner.mat-accent circle{stroke:#ff4081}.mat-progress-spinner.mat-warn circle,.mat-spinner.mat-warn circle{stroke:#f44336}.mat-radio-outer-circle{border-color:#0000008a}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-outer-circle{border-color:#3f51b5}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-primary .mat-radio-inner-circle,.mat-radio-button.mat-primary .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-primary:active .mat-radio-persistent-ripple{background-color:#3f51b5}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-outer-circle{border-color:#ff4081}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-accent .mat-radio-inner-circle,.mat-radio-button.mat-accent .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-accent:active .mat-radio-persistent-ripple{background-color:#ff4081}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-outer-circle{border-color:#f44336}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-warn .mat-radio-inner-circle,.mat-radio-button.mat-warn .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-warn:active .mat-radio-persistent-ripple{background-color:#f44336}.mat-radio-button.mat-radio-disabled.mat-radio-checked .mat-radio-outer-circle,.mat-radio-button.mat-radio-disabled .mat-radio-outer-circle{border-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-inner-circle,.mat-radio-button.mat-radio-disabled .mat-radio-ripple .mat-ripple-element{background-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-label-content{color:#00000061}.mat-radio-button .mat-ripple-element{background-color:#000}.mat-select-value{color:#000000de}.mat-select-placeholder{color:#0000006b}.mat-select-disabled .mat-select-value{color:#00000061}.mat-select-arrow{color:#0000008a}.mat-select-panel{background:#fff}.mat-select-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-select-panel .mat-option.mat-selected:not(.mat-option-multiple){background:#0000001f}.mat-form-field.mat-focused.mat-primary .mat-select-arrow{color:#3f51b5}.mat-form-field.mat-focused.mat-accent .mat-select-arrow{color:#ff4081}.mat-form-field.mat-focused.mat-warn .mat-select-arrow,.mat-form-field .mat-select.mat-select-invalid .mat-select-arrow{color:#f44336}.mat-form-field .mat-select.mat-select-disabled .mat-select-arrow{color:#00000061}.mat-drawer-container{background-color:#fafafa;color:#000000de}.mat-drawer{color:#000000de}.mat-drawer,.mat-drawer.mat-drawer-push{background-color:#fff}.mat-drawer:not(.mat-drawer-side){box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-drawer-side{border-right:1px solid #0000001f}.mat-drawer-side.mat-drawer-end,[dir=rtl] .mat-drawer-side{border-left:1px solid #0000001f;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-left:none;border-right:1px solid #0000001f}.mat-drawer-backdrop.mat-drawer-shown{background-color:#0009}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#ff4081}.mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:#ff40818a}.mat-slide-toggle.mat-checked .mat-ripple-element{background-color:#ff4081}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-thumb{background-color:#3f51b5}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-bar{background-color:#3f51b58a}.mat-slide-toggle.mat-primary.mat-checked .mat-ripple-element{background-color:#3f51b5}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-thumb{background-color:#f44336}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-bar{background-color:#f443368a}.mat-slide-toggle.mat-warn.mat-checked .mat-ripple-element{background-color:#f44336}.mat-slide-toggle:not(.mat-checked) .mat-ripple-element{background-color:#000}.mat-slide-toggle-thumb{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f;background-color:#fafafa}.mat-slide-toggle-bar{background-color:#00000061}.mat-slider-track-background{background-color:#00000042}.mat-primary .mat-slider-thumb,.mat-primary .mat-slider-thumb-label,.mat-primary .mat-slider-track-fill{background-color:#3f51b5}.mat-primary .mat-slider-thumb-label-text{color:#fff}.mat-primary .mat-slider-focus-ring{background-color:#3f51b533}.mat-accent .mat-slider-thumb,.mat-accent .mat-slider-thumb-label,.mat-accent .mat-slider-track-fill{background-color:#ff4081}.mat-accent .mat-slider-thumb-label-text{color:#fff}.mat-accent .mat-slider-focus-ring{background-color:#ff408133}.mat-warn .mat-slider-thumb,.mat-warn .mat-slider-thumb-label,.mat-warn .mat-slider-track-fill{background-color:#f44336}.mat-warn .mat-slider-thumb-label-text{color:#fff}.mat-warn .mat-slider-focus-ring{background-color:#f4433633}.mat-slider.cdk-focused .mat-slider-track-background,.mat-slider:hover .mat-slider-track-background{background-color:#00000061}.mat-slider-disabled .mat-slider-thumb,.mat-slider-disabled .mat-slider-track-background,.mat-slider-disabled .mat-slider-track-fill,.mat-slider-disabled:hover .mat-slider-track-background{background-color:#00000042}.mat-slider-min-value .mat-slider-focus-ring{background-color:#0000001f}.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb-label{background-color:#000000de}.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb-label{background-color:#00000042}.mat-slider-min-value:not(.mat-slider-thumb-label-showing) .mat-slider-thumb{border-color:#00000042;background-color:initial}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover .mat-slider-thumb{border-color:#00000061}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused.mat-slider-disabled .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover.mat-slider-disabled .mat-slider-thumb{border-color:#00000042}.mat-slider-has-ticks .mat-slider-wrapper:after{border-color:#000000b3}.mat-slider-horizontal .mat-slider-ticks{background-image:repeating-linear-gradient(90deg,#000000b3,#000000b3 2px,#0000 0,#0000);background-image:-moz-repeating-linear-gradient(.0001deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-slider-vertical .mat-slider-ticks{background-image:repeating-linear-gradient(180deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused,.mat-step-header:hover:not([aria-disabled]),.mat-step-header:hover[aria-disabled=false]{background-color:#0000000a}.mat-step-header:hover[aria-disabled=true]{cursor:default}@media(hover: none){.mat-step-header:hover{background:none}}.mat-step-header .mat-step-label,.mat-step-header .mat-step-optional{color:#0000008a}.mat-step-header .mat-step-icon{background-color:#0000008a;color:#fff}.mat-step-header .mat-step-icon-selected,.mat-step-header .mat-step-icon-state-done,.mat-step-header .mat-step-icon-state-edit{background-color:#3f51b5;color:#fff}.mat-step-header.mat-accent .mat-step-icon{color:#fff}.mat-step-header.mat-accent .mat-step-icon-selected,.mat-step-header.mat-accent .mat-step-icon-state-done,.mat-step-header.mat-accent .mat-step-icon-state-edit{background-color:#ff4081;color:#fff}.mat-step-header.mat-warn .mat-step-icon{color:#fff}.mat-step-header.mat-warn .mat-step-icon-selected,.mat-step-header.mat-warn .mat-step-icon-state-done,.mat-step-header.mat-warn .mat-step-icon-state-edit{background-color:#f44336;color:#fff}.mat-step-header .mat-step-icon-state-error{background-color:initial;color:#f44336}.mat-step-header .mat-step-label.mat-step-label-active{color:#000000de}.mat-step-header .mat-step-label.mat-step-label-error{color:#f44336}.mat-stepper-horizontal,.mat-stepper-vertical{background-color:#fff}.mat-stepper-vertical-line:before{border-left-color:#0000001f}.mat-horizontal-stepper-header:after,.mat-horizontal-stepper-header:before,.mat-stepper-horizontal-line{border-top-color:#0000001f}.mat-horizontal-stepper-header{height:72px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header,.mat-vertical-stepper-header{padding:24px}.mat-stepper-vertical-line:before{top:-16px;bottom:-16px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:after,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:before,.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{top:36px}.mat-sort-header-arrow{color:#757575}.mat-tab-header,.mat-tab-nav-bar{border-bottom:1px solid #0000001f}.mat-tab-group-inverted-header .mat-tab-header,.mat-tab-group-inverted-header .mat-tab-nav-bar{border-top:1px solid #0000001f;border-bottom:none}.mat-tab-label,.mat-tab-link{color:#000000de}.mat-tab-label.mat-tab-disabled,.mat-tab-link.mat-tab-disabled{color:#00000061}.mat-tab-header-pagination-chevron{border-color:#000000de}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#00000061}.mat-tab-group[class*=mat-background-]&gt;.mat-tab-header,.mat-tab-nav-bar[class*=mat-background-]{border-bottom:none;border-top:none}.mat-tab-group.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-primary .mat-ink-bar,.mat-tab-nav-bar.mat-primary .mat-ink-bar{background-color:#3f51b5}.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-accent .mat-ink-bar,.mat-tab-nav-bar.mat-accent .mat-ink-bar{background-color:#ff4081}.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-warn .mat-ink-bar,.mat-tab-nav-bar.mat-warn .mat-ink-bar{background-color:#f44336}.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-background-primary&gt;.mat-tab-header,.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container{background-color:#3f51b5}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-background-accent&gt;.mat-tab-header,.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container{background-color:#ff4081}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-background-warn&gt;.mat-tab-header,.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container{background-color:#f44336}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-toolbar{background:#f5f5f5;color:#000000de}.mat-toolbar.mat-primary{background:#3f51b5;color:#fff}.mat-toolbar.mat-accent{background:#ff4081;color:#fff}.mat-toolbar.mat-warn{background:#f44336;color:#fff}.mat-toolbar .mat-focused .mat-form-field-ripple,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-form-field-underline{background-color:currentColor}.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-select-value{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}.mat-tooltip{background:#616161e6}.mat-tree{background:#fff}.mat-nested-tree-node,.mat-tree-node{color:#000000de}.mat-tree-node{min-height:48px}.mat-snack-bar-container{color:#ffffffb3;background:#323232;box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-simple-snackbar-action{color:#ff4081}body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>00000024</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/styles.aed625f13435cbb527ed.css</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>A timestamp was disclosed by the application/web server - Unix</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>00000042, which evaluates to: 1970-01-01 01:00:42</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (389 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/styles.aed625f13435cbb527ed.css HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: text/css,*/*;q=0.1
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: style
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 17:37:48 GMT
ETag: W/&quot;11dde-17e3ac49546&quot;
Content-Type: text/css; charset=UTF-8
Content-Length: 73182
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (73182 bytes)</summary>
				
				<pre><code>.mat-badge-content{font-weight:600;font-size:12px;font-family:Roboto,Helvetica Neue,sans-serif}.mat-badge-small .mat-badge-content{font-size:9px}.mat-badge-large .mat-badge-content{font-size:24px}.mat-h1,.mat-headline,.mat-typography h1{font:400 24px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h2,.mat-title,.mat-typography h2{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h3,.mat-subheading-2,.mat-typography h3{font:400 16px/28px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h4,.mat-subheading-1,.mat-typography h4{font:400 15px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h5,.mat-typography h5{font:400 calc(14px * .83)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-h6,.mat-typography h6{font:400 calc(14px * .67)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-body-2,.mat-body-strong{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body,.mat-body-1,.mat-typography{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body-1 p,.mat-body p,.mat-typography p{margin:0 0 12px}.mat-caption,.mat-small{font:400 12px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-display-4,.mat-typography .mat-display-4{font:300 112px/112px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.05em;margin:0 0 56px}.mat-display-3,.mat-typography .mat-display-3{font:400 56px/56px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.02em;margin:0 0 64px}.mat-display-2,.mat-typography .mat-display-2{font:400 45px/48px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.005em;margin:0 0 64px}.mat-display-1,.mat-typography .mat-display-1{font:400 34px/40px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 64px}.mat-bottom-sheet-container{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button,.mat-stroked-button{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-button-toggle,.mat-card{font-family:Roboto,Helvetica Neue,sans-serif}.mat-card-title{font-size:24px;font-weight:500}.mat-card-header .mat-card-title{font-size:20px}.mat-card-content,.mat-card-subtitle{font-size:14px}.mat-checkbox{font-family:Roboto,Helvetica Neue,sans-serif}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-chip{font-size:14px;font-weight:500}.mat-chip .mat-chip-remove.mat-icon,.mat-chip .mat-chip-trailing-icon.mat-icon{font-size:18px}.mat-table{font-family:Roboto,Helvetica Neue,sans-serif}.mat-header-cell{font-size:12px;font-weight:500}.mat-cell,.mat-footer-cell{font-size:14px}.mat-calendar{font-family:Roboto,Helvetica Neue,sans-serif}.mat-calendar-body{font-size:13px}.mat-calendar-body-label,.mat-calendar-period-button{font-size:14px;font-weight:500}.mat-calendar-table-header th{font-size:11px;font-weight:400}.mat-dialog-title{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-expansion-panel-header{font-family:Roboto,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.mat-expansion-panel-content{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field{font-size:inherit;font-weight:400;line-height:1.125;font-family:Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field-wrapper{padding-bottom:1.34375em}.mat-form-field-prefix .mat-icon,.mat-form-field-suffix .mat-icon{font-size:150%;line-height:1.125}.mat-form-field-prefix .mat-icon-button,.mat-form-field-suffix .mat-icon-button{height:1.5em;width:1.5em}.mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-suffix .mat-icon-button .mat-icon{height:1.125em;line-height:1.125}.mat-form-field-infix{padding:.5em 0;border-top:.84375em solid #0000}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34375em) scale(.75);width:133.3333333333%}.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34374em) scale(.75);width:133.3333433333%}.mat-form-field-label-wrapper{top:-.84375em;padding-top:.84375em}.mat-form-field-label{top:1.34375em}.mat-form-field-underline{bottom:1.34375em}.mat-form-field-subscript-wrapper{font-size:75%;margin-top:.6666666667em;top:calc(100% - 1.7916666667em)}.mat-form-field-appearance-legacy .mat-form-field-wrapper{padding-bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-infix{padding:.4375em 0}.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.001px);-ms-transform:translateY(-1.28125em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00101px);-ms-transform:translateY(-1.28124em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00102px);-ms-transform:translateY(-1.28123em) scale(.75);width:133.3333533333%}.mat-form-field-appearance-legacy .mat-form-field-label{top:1.28125em}.mat-form-field-appearance-legacy .mat-form-field-underline{bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-subscript-wrapper{margin-top:.5416666667em;top:calc(100% - 1.6666666667em)}@media print{.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28122em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28121em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.2812em) scale(.75)}}.mat-form-field-appearance-fill .mat-form-field-infix{padding:.25em 0 .75em}.mat-form-field-appearance-fill .mat-form-field-label{top:1.09375em;margin-top:-.5em}.mat-form-field-appearance-fill.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59374em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-outline .mat-form-field-infix{padding:1em 0}.mat-form-field-appearance-outline .mat-form-field-label{top:1.84375em;margin-top:-.25em}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59374em) scale(.75);width:133.3333433333%}.mat-grid-tile-footer,.mat-grid-tile-header{font-size:14px}.mat-grid-tile-footer .mat-line,.mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}input.mat-input-element{margin-top:-.0625em}.mat-menu-item{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:400}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px}.mat-radio-button,.mat-select{font-family:Roboto,Helvetica Neue,sans-serif}.mat-select-trigger{height:1.125em}.mat-slide-toggle-content,.mat-slider-thumb-label-text{font-family:Roboto,Helvetica Neue,sans-serif}.mat-slider-thumb-label-text{font-size:12px;font-weight:500}.mat-stepper-horizontal,.mat-stepper-vertical{font-family:Roboto,Helvetica Neue,sans-serif}.mat-step-label{font-size:14px;font-weight:400}.mat-step-sub-label-error{font-weight:400}.mat-step-label-error{font-size:14px}.mat-step-label-selected{font-size:14px;font-weight:500}.mat-tab-group,.mat-tab-label,.mat-tab-link{font-family:Roboto,Helvetica Neue,sans-serif}.mat-tab-label,.mat-tab-link{font-size:14px;font-weight:500}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0}.mat-tooltip{font-family:Roboto,Helvetica Neue,sans-serif;font-size:10px;padding-top:6px;padding-bottom:6px}.mat-tooltip-handset{font-size:14px;padding-top:8px;padding-bottom:8px}.mat-list-item,.mat-list-option{font-family:Roboto,Helvetica Neue,sans-serif}.mat-list-base .mat-list-item{font-size:16px}.mat-list-base .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-list-option{font-size:16px}.mat-list-base .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-option .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-list-base[dense] .mat-list-item{font-size:12px}.mat-list-base[dense] .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-list-base[dense] .mat-list-option{font-size:12px}.mat-list-base[dense] .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-option .mat-line:nth-child(n+2){font-size:12px}.mat-list-base[dense] .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;font-weight:500}.mat-option{font-family:Roboto,Helvetica Neue,sans-serif;font-size:16px}.mat-optgroup-label{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-simple-snackbar{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px}.mat-simple-snackbar-action{line-height:1;font-family:inherit;font-size:inherit;font-weight:500}.mat-tree{font-family:Roboto,Helvetica Neue,sans-serif}.mat-nested-tree-node,.mat-tree-node{font-weight:400;font-size:14px}.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale(0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper,.cdk-overlay-pane{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{pointer-events:auto;box-sizing:border-box;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:#00000052}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:initial!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:initial!important;height:0!important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator,.mat-mdc-focus-indicator{position:relative}.mat-ripple-element{background-color:#0000001a}.mat-option{color:#000000de}.mat-option.mat-selected:not(.mat-option-multiple):not(.mat-option-disabled),.mat-option:focus:not(.mat-option-disabled),.mat-option:hover:not(.mat-option-disabled){background:#0000000a}.mat-option.mat-active{background:#0000000a;color:#000000de}.mat-option.mat-option-disabled{color:#00000061}.mat-primary .mat-option.mat-selected:not(.mat-option-disabled){color:#3f51b5}.mat-accent .mat-option.mat-selected:not(.mat-option-disabled){color:#ff4081}.mat-warn .mat-option.mat-selected:not(.mat-option-disabled){color:#f44336}.mat-optgroup-label{color:#0000008a}.mat-optgroup-disabled .mat-optgroup-label{color:#00000061}.mat-pseudo-checkbox{color:#0000008a}.mat-pseudo-checkbox:after{color:#fafafa}.mat-pseudo-checkbox-disabled{color:#b0b0b0}.mat-primary .mat-pseudo-checkbox-checked,.mat-primary .mat-pseudo-checkbox-indeterminate{background:#3f51b5}.mat-accent .mat-pseudo-checkbox-checked,.mat-accent .mat-pseudo-checkbox-indeterminate,.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-indeterminate{background:#ff4081}.mat-warn .mat-pseudo-checkbox-checked,.mat-warn .mat-pseudo-checkbox-indeterminate{background:#f44336}.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background:#b0b0b0}.mat-app-background{background-color:#fafafa;color:#000000de}.mat-elevation-z0{box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-elevation-z1{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-elevation-z2{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-elevation-z3{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-elevation-z4{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-elevation-z5{box-shadow:0 3px 5px -1px #0003,0 5px 8px 0 #00000024,0 1px 14px 0 #0000001f}.mat-elevation-z6{box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-elevation-z7{box-shadow:0 4px 5px -2px #0003,0 7px 10px 1px #00000024,0 2px 16px 1px #0000001f}.mat-elevation-z8{box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-elevation-z9{box-shadow:0 5px 6px -3px #0003,0 9px 12px 1px #00000024,0 3px 16px 2px #0000001f}.mat-elevation-z10{box-shadow:0 6px 6px -3px #0003,0 10px 14px 1px #00000024,0 4px 18px 3px #0000001f}.mat-elevation-z11{box-shadow:0 6px 7px -4px #0003,0 11px 15px 1px #00000024,0 4px 20px 3px #0000001f}.mat-elevation-z12{box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-elevation-z13{box-shadow:0 7px 8px -4px #0003,0 13px 19px 2px #00000024,0 5px 24px 4px #0000001f}.mat-elevation-z14{box-shadow:0 7px 9px -4px #0003,0 14px 21px 2px #00000024,0 5px 26px 4px #0000001f}.mat-elevation-z15{box-shadow:0 8px 9px -5px #0003,0 15px 22px 2px #00000024,0 6px 28px 5px #0000001f}.mat-elevation-z16{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-elevation-z17{box-shadow:0 8px 11px -5px #0003,0 17px 26px 2px #00000024,0 6px 32px 5px #0000001f}.mat-elevation-z18{box-shadow:0 9px 11px -5px #0003,0 18px 28px 2px #00000024,0 7px 34px 6px #0000001f}.mat-elevation-z19{box-shadow:0 9px 12px -6px #0003,0 19px 29px 2px #00000024,0 7px 36px 6px #0000001f}.mat-elevation-z20{box-shadow:0 10px 13px -6px #0003,0 20px 31px 3px #00000024,0 8px 38px 7px #0000001f}.mat-elevation-z21{box-shadow:0 10px 13px -6px #0003,0 21px 33px 3px #00000024,0 8px 40px 7px #0000001f}.mat-elevation-z22{box-shadow:0 10px 14px -6px #0003,0 22px 35px 3px #00000024,0 8px 42px 7px #0000001f}.mat-elevation-z23{box-shadow:0 11px 14px -7px #0003,0 23px 36px 3px #00000024,0 9px 44px 8px #0000001f}.mat-elevation-z24{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-theme-loaded-marker{display:none}.mat-autocomplete-panel{background:#fff;color:#000000de}.mat-autocomplete-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover){background:#fff}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover):not(.mat-option-disabled){color:#000000de}.mat-badge{position:relative}.mat-badge-hidden .mat-badge-content{display:none}.mat-badge-content{position:absolute;text-align:center;display:inline-block;border-radius:50%;transition:transform .2s ease-in-out;transform:scale(.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;pointer-events:none}.mat-badge-content._mat-animation-noopable,.ng-animate-disabled .mat-badge-content{transition:none}.mat-badge-content.mat-badge-active{transform:none}.mat-badge-small .mat-badge-content{width:16px;height:16px;line-height:16px}.mat-badge-small.mat-badge-above .mat-badge-content{top:-8px}.mat-badge-small.mat-badge-below .mat-badge-content{bottom:-8px}.mat-badge-small.mat-badge-before .mat-badge-content{left:-16px}[dir=rtl] .mat-badge-small.mat-badge-before .mat-badge-content{left:auto;right:-16px}.mat-badge-small.mat-badge-after .mat-badge-content{right:-16px}[dir=rtl] .mat-badge-small.mat-badge-after .mat-badge-content{right:auto;left:-16px}.mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-8px}.mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-8px}.mat-badge-medium .mat-badge-content{width:22px;height:22px;line-height:22px}.mat-badge-medium.mat-badge-above .mat-badge-content{top:-11px}.mat-badge-medium.mat-badge-below .mat-badge-content{bottom:-11px}.mat-badge-medium.mat-badge-before .mat-badge-content{left:-22px}[dir=rtl] .mat-badge-medium.mat-badge-before .mat-badge-content{left:auto;right:-22px}.mat-badge-medium.mat-badge-after .mat-badge-content{right:-22px}[dir=rtl] .mat-badge-medium.mat-badge-after .mat-badge-content{right:auto;left:-22px}.mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-11px}.mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-11px}.mat-badge-large .mat-badge-content{width:28px;height:28px;line-height:28px}.mat-badge-large.mat-badge-above .mat-badge-content{top:-14px}.mat-badge-large.mat-badge-below .mat-badge-content{bottom:-14px}.mat-badge-large.mat-badge-before .mat-badge-content{left:-28px}[dir=rtl] .mat-badge-large.mat-badge-before .mat-badge-content{left:auto;right:-28px}.mat-badge-large.mat-badge-after .mat-badge-content{right:-28px}[dir=rtl] .mat-badge-large.mat-badge-after .mat-badge-content{right:auto;left:-28px}.mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-14px}.mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-14px}.mat-badge-content{color:#fff;background:#3f51b5}.cdk-high-contrast-active .mat-badge-content{outline:1px solid;border-radius:0}.mat-badge-accent .mat-badge-content{background:#ff4081;color:#fff}.mat-badge-warn .mat-badge-content{color:#fff;background:#f44336}.mat-badge-disabled .mat-badge-content{background:#b9b9b9;color:#00000061}.mat-bottom-sheet-container{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f;background:#fff;color:#000000de}.mat-button,.mat-icon-button,.mat-stroked-button{color:inherit;background:#0000}.mat-button.mat-primary,.mat-icon-button.mat-primary,.mat-stroked-button.mat-primary{color:#3f51b5}.mat-button.mat-accent,.mat-icon-button.mat-accent,.mat-stroked-button.mat-accent{color:#ff4081}.mat-button.mat-warn,.mat-icon-button.mat-warn,.mat-stroked-button.mat-warn{color:#f44336}.mat-button.mat-accent.mat-button-disabled,.mat-button.mat-button-disabled.mat-button-disabled,.mat-button.mat-primary.mat-button-disabled,.mat-button.mat-warn.mat-button-disabled,.mat-icon-button.mat-accent.mat-button-disabled,.mat-icon-button.mat-button-disabled.mat-button-disabled,.mat-icon-button.mat-primary.mat-button-disabled,.mat-icon-button.mat-warn.mat-button-disabled,.mat-stroked-button.mat-accent.mat-button-disabled,.mat-stroked-button.mat-button-disabled.mat-button-disabled,.mat-stroked-button.mat-primary.mat-button-disabled,.mat-stroked-button.mat-warn.mat-button-disabled{color:#00000042}.mat-button.mat-primary .mat-button-focus-overlay,.mat-icon-button.mat-primary .mat-button-focus-overlay,.mat-stroked-button.mat-primary .mat-button-focus-overlay{background-color:#3f51b5}.mat-button.mat-accent .mat-button-focus-overlay,.mat-icon-button.mat-accent .mat-button-focus-overlay,.mat-stroked-button.mat-accent .mat-button-focus-overlay{background-color:#ff4081}.mat-button.mat-warn .mat-button-focus-overlay,.mat-icon-button.mat-warn .mat-button-focus-overlay,.mat-stroked-button.mat-warn .mat-button-focus-overlay{background-color:#f44336}.mat-button.mat-button-disabled .mat-button-focus-overlay,.mat-icon-button.mat-button-disabled .mat-button-focus-overlay,.mat-stroked-button.mat-button-disabled .mat-button-focus-overlay{background-color:initial}.mat-button .mat-ripple-element,.mat-icon-button .mat-ripple-element,.mat-stroked-button .mat-ripple-element{opacity:.1;background-color:currentColor}.mat-button-focus-overlay{background:#000}.mat-stroked-button:not(.mat-button-disabled){border-color:#0000001f}.mat-fab,.mat-flat-button,.mat-mini-fab,.mat-raised-button{color:#000000de;background-color:#fff}.mat-fab.mat-accent,.mat-fab.mat-primary,.mat-fab.mat-warn,.mat-flat-button.mat-accent,.mat-flat-button.mat-primary,.mat-flat-button.mat-warn,.mat-mini-fab.mat-accent,.mat-mini-fab.mat-primary,.mat-mini-fab.mat-warn,.mat-raised-button.mat-accent,.mat-raised-button.mat-primary,.mat-raised-button.mat-warn{color:#fff}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{color:#00000042}.mat-fab.mat-primary,.mat-flat-button.mat-primary,.mat-mini-fab.mat-primary,.mat-raised-button.mat-primary{background-color:#3f51b5}.mat-fab.mat-accent,.mat-flat-button.mat-accent,.mat-mini-fab.mat-accent,.mat-raised-button.mat-accent{background-color:#ff4081}.mat-fab.mat-warn,.mat-flat-button.mat-warn,.mat-mini-fab.mat-warn,.mat-raised-button.mat-warn{background-color:#f44336}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{background-color:#0000001f}.mat-fab.mat-accent .mat-ripple-element,.mat-fab.mat-primary .mat-ripple-element,.mat-fab.mat-warn .mat-ripple-element,.mat-flat-button.mat-accent .mat-ripple-element,.mat-flat-button.mat-primary .mat-ripple-element,.mat-flat-button.mat-warn .mat-ripple-element,.mat-mini-fab.mat-accent .mat-ripple-element,.mat-mini-fab.mat-primary .mat-ripple-element,.mat-mini-fab.mat-warn .mat-ripple-element,.mat-raised-button.mat-accent .mat-ripple-element,.mat-raised-button.mat-primary .mat-ripple-element,.mat-raised-button.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-flat-button:not([class*=mat-elevation-z]),.mat-stroked-button:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-raised-button:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-raised-button:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-raised-button.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-fab:not([class*=mat-elevation-z]),.mat-mini-fab:not([class*=mat-elevation-z]){box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]),.mat-mini-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-fab.mat-button-disabled:not([class*=mat-elevation-z]),.mat-mini-fab.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-button-toggle-group,.mat-button-toggle-standalone{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{box-shadow:none}.mat-button-toggle{color:#00000061}.mat-button-toggle .mat-button-toggle-focus-overlay{background-color:#0000001f}.mat-button-toggle-appearance-standard{color:#000000de;background:#fff}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:#000}.mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:1px solid #0000001f}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:1px solid #0000001f}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:none;border-top:1px solid #0000001f}.mat-button-toggle-checked{background-color:#e0e0e0;color:#0000008a}.mat-button-toggle-checked.mat-button-toggle-appearance-standard{color:#000000de}.mat-button-toggle-disabled{color:#00000042;background-color:#eee}.mat-button-toggle-disabled.mat-button-toggle-appearance-standard{background:#fff}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:#bdbdbd}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border:1px solid #0000001f}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px}.mat-card{background:#fff;color:#000000de}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-card.mat-card-flat:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-card-subtitle{color:#0000008a}.mat-checkbox-frame{border-color:#0000008a}.mat-checkbox-checkmark{fill:#fafafa}.mat-checkbox-checkmark-path{stroke:#fafafa!important}.mat-checkbox-mixedmark{background-color:#fafafa}.mat-checkbox-checked.mat-primary .mat-checkbox-background,.mat-checkbox-indeterminate.mat-primary .mat-checkbox-background{background-color:#3f51b5}.mat-checkbox-checked.mat-accent .mat-checkbox-background,.mat-checkbox-indeterminate.mat-accent .mat-checkbox-background{background-color:#ff4081}.mat-checkbox-checked.mat-warn .mat-checkbox-background,.mat-checkbox-indeterminate.mat-warn .mat-checkbox-background{background-color:#f44336}.mat-checkbox-disabled.mat-checkbox-checked .mat-checkbox-background,.mat-checkbox-disabled.mat-checkbox-indeterminate .mat-checkbox-background{background-color:#b0b0b0}.mat-checkbox-disabled:not(.mat-checkbox-checked) .mat-checkbox-frame{border-color:#b0b0b0}.mat-checkbox-disabled .mat-checkbox-label{color:#0000008a}.mat-checkbox .mat-ripple-element{background-color:#000}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element{background:#3f51b5}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element{background:#ff4081}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element{background:#f44336}.mat-chip.mat-standard-chip{background-color:#e0e0e0;color:#000000de}.mat-chip.mat-standard-chip .mat-chip-remove{color:#000000de;opacity:.4}.mat-chip.mat-standard-chip:not(.mat-chip-disabled):active{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-chip.mat-standard-chip:not(.mat-chip-disabled) .mat-chip-remove:hover{opacity:.54}.mat-chip.mat-standard-chip.mat-chip-disabled{opacity:.4}.mat-chip.mat-standard-chip:after{background:#000}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary{background-color:#3f51b5;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn{background-color:#f44336;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent{background-color:#ff4081;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-ripple-element{background-color:#ffffff1a}.mat-table{background:#fff}.mat-table-sticky,.mat-table tbody,.mat-table tfoot,.mat-table thead,[mat-footer-row],[mat-header-row],[mat-row],mat-footer-row,mat-header-row,mat-row{background:inherit}mat-footer-row,mat-header-row,mat-row,td.mat-cell,td.mat-footer-cell,th.mat-header-cell{border-bottom-color:#0000001f}.mat-header-cell{color:#0000008a}.mat-cell,.mat-footer-cell{color:#000000de}.mat-calendar-arrow{border-top-color:#0000008a}.mat-datepicker-content .mat-calendar-next-button,.mat-datepicker-content .mat-calendar-previous-button,.mat-datepicker-toggle{color:#0000008a}.mat-calendar-table-header-divider:after{background:#0000001f}.mat-calendar-body-label,.mat-calendar-table-header{color:#0000008a}.mat-calendar-body-cell-content,.mat-date-range-input-separator{color:#000000de;border-color:#0000}.mat-calendar-body-disabled&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-form-field-disabled .mat-date-range-input-separator{color:#00000061}.mat-calendar-body-in-preview{color:#0000003d}.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#00000061}.mat-calendar-body-disabled&gt;.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#0000002e}.mat-calendar-body-in-range:before{background:#3f51b533}.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-calendar-body-comparison-bridge-start:before,[dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-comparison-bridge-end:before,[dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-calendar-body-selected{background-color:#3f51b5;color:#fff}.mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#3f51b566}.mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#3f51b54d}.mat-datepicker-content{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f;background-color:#fff;color:#000000de}.mat-datepicker-content.mat-accent .mat-calendar-body-in-range:before{background:#ff408133}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-accent .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-accent .mat-calendar-body-selected{background-color:#ff4081;color:#fff}.mat-datepicker-content.mat-accent .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#ff408166}.mat-datepicker-content.mat-accent .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-accent .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#ff40814d}.mat-datepicker-content.mat-warn .mat-calendar-body-in-range:before{background:#f4433633}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-warn .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-warn .mat-calendar-body-selected{background-color:#f44336;color:#fff}.mat-datepicker-content.mat-warn .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#f4433666}.mat-datepicker-content.mat-warn .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-warn .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#f443364d}.mat-datepicker-content-touch{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-datepicker-toggle-active{color:#3f51b5}.mat-datepicker-toggle-active.mat-accent{color:#ff4081}.mat-datepicker-toggle-active.mat-warn{color:#f44336}.mat-date-range-input-inner[disabled]{color:#00000061}.mat-dialog-container{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f;background:#fff;color:#000000de}.mat-divider{border-top-color:#0000001f}.mat-divider-vertical{border-right-color:#0000001f}.mat-expansion-panel{background:#fff;color:#000000de}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-action-row{border-top-color:#0000001f}.mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true]),.mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true]),.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true]){background:#0000000a}@media(hover: none){.mat-expansion-panel:not(.mat-expanded):not([aria-disabled=true]) .mat-expansion-panel-header:hover{background:#fff}}.mat-expansion-panel-header-title{color:#000000de}.mat-expansion-indicator:after,.mat-expansion-panel-header-description{color:#0000008a}.mat-expansion-panel-header[aria-disabled=true]{color:#00000042}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title{color:inherit}.mat-expansion-panel-header{height:48px}.mat-expansion-panel-header.mat-expanded{height:64px}.mat-form-field-label,.mat-hint{color:#0009}.mat-form-field.mat-focused .mat-form-field-label{color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-label.mat-accent{color:#ff4081}.mat-form-field.mat-focused .mat-form-field-label.mat-warn{color:#f44336}.mat-focused .mat-form-field-required-marker{color:#ff4081}.mat-form-field-ripple{background-color:#000000de}.mat-form-field.mat-focused .mat-form-field-ripple{background-color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-ripple.mat-accent{background-color:#ff4081}.mat-form-field.mat-focused .mat-form-field-ripple.mat-warn{background-color:#f44336}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid) .mat-form-field-infix:after{color:#3f51b5}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-accent .mat-form-field-infix:after{color:#ff4081}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-warn .mat-form-field-infix:after,.mat-form-field.mat-form-field-invalid .mat-form-field-label,.mat-form-field.mat-form-field-invalid .mat-form-field-label.mat-accent,.mat-form-field.mat-form-field-invalid .mat-form-field-label .mat-form-field-required-marker{color:#f44336}.mat-form-field.mat-form-field-invalid .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple.mat-accent{background-color:#f44336}.mat-error{color:#f44336}.mat-form-field-appearance-legacy .mat-form-field-label,.mat-form-field-appearance-legacy .mat-hint{color:#0000008a}.mat-form-field-appearance-legacy .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-standard .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-fill .mat-form-field-flex{background-color:#0000000a}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{background-color:#00000005}.mat-form-field-appearance-fill .mat-form-field-underline:before{background-color:#0000006b}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-underline:before{background-color:initial}.mat-form-field-appearance-outline .mat-form-field-outline{color:#0000001f}.mat-form-field-appearance-outline .mat-form-field-outline-thick{color:#000000de}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{color:#3f51b5}.mat-form-field-appearance-outline.mat-focused.mat-accent .mat-form-field-outline-thick{color:#ff4081}.mat-form-field-appearance-outline.mat-focused.mat-warn .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid.mat-form-field-invalid .mat-form-field-outline-thick{color:#f44336}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:#0000000f}.mat-icon.mat-primary{color:#3f51b5}.mat-icon.mat-accent{color:#ff4081}.mat-icon.mat-warn{color:#f44336}.mat-form-field-type-mat-native-select .mat-form-field-infix:after{color:#0000008a}.mat-form-field-type-mat-native-select.mat-form-field-disabled .mat-form-field-infix:after,.mat-input-element:disabled{color:#00000061}.mat-input-element{caret-color:#3f51b5}.mat-input-element::placeholder{color:#0000006b}.mat-input-element::-moz-placeholder{color:#0000006b}.mat-input-element::-webkit-input-placeholder{color:#0000006b}.mat-input-element:-ms-input-placeholder{color:#0000006b}.mat-form-field.mat-accent .mat-input-element{caret-color:#ff4081}.mat-form-field-invalid .mat-input-element,.mat-form-field.mat-warn .mat-input-element{caret-color:#f44336}.mat-form-field-type-mat-native-select.mat-form-field-invalid .mat-form-field-infix:after{color:#f44336}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{color:#000000de}.mat-list-base .mat-subheader{color:#0000008a}.mat-list-item-disabled{background-color:#eee}.mat-action-list .mat-list-item:focus,.mat-action-list .mat-list-item:hover,.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover{background:#0000000a}.mat-list-single-selected-option,.mat-list-single-selected-option:focus,.mat-list-single-selected-option:hover{background:#0000001f}.mat-menu-panel{background:#fff}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-menu-item{background:#0000;color:#000000de}.mat-menu-item[disabled],.mat-menu-item[disabled] .mat-icon-no-color,.mat-menu-item[disabled] .mat-menu-submenu-icon{color:#00000061}.mat-menu-item .mat-icon-no-color,.mat-menu-submenu-icon{color:#0000008a}.mat-menu-item-highlighted:not([disabled]),.mat-menu-item.cdk-keyboard-focused:not([disabled]),.mat-menu-item.cdk-program-focused:not([disabled]),.mat-menu-item:hover:not([disabled]){background:#0000000a}.mat-paginator{background:#fff}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{color:#0000008a}.mat-paginator-decrement,.mat-paginator-increment{border-top:2px solid #0000008a;border-right:2px solid #0000008a}.mat-paginator-first,.mat-paginator-last{border-top:2px solid #0000008a}.mat-icon-button[disabled] .mat-paginator-decrement,.mat-icon-button[disabled] .mat-paginator-first,.mat-icon-button[disabled] .mat-paginator-increment,.mat-icon-button[disabled] .mat-paginator-last{border-color:#00000061}.mat-paginator-container{min-height:56px}.mat-progress-bar-background{fill:#cbd0e9}.mat-progress-bar-buffer{background-color:#cbd0e9}.mat-progress-bar-fill:after{background-color:#3f51b5}.mat-progress-bar.mat-accent .mat-progress-bar-background{fill:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-buffer{background-color:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-fill:after{background-color:#ff4081}.mat-progress-bar.mat-warn .mat-progress-bar-background{fill:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-buffer{background-color:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-fill:after{background-color:#f44336}.mat-progress-spinner circle,.mat-spinner circle{stroke:#3f51b5}.mat-progress-spinner.mat-accent circle,.mat-spinner.mat-accent circle{stroke:#ff4081}.mat-progress-spinner.mat-warn circle,.mat-spinner.mat-warn circle{stroke:#f44336}.mat-radio-outer-circle{border-color:#0000008a}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-outer-circle{border-color:#3f51b5}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-primary .mat-radio-inner-circle,.mat-radio-button.mat-primary .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-primary:active .mat-radio-persistent-ripple{background-color:#3f51b5}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-outer-circle{border-color:#ff4081}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-accent .mat-radio-inner-circle,.mat-radio-button.mat-accent .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-accent:active .mat-radio-persistent-ripple{background-color:#ff4081}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-outer-circle{border-color:#f44336}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-warn .mat-radio-inner-circle,.mat-radio-button.mat-warn .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-warn:active .mat-radio-persistent-ripple{background-color:#f44336}.mat-radio-button.mat-radio-disabled.mat-radio-checked .mat-radio-outer-circle,.mat-radio-button.mat-radio-disabled .mat-radio-outer-circle{border-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-inner-circle,.mat-radio-button.mat-radio-disabled .mat-radio-ripple .mat-ripple-element{background-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-label-content{color:#00000061}.mat-radio-button .mat-ripple-element{background-color:#000}.mat-select-value{color:#000000de}.mat-select-placeholder{color:#0000006b}.mat-select-disabled .mat-select-value{color:#00000061}.mat-select-arrow{color:#0000008a}.mat-select-panel{background:#fff}.mat-select-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-select-panel .mat-option.mat-selected:not(.mat-option-multiple){background:#0000001f}.mat-form-field.mat-focused.mat-primary .mat-select-arrow{color:#3f51b5}.mat-form-field.mat-focused.mat-accent .mat-select-arrow{color:#ff4081}.mat-form-field.mat-focused.mat-warn .mat-select-arrow,.mat-form-field .mat-select.mat-select-invalid .mat-select-arrow{color:#f44336}.mat-form-field .mat-select.mat-select-disabled .mat-select-arrow{color:#00000061}.mat-drawer-container{background-color:#fafafa;color:#000000de}.mat-drawer{color:#000000de}.mat-drawer,.mat-drawer.mat-drawer-push{background-color:#fff}.mat-drawer:not(.mat-drawer-side){box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-drawer-side{border-right:1px solid #0000001f}.mat-drawer-side.mat-drawer-end,[dir=rtl] .mat-drawer-side{border-left:1px solid #0000001f;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-left:none;border-right:1px solid #0000001f}.mat-drawer-backdrop.mat-drawer-shown{background-color:#0009}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#ff4081}.mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:#ff40818a}.mat-slide-toggle.mat-checked .mat-ripple-element{background-color:#ff4081}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-thumb{background-color:#3f51b5}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-bar{background-color:#3f51b58a}.mat-slide-toggle.mat-primary.mat-checked .mat-ripple-element{background-color:#3f51b5}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-thumb{background-color:#f44336}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-bar{background-color:#f443368a}.mat-slide-toggle.mat-warn.mat-checked .mat-ripple-element{background-color:#f44336}.mat-slide-toggle:not(.mat-checked) .mat-ripple-element{background-color:#000}.mat-slide-toggle-thumb{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f;background-color:#fafafa}.mat-slide-toggle-bar{background-color:#00000061}.mat-slider-track-background{background-color:#00000042}.mat-primary .mat-slider-thumb,.mat-primary .mat-slider-thumb-label,.mat-primary .mat-slider-track-fill{background-color:#3f51b5}.mat-primary .mat-slider-thumb-label-text{color:#fff}.mat-primary .mat-slider-focus-ring{background-color:#3f51b533}.mat-accent .mat-slider-thumb,.mat-accent .mat-slider-thumb-label,.mat-accent .mat-slider-track-fill{background-color:#ff4081}.mat-accent .mat-slider-thumb-label-text{color:#fff}.mat-accent .mat-slider-focus-ring{background-color:#ff408133}.mat-warn .mat-slider-thumb,.mat-warn .mat-slider-thumb-label,.mat-warn .mat-slider-track-fill{background-color:#f44336}.mat-warn .mat-slider-thumb-label-text{color:#fff}.mat-warn .mat-slider-focus-ring{background-color:#f4433633}.mat-slider.cdk-focused .mat-slider-track-background,.mat-slider:hover .mat-slider-track-background{background-color:#00000061}.mat-slider-disabled .mat-slider-thumb,.mat-slider-disabled .mat-slider-track-background,.mat-slider-disabled .mat-slider-track-fill,.mat-slider-disabled:hover .mat-slider-track-background{background-color:#00000042}.mat-slider-min-value .mat-slider-focus-ring{background-color:#0000001f}.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb-label{background-color:#000000de}.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb-label{background-color:#00000042}.mat-slider-min-value:not(.mat-slider-thumb-label-showing) .mat-slider-thumb{border-color:#00000042;background-color:initial}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover .mat-slider-thumb{border-color:#00000061}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused.mat-slider-disabled .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover.mat-slider-disabled .mat-slider-thumb{border-color:#00000042}.mat-slider-has-ticks .mat-slider-wrapper:after{border-color:#000000b3}.mat-slider-horizontal .mat-slider-ticks{background-image:repeating-linear-gradient(90deg,#000000b3,#000000b3 2px,#0000 0,#0000);background-image:-moz-repeating-linear-gradient(.0001deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-slider-vertical .mat-slider-ticks{background-image:repeating-linear-gradient(180deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused,.mat-step-header:hover:not([aria-disabled]),.mat-step-header:hover[aria-disabled=false]{background-color:#0000000a}.mat-step-header:hover[aria-disabled=true]{cursor:default}@media(hover: none){.mat-step-header:hover{background:none}}.mat-step-header .mat-step-label,.mat-step-header .mat-step-optional{color:#0000008a}.mat-step-header .mat-step-icon{background-color:#0000008a;color:#fff}.mat-step-header .mat-step-icon-selected,.mat-step-header .mat-step-icon-state-done,.mat-step-header .mat-step-icon-state-edit{background-color:#3f51b5;color:#fff}.mat-step-header.mat-accent .mat-step-icon{color:#fff}.mat-step-header.mat-accent .mat-step-icon-selected,.mat-step-header.mat-accent .mat-step-icon-state-done,.mat-step-header.mat-accent .mat-step-icon-state-edit{background-color:#ff4081;color:#fff}.mat-step-header.mat-warn .mat-step-icon{color:#fff}.mat-step-header.mat-warn .mat-step-icon-selected,.mat-step-header.mat-warn .mat-step-icon-state-done,.mat-step-header.mat-warn .mat-step-icon-state-edit{background-color:#f44336;color:#fff}.mat-step-header .mat-step-icon-state-error{background-color:initial;color:#f44336}.mat-step-header .mat-step-label.mat-step-label-active{color:#000000de}.mat-step-header .mat-step-label.mat-step-label-error{color:#f44336}.mat-stepper-horizontal,.mat-stepper-vertical{background-color:#fff}.mat-stepper-vertical-line:before{border-left-color:#0000001f}.mat-horizontal-stepper-header:after,.mat-horizontal-stepper-header:before,.mat-stepper-horizontal-line{border-top-color:#0000001f}.mat-horizontal-stepper-header{height:72px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header,.mat-vertical-stepper-header{padding:24px}.mat-stepper-vertical-line:before{top:-16px;bottom:-16px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:after,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:before,.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{top:36px}.mat-sort-header-arrow{color:#757575}.mat-tab-header,.mat-tab-nav-bar{border-bottom:1px solid #0000001f}.mat-tab-group-inverted-header .mat-tab-header,.mat-tab-group-inverted-header .mat-tab-nav-bar{border-top:1px solid #0000001f;border-bottom:none}.mat-tab-label,.mat-tab-link{color:#000000de}.mat-tab-label.mat-tab-disabled,.mat-tab-link.mat-tab-disabled{color:#00000061}.mat-tab-header-pagination-chevron{border-color:#000000de}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#00000061}.mat-tab-group[class*=mat-background-]&gt;.mat-tab-header,.mat-tab-nav-bar[class*=mat-background-]{border-bottom:none;border-top:none}.mat-tab-group.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-primary .mat-ink-bar,.mat-tab-nav-bar.mat-primary .mat-ink-bar{background-color:#3f51b5}.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-accent .mat-ink-bar,.mat-tab-nav-bar.mat-accent .mat-ink-bar{background-color:#ff4081}.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-warn .mat-ink-bar,.mat-tab-nav-bar.mat-warn .mat-ink-bar{background-color:#f44336}.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-background-primary&gt;.mat-tab-header,.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container{background-color:#3f51b5}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-background-accent&gt;.mat-tab-header,.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container{background-color:#ff4081}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-background-warn&gt;.mat-tab-header,.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container{background-color:#f44336}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-toolbar{background:#f5f5f5;color:#000000de}.mat-toolbar.mat-primary{background:#3f51b5;color:#fff}.mat-toolbar.mat-accent{background:#ff4081;color:#fff}.mat-toolbar.mat-warn{background:#f44336;color:#fff}.mat-toolbar .mat-focused .mat-form-field-ripple,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-form-field-underline{background-color:currentColor}.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-select-value{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}.mat-tooltip{background:#616161e6}.mat-tree{background:#fff}.mat-nested-tree-node,.mat-tree-node{color:#000000de}.mat-tree-node{min-height:48px}.mat-snack-bar-container{color:#ffffffb3;background:#323232;box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-simple-snackbar-action{color:#ff4081}body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>00000042</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/styles.aed625f13435cbb527ed.css</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>A timestamp was disclosed by the application/web server - Unix</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>00000052, which evaluates to: 1970-01-01 01:00:52</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (389 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/styles.aed625f13435cbb527ed.css HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: text/css,*/*;q=0.1
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: style
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 17:37:48 GMT
ETag: W/&quot;11dde-17e3ac49546&quot;
Content-Type: text/css; charset=UTF-8
Content-Length: 73182
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (73182 bytes)</summary>
				
				<pre><code>.mat-badge-content{font-weight:600;font-size:12px;font-family:Roboto,Helvetica Neue,sans-serif}.mat-badge-small .mat-badge-content{font-size:9px}.mat-badge-large .mat-badge-content{font-size:24px}.mat-h1,.mat-headline,.mat-typography h1{font:400 24px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h2,.mat-title,.mat-typography h2{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h3,.mat-subheading-2,.mat-typography h3{font:400 16px/28px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h4,.mat-subheading-1,.mat-typography h4{font:400 15px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h5,.mat-typography h5{font:400 calc(14px * .83)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-h6,.mat-typography h6{font:400 calc(14px * .67)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-body-2,.mat-body-strong{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body,.mat-body-1,.mat-typography{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body-1 p,.mat-body p,.mat-typography p{margin:0 0 12px}.mat-caption,.mat-small{font:400 12px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-display-4,.mat-typography .mat-display-4{font:300 112px/112px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.05em;margin:0 0 56px}.mat-display-3,.mat-typography .mat-display-3{font:400 56px/56px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.02em;margin:0 0 64px}.mat-display-2,.mat-typography .mat-display-2{font:400 45px/48px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.005em;margin:0 0 64px}.mat-display-1,.mat-typography .mat-display-1{font:400 34px/40px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 64px}.mat-bottom-sheet-container{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button,.mat-stroked-button{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-button-toggle,.mat-card{font-family:Roboto,Helvetica Neue,sans-serif}.mat-card-title{font-size:24px;font-weight:500}.mat-card-header .mat-card-title{font-size:20px}.mat-card-content,.mat-card-subtitle{font-size:14px}.mat-checkbox{font-family:Roboto,Helvetica Neue,sans-serif}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-chip{font-size:14px;font-weight:500}.mat-chip .mat-chip-remove.mat-icon,.mat-chip .mat-chip-trailing-icon.mat-icon{font-size:18px}.mat-table{font-family:Roboto,Helvetica Neue,sans-serif}.mat-header-cell{font-size:12px;font-weight:500}.mat-cell,.mat-footer-cell{font-size:14px}.mat-calendar{font-family:Roboto,Helvetica Neue,sans-serif}.mat-calendar-body{font-size:13px}.mat-calendar-body-label,.mat-calendar-period-button{font-size:14px;font-weight:500}.mat-calendar-table-header th{font-size:11px;font-weight:400}.mat-dialog-title{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-expansion-panel-header{font-family:Roboto,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.mat-expansion-panel-content{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field{font-size:inherit;font-weight:400;line-height:1.125;font-family:Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field-wrapper{padding-bottom:1.34375em}.mat-form-field-prefix .mat-icon,.mat-form-field-suffix .mat-icon{font-size:150%;line-height:1.125}.mat-form-field-prefix .mat-icon-button,.mat-form-field-suffix .mat-icon-button{height:1.5em;width:1.5em}.mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-suffix .mat-icon-button .mat-icon{height:1.125em;line-height:1.125}.mat-form-field-infix{padding:.5em 0;border-top:.84375em solid #0000}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34375em) scale(.75);width:133.3333333333%}.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34374em) scale(.75);width:133.3333433333%}.mat-form-field-label-wrapper{top:-.84375em;padding-top:.84375em}.mat-form-field-label{top:1.34375em}.mat-form-field-underline{bottom:1.34375em}.mat-form-field-subscript-wrapper{font-size:75%;margin-top:.6666666667em;top:calc(100% - 1.7916666667em)}.mat-form-field-appearance-legacy .mat-form-field-wrapper{padding-bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-infix{padding:.4375em 0}.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.001px);-ms-transform:translateY(-1.28125em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00101px);-ms-transform:translateY(-1.28124em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00102px);-ms-transform:translateY(-1.28123em) scale(.75);width:133.3333533333%}.mat-form-field-appearance-legacy .mat-form-field-label{top:1.28125em}.mat-form-field-appearance-legacy .mat-form-field-underline{bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-subscript-wrapper{margin-top:.5416666667em;top:calc(100% - 1.6666666667em)}@media print{.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28122em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28121em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.2812em) scale(.75)}}.mat-form-field-appearance-fill .mat-form-field-infix{padding:.25em 0 .75em}.mat-form-field-appearance-fill .mat-form-field-label{top:1.09375em;margin-top:-.5em}.mat-form-field-appearance-fill.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59374em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-outline .mat-form-field-infix{padding:1em 0}.mat-form-field-appearance-outline .mat-form-field-label{top:1.84375em;margin-top:-.25em}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59374em) scale(.75);width:133.3333433333%}.mat-grid-tile-footer,.mat-grid-tile-header{font-size:14px}.mat-grid-tile-footer .mat-line,.mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}input.mat-input-element{margin-top:-.0625em}.mat-menu-item{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:400}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px}.mat-radio-button,.mat-select{font-family:Roboto,Helvetica Neue,sans-serif}.mat-select-trigger{height:1.125em}.mat-slide-toggle-content,.mat-slider-thumb-label-text{font-family:Roboto,Helvetica Neue,sans-serif}.mat-slider-thumb-label-text{font-size:12px;font-weight:500}.mat-stepper-horizontal,.mat-stepper-vertical{font-family:Roboto,Helvetica Neue,sans-serif}.mat-step-label{font-size:14px;font-weight:400}.mat-step-sub-label-error{font-weight:400}.mat-step-label-error{font-size:14px}.mat-step-label-selected{font-size:14px;font-weight:500}.mat-tab-group,.mat-tab-label,.mat-tab-link{font-family:Roboto,Helvetica Neue,sans-serif}.mat-tab-label,.mat-tab-link{font-size:14px;font-weight:500}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0}.mat-tooltip{font-family:Roboto,Helvetica Neue,sans-serif;font-size:10px;padding-top:6px;padding-bottom:6px}.mat-tooltip-handset{font-size:14px;padding-top:8px;padding-bottom:8px}.mat-list-item,.mat-list-option{font-family:Roboto,Helvetica Neue,sans-serif}.mat-list-base .mat-list-item{font-size:16px}.mat-list-base .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-list-option{font-size:16px}.mat-list-base .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-option .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-list-base[dense] .mat-list-item{font-size:12px}.mat-list-base[dense] .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-list-base[dense] .mat-list-option{font-size:12px}.mat-list-base[dense] .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-option .mat-line:nth-child(n+2){font-size:12px}.mat-list-base[dense] .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;font-weight:500}.mat-option{font-family:Roboto,Helvetica Neue,sans-serif;font-size:16px}.mat-optgroup-label{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-simple-snackbar{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px}.mat-simple-snackbar-action{line-height:1;font-family:inherit;font-size:inherit;font-weight:500}.mat-tree{font-family:Roboto,Helvetica Neue,sans-serif}.mat-nested-tree-node,.mat-tree-node{font-weight:400;font-size:14px}.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale(0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper,.cdk-overlay-pane{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{pointer-events:auto;box-sizing:border-box;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:#00000052}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:initial!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:initial!important;height:0!important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator,.mat-mdc-focus-indicator{position:relative}.mat-ripple-element{background-color:#0000001a}.mat-option{color:#000000de}.mat-option.mat-selected:not(.mat-option-multiple):not(.mat-option-disabled),.mat-option:focus:not(.mat-option-disabled),.mat-option:hover:not(.mat-option-disabled){background:#0000000a}.mat-option.mat-active{background:#0000000a;color:#000000de}.mat-option.mat-option-disabled{color:#00000061}.mat-primary .mat-option.mat-selected:not(.mat-option-disabled){color:#3f51b5}.mat-accent .mat-option.mat-selected:not(.mat-option-disabled){color:#ff4081}.mat-warn .mat-option.mat-selected:not(.mat-option-disabled){color:#f44336}.mat-optgroup-label{color:#0000008a}.mat-optgroup-disabled .mat-optgroup-label{color:#00000061}.mat-pseudo-checkbox{color:#0000008a}.mat-pseudo-checkbox:after{color:#fafafa}.mat-pseudo-checkbox-disabled{color:#b0b0b0}.mat-primary .mat-pseudo-checkbox-checked,.mat-primary .mat-pseudo-checkbox-indeterminate{background:#3f51b5}.mat-accent .mat-pseudo-checkbox-checked,.mat-accent .mat-pseudo-checkbox-indeterminate,.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-indeterminate{background:#ff4081}.mat-warn .mat-pseudo-checkbox-checked,.mat-warn .mat-pseudo-checkbox-indeterminate{background:#f44336}.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background:#b0b0b0}.mat-app-background{background-color:#fafafa;color:#000000de}.mat-elevation-z0{box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-elevation-z1{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-elevation-z2{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-elevation-z3{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-elevation-z4{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-elevation-z5{box-shadow:0 3px 5px -1px #0003,0 5px 8px 0 #00000024,0 1px 14px 0 #0000001f}.mat-elevation-z6{box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-elevation-z7{box-shadow:0 4px 5px -2px #0003,0 7px 10px 1px #00000024,0 2px 16px 1px #0000001f}.mat-elevation-z8{box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-elevation-z9{box-shadow:0 5px 6px -3px #0003,0 9px 12px 1px #00000024,0 3px 16px 2px #0000001f}.mat-elevation-z10{box-shadow:0 6px 6px -3px #0003,0 10px 14px 1px #00000024,0 4px 18px 3px #0000001f}.mat-elevation-z11{box-shadow:0 6px 7px -4px #0003,0 11px 15px 1px #00000024,0 4px 20px 3px #0000001f}.mat-elevation-z12{box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-elevation-z13{box-shadow:0 7px 8px -4px #0003,0 13px 19px 2px #00000024,0 5px 24px 4px #0000001f}.mat-elevation-z14{box-shadow:0 7px 9px -4px #0003,0 14px 21px 2px #00000024,0 5px 26px 4px #0000001f}.mat-elevation-z15{box-shadow:0 8px 9px -5px #0003,0 15px 22px 2px #00000024,0 6px 28px 5px #0000001f}.mat-elevation-z16{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-elevation-z17{box-shadow:0 8px 11px -5px #0003,0 17px 26px 2px #00000024,0 6px 32px 5px #0000001f}.mat-elevation-z18{box-shadow:0 9px 11px -5px #0003,0 18px 28px 2px #00000024,0 7px 34px 6px #0000001f}.mat-elevation-z19{box-shadow:0 9px 12px -6px #0003,0 19px 29px 2px #00000024,0 7px 36px 6px #0000001f}.mat-elevation-z20{box-shadow:0 10px 13px -6px #0003,0 20px 31px 3px #00000024,0 8px 38px 7px #0000001f}.mat-elevation-z21{box-shadow:0 10px 13px -6px #0003,0 21px 33px 3px #00000024,0 8px 40px 7px #0000001f}.mat-elevation-z22{box-shadow:0 10px 14px -6px #0003,0 22px 35px 3px #00000024,0 8px 42px 7px #0000001f}.mat-elevation-z23{box-shadow:0 11px 14px -7px #0003,0 23px 36px 3px #00000024,0 9px 44px 8px #0000001f}.mat-elevation-z24{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-theme-loaded-marker{display:none}.mat-autocomplete-panel{background:#fff;color:#000000de}.mat-autocomplete-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover){background:#fff}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover):not(.mat-option-disabled){color:#000000de}.mat-badge{position:relative}.mat-badge-hidden .mat-badge-content{display:none}.mat-badge-content{position:absolute;text-align:center;display:inline-block;border-radius:50%;transition:transform .2s ease-in-out;transform:scale(.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;pointer-events:none}.mat-badge-content._mat-animation-noopable,.ng-animate-disabled .mat-badge-content{transition:none}.mat-badge-content.mat-badge-active{transform:none}.mat-badge-small .mat-badge-content{width:16px;height:16px;line-height:16px}.mat-badge-small.mat-badge-above .mat-badge-content{top:-8px}.mat-badge-small.mat-badge-below .mat-badge-content{bottom:-8px}.mat-badge-small.mat-badge-before .mat-badge-content{left:-16px}[dir=rtl] .mat-badge-small.mat-badge-before .mat-badge-content{left:auto;right:-16px}.mat-badge-small.mat-badge-after .mat-badge-content{right:-16px}[dir=rtl] .mat-badge-small.mat-badge-after .mat-badge-content{right:auto;left:-16px}.mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-8px}.mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-8px}.mat-badge-medium .mat-badge-content{width:22px;height:22px;line-height:22px}.mat-badge-medium.mat-badge-above .mat-badge-content{top:-11px}.mat-badge-medium.mat-badge-below .mat-badge-content{bottom:-11px}.mat-badge-medium.mat-badge-before .mat-badge-content{left:-22px}[dir=rtl] .mat-badge-medium.mat-badge-before .mat-badge-content{left:auto;right:-22px}.mat-badge-medium.mat-badge-after .mat-badge-content{right:-22px}[dir=rtl] .mat-badge-medium.mat-badge-after .mat-badge-content{right:auto;left:-22px}.mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-11px}.mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-11px}.mat-badge-large .mat-badge-content{width:28px;height:28px;line-height:28px}.mat-badge-large.mat-badge-above .mat-badge-content{top:-14px}.mat-badge-large.mat-badge-below .mat-badge-content{bottom:-14px}.mat-badge-large.mat-badge-before .mat-badge-content{left:-28px}[dir=rtl] .mat-badge-large.mat-badge-before .mat-badge-content{left:auto;right:-28px}.mat-badge-large.mat-badge-after .mat-badge-content{right:-28px}[dir=rtl] .mat-badge-large.mat-badge-after .mat-badge-content{right:auto;left:-28px}.mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-14px}.mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-14px}.mat-badge-content{color:#fff;background:#3f51b5}.cdk-high-contrast-active .mat-badge-content{outline:1px solid;border-radius:0}.mat-badge-accent .mat-badge-content{background:#ff4081;color:#fff}.mat-badge-warn .mat-badge-content{color:#fff;background:#f44336}.mat-badge-disabled .mat-badge-content{background:#b9b9b9;color:#00000061}.mat-bottom-sheet-container{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f;background:#fff;color:#000000de}.mat-button,.mat-icon-button,.mat-stroked-button{color:inherit;background:#0000}.mat-button.mat-primary,.mat-icon-button.mat-primary,.mat-stroked-button.mat-primary{color:#3f51b5}.mat-button.mat-accent,.mat-icon-button.mat-accent,.mat-stroked-button.mat-accent{color:#ff4081}.mat-button.mat-warn,.mat-icon-button.mat-warn,.mat-stroked-button.mat-warn{color:#f44336}.mat-button.mat-accent.mat-button-disabled,.mat-button.mat-button-disabled.mat-button-disabled,.mat-button.mat-primary.mat-button-disabled,.mat-button.mat-warn.mat-button-disabled,.mat-icon-button.mat-accent.mat-button-disabled,.mat-icon-button.mat-button-disabled.mat-button-disabled,.mat-icon-button.mat-primary.mat-button-disabled,.mat-icon-button.mat-warn.mat-button-disabled,.mat-stroked-button.mat-accent.mat-button-disabled,.mat-stroked-button.mat-button-disabled.mat-button-disabled,.mat-stroked-button.mat-primary.mat-button-disabled,.mat-stroked-button.mat-warn.mat-button-disabled{color:#00000042}.mat-button.mat-primary .mat-button-focus-overlay,.mat-icon-button.mat-primary .mat-button-focus-overlay,.mat-stroked-button.mat-primary .mat-button-focus-overlay{background-color:#3f51b5}.mat-button.mat-accent .mat-button-focus-overlay,.mat-icon-button.mat-accent .mat-button-focus-overlay,.mat-stroked-button.mat-accent .mat-button-focus-overlay{background-color:#ff4081}.mat-button.mat-warn .mat-button-focus-overlay,.mat-icon-button.mat-warn .mat-button-focus-overlay,.mat-stroked-button.mat-warn .mat-button-focus-overlay{background-color:#f44336}.mat-button.mat-button-disabled .mat-button-focus-overlay,.mat-icon-button.mat-button-disabled .mat-button-focus-overlay,.mat-stroked-button.mat-button-disabled .mat-button-focus-overlay{background-color:initial}.mat-button .mat-ripple-element,.mat-icon-button .mat-ripple-element,.mat-stroked-button .mat-ripple-element{opacity:.1;background-color:currentColor}.mat-button-focus-overlay{background:#000}.mat-stroked-button:not(.mat-button-disabled){border-color:#0000001f}.mat-fab,.mat-flat-button,.mat-mini-fab,.mat-raised-button{color:#000000de;background-color:#fff}.mat-fab.mat-accent,.mat-fab.mat-primary,.mat-fab.mat-warn,.mat-flat-button.mat-accent,.mat-flat-button.mat-primary,.mat-flat-button.mat-warn,.mat-mini-fab.mat-accent,.mat-mini-fab.mat-primary,.mat-mini-fab.mat-warn,.mat-raised-button.mat-accent,.mat-raised-button.mat-primary,.mat-raised-button.mat-warn{color:#fff}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{color:#00000042}.mat-fab.mat-primary,.mat-flat-button.mat-primary,.mat-mini-fab.mat-primary,.mat-raised-button.mat-primary{background-color:#3f51b5}.mat-fab.mat-accent,.mat-flat-button.mat-accent,.mat-mini-fab.mat-accent,.mat-raised-button.mat-accent{background-color:#ff4081}.mat-fab.mat-warn,.mat-flat-button.mat-warn,.mat-mini-fab.mat-warn,.mat-raised-button.mat-warn{background-color:#f44336}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{background-color:#0000001f}.mat-fab.mat-accent .mat-ripple-element,.mat-fab.mat-primary .mat-ripple-element,.mat-fab.mat-warn .mat-ripple-element,.mat-flat-button.mat-accent .mat-ripple-element,.mat-flat-button.mat-primary .mat-ripple-element,.mat-flat-button.mat-warn .mat-ripple-element,.mat-mini-fab.mat-accent .mat-ripple-element,.mat-mini-fab.mat-primary .mat-ripple-element,.mat-mini-fab.mat-warn .mat-ripple-element,.mat-raised-button.mat-accent .mat-ripple-element,.mat-raised-button.mat-primary .mat-ripple-element,.mat-raised-button.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-flat-button:not([class*=mat-elevation-z]),.mat-stroked-button:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-raised-button:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-raised-button:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-raised-button.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-fab:not([class*=mat-elevation-z]),.mat-mini-fab:not([class*=mat-elevation-z]){box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]),.mat-mini-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-fab.mat-button-disabled:not([class*=mat-elevation-z]),.mat-mini-fab.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-button-toggle-group,.mat-button-toggle-standalone{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{box-shadow:none}.mat-button-toggle{color:#00000061}.mat-button-toggle .mat-button-toggle-focus-overlay{background-color:#0000001f}.mat-button-toggle-appearance-standard{color:#000000de;background:#fff}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:#000}.mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:1px solid #0000001f}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:1px solid #0000001f}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:none;border-top:1px solid #0000001f}.mat-button-toggle-checked{background-color:#e0e0e0;color:#0000008a}.mat-button-toggle-checked.mat-button-toggle-appearance-standard{color:#000000de}.mat-button-toggle-disabled{color:#00000042;background-color:#eee}.mat-button-toggle-disabled.mat-button-toggle-appearance-standard{background:#fff}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:#bdbdbd}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border:1px solid #0000001f}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px}.mat-card{background:#fff;color:#000000de}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-card.mat-card-flat:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-card-subtitle{color:#0000008a}.mat-checkbox-frame{border-color:#0000008a}.mat-checkbox-checkmark{fill:#fafafa}.mat-checkbox-checkmark-path{stroke:#fafafa!important}.mat-checkbox-mixedmark{background-color:#fafafa}.mat-checkbox-checked.mat-primary .mat-checkbox-background,.mat-checkbox-indeterminate.mat-primary .mat-checkbox-background{background-color:#3f51b5}.mat-checkbox-checked.mat-accent .mat-checkbox-background,.mat-checkbox-indeterminate.mat-accent .mat-checkbox-background{background-color:#ff4081}.mat-checkbox-checked.mat-warn .mat-checkbox-background,.mat-checkbox-indeterminate.mat-warn .mat-checkbox-background{background-color:#f44336}.mat-checkbox-disabled.mat-checkbox-checked .mat-checkbox-background,.mat-checkbox-disabled.mat-checkbox-indeterminate .mat-checkbox-background{background-color:#b0b0b0}.mat-checkbox-disabled:not(.mat-checkbox-checked) .mat-checkbox-frame{border-color:#b0b0b0}.mat-checkbox-disabled .mat-checkbox-label{color:#0000008a}.mat-checkbox .mat-ripple-element{background-color:#000}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element{background:#3f51b5}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element{background:#ff4081}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element{background:#f44336}.mat-chip.mat-standard-chip{background-color:#e0e0e0;color:#000000de}.mat-chip.mat-standard-chip .mat-chip-remove{color:#000000de;opacity:.4}.mat-chip.mat-standard-chip:not(.mat-chip-disabled):active{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-chip.mat-standard-chip:not(.mat-chip-disabled) .mat-chip-remove:hover{opacity:.54}.mat-chip.mat-standard-chip.mat-chip-disabled{opacity:.4}.mat-chip.mat-standard-chip:after{background:#000}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary{background-color:#3f51b5;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn{background-color:#f44336;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent{background-color:#ff4081;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-ripple-element{background-color:#ffffff1a}.mat-table{background:#fff}.mat-table-sticky,.mat-table tbody,.mat-table tfoot,.mat-table thead,[mat-footer-row],[mat-header-row],[mat-row],mat-footer-row,mat-header-row,mat-row{background:inherit}mat-footer-row,mat-header-row,mat-row,td.mat-cell,td.mat-footer-cell,th.mat-header-cell{border-bottom-color:#0000001f}.mat-header-cell{color:#0000008a}.mat-cell,.mat-footer-cell{color:#000000de}.mat-calendar-arrow{border-top-color:#0000008a}.mat-datepicker-content .mat-calendar-next-button,.mat-datepicker-content .mat-calendar-previous-button,.mat-datepicker-toggle{color:#0000008a}.mat-calendar-table-header-divider:after{background:#0000001f}.mat-calendar-body-label,.mat-calendar-table-header{color:#0000008a}.mat-calendar-body-cell-content,.mat-date-range-input-separator{color:#000000de;border-color:#0000}.mat-calendar-body-disabled&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-form-field-disabled .mat-date-range-input-separator{color:#00000061}.mat-calendar-body-in-preview{color:#0000003d}.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#00000061}.mat-calendar-body-disabled&gt;.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#0000002e}.mat-calendar-body-in-range:before{background:#3f51b533}.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-calendar-body-comparison-bridge-start:before,[dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-comparison-bridge-end:before,[dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-calendar-body-selected{background-color:#3f51b5;color:#fff}.mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#3f51b566}.mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#3f51b54d}.mat-datepicker-content{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f;background-color:#fff;color:#000000de}.mat-datepicker-content.mat-accent .mat-calendar-body-in-range:before{background:#ff408133}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-accent .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-accent .mat-calendar-body-selected{background-color:#ff4081;color:#fff}.mat-datepicker-content.mat-accent .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#ff408166}.mat-datepicker-content.mat-accent .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-accent .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#ff40814d}.mat-datepicker-content.mat-warn .mat-calendar-body-in-range:before{background:#f4433633}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-warn .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-warn .mat-calendar-body-selected{background-color:#f44336;color:#fff}.mat-datepicker-content.mat-warn .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#f4433666}.mat-datepicker-content.mat-warn .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-warn .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#f443364d}.mat-datepicker-content-touch{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-datepicker-toggle-active{color:#3f51b5}.mat-datepicker-toggle-active.mat-accent{color:#ff4081}.mat-datepicker-toggle-active.mat-warn{color:#f44336}.mat-date-range-input-inner[disabled]{color:#00000061}.mat-dialog-container{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f;background:#fff;color:#000000de}.mat-divider{border-top-color:#0000001f}.mat-divider-vertical{border-right-color:#0000001f}.mat-expansion-panel{background:#fff;color:#000000de}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-action-row{border-top-color:#0000001f}.mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true]),.mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true]),.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true]){background:#0000000a}@media(hover: none){.mat-expansion-panel:not(.mat-expanded):not([aria-disabled=true]) .mat-expansion-panel-header:hover{background:#fff}}.mat-expansion-panel-header-title{color:#000000de}.mat-expansion-indicator:after,.mat-expansion-panel-header-description{color:#0000008a}.mat-expansion-panel-header[aria-disabled=true]{color:#00000042}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title{color:inherit}.mat-expansion-panel-header{height:48px}.mat-expansion-panel-header.mat-expanded{height:64px}.mat-form-field-label,.mat-hint{color:#0009}.mat-form-field.mat-focused .mat-form-field-label{color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-label.mat-accent{color:#ff4081}.mat-form-field.mat-focused .mat-form-field-label.mat-warn{color:#f44336}.mat-focused .mat-form-field-required-marker{color:#ff4081}.mat-form-field-ripple{background-color:#000000de}.mat-form-field.mat-focused .mat-form-field-ripple{background-color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-ripple.mat-accent{background-color:#ff4081}.mat-form-field.mat-focused .mat-form-field-ripple.mat-warn{background-color:#f44336}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid) .mat-form-field-infix:after{color:#3f51b5}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-accent .mat-form-field-infix:after{color:#ff4081}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-warn .mat-form-field-infix:after,.mat-form-field.mat-form-field-invalid .mat-form-field-label,.mat-form-field.mat-form-field-invalid .mat-form-field-label.mat-accent,.mat-form-field.mat-form-field-invalid .mat-form-field-label .mat-form-field-required-marker{color:#f44336}.mat-form-field.mat-form-field-invalid .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple.mat-accent{background-color:#f44336}.mat-error{color:#f44336}.mat-form-field-appearance-legacy .mat-form-field-label,.mat-form-field-appearance-legacy .mat-hint{color:#0000008a}.mat-form-field-appearance-legacy .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-standard .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-fill .mat-form-field-flex{background-color:#0000000a}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{background-color:#00000005}.mat-form-field-appearance-fill .mat-form-field-underline:before{background-color:#0000006b}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-underline:before{background-color:initial}.mat-form-field-appearance-outline .mat-form-field-outline{color:#0000001f}.mat-form-field-appearance-outline .mat-form-field-outline-thick{color:#000000de}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{color:#3f51b5}.mat-form-field-appearance-outline.mat-focused.mat-accent .mat-form-field-outline-thick{color:#ff4081}.mat-form-field-appearance-outline.mat-focused.mat-warn .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid.mat-form-field-invalid .mat-form-field-outline-thick{color:#f44336}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:#0000000f}.mat-icon.mat-primary{color:#3f51b5}.mat-icon.mat-accent{color:#ff4081}.mat-icon.mat-warn{color:#f44336}.mat-form-field-type-mat-native-select .mat-form-field-infix:after{color:#0000008a}.mat-form-field-type-mat-native-select.mat-form-field-disabled .mat-form-field-infix:after,.mat-input-element:disabled{color:#00000061}.mat-input-element{caret-color:#3f51b5}.mat-input-element::placeholder{color:#0000006b}.mat-input-element::-moz-placeholder{color:#0000006b}.mat-input-element::-webkit-input-placeholder{color:#0000006b}.mat-input-element:-ms-input-placeholder{color:#0000006b}.mat-form-field.mat-accent .mat-input-element{caret-color:#ff4081}.mat-form-field-invalid .mat-input-element,.mat-form-field.mat-warn .mat-input-element{caret-color:#f44336}.mat-form-field-type-mat-native-select.mat-form-field-invalid .mat-form-field-infix:after{color:#f44336}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{color:#000000de}.mat-list-base .mat-subheader{color:#0000008a}.mat-list-item-disabled{background-color:#eee}.mat-action-list .mat-list-item:focus,.mat-action-list .mat-list-item:hover,.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover{background:#0000000a}.mat-list-single-selected-option,.mat-list-single-selected-option:focus,.mat-list-single-selected-option:hover{background:#0000001f}.mat-menu-panel{background:#fff}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-menu-item{background:#0000;color:#000000de}.mat-menu-item[disabled],.mat-menu-item[disabled] .mat-icon-no-color,.mat-menu-item[disabled] .mat-menu-submenu-icon{color:#00000061}.mat-menu-item .mat-icon-no-color,.mat-menu-submenu-icon{color:#0000008a}.mat-menu-item-highlighted:not([disabled]),.mat-menu-item.cdk-keyboard-focused:not([disabled]),.mat-menu-item.cdk-program-focused:not([disabled]),.mat-menu-item:hover:not([disabled]){background:#0000000a}.mat-paginator{background:#fff}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{color:#0000008a}.mat-paginator-decrement,.mat-paginator-increment{border-top:2px solid #0000008a;border-right:2px solid #0000008a}.mat-paginator-first,.mat-paginator-last{border-top:2px solid #0000008a}.mat-icon-button[disabled] .mat-paginator-decrement,.mat-icon-button[disabled] .mat-paginator-first,.mat-icon-button[disabled] .mat-paginator-increment,.mat-icon-button[disabled] .mat-paginator-last{border-color:#00000061}.mat-paginator-container{min-height:56px}.mat-progress-bar-background{fill:#cbd0e9}.mat-progress-bar-buffer{background-color:#cbd0e9}.mat-progress-bar-fill:after{background-color:#3f51b5}.mat-progress-bar.mat-accent .mat-progress-bar-background{fill:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-buffer{background-color:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-fill:after{background-color:#ff4081}.mat-progress-bar.mat-warn .mat-progress-bar-background{fill:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-buffer{background-color:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-fill:after{background-color:#f44336}.mat-progress-spinner circle,.mat-spinner circle{stroke:#3f51b5}.mat-progress-spinner.mat-accent circle,.mat-spinner.mat-accent circle{stroke:#ff4081}.mat-progress-spinner.mat-warn circle,.mat-spinner.mat-warn circle{stroke:#f44336}.mat-radio-outer-circle{border-color:#0000008a}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-outer-circle{border-color:#3f51b5}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-primary .mat-radio-inner-circle,.mat-radio-button.mat-primary .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-primary:active .mat-radio-persistent-ripple{background-color:#3f51b5}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-outer-circle{border-color:#ff4081}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-accent .mat-radio-inner-circle,.mat-radio-button.mat-accent .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-accent:active .mat-radio-persistent-ripple{background-color:#ff4081}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-outer-circle{border-color:#f44336}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-warn .mat-radio-inner-circle,.mat-radio-button.mat-warn .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-warn:active .mat-radio-persistent-ripple{background-color:#f44336}.mat-radio-button.mat-radio-disabled.mat-radio-checked .mat-radio-outer-circle,.mat-radio-button.mat-radio-disabled .mat-radio-outer-circle{border-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-inner-circle,.mat-radio-button.mat-radio-disabled .mat-radio-ripple .mat-ripple-element{background-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-label-content{color:#00000061}.mat-radio-button .mat-ripple-element{background-color:#000}.mat-select-value{color:#000000de}.mat-select-placeholder{color:#0000006b}.mat-select-disabled .mat-select-value{color:#00000061}.mat-select-arrow{color:#0000008a}.mat-select-panel{background:#fff}.mat-select-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-select-panel .mat-option.mat-selected:not(.mat-option-multiple){background:#0000001f}.mat-form-field.mat-focused.mat-primary .mat-select-arrow{color:#3f51b5}.mat-form-field.mat-focused.mat-accent .mat-select-arrow{color:#ff4081}.mat-form-field.mat-focused.mat-warn .mat-select-arrow,.mat-form-field .mat-select.mat-select-invalid .mat-select-arrow{color:#f44336}.mat-form-field .mat-select.mat-select-disabled .mat-select-arrow{color:#00000061}.mat-drawer-container{background-color:#fafafa;color:#000000de}.mat-drawer{color:#000000de}.mat-drawer,.mat-drawer.mat-drawer-push{background-color:#fff}.mat-drawer:not(.mat-drawer-side){box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-drawer-side{border-right:1px solid #0000001f}.mat-drawer-side.mat-drawer-end,[dir=rtl] .mat-drawer-side{border-left:1px solid #0000001f;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-left:none;border-right:1px solid #0000001f}.mat-drawer-backdrop.mat-drawer-shown{background-color:#0009}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#ff4081}.mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:#ff40818a}.mat-slide-toggle.mat-checked .mat-ripple-element{background-color:#ff4081}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-thumb{background-color:#3f51b5}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-bar{background-color:#3f51b58a}.mat-slide-toggle.mat-primary.mat-checked .mat-ripple-element{background-color:#3f51b5}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-thumb{background-color:#f44336}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-bar{background-color:#f443368a}.mat-slide-toggle.mat-warn.mat-checked .mat-ripple-element{background-color:#f44336}.mat-slide-toggle:not(.mat-checked) .mat-ripple-element{background-color:#000}.mat-slide-toggle-thumb{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f;background-color:#fafafa}.mat-slide-toggle-bar{background-color:#00000061}.mat-slider-track-background{background-color:#00000042}.mat-primary .mat-slider-thumb,.mat-primary .mat-slider-thumb-label,.mat-primary .mat-slider-track-fill{background-color:#3f51b5}.mat-primary .mat-slider-thumb-label-text{color:#fff}.mat-primary .mat-slider-focus-ring{background-color:#3f51b533}.mat-accent .mat-slider-thumb,.mat-accent .mat-slider-thumb-label,.mat-accent .mat-slider-track-fill{background-color:#ff4081}.mat-accent .mat-slider-thumb-label-text{color:#fff}.mat-accent .mat-slider-focus-ring{background-color:#ff408133}.mat-warn .mat-slider-thumb,.mat-warn .mat-slider-thumb-label,.mat-warn .mat-slider-track-fill{background-color:#f44336}.mat-warn .mat-slider-thumb-label-text{color:#fff}.mat-warn .mat-slider-focus-ring{background-color:#f4433633}.mat-slider.cdk-focused .mat-slider-track-background,.mat-slider:hover .mat-slider-track-background{background-color:#00000061}.mat-slider-disabled .mat-slider-thumb,.mat-slider-disabled .mat-slider-track-background,.mat-slider-disabled .mat-slider-track-fill,.mat-slider-disabled:hover .mat-slider-track-background{background-color:#00000042}.mat-slider-min-value .mat-slider-focus-ring{background-color:#0000001f}.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb-label{background-color:#000000de}.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb-label{background-color:#00000042}.mat-slider-min-value:not(.mat-slider-thumb-label-showing) .mat-slider-thumb{border-color:#00000042;background-color:initial}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover .mat-slider-thumb{border-color:#00000061}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused.mat-slider-disabled .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover.mat-slider-disabled .mat-slider-thumb{border-color:#00000042}.mat-slider-has-ticks .mat-slider-wrapper:after{border-color:#000000b3}.mat-slider-horizontal .mat-slider-ticks{background-image:repeating-linear-gradient(90deg,#000000b3,#000000b3 2px,#0000 0,#0000);background-image:-moz-repeating-linear-gradient(.0001deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-slider-vertical .mat-slider-ticks{background-image:repeating-linear-gradient(180deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused,.mat-step-header:hover:not([aria-disabled]),.mat-step-header:hover[aria-disabled=false]{background-color:#0000000a}.mat-step-header:hover[aria-disabled=true]{cursor:default}@media(hover: none){.mat-step-header:hover{background:none}}.mat-step-header .mat-step-label,.mat-step-header .mat-step-optional{color:#0000008a}.mat-step-header .mat-step-icon{background-color:#0000008a;color:#fff}.mat-step-header .mat-step-icon-selected,.mat-step-header .mat-step-icon-state-done,.mat-step-header .mat-step-icon-state-edit{background-color:#3f51b5;color:#fff}.mat-step-header.mat-accent .mat-step-icon{color:#fff}.mat-step-header.mat-accent .mat-step-icon-selected,.mat-step-header.mat-accent .mat-step-icon-state-done,.mat-step-header.mat-accent .mat-step-icon-state-edit{background-color:#ff4081;color:#fff}.mat-step-header.mat-warn .mat-step-icon{color:#fff}.mat-step-header.mat-warn .mat-step-icon-selected,.mat-step-header.mat-warn .mat-step-icon-state-done,.mat-step-header.mat-warn .mat-step-icon-state-edit{background-color:#f44336;color:#fff}.mat-step-header .mat-step-icon-state-error{background-color:initial;color:#f44336}.mat-step-header .mat-step-label.mat-step-label-active{color:#000000de}.mat-step-header .mat-step-label.mat-step-label-error{color:#f44336}.mat-stepper-horizontal,.mat-stepper-vertical{background-color:#fff}.mat-stepper-vertical-line:before{border-left-color:#0000001f}.mat-horizontal-stepper-header:after,.mat-horizontal-stepper-header:before,.mat-stepper-horizontal-line{border-top-color:#0000001f}.mat-horizontal-stepper-header{height:72px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header,.mat-vertical-stepper-header{padding:24px}.mat-stepper-vertical-line:before{top:-16px;bottom:-16px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:after,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:before,.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{top:36px}.mat-sort-header-arrow{color:#757575}.mat-tab-header,.mat-tab-nav-bar{border-bottom:1px solid #0000001f}.mat-tab-group-inverted-header .mat-tab-header,.mat-tab-group-inverted-header .mat-tab-nav-bar{border-top:1px solid #0000001f;border-bottom:none}.mat-tab-label,.mat-tab-link{color:#000000de}.mat-tab-label.mat-tab-disabled,.mat-tab-link.mat-tab-disabled{color:#00000061}.mat-tab-header-pagination-chevron{border-color:#000000de}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#00000061}.mat-tab-group[class*=mat-background-]&gt;.mat-tab-header,.mat-tab-nav-bar[class*=mat-background-]{border-bottom:none;border-top:none}.mat-tab-group.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-primary .mat-ink-bar,.mat-tab-nav-bar.mat-primary .mat-ink-bar{background-color:#3f51b5}.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-accent .mat-ink-bar,.mat-tab-nav-bar.mat-accent .mat-ink-bar{background-color:#ff4081}.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-warn .mat-ink-bar,.mat-tab-nav-bar.mat-warn .mat-ink-bar{background-color:#f44336}.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-background-primary&gt;.mat-tab-header,.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container{background-color:#3f51b5}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-background-accent&gt;.mat-tab-header,.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container{background-color:#ff4081}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-background-warn&gt;.mat-tab-header,.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container{background-color:#f44336}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-toolbar{background:#f5f5f5;color:#000000de}.mat-toolbar.mat-primary{background:#3f51b5;color:#fff}.mat-toolbar.mat-accent{background:#ff4081;color:#fff}.mat-toolbar.mat-warn{background:#f44336;color:#fff}.mat-toolbar .mat-focused .mat-form-field-ripple,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-form-field-underline{background-color:currentColor}.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-select-value{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}.mat-tooltip{background:#616161e6}.mat-tree{background:#fff}.mat-nested-tree-node,.mat-tree-node{color:#000000de}.mat-tree-node{min-height:48px}.mat-snack-bar-container{color:#ffffffb3;background:#323232;box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-simple-snackbar-action{color:#ff4081}body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>00000052</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/styles.aed625f13435cbb527ed.css</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>A timestamp was disclosed by the application/web server - Unix</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>00000061, which evaluates to: 1970-01-01 01:01:01</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (389 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/styles.aed625f13435cbb527ed.css HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: text/css,*/*;q=0.1
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: style
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 17:37:48 GMT
ETag: W/&quot;11dde-17e3ac49546&quot;
Content-Type: text/css; charset=UTF-8
Content-Length: 73182
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (73182 bytes)</summary>
				
				<pre><code>.mat-badge-content{font-weight:600;font-size:12px;font-family:Roboto,Helvetica Neue,sans-serif}.mat-badge-small .mat-badge-content{font-size:9px}.mat-badge-large .mat-badge-content{font-size:24px}.mat-h1,.mat-headline,.mat-typography h1{font:400 24px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h2,.mat-title,.mat-typography h2{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h3,.mat-subheading-2,.mat-typography h3{font:400 16px/28px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h4,.mat-subheading-1,.mat-typography h4{font:400 15px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 16px}.mat-h5,.mat-typography h5{font:400 calc(14px * .83)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-h6,.mat-typography h6{font:400 calc(14px * .67)/20px Roboto,Helvetica Neue,sans-serif;margin:0 0 12px}.mat-body-2,.mat-body-strong{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body,.mat-body-1,.mat-typography{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-body-1 p,.mat-body p,.mat-typography p{margin:0 0 12px}.mat-caption,.mat-small{font:400 12px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-display-4,.mat-typography .mat-display-4{font:300 112px/112px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.05em;margin:0 0 56px}.mat-display-3,.mat-typography .mat-display-3{font:400 56px/56px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.02em;margin:0 0 64px}.mat-display-2,.mat-typography .mat-display-2{font:400 45px/48px Roboto,Helvetica Neue,sans-serif;letter-spacing:-.005em;margin:0 0 64px}.mat-display-1,.mat-typography .mat-display-1{font:400 34px/40px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0 0 64px}.mat-bottom-sheet-container{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-button,.mat-fab,.mat-flat-button,.mat-icon-button,.mat-mini-fab,.mat-raised-button,.mat-stroked-button{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-button-toggle,.mat-card{font-family:Roboto,Helvetica Neue,sans-serif}.mat-card-title{font-size:24px;font-weight:500}.mat-card-header .mat-card-title{font-size:20px}.mat-card-content,.mat-card-subtitle{font-size:14px}.mat-checkbox{font-family:Roboto,Helvetica Neue,sans-serif}.mat-checkbox-layout .mat-checkbox-label{line-height:24px}.mat-chip{font-size:14px;font-weight:500}.mat-chip .mat-chip-remove.mat-icon,.mat-chip .mat-chip-trailing-icon.mat-icon{font-size:18px}.mat-table{font-family:Roboto,Helvetica Neue,sans-serif}.mat-header-cell{font-size:12px;font-weight:500}.mat-cell,.mat-footer-cell{font-size:14px}.mat-calendar{font-family:Roboto,Helvetica Neue,sans-serif}.mat-calendar-body{font-size:13px}.mat-calendar-body-label,.mat-calendar-period-button{font-size:14px;font-weight:500}.mat-calendar-table-header th{font-size:11px;font-weight:400}.mat-dialog-title{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-expansion-panel-header{font-family:Roboto,Helvetica Neue,sans-serif;font-size:15px;font-weight:400}.mat-expansion-panel-content{font:400 14px/20px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field{font-size:inherit;font-weight:400;line-height:1.125;font-family:Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-form-field-wrapper{padding-bottom:1.34375em}.mat-form-field-prefix .mat-icon,.mat-form-field-suffix .mat-icon{font-size:150%;line-height:1.125}.mat-form-field-prefix .mat-icon-button,.mat-form-field-suffix .mat-icon-button{height:1.5em;width:1.5em}.mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-suffix .mat-icon-button .mat-icon{height:1.125em;line-height:1.125}.mat-form-field-infix{padding:.5em 0;border-top:.84375em solid #0000}.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34375em) scale(.75);width:133.3333333333%}.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.34374em) scale(.75);width:133.3333433333%}.mat-form-field-label-wrapper{top:-.84375em;padding-top:.84375em}.mat-form-field-label{top:1.34375em}.mat-form-field-underline{bottom:1.34375em}.mat-form-field-subscript-wrapper{font-size:75%;margin-top:.6666666667em;top:calc(100% - 1.7916666667em)}.mat-form-field-appearance-legacy .mat-form-field-wrapper{padding-bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-infix{padding:.4375em 0}.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.001px);-ms-transform:translateY(-1.28125em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00101px);-ms-transform:translateY(-1.28124em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28125em) scale(.75) perspective(100px) translateZ(.00102px);-ms-transform:translateY(-1.28123em) scale(.75);width:133.3333533333%}.mat-form-field-appearance-legacy .mat-form-field-label{top:1.28125em}.mat-form-field-appearance-legacy .mat-form-field-underline{bottom:1.25em}.mat-form-field-appearance-legacy .mat-form-field-subscript-wrapper{margin-top:.5416666667em;top:calc(100% - 1.6666666667em)}@media print{.mat-form-field-appearance-legacy.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28122em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.28121em) scale(.75)}.mat-form-field-appearance-legacy.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.2812em) scale(.75)}}.mat-form-field-appearance-fill .mat-form-field-infix{padding:.25em 0 .75em}.mat-form-field-appearance-fill .mat-form-field-label{top:1.09375em;margin-top:-.5em}.mat-form-field-appearance-fill.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-fill.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-.59374em) scale(.75);width:133.3333433333%}.mat-form-field-appearance-outline .mat-form-field-infix{padding:1em 0}.mat-form-field-appearance-outline .mat-form-field-label{top:1.84375em;margin-top:-.25em}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label,.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59375em) scale(.75);width:133.3333333333%}.mat-form-field-appearance-outline.mat-form-field-can-float .mat-input-server[label]:not(:label-shown)+.mat-form-field-label-wrapper .mat-form-field-label{transform:translateY(-1.59374em) scale(.75);width:133.3333433333%}.mat-grid-tile-footer,.mat-grid-tile-header{font-size:14px}.mat-grid-tile-footer .mat-line,.mat-grid-tile-header .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-grid-tile-footer .mat-line:nth-child(n+2),.mat-grid-tile-header .mat-line:nth-child(n+2){font-size:12px}input.mat-input-element{margin-top:-.0625em}.mat-menu-item{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:400}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px}.mat-radio-button,.mat-select{font-family:Roboto,Helvetica Neue,sans-serif}.mat-select-trigger{height:1.125em}.mat-slide-toggle-content,.mat-slider-thumb-label-text{font-family:Roboto,Helvetica Neue,sans-serif}.mat-slider-thumb-label-text{font-size:12px;font-weight:500}.mat-stepper-horizontal,.mat-stepper-vertical{font-family:Roboto,Helvetica Neue,sans-serif}.mat-step-label{font-size:14px;font-weight:400}.mat-step-sub-label-error{font-weight:400}.mat-step-label-error{font-size:14px}.mat-step-label-selected{font-size:14px;font-weight:500}.mat-tab-group,.mat-tab-label,.mat-tab-link{font-family:Roboto,Helvetica Neue,sans-serif}.mat-tab-label,.mat-tab-link{font-size:14px;font-weight:500}.mat-toolbar,.mat-toolbar h1,.mat-toolbar h2,.mat-toolbar h3,.mat-toolbar h4,.mat-toolbar h5,.mat-toolbar h6{font:500 20px/32px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal;margin:0}.mat-tooltip{font-family:Roboto,Helvetica Neue,sans-serif;font-size:10px;padding-top:6px;padding-bottom:6px}.mat-tooltip-handset{font-size:14px;padding-top:8px;padding-bottom:8px}.mat-list-item,.mat-list-option{font-family:Roboto,Helvetica Neue,sans-serif}.mat-list-base .mat-list-item{font-size:16px}.mat-list-base .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-item .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-list-option{font-size:16px}.mat-list-base .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base .mat-list-option .mat-line:nth-child(n+2){font-size:14px}.mat-list-base .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px;font-weight:500}.mat-list-base[dense] .mat-list-item{font-size:12px}.mat-list-base[dense] .mat-list-item .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-item .mat-line:nth-child(n+2),.mat-list-base[dense] .mat-list-option{font-size:12px}.mat-list-base[dense] .mat-list-option .mat-line{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;box-sizing:border-box}.mat-list-base[dense] .mat-list-option .mat-line:nth-child(n+2){font-size:12px}.mat-list-base[dense] .mat-subheader{font-family:Roboto,Helvetica Neue,sans-serif;font-size:12px;font-weight:500}.mat-option{font-family:Roboto,Helvetica Neue,sans-serif;font-size:16px}.mat-optgroup-label{font:500 14px/24px Roboto,Helvetica Neue,sans-serif;letter-spacing:normal}.mat-simple-snackbar{font-family:Roboto,Helvetica Neue,sans-serif;font-size:14px}.mat-simple-snackbar-action{line-height:1;font-family:inherit;font-size:inherit;font-weight:500}.mat-tree{font-family:Roboto,Helvetica Neue,sans-serif}.mat-nested-tree-node,.mat-tree-node{font-weight:400;font-size:14px}.mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0,0,.2,1);transform:scale(0)}.cdk-high-contrast-active .mat-ripple-element{display:none}.cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none}.cdk-global-overlay-wrapper,.cdk-overlay-container{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed;z-index:1000}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper,.cdk-overlay-pane{display:flex;position:absolute;z-index:1000}.cdk-overlay-pane{pointer-events:auto;box-sizing:border-box;max-width:100%;max-height:100%}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;z-index:1000;pointer-events:auto;-webkit-tap-highlight-color:transparent;transition:opacity .4s cubic-bezier(.25,.8,.25,1);opacity:0}.cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:1}.cdk-high-contrast-active .cdk-overlay-backdrop.cdk-overlay-backdrop-showing{opacity:.6}.cdk-overlay-dark-backdrop{background:#00000052}.cdk-overlay-transparent-backdrop,.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing{opacity:0}.cdk-overlay-connected-position-bounding-box{position:absolute;z-index:1000;display:flex;flex-direction:column;min-width:1px;min-height:1px}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}textarea.cdk-textarea-autosize{resize:none}textarea.cdk-textarea-autosize-measuring{padding:2px 0!important;box-sizing:initial!important;height:auto!important;overflow:hidden!important}textarea.cdk-textarea-autosize-measuring-firefox{padding:2px 0!important;box-sizing:initial!important;height:0!important}@keyframes cdk-text-field-autofill-start{/*!*/}@keyframes cdk-text-field-autofill-end{/*!*/}.cdk-text-field-autofill-monitored:-webkit-autofill{animation:cdk-text-field-autofill-start 0s 1ms}.cdk-text-field-autofill-monitored:not(:-webkit-autofill){animation:cdk-text-field-autofill-end 0s 1ms}.mat-focus-indicator,.mat-mdc-focus-indicator{position:relative}.mat-ripple-element{background-color:#0000001a}.mat-option{color:#000000de}.mat-option.mat-selected:not(.mat-option-multiple):not(.mat-option-disabled),.mat-option:focus:not(.mat-option-disabled),.mat-option:hover:not(.mat-option-disabled){background:#0000000a}.mat-option.mat-active{background:#0000000a;color:#000000de}.mat-option.mat-option-disabled{color:#00000061}.mat-primary .mat-option.mat-selected:not(.mat-option-disabled){color:#3f51b5}.mat-accent .mat-option.mat-selected:not(.mat-option-disabled){color:#ff4081}.mat-warn .mat-option.mat-selected:not(.mat-option-disabled){color:#f44336}.mat-optgroup-label{color:#0000008a}.mat-optgroup-disabled .mat-optgroup-label{color:#00000061}.mat-pseudo-checkbox{color:#0000008a}.mat-pseudo-checkbox:after{color:#fafafa}.mat-pseudo-checkbox-disabled{color:#b0b0b0}.mat-primary .mat-pseudo-checkbox-checked,.mat-primary .mat-pseudo-checkbox-indeterminate{background:#3f51b5}.mat-accent .mat-pseudo-checkbox-checked,.mat-accent .mat-pseudo-checkbox-indeterminate,.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-indeterminate{background:#ff4081}.mat-warn .mat-pseudo-checkbox-checked,.mat-warn .mat-pseudo-checkbox-indeterminate{background:#f44336}.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background:#b0b0b0}.mat-app-background{background-color:#fafafa;color:#000000de}.mat-elevation-z0{box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-elevation-z1{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-elevation-z2{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-elevation-z3{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-elevation-z4{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-elevation-z5{box-shadow:0 3px 5px -1px #0003,0 5px 8px 0 #00000024,0 1px 14px 0 #0000001f}.mat-elevation-z6{box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-elevation-z7{box-shadow:0 4px 5px -2px #0003,0 7px 10px 1px #00000024,0 2px 16px 1px #0000001f}.mat-elevation-z8{box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-elevation-z9{box-shadow:0 5px 6px -3px #0003,0 9px 12px 1px #00000024,0 3px 16px 2px #0000001f}.mat-elevation-z10{box-shadow:0 6px 6px -3px #0003,0 10px 14px 1px #00000024,0 4px 18px 3px #0000001f}.mat-elevation-z11{box-shadow:0 6px 7px -4px #0003,0 11px 15px 1px #00000024,0 4px 20px 3px #0000001f}.mat-elevation-z12{box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-elevation-z13{box-shadow:0 7px 8px -4px #0003,0 13px 19px 2px #00000024,0 5px 24px 4px #0000001f}.mat-elevation-z14{box-shadow:0 7px 9px -4px #0003,0 14px 21px 2px #00000024,0 5px 26px 4px #0000001f}.mat-elevation-z15{box-shadow:0 8px 9px -5px #0003,0 15px 22px 2px #00000024,0 6px 28px 5px #0000001f}.mat-elevation-z16{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-elevation-z17{box-shadow:0 8px 11px -5px #0003,0 17px 26px 2px #00000024,0 6px 32px 5px #0000001f}.mat-elevation-z18{box-shadow:0 9px 11px -5px #0003,0 18px 28px 2px #00000024,0 7px 34px 6px #0000001f}.mat-elevation-z19{box-shadow:0 9px 12px -6px #0003,0 19px 29px 2px #00000024,0 7px 36px 6px #0000001f}.mat-elevation-z20{box-shadow:0 10px 13px -6px #0003,0 20px 31px 3px #00000024,0 8px 38px 7px #0000001f}.mat-elevation-z21{box-shadow:0 10px 13px -6px #0003,0 21px 33px 3px #00000024,0 8px 40px 7px #0000001f}.mat-elevation-z22{box-shadow:0 10px 14px -6px #0003,0 22px 35px 3px #00000024,0 8px 42px 7px #0000001f}.mat-elevation-z23{box-shadow:0 11px 14px -7px #0003,0 23px 36px 3px #00000024,0 9px 44px 8px #0000001f}.mat-elevation-z24{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-theme-loaded-marker{display:none}.mat-autocomplete-panel{background:#fff;color:#000000de}.mat-autocomplete-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover){background:#fff}.mat-autocomplete-panel .mat-option.mat-selected:not(.mat-active):not(:hover):not(.mat-option-disabled){color:#000000de}.mat-badge{position:relative}.mat-badge-hidden .mat-badge-content{display:none}.mat-badge-content{position:absolute;text-align:center;display:inline-block;border-radius:50%;transition:transform .2s ease-in-out;transform:scale(.6);overflow:hidden;white-space:nowrap;text-overflow:ellipsis;pointer-events:none}.mat-badge-content._mat-animation-noopable,.ng-animate-disabled .mat-badge-content{transition:none}.mat-badge-content.mat-badge-active{transform:none}.mat-badge-small .mat-badge-content{width:16px;height:16px;line-height:16px}.mat-badge-small.mat-badge-above .mat-badge-content{top:-8px}.mat-badge-small.mat-badge-below .mat-badge-content{bottom:-8px}.mat-badge-small.mat-badge-before .mat-badge-content{left:-16px}[dir=rtl] .mat-badge-small.mat-badge-before .mat-badge-content{left:auto;right:-16px}.mat-badge-small.mat-badge-after .mat-badge-content{right:-16px}[dir=rtl] .mat-badge-small.mat-badge-after .mat-badge-content{right:auto;left:-16px}.mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-8px}.mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-8px}[dir=rtl] .mat-badge-small.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-8px}.mat-badge-medium .mat-badge-content{width:22px;height:22px;line-height:22px}.mat-badge-medium.mat-badge-above .mat-badge-content{top:-11px}.mat-badge-medium.mat-badge-below .mat-badge-content{bottom:-11px}.mat-badge-medium.mat-badge-before .mat-badge-content{left:-22px}[dir=rtl] .mat-badge-medium.mat-badge-before .mat-badge-content{left:auto;right:-22px}.mat-badge-medium.mat-badge-after .mat-badge-content{right:-22px}[dir=rtl] .mat-badge-medium.mat-badge-after .mat-badge-content{right:auto;left:-22px}.mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-11px}.mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-11px}[dir=rtl] .mat-badge-medium.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-11px}.mat-badge-large .mat-badge-content{width:28px;height:28px;line-height:28px}.mat-badge-large.mat-badge-above .mat-badge-content{top:-14px}.mat-badge-large.mat-badge-below .mat-badge-content{bottom:-14px}.mat-badge-large.mat-badge-before .mat-badge-content{left:-28px}[dir=rtl] .mat-badge-large.mat-badge-before .mat-badge-content{left:auto;right:-28px}.mat-badge-large.mat-badge-after .mat-badge-content{right:-28px}[dir=rtl] .mat-badge-large.mat-badge-after .mat-badge-content{right:auto;left:-28px}.mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-before .mat-badge-content{left:auto;right:-14px}.mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:-14px}[dir=rtl] .mat-badge-large.mat-badge-overlap.mat-badge-after .mat-badge-content{right:auto;left:-14px}.mat-badge-content{color:#fff;background:#3f51b5}.cdk-high-contrast-active .mat-badge-content{outline:1px solid;border-radius:0}.mat-badge-accent .mat-badge-content{background:#ff4081;color:#fff}.mat-badge-warn .mat-badge-content{color:#fff;background:#f44336}.mat-badge-disabled .mat-badge-content{background:#b9b9b9;color:#00000061}.mat-bottom-sheet-container{box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f;background:#fff;color:#000000de}.mat-button,.mat-icon-button,.mat-stroked-button{color:inherit;background:#0000}.mat-button.mat-primary,.mat-icon-button.mat-primary,.mat-stroked-button.mat-primary{color:#3f51b5}.mat-button.mat-accent,.mat-icon-button.mat-accent,.mat-stroked-button.mat-accent{color:#ff4081}.mat-button.mat-warn,.mat-icon-button.mat-warn,.mat-stroked-button.mat-warn{color:#f44336}.mat-button.mat-accent.mat-button-disabled,.mat-button.mat-button-disabled.mat-button-disabled,.mat-button.mat-primary.mat-button-disabled,.mat-button.mat-warn.mat-button-disabled,.mat-icon-button.mat-accent.mat-button-disabled,.mat-icon-button.mat-button-disabled.mat-button-disabled,.mat-icon-button.mat-primary.mat-button-disabled,.mat-icon-button.mat-warn.mat-button-disabled,.mat-stroked-button.mat-accent.mat-button-disabled,.mat-stroked-button.mat-button-disabled.mat-button-disabled,.mat-stroked-button.mat-primary.mat-button-disabled,.mat-stroked-button.mat-warn.mat-button-disabled{color:#00000042}.mat-button.mat-primary .mat-button-focus-overlay,.mat-icon-button.mat-primary .mat-button-focus-overlay,.mat-stroked-button.mat-primary .mat-button-focus-overlay{background-color:#3f51b5}.mat-button.mat-accent .mat-button-focus-overlay,.mat-icon-button.mat-accent .mat-button-focus-overlay,.mat-stroked-button.mat-accent .mat-button-focus-overlay{background-color:#ff4081}.mat-button.mat-warn .mat-button-focus-overlay,.mat-icon-button.mat-warn .mat-button-focus-overlay,.mat-stroked-button.mat-warn .mat-button-focus-overlay{background-color:#f44336}.mat-button.mat-button-disabled .mat-button-focus-overlay,.mat-icon-button.mat-button-disabled .mat-button-focus-overlay,.mat-stroked-button.mat-button-disabled .mat-button-focus-overlay{background-color:initial}.mat-button .mat-ripple-element,.mat-icon-button .mat-ripple-element,.mat-stroked-button .mat-ripple-element{opacity:.1;background-color:currentColor}.mat-button-focus-overlay{background:#000}.mat-stroked-button:not(.mat-button-disabled){border-color:#0000001f}.mat-fab,.mat-flat-button,.mat-mini-fab,.mat-raised-button{color:#000000de;background-color:#fff}.mat-fab.mat-accent,.mat-fab.mat-primary,.mat-fab.mat-warn,.mat-flat-button.mat-accent,.mat-flat-button.mat-primary,.mat-flat-button.mat-warn,.mat-mini-fab.mat-accent,.mat-mini-fab.mat-primary,.mat-mini-fab.mat-warn,.mat-raised-button.mat-accent,.mat-raised-button.mat-primary,.mat-raised-button.mat-warn{color:#fff}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{color:#00000042}.mat-fab.mat-primary,.mat-flat-button.mat-primary,.mat-mini-fab.mat-primary,.mat-raised-button.mat-primary{background-color:#3f51b5}.mat-fab.mat-accent,.mat-flat-button.mat-accent,.mat-mini-fab.mat-accent,.mat-raised-button.mat-accent{background-color:#ff4081}.mat-fab.mat-warn,.mat-flat-button.mat-warn,.mat-mini-fab.mat-warn,.mat-raised-button.mat-warn{background-color:#f44336}.mat-fab.mat-accent.mat-button-disabled,.mat-fab.mat-button-disabled.mat-button-disabled,.mat-fab.mat-primary.mat-button-disabled,.mat-fab.mat-warn.mat-button-disabled,.mat-flat-button.mat-accent.mat-button-disabled,.mat-flat-button.mat-button-disabled.mat-button-disabled,.mat-flat-button.mat-primary.mat-button-disabled,.mat-flat-button.mat-warn.mat-button-disabled,.mat-mini-fab.mat-accent.mat-button-disabled,.mat-mini-fab.mat-button-disabled.mat-button-disabled,.mat-mini-fab.mat-primary.mat-button-disabled,.mat-mini-fab.mat-warn.mat-button-disabled,.mat-raised-button.mat-accent.mat-button-disabled,.mat-raised-button.mat-button-disabled.mat-button-disabled,.mat-raised-button.mat-primary.mat-button-disabled,.mat-raised-button.mat-warn.mat-button-disabled{background-color:#0000001f}.mat-fab.mat-accent .mat-ripple-element,.mat-fab.mat-primary .mat-ripple-element,.mat-fab.mat-warn .mat-ripple-element,.mat-flat-button.mat-accent .mat-ripple-element,.mat-flat-button.mat-primary .mat-ripple-element,.mat-flat-button.mat-warn .mat-ripple-element,.mat-mini-fab.mat-accent .mat-ripple-element,.mat-mini-fab.mat-primary .mat-ripple-element,.mat-mini-fab.mat-warn .mat-ripple-element,.mat-raised-button.mat-accent .mat-ripple-element,.mat-raised-button.mat-primary .mat-ripple-element,.mat-raised-button.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-flat-button:not([class*=mat-elevation-z]),.mat-stroked-button:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-raised-button:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-raised-button:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 5px 5px -3px #0003,0 8px 10px 1px #00000024,0 3px 14px 2px #0000001f}.mat-raised-button.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-fab:not([class*=mat-elevation-z]),.mat-mini-fab:not([class*=mat-elevation-z]){box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]),.mat-mini-fab:not(.mat-button-disabled):active:not([class*=mat-elevation-z]){box-shadow:0 7px 8px -4px #0003,0 12px 17px 2px #00000024,0 5px 22px 4px #0000001f}.mat-fab.mat-button-disabled:not([class*=mat-elevation-z]),.mat-mini-fab.mat-button-disabled:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-button-toggle-group,.mat-button-toggle-standalone{box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{box-shadow:none}.mat-button-toggle{color:#00000061}.mat-button-toggle .mat-button-toggle-focus-overlay{background-color:#0000001f}.mat-button-toggle-appearance-standard{color:#000000de;background:#fff}.mat-button-toggle-appearance-standard .mat-button-toggle-focus-overlay{background-color:#000}.mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:1px solid #0000001f}[dir=rtl] .mat-button-toggle-group-appearance-standard .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:1px solid #0000001f}.mat-button-toggle-group-appearance-standard.mat-button-toggle-vertical .mat-button-toggle+.mat-button-toggle{border-left:none;border-right:none;border-top:1px solid #0000001f}.mat-button-toggle-checked{background-color:#e0e0e0;color:#0000008a}.mat-button-toggle-checked.mat-button-toggle-appearance-standard{color:#000000de}.mat-button-toggle-disabled{color:#00000042;background-color:#eee}.mat-button-toggle-disabled.mat-button-toggle-appearance-standard{background:#fff}.mat-button-toggle-disabled.mat-button-toggle-checked{background-color:#bdbdbd}.mat-button-toggle-group-appearance-standard,.mat-button-toggle-standalone.mat-button-toggle-appearance-standard{border:1px solid #0000001f}.mat-button-toggle-appearance-standard .mat-button-toggle-label-content{line-height:48px}.mat-card{background:#fff;color:#000000de}.mat-card:not([class*=mat-elevation-z]){box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f}.mat-card.mat-card-flat:not([class*=mat-elevation-z]){box-shadow:0 0 0 0 #0003,0 0 0 0 #00000024,0 0 0 0 #0000001f}.mat-card-subtitle{color:#0000008a}.mat-checkbox-frame{border-color:#0000008a}.mat-checkbox-checkmark{fill:#fafafa}.mat-checkbox-checkmark-path{stroke:#fafafa!important}.mat-checkbox-mixedmark{background-color:#fafafa}.mat-checkbox-checked.mat-primary .mat-checkbox-background,.mat-checkbox-indeterminate.mat-primary .mat-checkbox-background{background-color:#3f51b5}.mat-checkbox-checked.mat-accent .mat-checkbox-background,.mat-checkbox-indeterminate.mat-accent .mat-checkbox-background{background-color:#ff4081}.mat-checkbox-checked.mat-warn .mat-checkbox-background,.mat-checkbox-indeterminate.mat-warn .mat-checkbox-background{background-color:#f44336}.mat-checkbox-disabled.mat-checkbox-checked .mat-checkbox-background,.mat-checkbox-disabled.mat-checkbox-indeterminate .mat-checkbox-background{background-color:#b0b0b0}.mat-checkbox-disabled:not(.mat-checkbox-checked) .mat-checkbox-frame{border-color:#b0b0b0}.mat-checkbox-disabled .mat-checkbox-label{color:#0000008a}.mat-checkbox .mat-ripple-element{background-color:#000}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-primary .mat-ripple-element{background:#3f51b5}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-accent .mat-ripple-element{background:#ff4081}.mat-checkbox-checked:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element,.mat-checkbox:active:not(.mat-checkbox-disabled).mat-warn .mat-ripple-element{background:#f44336}.mat-chip.mat-standard-chip{background-color:#e0e0e0;color:#000000de}.mat-chip.mat-standard-chip .mat-chip-remove{color:#000000de;opacity:.4}.mat-chip.mat-standard-chip:not(.mat-chip-disabled):active{box-shadow:0 3px 3px -2px #0003,0 3px 4px 0 #00000024,0 1px 8px 0 #0000001f}.mat-chip.mat-standard-chip:not(.mat-chip-disabled) .mat-chip-remove:hover{opacity:.54}.mat-chip.mat-standard-chip.mat-chip-disabled{opacity:.4}.mat-chip.mat-standard-chip:after{background:#000}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary{background-color:#3f51b5;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-primary .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn{background-color:#f44336;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-warn .mat-ripple-element{background-color:#ffffff1a}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent{background-color:#ff4081;color:#fff}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-chip-remove{color:#fff;opacity:.4}.mat-chip.mat-standard-chip.mat-chip-selected.mat-accent .mat-ripple-element{background-color:#ffffff1a}.mat-table{background:#fff}.mat-table-sticky,.mat-table tbody,.mat-table tfoot,.mat-table thead,[mat-footer-row],[mat-header-row],[mat-row],mat-footer-row,mat-header-row,mat-row{background:inherit}mat-footer-row,mat-header-row,mat-row,td.mat-cell,td.mat-footer-cell,th.mat-header-cell{border-bottom-color:#0000001f}.mat-header-cell{color:#0000008a}.mat-cell,.mat-footer-cell{color:#000000de}.mat-calendar-arrow{border-top-color:#0000008a}.mat-datepicker-content .mat-calendar-next-button,.mat-datepicker-content .mat-calendar-previous-button,.mat-datepicker-toggle{color:#0000008a}.mat-calendar-table-header-divider:after{background:#0000001f}.mat-calendar-body-label,.mat-calendar-table-header{color:#0000008a}.mat-calendar-body-cell-content,.mat-date-range-input-separator{color:#000000de;border-color:#0000}.mat-calendar-body-disabled&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-form-field-disabled .mat-date-range-input-separator{color:#00000061}.mat-calendar-body-in-preview{color:#0000003d}.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#00000061}.mat-calendar-body-disabled&gt;.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:#0000002e}.mat-calendar-body-in-range:before{background:#3f51b533}.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-calendar-body-comparison-bridge-start:before,[dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-comparison-bridge-end:before,[dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#3f51b533 50%,#f9ab0033 0)}.mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-calendar-body-selected{background-color:#3f51b5;color:#fff}.mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#3f51b566}.mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#3f51b54d}.mat-datepicker-content{box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f;background-color:#fff;color:#000000de}.mat-datepicker-content.mat-accent .mat-calendar-body-in-range:before{background:#ff408133}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-accent [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#ff408133 50%,#f9ab0033 0)}.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-accent .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-accent .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-accent .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-accent .mat-calendar-body-selected{background-color:#ff4081;color:#fff}.mat-datepicker-content.mat-accent .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#ff408166}.mat-datepicker-content.mat-accent .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-accent .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-accent .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#ff40814d}.mat-datepicker-content.mat-warn .mat-calendar-body-in-range:before{background:#f4433633}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range:before{background:#f9ab0033}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-start:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-end:before{background:linear-gradient(90deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-bridge-end:before,.mat-datepicker-content.mat-warn [dir=rtl] .mat-calendar-body-comparison-bridge-start:before{background:linear-gradient(270deg,#f4433633 50%,#f9ab0033 0)}.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range.mat-calendar-body-in-range:after,.mat-datepicker-content.mat-warn .mat-calendar-body-in-range&gt;.mat-calendar-body-comparison-identical{background:#a8dab5}.mat-datepicker-content.mat-warn .mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-datepicker-content.mat-warn .mat-calendar-body-in-comparison-range&gt;.mat-calendar-body-selected{background:#46a35e}.mat-datepicker-content.mat-warn .mat-calendar-body-selected{background-color:#f44336;color:#fff}.mat-datepicker-content.mat-warn .mat-calendar-body-disabled&gt;.mat-calendar-body-selected{background-color:#f4433666}.mat-datepicker-content.mat-warn .mat-calendar-body-today.mat-calendar-body-selected{box-shadow:inset 0 0 0 1px #fff}.mat-datepicker-content.mat-warn .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.mat-datepicker-content.mat-warn .mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:#f443364d}.mat-datepicker-content-touch{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f}.mat-datepicker-toggle-active{color:#3f51b5}.mat-datepicker-toggle-active.mat-accent{color:#ff4081}.mat-datepicker-toggle-active.mat-warn{color:#f44336}.mat-date-range-input-inner[disabled]{color:#00000061}.mat-dialog-container{box-shadow:0 11px 15px -7px #0003,0 24px 38px 3px #00000024,0 9px 46px 8px #0000001f;background:#fff;color:#000000de}.mat-divider{border-top-color:#0000001f}.mat-divider-vertical{border-right-color:#0000001f}.mat-expansion-panel{background:#fff;color:#000000de}.mat-expansion-panel:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px #0003,0 2px 2px 0 #00000024,0 1px 5px 0 #0000001f}.mat-action-row{border-top-color:#0000001f}.mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true]),.mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true]),.mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true]){background:#0000000a}@media(hover: none){.mat-expansion-panel:not(.mat-expanded):not([aria-disabled=true]) .mat-expansion-panel-header:hover{background:#fff}}.mat-expansion-panel-header-title{color:#000000de}.mat-expansion-indicator:after,.mat-expansion-panel-header-description{color:#0000008a}.mat-expansion-panel-header[aria-disabled=true]{color:#00000042}.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-description,.mat-expansion-panel-header[aria-disabled=true] .mat-expansion-panel-header-title{color:inherit}.mat-expansion-panel-header{height:48px}.mat-expansion-panel-header.mat-expanded{height:64px}.mat-form-field-label,.mat-hint{color:#0009}.mat-form-field.mat-focused .mat-form-field-label{color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-label.mat-accent{color:#ff4081}.mat-form-field.mat-focused .mat-form-field-label.mat-warn{color:#f44336}.mat-focused .mat-form-field-required-marker{color:#ff4081}.mat-form-field-ripple{background-color:#000000de}.mat-form-field.mat-focused .mat-form-field-ripple{background-color:#3f51b5}.mat-form-field.mat-focused .mat-form-field-ripple.mat-accent{background-color:#ff4081}.mat-form-field.mat-focused .mat-form-field-ripple.mat-warn{background-color:#f44336}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid) .mat-form-field-infix:after{color:#3f51b5}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-accent .mat-form-field-infix:after{color:#ff4081}.mat-form-field-type-mat-native-select.mat-focused:not(.mat-form-field-invalid).mat-warn .mat-form-field-infix:after,.mat-form-field.mat-form-field-invalid .mat-form-field-label,.mat-form-field.mat-form-field-invalid .mat-form-field-label.mat-accent,.mat-form-field.mat-form-field-invalid .mat-form-field-label .mat-form-field-required-marker{color:#f44336}.mat-form-field.mat-form-field-invalid .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple.mat-accent{background-color:#f44336}.mat-error{color:#f44336}.mat-form-field-appearance-legacy .mat-form-field-label,.mat-form-field-appearance-legacy .mat-hint{color:#0000008a}.mat-form-field-appearance-legacy .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-standard .mat-form-field-underline{background-color:#0000006b}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-image:linear-gradient(90deg,#0000006b 0,#0000006b 33%,#0000 0);background-size:4px 100%;background-repeat:repeat-x}.mat-form-field-appearance-fill .mat-form-field-flex{background-color:#0000000a}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-flex{background-color:#00000005}.mat-form-field-appearance-fill .mat-form-field-underline:before{background-color:#0000006b}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-fill.mat-form-field-disabled .mat-form-field-underline:before{background-color:initial}.mat-form-field-appearance-outline .mat-form-field-outline{color:#0000001f}.mat-form-field-appearance-outline .mat-form-field-outline-thick{color:#000000de}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{color:#3f51b5}.mat-form-field-appearance-outline.mat-focused.mat-accent .mat-form-field-outline-thick{color:#ff4081}.mat-form-field-appearance-outline.mat-focused.mat-warn .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid.mat-form-field-invalid .mat-form-field-outline-thick{color:#f44336}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-label{color:#00000061}.mat-form-field-appearance-outline.mat-form-field-disabled .mat-form-field-outline{color:#0000000f}.mat-icon.mat-primary{color:#3f51b5}.mat-icon.mat-accent{color:#ff4081}.mat-icon.mat-warn{color:#f44336}.mat-form-field-type-mat-native-select .mat-form-field-infix:after{color:#0000008a}.mat-form-field-type-mat-native-select.mat-form-field-disabled .mat-form-field-infix:after,.mat-input-element:disabled{color:#00000061}.mat-input-element{caret-color:#3f51b5}.mat-input-element::placeholder{color:#0000006b}.mat-input-element::-moz-placeholder{color:#0000006b}.mat-input-element::-webkit-input-placeholder{color:#0000006b}.mat-input-element:-ms-input-placeholder{color:#0000006b}.mat-form-field.mat-accent .mat-input-element{caret-color:#ff4081}.mat-form-field-invalid .mat-input-element,.mat-form-field.mat-warn .mat-input-element{caret-color:#f44336}.mat-form-field-type-mat-native-select.mat-form-field-invalid .mat-form-field-infix:after{color:#f44336}.mat-list-base .mat-list-item,.mat-list-base .mat-list-option{color:#000000de}.mat-list-base .mat-subheader{color:#0000008a}.mat-list-item-disabled{background-color:#eee}.mat-action-list .mat-list-item:focus,.mat-action-list .mat-list-item:hover,.mat-list-option:focus,.mat-list-option:hover,.mat-nav-list .mat-list-item:focus,.mat-nav-list .mat-list-item:hover{background:#0000000a}.mat-list-single-selected-option,.mat-list-single-selected-option:focus,.mat-list-single-selected-option:hover{background:#0000001f}.mat-menu-panel{background:#fff}.mat-menu-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-menu-item{background:#0000;color:#000000de}.mat-menu-item[disabled],.mat-menu-item[disabled] .mat-icon-no-color,.mat-menu-item[disabled] .mat-menu-submenu-icon{color:#00000061}.mat-menu-item .mat-icon-no-color,.mat-menu-submenu-icon{color:#0000008a}.mat-menu-item-highlighted:not([disabled]),.mat-menu-item.cdk-keyboard-focused:not([disabled]),.mat-menu-item.cdk-program-focused:not([disabled]),.mat-menu-item:hover:not([disabled]){background:#0000000a}.mat-paginator{background:#fff}.mat-paginator,.mat-paginator-page-size .mat-select-trigger{color:#0000008a}.mat-paginator-decrement,.mat-paginator-increment{border-top:2px solid #0000008a;border-right:2px solid #0000008a}.mat-paginator-first,.mat-paginator-last{border-top:2px solid #0000008a}.mat-icon-button[disabled] .mat-paginator-decrement,.mat-icon-button[disabled] .mat-paginator-first,.mat-icon-button[disabled] .mat-paginator-increment,.mat-icon-button[disabled] .mat-paginator-last{border-color:#00000061}.mat-paginator-container{min-height:56px}.mat-progress-bar-background{fill:#cbd0e9}.mat-progress-bar-buffer{background-color:#cbd0e9}.mat-progress-bar-fill:after{background-color:#3f51b5}.mat-progress-bar.mat-accent .mat-progress-bar-background{fill:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-buffer{background-color:#fbccdc}.mat-progress-bar.mat-accent .mat-progress-bar-fill:after{background-color:#ff4081}.mat-progress-bar.mat-warn .mat-progress-bar-background{fill:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-buffer{background-color:#f9ccc9}.mat-progress-bar.mat-warn .mat-progress-bar-fill:after{background-color:#f44336}.mat-progress-spinner circle,.mat-spinner circle{stroke:#3f51b5}.mat-progress-spinner.mat-accent circle,.mat-spinner.mat-accent circle{stroke:#ff4081}.mat-progress-spinner.mat-warn circle,.mat-spinner.mat-warn circle{stroke:#f44336}.mat-radio-outer-circle{border-color:#0000008a}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-outer-circle{border-color:#3f51b5}.mat-radio-button.mat-primary.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-primary .mat-radio-inner-circle,.mat-radio-button.mat-primary .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-primary:active .mat-radio-persistent-ripple{background-color:#3f51b5}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-outer-circle{border-color:#ff4081}.mat-radio-button.mat-accent.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-accent .mat-radio-inner-circle,.mat-radio-button.mat-accent .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-accent:active .mat-radio-persistent-ripple{background-color:#ff4081}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-outer-circle{border-color:#f44336}.mat-radio-button.mat-warn.mat-radio-checked .mat-radio-persistent-ripple,.mat-radio-button.mat-warn .mat-radio-inner-circle,.mat-radio-button.mat-warn .mat-radio-ripple .mat-ripple-element:not(.mat-radio-persistent-ripple),.mat-radio-button.mat-warn:active .mat-radio-persistent-ripple{background-color:#f44336}.mat-radio-button.mat-radio-disabled.mat-radio-checked .mat-radio-outer-circle,.mat-radio-button.mat-radio-disabled .mat-radio-outer-circle{border-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-inner-circle,.mat-radio-button.mat-radio-disabled .mat-radio-ripple .mat-ripple-element{background-color:#00000061}.mat-radio-button.mat-radio-disabled .mat-radio-label-content{color:#00000061}.mat-radio-button .mat-ripple-element{background-color:#000}.mat-select-value{color:#000000de}.mat-select-placeholder{color:#0000006b}.mat-select-disabled .mat-select-value{color:#00000061}.mat-select-arrow{color:#0000008a}.mat-select-panel{background:#fff}.mat-select-panel:not([class*=mat-elevation-z]){box-shadow:0 2px 4px -1px #0003,0 4px 5px 0 #00000024,0 1px 10px 0 #0000001f}.mat-select-panel .mat-option.mat-selected:not(.mat-option-multiple){background:#0000001f}.mat-form-field.mat-focused.mat-primary .mat-select-arrow{color:#3f51b5}.mat-form-field.mat-focused.mat-accent .mat-select-arrow{color:#ff4081}.mat-form-field.mat-focused.mat-warn .mat-select-arrow,.mat-form-field .mat-select.mat-select-invalid .mat-select-arrow{color:#f44336}.mat-form-field .mat-select.mat-select-disabled .mat-select-arrow{color:#00000061}.mat-drawer-container{background-color:#fafafa;color:#000000de}.mat-drawer{color:#000000de}.mat-drawer,.mat-drawer.mat-drawer-push{background-color:#fff}.mat-drawer:not(.mat-drawer-side){box-shadow:0 8px 10px -5px #0003,0 16px 24px 2px #00000024,0 6px 30px 5px #0000001f}.mat-drawer-side{border-right:1px solid #0000001f}.mat-drawer-side.mat-drawer-end,[dir=rtl] .mat-drawer-side{border-left:1px solid #0000001f;border-right:none}[dir=rtl] .mat-drawer-side.mat-drawer-end{border-left:none;border-right:1px solid #0000001f}.mat-drawer-backdrop.mat-drawer-shown{background-color:#0009}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#ff4081}.mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:#ff40818a}.mat-slide-toggle.mat-checked .mat-ripple-element{background-color:#ff4081}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-thumb{background-color:#3f51b5}.mat-slide-toggle.mat-primary.mat-checked .mat-slide-toggle-bar{background-color:#3f51b58a}.mat-slide-toggle.mat-primary.mat-checked .mat-ripple-element{background-color:#3f51b5}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-thumb{background-color:#f44336}.mat-slide-toggle.mat-warn.mat-checked .mat-slide-toggle-bar{background-color:#f443368a}.mat-slide-toggle.mat-warn.mat-checked .mat-ripple-element{background-color:#f44336}.mat-slide-toggle:not(.mat-checked) .mat-ripple-element{background-color:#000}.mat-slide-toggle-thumb{box-shadow:0 2px 1px -1px #0003,0 1px 1px 0 #00000024,0 1px 3px 0 #0000001f;background-color:#fafafa}.mat-slide-toggle-bar{background-color:#00000061}.mat-slider-track-background{background-color:#00000042}.mat-primary .mat-slider-thumb,.mat-primary .mat-slider-thumb-label,.mat-primary .mat-slider-track-fill{background-color:#3f51b5}.mat-primary .mat-slider-thumb-label-text{color:#fff}.mat-primary .mat-slider-focus-ring{background-color:#3f51b533}.mat-accent .mat-slider-thumb,.mat-accent .mat-slider-thumb-label,.mat-accent .mat-slider-track-fill{background-color:#ff4081}.mat-accent .mat-slider-thumb-label-text{color:#fff}.mat-accent .mat-slider-focus-ring{background-color:#ff408133}.mat-warn .mat-slider-thumb,.mat-warn .mat-slider-thumb-label,.mat-warn .mat-slider-track-fill{background-color:#f44336}.mat-warn .mat-slider-thumb-label-text{color:#fff}.mat-warn .mat-slider-focus-ring{background-color:#f4433633}.mat-slider.cdk-focused .mat-slider-track-background,.mat-slider:hover .mat-slider-track-background{background-color:#00000061}.mat-slider-disabled .mat-slider-thumb,.mat-slider-disabled .mat-slider-track-background,.mat-slider-disabled .mat-slider-track-fill,.mat-slider-disabled:hover .mat-slider-track-background{background-color:#00000042}.mat-slider-min-value .mat-slider-focus-ring{background-color:#0000001f}.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing .mat-slider-thumb-label{background-color:#000000de}.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb,.mat-slider-min-value.mat-slider-thumb-label-showing.cdk-focused .mat-slider-thumb-label{background-color:#00000042}.mat-slider-min-value:not(.mat-slider-thumb-label-showing) .mat-slider-thumb{border-color:#00000042;background-color:initial}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover .mat-slider-thumb{border-color:#00000061}.mat-slider-min-value:not(.mat-slider-thumb-label-showing).cdk-focused.mat-slider-disabled .mat-slider-thumb,.mat-slider-min-value:not(.mat-slider-thumb-label-showing):hover.mat-slider-disabled .mat-slider-thumb{border-color:#00000042}.mat-slider-has-ticks .mat-slider-wrapper:after{border-color:#000000b3}.mat-slider-horizontal .mat-slider-ticks{background-image:repeating-linear-gradient(90deg,#000000b3,#000000b3 2px,#0000 0,#0000);background-image:-moz-repeating-linear-gradient(.0001deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-slider-vertical .mat-slider-ticks{background-image:repeating-linear-gradient(180deg,#000000b3,#000000b3 2px,#0000 0,#0000)}.mat-step-header.cdk-keyboard-focused,.mat-step-header.cdk-program-focused,.mat-step-header:hover:not([aria-disabled]),.mat-step-header:hover[aria-disabled=false]{background-color:#0000000a}.mat-step-header:hover[aria-disabled=true]{cursor:default}@media(hover: none){.mat-step-header:hover{background:none}}.mat-step-header .mat-step-label,.mat-step-header .mat-step-optional{color:#0000008a}.mat-step-header .mat-step-icon{background-color:#0000008a;color:#fff}.mat-step-header .mat-step-icon-selected,.mat-step-header .mat-step-icon-state-done,.mat-step-header .mat-step-icon-state-edit{background-color:#3f51b5;color:#fff}.mat-step-header.mat-accent .mat-step-icon{color:#fff}.mat-step-header.mat-accent .mat-step-icon-selected,.mat-step-header.mat-accent .mat-step-icon-state-done,.mat-step-header.mat-accent .mat-step-icon-state-edit{background-color:#ff4081;color:#fff}.mat-step-header.mat-warn .mat-step-icon{color:#fff}.mat-step-header.mat-warn .mat-step-icon-selected,.mat-step-header.mat-warn .mat-step-icon-state-done,.mat-step-header.mat-warn .mat-step-icon-state-edit{background-color:#f44336;color:#fff}.mat-step-header .mat-step-icon-state-error{background-color:initial;color:#f44336}.mat-step-header .mat-step-label.mat-step-label-active{color:#000000de}.mat-step-header .mat-step-label.mat-step-label-error{color:#f44336}.mat-stepper-horizontal,.mat-stepper-vertical{background-color:#fff}.mat-stepper-vertical-line:before{border-left-color:#0000001f}.mat-horizontal-stepper-header:after,.mat-horizontal-stepper-header:before,.mat-stepper-horizontal-line{border-top-color:#0000001f}.mat-horizontal-stepper-header{height:72px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header,.mat-vertical-stepper-header{padding:24px}.mat-stepper-vertical-line:before{top:-16px;bottom:-16px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:after,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:before,.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{top:36px}.mat-sort-header-arrow{color:#757575}.mat-tab-header,.mat-tab-nav-bar{border-bottom:1px solid #0000001f}.mat-tab-group-inverted-header .mat-tab-header,.mat-tab-group-inverted-header .mat-tab-nav-bar{border-top:1px solid #0000001f;border-bottom:none}.mat-tab-label,.mat-tab-link{color:#000000de}.mat-tab-label.mat-tab-disabled,.mat-tab-link.mat-tab-disabled{color:#00000061}.mat-tab-header-pagination-chevron{border-color:#000000de}.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#00000061}.mat-tab-group[class*=mat-background-]&gt;.mat-tab-header,.mat-tab-nav-bar[class*=mat-background-]{border-bottom:none;border-top:none}.mat-tab-group.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-primary .mat-ink-bar,.mat-tab-nav-bar.mat-primary .mat-ink-bar{background-color:#3f51b5}.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-primary.mat-background-primary&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-accent .mat-ink-bar,.mat-tab-nav-bar.mat-accent .mat-ink-bar{background-color:#ff4081}.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-accent.mat-background-accent&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-warn .mat-ink-bar,.mat-tab-nav-bar.mat-warn .mat-ink-bar{background-color:#f44336}.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-group.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-header .mat-ink-bar,.mat-tab-nav-bar.mat-warn.mat-background-warn&gt;.mat-tab-link-container .mat-ink-bar{background-color:#fff}.mat-tab-group.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-primary .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#c5cae94d}.mat-tab-group.mat-background-primary&gt;.mat-tab-header,.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container{background-color:#3f51b5}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-primary&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-accent .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ff80ab4d}.mat-tab-group.mat-background-accent&gt;.mat-tab-header,.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container{background-color:#ff4081}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-accent&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-tab-group.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-group.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-label.cdk-program-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-keyboard-focused:not(.mat-tab-disabled),.mat-tab-nav-bar.mat-background-warn .mat-tab-link.cdk-program-focused:not(.mat-tab-disabled){background-color:#ffcdd24d}.mat-tab-group.mat-background-warn&gt;.mat-tab-header,.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container{background-color:#f44336}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link{color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-label.mat-tab-disabled,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-tab-link.mat-tab-disabled{color:#fff6}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-focus-indicator:before,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-focus-indicator:before{border-color:#fff}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-tab-header-pagination-disabled .mat-tab-header-pagination-chevron{border-color:#fff;opacity:.4}.mat-tab-group.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-group.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header-pagination .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-header .mat-ripple-element,.mat-tab-nav-bar.mat-background-warn&gt;.mat-tab-link-container .mat-ripple-element{background-color:#fff;opacity:.12}.mat-toolbar{background:#f5f5f5;color:#000000de}.mat-toolbar.mat-primary{background:#3f51b5;color:#fff}.mat-toolbar.mat-accent{background:#ff4081;color:#fff}.mat-toolbar.mat-warn{background:#f44336;color:#fff}.mat-toolbar .mat-focused .mat-form-field-ripple,.mat-toolbar .mat-form-field-ripple,.mat-toolbar .mat-form-field-underline{background-color:currentColor}.mat-toolbar .mat-focused .mat-form-field-label,.mat-toolbar .mat-form-field-label,.mat-toolbar .mat-form-field.mat-focused .mat-select-arrow,.mat-toolbar .mat-select-arrow,.mat-toolbar .mat-select-value{color:inherit}.mat-toolbar .mat-input-element{caret-color:currentColor}.mat-toolbar-multiple-rows{min-height:64px}.mat-toolbar-row,.mat-toolbar-single-row{height:64px}@media(max-width: 599px){.mat-toolbar-multiple-rows{min-height:56px}.mat-toolbar-row,.mat-toolbar-single-row{height:56px}}.mat-tooltip{background:#616161e6}.mat-tree{background:#fff}.mat-nested-tree-node,.mat-tree-node{color:#000000de}.mat-tree-node{min-height:48px}.mat-snack-bar-container{color:#ffffffb3;background:#323232;box-shadow:0 3px 5px -1px #0003,0 6px 10px 0 #00000024,0 1px 18px 0 #0000001f}.mat-simple-snackbar-action{color:#ff4081}body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>00000061</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Manually confirm that the timestamp data is not sensitive, and that the data cannot be aggregated to disclose exploitable patterns.</p>
 </td>
	</tr>
</table>

											</details></li>
									</ol>
								</li>
								
							</ol>
						</li>
						
					</ol>
				</li>
				  
				 
				
				
				
				
				<li id="alerts--risk-0-confidence-2">
					<h3>
						<span>Risk</span>=<span
							class="risk-level">Informational</span>, <span>Confidence</span>=<span
							class="confidence-level">Medium</span> <span>(1)</span>
					</h3>
					<ol>
						
						<li class="alerts--site-li">
							<h4>
								<span class="site">http://localhost:3000</span> <span>(1)</span>
							</h4>
							<ol>
								
								<li>
									<h5>
										<a
											href="#alert-type-2">Information Disclosure - Sensitive Information in URL</a> <span>(1)</span>
									</h5>
									<ol>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/index.html?ngsw-cache-bust=0.6599526791746044</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The request appeared to contain sensitive information leaked in the URL. This can violate PCI and most organizational compliance policies. You can configure the list of strings for this check to add or remove values specific to your environment.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The URL appears to contain credit card information.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (399 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/index.html?ngsw-cache-bust=0.6599526791746044 HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Referer: https://localhost:3000/ngsw-worker.js
Connection: keep-alive
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (385 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;2c8f-17e3bd609fc&quot;
Content-Type: text/html; charset=UTF-8
Content-Length: 11407
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (11407 bytes)</summary>
				
				<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;title&gt;GoodMeets&lt;/title&gt;
  &lt;base href=&quot;/&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

  &lt;meta name=&quot;description&quot; content=&quot;This is GoodMeets, an app for socializing in Covid-19 times.&quot;&gt;


  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.webmanifest&quot;&gt;
  &lt;meta name=&quot;theme-color&quot; content=&quot;#1976d2&quot;&gt;

  &lt;style&gt;@import url(https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&amp;display=swap);:root{--bs-blue:#325d88;--bs-indigo:#6610f2;--bs-purple:#6f42c1;--bs-pink:#e83e8c;--bs-red:#d9534f;--bs-orange:#f47c3c;--bs-yellow:#ffc107;--bs-green:#93c54b;--bs-teal:#20c997;--bs-cyan:#29abe0;--bs-white:#fff;--bs-gray:#8e8c84;--bs-gray-dark:#3e3f3a;--bs-gray-100:#f8f9fa;--bs-gray-200:#f8f5f0;--bs-gray-300:#dfd7ca;--bs-gray-400:#ced4da;--bs-gray-500:#98978b;--bs-gray-600:#8e8c84;--bs-gray-700:#495057;--bs-gray-800:#3e3f3a;--bs-gray-900:#212529;--bs-primary:#325d88;--bs-secondary:#8e8c84;--bs-success:#93c54b;--bs-info:#29abe0;--bs-warning:#f47c3c;--bs-danger:#d9534f;--bs-light:#f8f5f0;--bs-dark:#3e3f3a;--bs-primary-rgb:50,93,136;--bs-secondary-rgb:142,140,132;--bs-success-rgb:147,197,75;--bs-info-rgb:41,171,224;--bs-warning-rgb:244,124,60;--bs-danger-rgb:217,83,79;--bs-light-rgb:248,245,240;--bs-dark-rgb:62,63,58;--bs-white-rgb:255,255,255;--bs-black-rgb:0,0,0;--bs-body-color-rgb:62,63,58;--bs-body-bg-rgb:255,255,255;--bs-font-sans-serif:Roboto,-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;,&quot;Segoe UI Symbol&quot;;--bs-font-monospace:SFMono-Regular,Menlo,Monaco,Consolas,&quot;Liberation Mono&quot;,&quot;Courier New&quot;,monospace;--bs-gradient:linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));--bs-body-font-family:var(--bs-font-sans-serif);--bs-body-font-size:1rem;--bs-body-font-weight:400;--bs-body-line-height:1.5;--bs-body-color:#3e3f3a;--bs-body-bg:#fff}*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:var(--bs-body-font-family);font-size:var(--bs-body-font-size);font-weight:var(--bs-body-font-weight);line-height:var(--bs-body-line-height);color:var(--bs-body-color);text-align:var(--bs-body-text-align);background-color:var(--bs-body-bg);-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/bootstrap.sandstone.min.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/style.css&quot;&gt;&lt;/noscript&gt;
  &lt;style&gt;body{padding-bottom:1rem}@media (min-width: 40em){}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/styles.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;assets/stylesheets/chatTest.css&quot;&gt;&lt;/noscript&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap-icons@1.6.1/font/bootstrap-icons.css&quot;&gt;
  &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.css&quot;/&gt; --&gt;
  &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;assets/images/GoodMeetsLogo.png&quot;&gt;
  &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;/assets/icons/icon-192x192.png&quot;&gt;
  &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot;&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+1F00-1FFF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0370-03FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+1EA0-1EF9, U+20AB;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format(&#39;woff2&#39;);unicode-range:U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;}@font-face{font-family:&#39;Roboto&#39;;font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format(&#39;woff2&#39;);unicode-range:U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;}&lt;/style&gt;
  &lt;style type=&quot;text/css&quot;&gt;@font-face{font-family:&#39;Material Icons&#39;;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v118/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.woff2) format(&#39;woff2&#39;);}.material-icons{font-family:&#39;Material Icons&#39;;font-weight:normal;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:&#39;liga&#39;;-webkit-font-smoothing:antialiased;}&lt;/style&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.css&quot; integrity=&quot;sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A==&quot; crossorigin=&quot;&quot;&gt;

  &lt;script src=&quot;https://unpkg.com/leaflet@1.7.1/dist/leaflet.js&quot; integrity=&quot;sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA==&quot; crossorigin=&quot;&quot;&gt;&lt;/script&gt;

&lt;style&gt;body,html{height:100%}body{margin:0;font-family:Roboto,Helvetica Neue,sans-serif}&lt;/style&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#39;all&#39;&quot;&gt;&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.aed625f13435cbb527ed.css&quot;&gt;&lt;/noscript&gt;&lt;/head&gt;

&lt;body&gt;
  &lt;app-ogrodje&gt;&lt;/app-ogrodje&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.js&quot;&gt;&lt;/script&gt;
  &lt;!-- &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/js/bootstrap-datepicker.js&quot;&gt;&lt;/script&gt; --&gt;
  &lt;noscript&gt;Please enable JavaScript to continue using this application.&lt;/noscript&gt;
&lt;script src=&quot;runtime.ae7bad9777036afb7f47.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;polyfills.45aa6b15effea4b4c287.js&quot; defer&gt;&lt;/script&gt;&lt;script src=&quot;main.33dffcd326587626e657.js&quot; defer&gt;&lt;/script&gt;

&lt;/body&gt;&lt;/html&gt;</code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Parameter</th>
		<td><pre><code>ngsw-cache-bust</code></pre></td>
	</tr>
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>0.6599526791746044</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Do not pass sensitive information in URIs.</p>
 </td>
	</tr>
</table>

											</details></li>
									</ol>
								</li>
								
							</ol>
						</li>
						
					</ol>
				</li>
				
				<li id="alerts--risk-0-confidence-1">
					<h3>
						<span>Risk</span>=<span
							class="risk-level">Informational</span>, <span>Confidence</span>=<span
							class="confidence-level">Low</span> <span>(11)</span>
					</h3>
					<ol>
						
						<li class="alerts--site-li">
							<h4>
								<span class="site">http://localhost:3000</span> <span>(11)</span>
							</h4>
							<ol>
								
								<li>
									<h5>
										<a
											href="#alert-type-3">Information Disclosure - Suspicious Comments</a> <span>(11)</span>
									</h5>
									<ol>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/main.33dffcd326587626e657.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bQUERY\b and was detected in the element starting with: &quot;(self.webpackChunkgood_meets=self.webpackChunkgood_meets||[]).push([[179],{255:_a=&gt;{function yr(ya){return Promise.resolve().the&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (372 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/main.33dffcd326587626e657.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: script
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 22:36:30 GMT
ETag: W/&quot;ad5e3-17e3bd60a04&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 710115
Date: Sat, 08 Jan 2022 23:37:51 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (710115 bytes)</summary>
				
				<pre><code>(self.webpackChunkgood_meets=self.webpackChunkgood_meets||[]).push([[179],{255:_a=&gt;{function yr(ya){return Promise.resolve().then(()=&gt;{var bi=new Error(&quot;Cannot find module &#39;&quot;+ya+&quot;&#39;&quot;);throw bi.code=&quot;MODULE_NOT_FOUND&quot;,bi})}yr.keys=()=&gt;[],yr.resolve=yr,yr.id=255,_a.exports=yr},633:(_a,yr,ya)=&gt;{&quot;use strict&quot;;function bi(n){return&quot;function&quot;==typeof n}let wh=!1;const Kn={Promise:void 0,set useDeprecatedSynchronousErrorHandling(n){if(n){const t=new Error;console.warn(&quot;DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n&quot;+t.stack)}else wh&amp;&amp;console.log(&quot;RxJS: Back to a better error behavior. Thank you. &lt;3&quot;);wh=n},get useDeprecatedSynchronousErrorHandling(){return wh}};function Hs(n){setTimeout(()=&gt;{throw n},0)}const gc={closed:!0,next(n){},error(n){if(Kn.useDeprecatedSynchronousErrorHandling)throw n;Hs(n)},complete(){}},zs=Array.isArray||(n=&gt;n&amp;&amp;&quot;number&quot;==typeof n.length);function Eh(n){return null!==n&amp;&amp;&quot;object&quot;==typeof n}const mc=(()=&gt;{function n(t){return Error.call(this),this.message=t?`${t.length} errors occurred during unsubscription:\n${t.map((e,i)=&gt;`${i+1}) ${e.toString()}`).join(&quot;\n  &quot;)}`:&quot;&quot;,this.name=&quot;UnsubscriptionError&quot;,this.errors=t,this}return n.prototype=Object.create(Error.prototype),n})();class ue{constructor(t){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,t&amp;&amp;(this._ctorUnsubscribe=!0,this._unsubscribe=t)}unsubscribe(){let t;if(this.closed)return;let{_parentOrParents:e,_ctorUnsubscribe:i,_unsubscribe:r,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,e instanceof ue)e.remove(this);else if(null!==e)for(let o=0;o&lt;e.length;++o)e[o].remove(this);if(bi(r)){i&amp;&amp;(this._unsubscribe=void 0);try{r.call(this)}catch(o){t=o instanceof mc?dy(o.errors):[o]}}if(zs(s)){let o=-1,a=s.length;for(;++o&lt;a;){const l=s[o];if(Eh(l))try{l.unsubscribe()}catch(c){t=t||[],c instanceof mc?t=t.concat(dy(c.errors)):t.push(c)}}}if(t)throw new mc(t)}add(t){let e=t;if(!t)return ue.EMPTY;switch(typeof t){case&quot;function&quot;:e=new ue(t);case&quot;object&quot;:if(e===this||e.closed||&quot;function&quot;!=typeof e.unsubscribe)return e;if(this.closed)return e.unsubscribe(),e;if(!(e instanceof ue)){const s=e;e=new ue,e._subscriptions=[s]}break;default:throw new Error(&quot;unrecognized teardown &quot;+t+&quot; added to Subscription.&quot;)}let{_parentOrParents:i}=e;if(null===i)e._parentOrParents=this;else if(i instanceof ue){if(i===this)return e;e._parentOrParents=[i,this]}else{if(-1!==i.indexOf(this))return e;i.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[e]:r.push(e),e}remove(t){const e=this._subscriptions;if(e){const i=e.indexOf(t);-1!==i&amp;&amp;e.splice(i,1)}}}var n;function dy(n){return n.reduce((t,e)=&gt;t.concat(e instanceof mc?e.errors:e),[])}ue.EMPTY=((n=new ue).closed=!0,n);const _c=&quot;function&quot;==typeof Symbol?Symbol(&quot;rxSubscriber&quot;):&quot;@@rxSubscriber_&quot;+Math.random();class xe extends ue{constructor(t,e,i){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=gc;break;case 1:if(!t){this.destination=gc;break}if(&quot;object&quot;==typeof t){t instanceof xe?(this.syncErrorThrowable=t.syncErrorThrowable,this.destination=t,t.add(this)):(this.syncErrorThrowable=!0,this.destination=new hy(this,t));break}default:this.syncErrorThrowable=!0,this.destination=new hy(this,t,e,i)}}[_c](){return this}static create(t,e,i){const r=new xe(t,e,i);return r.syncErrorThrowable=!1,r}next(t){this.isStopped||this._next(t)}error(t){this.isStopped||(this.isStopped=!0,this._error(t))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(t){this.destination.next(t)}_error(t){this.destination.error(t),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:t}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=t,this}}class hy extends xe{constructor(t,e,i,r){super(),this._parentSubscriber=t;let s,o=this;bi(e)?s=e:e&amp;&amp;(s=e.next,i=e.error,r=e.complete,e!==gc&amp;&amp;(o=Object.create(e),bi(o.unsubscribe)&amp;&amp;this.add(o.unsubscribe.bind(o)),o.unsubscribe=this.unsubscribe.bind(this))),this._context=o,this._next=s,this._error=i,this._complete=r}next(t){if(!this.isStopped&amp;&amp;this._next){const{_parentSubscriber:e}=this;Kn.useDeprecatedSynchronousErrorHandling&amp;&amp;e.syncErrorThrowable?this.__tryOrSetError(e,this._next,t)&amp;&amp;this.unsubscribe():this.__tryOrUnsub(this._next,t)}}error(t){if(!this.isStopped){const{_parentSubscriber:e}=this,{useDeprecatedSynchronousErrorHandling:i}=Kn;if(this._error)i&amp;&amp;e.syncErrorThrowable?(this.__tryOrSetError(e,this._error,t),this.unsubscribe()):(this.__tryOrUnsub(this._error,t),this.unsubscribe());else if(e.syncErrorThrowable)i?(e.syncErrorValue=t,e.syncErrorThrown=!0):Hs(t),this.unsubscribe();else{if(this.unsubscribe(),i)throw t;Hs(t)}}}complete(){if(!this.isStopped){const{_parentSubscriber:t}=this;if(this._complete){const e=()=&gt;this._complete.call(this._context);Kn.useDeprecatedSynchronousErrorHandling&amp;&amp;t.syncErrorThrowable?(this.__tryOrSetError(t,e),this.unsubscribe()):(this.__tryOrUnsub(e),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(t,e){try{t.call(this._context,e)}catch(i){if(this.unsubscribe(),Kn.useDeprecatedSynchronousErrorHandling)throw i;Hs(i)}}__tryOrSetError(t,e,i){if(!Kn.useDeprecatedSynchronousErrorHandling)throw new Error(&quot;bad call&quot;);try{e.call(this._context,i)}catch(r){return Kn.useDeprecatedSynchronousErrorHandling?(t.syncErrorValue=r,t.syncErrorThrown=!0,!0):(Hs(r),!0)}return!1}_unsubscribe(){const{_parentSubscriber:t}=this;this._context=null,this._parentSubscriber=null,t.unsubscribe()}}const va=&quot;function&quot;==typeof Symbol&amp;&amp;Symbol.observable||&quot;@@observable&quot;;function yc(n){return n}let ye=(()=&gt;{class n{constructor(e){this._isScalar=!1,e&amp;&amp;(this._subscribe=e)}lift(e){const i=new n;return i.source=this,i.operator=e,i}subscribe(e,i,r){const{operator:s}=this,o=function(n,t,e){if(n){if(n instanceof xe)return n;if(n[_c])return n[_c]()}return n||t||e?new xe(n,t,e):new xe(gc)}(e,i,r);if(o.add(s?s.call(o,this.source):this.source||Kn.useDeprecatedSynchronousErrorHandling&amp;&amp;!o.syncErrorThrowable?this._subscribe(o):this._trySubscribe(o)),Kn.useDeprecatedSynchronousErrorHandling&amp;&amp;o.syncErrorThrowable&amp;&amp;(o.syncErrorThrowable=!1,o.syncErrorThrown))throw o.syncErrorValue;return o}_trySubscribe(e){try{return this._subscribe(e)}catch(i){Kn.useDeprecatedSynchronousErrorHandling&amp;&amp;(e.syncErrorThrown=!0,e.syncErrorValue=i),function(n){for(;n;){const{closed:t,destination:e,isStopped:i}=n;if(t||i)return!1;n=e&amp;&amp;e instanceof xe?e:null}return!0}(e)?e.error(i):console.warn(i)}}forEach(e,i){return new(i=py(i))((r,s)=&gt;{let o;o=this.subscribe(a=&gt;{try{e(a)}catch(l){s(l),o&amp;&amp;o.unsubscribe()}},s,r)})}_subscribe(e){const{source:i}=this;return i&amp;&amp;i.subscribe(e)}[va](){return this}pipe(...e){return 0===e.length?this:function(n){return 0===n.length?yc:1===n.length?n[0]:function(e){return n.reduce((i,r)=&gt;r(i),e)}}(e)(this)}toPromise(e){return new(e=py(e))((i,r)=&gt;{let s;this.subscribe(o=&gt;s=o,o=&gt;r(o),()=&gt;i(s))})}}return n.create=t=&gt;new n(t),n})();function py(n){if(n||(n=Kn.Promise||Promise),!n)throw new Error(&quot;no Promise impl found&quot;);return n}const Qr=(()=&gt;{function n(){return Error.call(this),this.message=&quot;object unsubscribed&quot;,this.name=&quot;ObjectUnsubscribedError&quot;,this}return n.prototype=Object.create(Error.prototype),n})();class gy extends ue{constructor(t,e){super(),this.subject=t,this.subscriber=e,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const t=this.subject,e=t.observers;if(this.subject=null,!e||0===e.length||t.isStopped||t.closed)return;const i=e.indexOf(this.subscriber);-1!==i&amp;&amp;e.splice(i,1)}}class my extends xe{constructor(t){super(t),this.destination=t}}let ie=(()=&gt;{class n extends ye{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[_c](){return new my(this)}lift(e){const i=new _y(this,this);return i.operator=e,i}next(e){if(this.closed)throw new Qr;if(!this.isStopped){const{observers:i}=this,r=i.length,s=i.slice();for(let o=0;o&lt;r;o++)s[o].next(e)}}error(e){if(this.closed)throw new Qr;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:i}=this,r=i.length,s=i.slice();for(let o=0;o&lt;r;o++)s[o].error(e);this.observers.length=0}complete(){if(this.closed)throw new Qr;this.isStopped=!0;const{observers:e}=this,i=e.length,r=e.slice();for(let s=0;s&lt;i;s++)r[s].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new Qr;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new Qr;return this.hasError?(e.error(this.thrownError),ue.EMPTY):this.isStopped?(e.complete(),ue.EMPTY):(this.observers.push(e),new gy(this,e))}asObservable(){const e=new ye;return e.source=this,e}}return n.create=(t,e)=&gt;new _y(t,e),n})();class _y extends ie{constructor(t,e){super(),this.destination=t,this.source=e}next(t){const{destination:e}=this;e&amp;&amp;e.next&amp;&amp;e.next(t)}error(t){const{destination:e}=this;e&amp;&amp;e.error&amp;&amp;this.destination.error(t)}complete(){const{destination:t}=this;t&amp;&amp;t.complete&amp;&amp;this.destination.complete()}_subscribe(t){const{source:e}=this;return e?this.source.subscribe(t):ue.EMPTY}}function $s(n){return n&amp;&amp;&quot;function&quot;==typeof n.schedule}function pe(n,t){return function(i){if(&quot;function&quot;!=typeof n)throw new TypeError(&quot;argument is not a function. Are you looking for `mapTo()`?&quot;);return i.lift(new LA(n,t))}}class LA{constructor(t,e){this.project=t,this.thisArg=e}call(t,e){return e.subscribe(new jA(t,this.project,this.thisArg))}}class jA extends xe{constructor(t,e,i){super(t),this.project=e,this.count=0,this.thisArg=i||this}_next(t){let e;try{e=this.project.call(this.thisArg,t,this.count++)}catch(i){return void this.destination.error(i)}this.destination.next(e)}}const yy=n=&gt;t=&gt;{for(let e=0,i=n.length;e&lt;i&amp;&amp;!t.closed;e++)t.next(n[e]);t.complete()},vc=&quot;function&quot;==typeof Symbol&amp;&amp;Symbol.iterator?Symbol.iterator:&quot;@@iterator&quot;,vy=n=&gt;n&amp;&amp;&quot;number&quot;==typeof n.length&amp;&amp;&quot;function&quot;!=typeof n;function by(n){return!!n&amp;&amp;&quot;function&quot;!=typeof n.subscribe&amp;&amp;&quot;function&quot;==typeof n.then}const Sh=n=&gt;{if(n&amp;&amp;&quot;function&quot;==typeof n[va])return(n=&gt;t=&gt;{const e=n[va]();if(&quot;function&quot;!=typeof e.subscribe)throw new TypeError(&quot;Provided object does not correctly implement Symbol.observable&quot;);return e.subscribe(t)})(n);if(vy(n))return yy(n);if(by(n))return(n=&gt;t=&gt;(n.then(e=&gt;{t.closed||(t.next(e),t.complete())},e=&gt;t.error(e)).then(null,Hs),t))(n);if(n&amp;&amp;&quot;function&quot;==typeof n[vc])return(n=&gt;t=&gt;{const e=n[vc]();for(;;){let i;try{i=e.next()}catch(r){return t.error(r),t}if(i.done){t.complete();break}if(t.next(i.value),t.closed)break}return&quot;function&quot;==typeof e.return&amp;&amp;t.add(()=&gt;{e.return&amp;&amp;e.return()}),t})(n);{const e=`You provided ${Eh(n)?&quot;an invalid object&quot;:`&#39;${n}&#39;`} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`;throw new TypeError(e)}};function kh(n,t){return new ye(e=&gt;{const i=new ue;let r=0;return i.add(t.schedule(function(){r!==n.length?(e.next(n[r++]),e.closed||i.add(this.schedule())):e.complete()})),i})}function At(n,t){return t?function(n,t){if(null!=n){if(function(n){return n&amp;&amp;&quot;function&quot;==typeof n[va]}(n))return function(n,t){return new ye(e=&gt;{const i=new ue;return i.add(t.schedule(()=&gt;{const r=n[va]();i.add(r.subscribe({next(s){i.add(t.schedule(()=&gt;e.next(s)))},error(s){i.add(t.schedule(()=&gt;e.error(s)))},complete(){i.add(t.schedule(()=&gt;e.complete()))}}))})),i})}(n,t);if(by(n))return function(n,t){return new ye(e=&gt;{const i=new ue;return i.add(t.schedule(()=&gt;n.then(r=&gt;{i.add(t.schedule(()=&gt;{e.next(r),i.add(t.schedule(()=&gt;e.complete()))}))},r=&gt;{i.add(t.schedule(()=&gt;e.error(r)))}))),i})}(n,t);if(vy(n))return kh(n,t);if(function(n){return n&amp;&amp;&quot;function&quot;==typeof n[vc]}(n)||&quot;string&quot;==typeof n)return function(n,t){if(!n)throw new Error(&quot;Iterable cannot be null&quot;);return new ye(e=&gt;{const i=new ue;let r;return i.add(()=&gt;{r&amp;&amp;&quot;function&quot;==typeof r.return&amp;&amp;r.return()}),i.add(t.schedule(()=&gt;{r=n[vc](),i.add(t.schedule(function(){if(e.closed)return;let s,o;try{const a=r.next();s=a.value,o=a.done}catch(a){return void e.error(a)}o?e.complete():(e.next(s),this.schedule())}))})),i})}(n,t)}throw new TypeError((null!==n&amp;&amp;typeof n||n)+&quot; is not observable&quot;)}(n,t):n instanceof ye?n:new ye(Sh(n))}class ba extends xe{constructor(t){super(),this.parent=t}_next(t){this.parent.notifyNext(t)}_error(t){this.parent.notifyError(t),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class Ca extends xe{notifyNext(t){this.destination.next(t)}notifyError(t){this.destination.error(t)}notifyComplete(){this.destination.complete()}}function Da(n,t){if(t.closed)return;if(n instanceof ye)return n.subscribe(t);let e;try{e=Sh(n)(t)}catch(i){t.error(i)}return e}function Tt(n,t,e=Number.POSITIVE_INFINITY){return&quot;function&quot;==typeof t?i=&gt;i.pipe(Tt((r,s)=&gt;At(n(r,s)).pipe(pe((o,a)=&gt;t(r,o,s,a))),e)):(&quot;number&quot;==typeof t&amp;&amp;(e=t),i=&gt;i.lift(new QA(n,e)))}class QA{constructor(t,e=Number.POSITIVE_INFINITY){this.project=t,this.concurrent=e}call(t,e){return e.subscribe(new ZA(t,this.project,this.concurrent))}}class ZA extends Ca{constructor(t,e,i=Number.POSITIVE_INFINITY){super(t),this.project=e,this.concurrent=i,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(t){this.active&lt;this.concurrent?this._tryNext(t):this.buffer.push(t)}_tryNext(t){let e;const i=this.index++;try{e=this.project(t,i)}catch(r){return void this.destination.error(r)}this.active++,this._innerSub(e)}_innerSub(t){const e=new ba(this),i=this.destination;i.add(e);const r=Da(t,e);r!==e&amp;&amp;i.add(r)}_complete(){this.hasCompleted=!0,0===this.active&amp;&amp;0===this.buffer.length&amp;&amp;this.destination.complete(),this.unsubscribe()}notifyNext(t){this.destination.next(t)}notifyComplete(){const t=this.buffer;this.active--,t.length&gt;0?this._next(t.shift()):0===this.active&amp;&amp;this.hasCompleted&amp;&amp;this.destination.complete()}}function wa(n=Number.POSITIVE_INFINITY){return Tt(yc,n)}function Mh(n,t){return t?kh(n,t):new ye(yy(n))}function Ci(...n){let t=Number.POSITIVE_INFINITY,e=null,i=n[n.length-1];return $s(i)?(e=n.pop(),n.length&gt;1&amp;&amp;&quot;number&quot;==typeof n[n.length-1]&amp;&amp;(t=n.pop())):&quot;number&quot;==typeof i&amp;&amp;(t=n.pop()),null===e&amp;&amp;1===n.length&amp;&amp;n[0]instanceof ye?n[0]:wa(t)(Mh(n,e))}function Ah(){return function(t){return t.lift(new JA(t))}}class JA{constructor(t){this.connectable=t}call(t,e){const{connectable:i}=this;i._refCount++;const r=new XA(t,i),s=e.subscribe(r);return r.closed||(r.connection=i.connect()),s}}class XA extends xe{constructor(t,e){super(t),this.connectable=e}_unsubscribe(){const{connectable:t}=this;if(!t)return void(this.connection=null);this.connectable=null;const e=t._refCount;if(e&lt;=0)return void(this.connection=null);if(t._refCount=e-1,e&gt;1)return void(this.connection=null);const{connection:i}=this,r=t._connection;this.connection=null,r&amp;&amp;(!i||r===i)&amp;&amp;r.unsubscribe()}}class Cy extends ye{constructor(t,e){super(),this.source=t,this.subjectFactory=e,this._refCount=0,this._isComplete=!1}_subscribe(t){return this.getSubject().subscribe(t)}getSubject(){const t=this._subject;return(!t||t.isStopped)&amp;&amp;(this._subject=this.subjectFactory()),this._subject}connect(){let t=this._connection;return t||(this._isComplete=!1,t=this._connection=new ue,t.add(this.source.subscribe(new tT(this.getSubject(),this))),t.closed&amp;&amp;(this._connection=null,t=ue.EMPTY)),t}refCount(){return Ah()(this)}}const eT=(()=&gt;{const n=Cy.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:n._subscribe},_isComplete:{value:n._isComplete,writable:!0},getSubject:{value:n.getSubject},connect:{value:n.connect},refCount:{value:n.refCount}}})();class tT extends my{constructor(t,e){super(t),this.connectable=e}_error(t){this._unsubscribe(),super._error(t)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const t=this.connectable;if(t){this.connectable=null;const e=t._connection;t._refCount=0,t._subject=null,t._connection=null,e&amp;&amp;e.unsubscribe()}}}function Th(n,t){return function(i){let r;if(r=&quot;function&quot;==typeof n?n:function(){return n},&quot;function&quot;==typeof t)return i.lift(new iT(r,t));const s=Object.create(i,eT);return s.source=i,s.subjectFactory=r,s}}class iT{constructor(t,e){this.subjectFactory=t,this.selector=e}call(t,e){const{selector:i}=this,r=this.subjectFactory(),s=i(r).subscribe(t);return s.add(e.subscribe(r)),s}}function rT(){return new ie}function Re(n){for(let t in n)if(n[t]===Re)return t;throw Error(&quot;Could not find renamed property on target object.&quot;)}function Ih(n,t){for(const e in t)t.hasOwnProperty(e)&amp;&amp;!n.hasOwnProperty(e)&amp;&amp;(n[e]=t[e])}function ge(n){if(&quot;string&quot;==typeof n)return n;if(Array.isArray(n))return&quot;[&quot;+n.map(ge).join(&quot;, &quot;)+&quot;]&quot;;if(null==n)return&quot;&quot;+n;if(n.overriddenName)return`${n.overriddenName}`;if(n.name)return`${n.name}`;const t=n.toString();if(null==t)return&quot;&quot;+t;const e=t.indexOf(&quot;\n&quot;);return-1===e?t:t.substring(0,e)}function xh(n,t){return null==n||&quot;&quot;===n?null===t?&quot;&quot;:t:null==t||&quot;&quot;===t?n:n+&quot; &quot;+t}const oT=Re({__forward_ref__:Re});function Fe(n){return n.__forward_ref__=Fe,n.toString=function(){return ge(this())},n}function H(n){return Dy(n)?n():n}function Dy(n){return&quot;function&quot;==typeof n&amp;&amp;n.hasOwnProperty(oT)&amp;&amp;n.__forward_ref__===Fe}class Zr extends Error{constructor(t,e){super(function(n,t){return`${n?`NG0${n}: `:&quot;&quot;}${t}`}(t,e)),this.code=t}}function le(n){return&quot;string&quot;==typeof n?n:null==n?&quot;&quot;:String(n)}function qt(n){return&quot;function&quot;==typeof n?n.name||n.toString():&quot;object&quot;==typeof n&amp;&amp;null!=n&amp;&amp;&quot;function&quot;==typeof n.type?n.type.name||n.type.toString():le(n)}function bc(n,t){const e=t?` in ${t}`:&quot;&quot;;throw new Zr(&quot;201&quot;,`No provider for ${qt(n)} found${e}`)}function hn(n,t){null==n&amp;&amp;function(n,t,e,i){throw new Error(`ASSERTION ERROR: ${n}`+(null==i?&quot;&quot;:` [Expected=&gt; ${e} ${i} ${t} &lt;=Actual]`))}(t,n,null,&quot;!=&quot;)}function P(n){return{token:n.token,providedIn:n.providedIn||null,factory:n.factory,value:void 0}}function me(n){return{providers:n.providers||[],imports:n.imports||[]}}function qi(n){return wy(n,Cc)||wy(n,Sy)}function wy(n,t){return n.hasOwnProperty(t)?n[t]:null}function Ey(n){return n&amp;&amp;(n.hasOwnProperty(Ph)||n.hasOwnProperty(fT))?n[Ph]:null}const Cc=Re({\u0275prov:Re}),Ph=Re({\u0275inj:Re}),Sy=Re({ngInjectableDef:Re}),fT=Re({ngInjectorDef:Re});var z=(()=&gt;((z=z||{})[z.Default=0]=&quot;Default&quot;,z[z.Host=1]=&quot;Host&quot;,z[z.Self=2]=&quot;Self&quot;,z[z.SkipSelf=4]=&quot;SkipSelf&quot;,z[z.Optional=8]=&quot;Optional&quot;,z))();let Oh;function vr(n){const t=Oh;return Oh=n,t}function ky(n,t,e){const i=qi(n);return i&amp;&amp;&quot;root&quot;==i.providedIn?void 0===i.value?i.value=i.factory():i.value:e&amp;z.Optional?null:void 0!==t?t:void bc(ge(n),&quot;Injector&quot;)}function br(n){return{toString:n}.toString()}var kn=(()=&gt;((kn=kn||{})[kn.OnPush=0]=&quot;OnPush&quot;,kn[kn.Default=1]=&quot;Default&quot;,kn))(),ut=(()=&gt;((ut=ut||{})[ut.Emulated=0]=&quot;Emulated&quot;,ut[ut.None=2]=&quot;None&quot;,ut[ut.ShadowDom=3]=&quot;ShadowDom&quot;,ut))();const gT=&quot;undefined&quot;!=typeof globalThis&amp;&amp;globalThis,mT=&quot;undefined&quot;!=typeof window&amp;&amp;window,_T=&quot;undefined&quot;!=typeof self&amp;&amp;&quot;undefined&quot;!=typeof WorkerGlobalScope&amp;&amp;self instanceof WorkerGlobalScope&amp;&amp;self,Ne=gT||&quot;undefined&quot;!=typeof global&amp;&amp;global||mT||_T,Gs={},Be=[],Dc=Re({\u0275cmp:Re}),Fh=Re({\u0275dir:Re}),Nh=Re({\u0275pipe:Re}),My=Re({\u0275mod:Re}),yT=Re({\u0275loc:Re}),Yi=Re({\u0275fac:Re}),Ea=Re({__NG_ELEMENT_ID__:Re});let vT=0;function ee(n){return br(()=&gt;{const e={},i={type:n.type,providersResolver:null,decls:n.decls,vars:n.vars,factory:null,template:n.template||null,consts:n.consts||null,ngContentSelectors:n.ngContentSelectors,hostBindings:n.hostBindings||null,hostVars:n.hostVars||0,hostAttrs:n.hostAttrs||null,contentQueries:n.contentQueries||null,declaredInputs:e,inputs:null,outputs:null,exportAs:n.exportAs||null,onPush:n.changeDetection===kn.OnPush,directiveDefs:null,pipeDefs:null,selectors:n.selectors||Be,viewQuery:n.viewQuery||null,features:n.features||null,data:n.data||{},encapsulation:n.encapsulation||ut.Emulated,id:&quot;c&quot;,styles:n.styles||Be,_:null,setInput:null,schemas:n.schemas||null,tView:null},r=n.directives,s=n.features,o=n.pipes;return i.id+=vT++,i.inputs=xy(n.inputs,e),i.outputs=xy(n.outputs),s&amp;&amp;s.forEach(a=&gt;a(i)),i.directiveDefs=r?()=&gt;(&quot;function&quot;==typeof r?r():r).map(Ay):null,i.pipeDefs=o?()=&gt;(&quot;function&quot;==typeof o?o():o).map(Ty):null,i})}function Ay(n){return Yt(n)||function(n){return n[Fh]||null}(n)}function Ty(n){return function(n){return n[Nh]||null}(n)}const Iy={};function ve(n){return br(()=&gt;{const t={type:n.type,bootstrap:n.bootstrap||Be,declarations:n.declarations||Be,imports:n.imports||Be,exports:n.exports||Be,transitiveCompileScopes:null,schemas:n.schemas||null,id:n.id||null};return null!=n.id&amp;&amp;(Iy[n.id]=n.type),t})}function xy(n,t){if(null==n)return Gs;const e={};for(const i in n)if(n.hasOwnProperty(i)){let r=n[i],s=r;Array.isArray(r)&amp;&amp;(s=r[1],r=r[0]),e[r]=i,t&amp;&amp;(t[r]=s)}return e}const O=ee;function at(n){return{type:n.type,name:n.name,factory:null,pure:!1!==n.pure,onDestroy:n.type.prototype.ngOnDestroy||null}}function Yt(n){return n[Dc]||null}function Mn(n,t){const e=n[My]||null;if(!e&amp;&amp;!0===t)throw new Error(`Type ${ge(n)} does not have &#39;\u0275mod&#39; property.`);return e}function Di(n){return Array.isArray(n)&amp;&amp;&quot;object&quot;==typeof n[1]}function Zn(n){return Array.isArray(n)&amp;&amp;!0===n[1]}function jh(n){return 0!=(8&amp;n.flags)}function kc(n){return 2==(2&amp;n.flags)}function Mc(n){return 1==(1&amp;n.flags)}function Jn(n){return null!==n.template}function kT(n){return 0!=(512&amp;n[2])}function ns(n,t){return n.hasOwnProperty(Yi)?n[Yi]:null}class Py{constructor(t,e,i){this.previousValue=t,this.currentValue=e,this.firstChange=i}isFirstChange(){return this.firstChange}}function je(){return Oy}function Oy(n){return n.type.prototype.ngOnChanges&amp;&amp;(n.setInput=IT),TT}function TT(){const n=Ny(this),t=null==n?void 0:n.current;if(t){const e=n.previous;if(e===Gs)n.previous=t;else for(let i in t)e[i]=t[i];n.current=null,this.ngOnChanges(t)}}function IT(n,t,e,i){const r=Ny(n)||function(n,t){return n[Fy]=t}(n,{previous:Gs,current:null}),s=r.current||(r.current={}),o=r.previous,a=this.declaredInputs[e],l=o[a];s[a]=new Py(l&amp;&amp;l.currentValue,t,o===Gs),n[i]=t}je.ngInherit=!0;const Fy=&quot;__ngSimpleChanges__&quot;;function Ny(n){return n[Fy]||null}const Vy=&quot;http://www.w3.org/2000/svg&quot;;let Hh;function et(n){return!!n.listen}const jy={createRenderer:(n,t)=&gt;void 0!==Hh?Hh:&quot;undefined&quot;!=typeof document?document:void 0};function dt(n){for(;Array.isArray(n);)n=n[0];return n}function Ac(n,t){return dt(t[n])}function In(n,t){return dt(t[n.index])}function $h(n,t){return n.data[t]}function Qs(n,t){return n[t]}function pn(n,t){const e=t[n];return Di(e)?e:e[0]}function By(n){return 4==(4&amp;n[2])}function Gh(n){return 128==(128&amp;n[2])}function Dr(n,t){return null==t?null:n[t]}function Uy(n){n[18]=0}function Wh(n,t){n[5]+=t;let e=n,i=n[3];for(;null!==i&amp;&amp;(1===t&amp;&amp;1===e[5]||-1===t&amp;&amp;0===e[5]);)i[5]+=t,e=i,i=i[3]}const te={lFrame:Ky(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function Hy(){return te.bindingsEnabled}function x(){return te.lFrame.lView}function Ae(){return te.lFrame.tView}function _e(n){return te.lFrame.contextLView=n,n[8]}function _t(){let n=zy();for(;null!==n&amp;&amp;64===n.type;)n=n.parent;return n}function zy(){return te.lFrame.currentTNode}function wi(n,t){const e=te.lFrame;e.currentTNode=n,e.isParent=t}function qh(){return te.lFrame.isParent}function Yh(){te.lFrame.isParent=!1}function Tc(){return te.isInCheckNoChangesMode}function Ic(n){te.isInCheckNoChangesMode=n}function Kt(){const n=te.lFrame;let t=n.bindingRootIndex;return-1===t&amp;&amp;(t=n.bindingRootIndex=n.tView.bindingStartIndex),t}function Ei(){return te.lFrame.bindingIndex}function Zs(){return te.lFrame.bindingIndex++}function Ki(n){const t=te.lFrame,e=t.bindingIndex;return t.bindingIndex=t.bindingIndex+n,e}function GT(n,t){const e=te.lFrame;e.bindingIndex=e.bindingRootIndex=n,Kh(t)}function Kh(n){te.lFrame.currentDirectiveIndex=n}function Qh(n){const t=te.lFrame.currentDirectiveIndex;return-1===t?null:n[t]}function Wy(){return te.lFrame.currentQueryIndex}function Zh(n){te.lFrame.currentQueryIndex=n}function qT(n){const t=n[1];return 2===t.type?t.declTNode:1===t.type?n[6]:null}function qy(n,t,e){if(e&amp;z.SkipSelf){let r=t,s=n;for(;!(r=r.parent,null!==r||e&amp;z.Host||(r=qT(s),null===r||(s=s[15],10&amp;r.type))););if(null===r)return!1;t=r,n=s}const i=te.lFrame=Yy();return i.currentTNode=t,i.lView=n,!0}function xc(n){const t=Yy(),e=n[1];te.lFrame=t,t.currentTNode=e.firstChild,t.lView=n,t.tView=e,t.contextLView=n,t.bindingIndex=e.bindingStartIndex,t.inI18n=!1}function Yy(){const n=te.lFrame,t=null===n?null:n.child;return null===t?Ky(n):t}function Ky(n){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:n,child:null,inI18n:!1};return null!==n&amp;&amp;(n.child=t),t}function Qy(){const n=te.lFrame;return te.lFrame=n.parent,n.currentTNode=null,n.lView=null,n}const Zy=Qy;function Rc(){const n=Qy();n.isParent=!0,n.tView=null,n.selectedIndex=-1,n.contextLView=null,n.elementDepthCount=0,n.currentDirectiveIndex=-1,n.currentNamespace=null,n.bindingRootIndex=-1,n.bindingIndex=-1,n.currentQueryIndex=0}function Qt(){return te.lFrame.selectedIndex}function wr(n){te.lFrame.selectedIndex=n}function tt(){const n=te.lFrame;return $h(n.tView,n.selectedIndex)}function Pc(n,t){for(let e=t.directiveStart,i=t.directiveEnd;e&lt;i;e++){const s=n.data[e].type.prototype,{ngAfterContentInit:o,ngAfterContentChecked:a,ngAfterViewInit:l,ngAfterViewChecked:c,ngOnDestroy:u}=s;o&amp;&amp;(n.contentHooks||(n.contentHooks=[])).push(-e,o),a&amp;&amp;((n.contentHooks||(n.contentHooks=[])).push(e,a),(n.contentCheckHooks||(n.contentCheckHooks=[])).push(e,a)),l&amp;&amp;(n.viewHooks||(n.viewHooks=[])).push(-e,l),c&amp;&amp;((n.viewHooks||(n.viewHooks=[])).push(e,c),(n.viewCheckHooks||(n.viewCheckHooks=[])).push(e,c)),null!=u&amp;&amp;(n.destroyHooks||(n.destroyHooks=[])).push(e,u)}}function Oc(n,t,e){Xy(n,t,3,e)}function Fc(n,t,e,i){(3&amp;n[2])===e&amp;&amp;Xy(n,t,e,i)}function Jh(n,t){let e=n[2];(3&amp;e)===t&amp;&amp;(e&amp;=2047,e+=1,n[2]=e)}function Xy(n,t,e,i){const s=null!=i?i:-1,o=t.length-1;let a=0;for(let l=void 0!==i?65535&amp;n[18]:0;l&lt;o;l++)if(&quot;number&quot;==typeof t[l+1]){if(a=t[l],null!=i&amp;&amp;a&gt;=i)break}else t[l]&lt;0&amp;&amp;(n[18]+=65536),(a&lt;s||-1==s)&amp;&amp;(tI(n,e,t,l),n[18]=(4294901760&amp;n[18])+l+2),l++}function tI(n,t,e,i){const r=e[i]&lt;0,s=e[i+1],a=n[r?-e[i]:e[i]];if(r){if(n[2]&gt;&gt;11&lt;n[18]&gt;&gt;16&amp;&amp;(3&amp;n[2])===t){n[2]+=2048;try{s.call(a)}finally{}}}else try{s.call(a)}finally{}}class Ta{constructor(t,e,i){this.factory=t,this.resolving=!1,this.canSeeViewProviders=e,this.injectImpl=i}}function Nc(n,t,e){const i=et(n);let r=0;for(;r&lt;e.length;){const s=e[r];if(&quot;number&quot;==typeof s){if(0!==s)break;r++;const o=e[r++],a=e[r++],l=e[r++];i?n.setAttribute(t,a,l,o):t.setAttributeNS(o,a,l)}else{const o=s,a=e[++r];ef(o)?i&amp;&amp;n.setProperty(t,o,a):i?n.setAttribute(t,o,a):t.setAttribute(o,a),r++}}return r}function ev(n){return 3===n||4===n||6===n}function ef(n){return 64===n.charCodeAt(0)}function Vc(n,t){if(null!==t&amp;&amp;0!==t.length)if(null===n||0===n.length)n=t.slice();else{let e=-1;for(let i=0;i&lt;t.length;i++){const r=t[i];&quot;number&quot;==typeof r?e=r:0===e||tv(n,e,r,null,-1===e||2===e?t[++i]:null)}}return n}function tv(n,t,e,i,r){let s=0,o=n.length;if(-1===t)o=-1;else for(;s&lt;n.length;){const a=n[s++];if(&quot;number&quot;==typeof a){if(a===t){o=-1;break}if(a&gt;t){o=s-1;break}}}for(;s&lt;n.length;){const a=n[s];if(&quot;number&quot;==typeof a)break;if(a===e){if(null===i)return void(null!==r&amp;&amp;(n[s+1]=r));if(i===n[s+1])return void(n[s+2]=r)}s++,null!==i&amp;&amp;s++,null!==r&amp;&amp;s++}-1!==o&amp;&amp;(n.splice(o,0,t),s=o+1),n.splice(s++,0,e),null!==i&amp;&amp;n.splice(s++,0,i),null!==r&amp;&amp;n.splice(s++,0,r)}function nv(n){return-1!==n}function Js(n){return 32767&amp;n}function Xs(n,t){let e=function(n){return n&gt;&gt;16}(n),i=t;for(;e&gt;0;)i=i[15],e--;return i}let tf=!0;function Lc(n){const t=tf;return tf=n,t}let aI=0;function xa(n,t){const e=rf(n,t);if(-1!==e)return e;const i=t[1];i.firstCreatePass&amp;&amp;(n.injectorIndex=t.length,nf(i.data,n),nf(t,null),nf(i.blueprint,null));const r=jc(n,t),s=n.injectorIndex;if(nv(r)){const o=Js(r),a=Xs(r,t),l=a[1].data;for(let c=0;c&lt;8;c++)t[s+c]=a[o+c]|l[o+c]}return t[s+8]=r,s}function nf(n,t){n.push(0,0,0,0,0,0,0,0,t)}function rf(n,t){return-1===n.injectorIndex||n.parent&amp;&amp;n.parent.injectorIndex===n.injectorIndex||null===t[n.injectorIndex+8]?-1:n.injectorIndex}function jc(n,t){if(n.parent&amp;&amp;-1!==n.parent.injectorIndex)return n.parent.injectorIndex;let e=0,i=null,r=t;for(;null!==r;){const s=r[1],o=s.type;if(i=2===o?s.declTNode:1===o?r[6]:null,null===i)return-1;if(e++,r=r[15],-1!==i.injectorIndex)return i.injectorIndex|e&lt;&lt;16}return-1}function Bc(n,t,e){!function(n,t,e){let i;&quot;string&quot;==typeof e?i=e.charCodeAt(0)||0:e.hasOwnProperty(Ea)&amp;&amp;(i=e[Ea]),null==i&amp;&amp;(i=e[Ea]=aI++);const r=255&amp;i;t.data[n+(r&gt;&gt;5)]|=1&lt;&lt;r}(n,t,e)}function sv(n,t,e){if(e&amp;z.Optional)return n;bc(t,&quot;NodeInjector&quot;)}function ov(n,t,e,i){if(e&amp;z.Optional&amp;&amp;void 0===i&amp;&amp;(i=null),0==(e&amp;(z.Self|z.Host))){const r=n[9],s=vr(void 0);try{return r?r.get(t,i,e&amp;z.Optional):ky(t,i,e&amp;z.Optional)}finally{vr(s)}}return sv(i,t,e)}function av(n,t,e,i=z.Default,r){if(null!==n){const s=function(n){if(&quot;string&quot;==typeof n)return n.charCodeAt(0)||0;const t=n.hasOwnProperty(Ea)?n[Ea]:void 0;return&quot;number&quot;==typeof t?t&gt;=0?255&amp;t:uI:t}(e);if(&quot;function&quot;==typeof s){if(!qy(t,n,i))return i&amp;z.Host?sv(r,e,i):ov(t,e,i,r);try{const o=s(i);if(null!=o||i&amp;z.Optional)return o;bc(e)}finally{Zy()}}else if(&quot;number&quot;==typeof s){let o=null,a=rf(n,t),l=-1,c=i&amp;z.Host?t[16][6]:null;for((-1===a||i&amp;z.SkipSelf)&amp;&amp;(l=-1===a?jc(n,t):t[a+8],-1!==l&amp;&amp;uv(i,!1)?(o=t[1],a=Js(l),t=Xs(l,t)):a=-1);-1!==a;){const u=t[1];if(cv(s,a,u.data)){const f=dI(a,t,e,o,i,c);if(f!==lv)return f}l=t[a+8],-1!==l&amp;&amp;uv(i,t[1].data[a+8]===c)&amp;&amp;cv(s,a,t)?(o=u,a=Js(l),t=Xs(l,t)):a=-1}}}return ov(t,e,i,r)}const lv={};function uI(){return new eo(_t(),x())}function dI(n,t,e,i,r,s){const o=t[1],a=o.data[n+8],u=Uc(a,o,e,null==i?kc(a)&amp;&amp;tf:i!=o&amp;&amp;0!=(3&amp;a.type),r&amp;z.Host&amp;&amp;s===a);return null!==u?Ra(t,o,u,a):lv}function Uc(n,t,e,i,r){const s=n.providerIndexes,o=t.data,a=1048575&amp;s,l=n.directiveStart,u=s&gt;&gt;20,p=r?a+u:n.directiveEnd;for(let g=i?a:a+u;g&lt;p;g++){const m=o[g];if(g&lt;l&amp;&amp;e===m||g&gt;=l&amp;&amp;m.type===e)return g}if(r){const g=o[l];if(g&amp;&amp;Jn(g)&amp;&amp;g.type===e)return l}return null}function Ra(n,t,e,i){let r=n[e];const s=t.data;if(function(n){return n instanceof Ta}(r)){const o=r;o.resolving&amp;&amp;function(n,t){throw new Zr(&quot;200&quot;,`Circular dependency in DI detected for ${n}`)}(qt(s[e]));const a=Lc(o.canSeeViewProviders);o.resolving=!0;const l=o.injectImpl?vr(o.injectImpl):null;qy(n,i,z.Default);try{r=n[e]=o.factory(void 0,s,n,i),t.firstCreatePass&amp;&amp;e&gt;=i.directiveStart&amp;&amp;function(n,t,e){const{ngOnChanges:i,ngOnInit:r,ngDoCheck:s}=t.type.prototype;if(i){const o=Oy(t);(e.preOrderHooks||(e.preOrderHooks=[])).push(n,o),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,o)}r&amp;&amp;(e.preOrderHooks||(e.preOrderHooks=[])).push(0-n,r),s&amp;&amp;((e.preOrderHooks||(e.preOrderHooks=[])).push(n,s),(e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n,s))}(e,s[e],t)}finally{null!==l&amp;&amp;vr(l),Lc(a),o.resolving=!1,Zy()}}return r}function cv(n,t,e){return!!(e[t+(n&gt;&gt;5)]&amp;1&lt;&lt;n)}function uv(n,t){return!(n&amp;z.Self||n&amp;z.Host&amp;&amp;t)}class eo{constructor(t,e){this._tNode=t,this._lView=e}get(t,e,i){return av(this._tNode,this._lView,t,i,e)}}function Et(n){return br(()=&gt;{const t=n.prototype.constructor,e=t[Yi]||sf(t),i=Object.prototype;let r=Object.getPrototypeOf(n.prototype).constructor;for(;r&amp;&amp;r!==i;){const s=r[Yi]||sf(r);if(s&amp;&amp;s!==e)return s;r=Object.getPrototypeOf(r)}return s=&gt;new s})}function sf(n){return Dy(n)?()=&gt;{const t=sf(H(n));return t&amp;&amp;t()}:ns(n)}function is(n){return function(n,t){if(&quot;class&quot;===t)return n.classes;if(&quot;style&quot;===t)return n.styles;const e=n.attrs;if(e){const i=e.length;let r=0;for(;r&lt;i;){const s=e[r];if(ev(s))break;if(0===s)r+=2;else if(&quot;number&quot;==typeof s)for(r++;r&lt;i&amp;&amp;&quot;string&quot;==typeof e[r];)r++;else{if(s===t)return e[r+1];r+=2}}}return null}(_t(),n)}const no=&quot;__parameters__&quot;,io=&quot;__prop__metadata__&quot;;function of(n){return function(...e){if(n){const i=n(...e);for(const r in i)this[r]=i[r]}}}function rs(n,t,e){return br(()=&gt;{const i=of(t);function r(...s){if(this instanceof r)return i.apply(this,s),this;const o=new r(...s);return a.annotation=o,a;function a(l,c,u){const f=l.hasOwnProperty(no)?l[no]:Object.defineProperty(l,no,{value:[]})[no];for(;f.length&lt;=u;)f.push(null);return(f[u]=f[u]||[]).push(o),l}}return e&amp;&amp;(r.prototype=Object.create(e.prototype)),r.prototype.ngMetadataName=n,r.annotationCls=r,r})}function dv(n,t,e,i){return br(()=&gt;{const r=of(t);function s(...o){if(this instanceof s)return r.apply(this,o),this;const a=new s(...o);return function(c,u){const f=c.constructor,p=f.hasOwnProperty(io)?f[io]:Object.defineProperty(f,io,{value:{}})[io];p[u]=p.hasOwnProperty(u)&amp;&amp;p[u]||[],p[u].unshift(a),i&amp;&amp;i(c,u,...o)}}return e&amp;&amp;(s.prototype=Object.create(e.prototype)),s.prototype.ngMetadataName=n,s.annotationCls=s,s})}class j{constructor(t,e){this._desc=t,this.ngMetadataName=&quot;InjectionToken&quot;,this.\u0275prov=void 0,&quot;number&quot;==typeof e?this.__NG_ELEMENT_ID__=e:void 0!==e&amp;&amp;(this.\u0275prov=P({token:this,providedIn:e.providedIn||&quot;root&quot;,factory:e.factory}))}toString(){return`InjectionToken ${this._desc}`}}const gI=new j(&quot;AnalyzeForEntryComponents&quot;),Hc=Function;function xn(n,t){void 0===t&amp;&amp;(t=n);for(let e=0;e&lt;n.length;e++){let i=n[e];Array.isArray(i)?(t===n&amp;&amp;(t=n.slice(0,e)),xn(i,t)):t!==n&amp;&amp;t.push(i)}return t}function Si(n,t){n.forEach(e=&gt;Array.isArray(e)?Si(e,t):t(e))}function $c(n,t,e){t&gt;=n.length?n.push(e):n.splice(t,0,e)}function ss(n,t){return t&gt;=n.length-1?n.pop():n.splice(t,1)[0]}function Sr(n,t){const e=[];for(let i=0;i&lt;n;i++)e.push(t);return e}function gn(n,t,e){let i=ro(n,t);return i&gt;=0?n[1|i]=e:(i=~i,function(n,t,e,i){let r=n.length;if(r==t)n.push(e,i);else if(1===r)n.push(i,n[0]),n[0]=e;else{for(r--,n.push(n[r-1],n[r]);r&gt;t;)n[r]=n[r-2],r--;n[t]=e,n[t+1]=i}}(n,i,t,e)),i}function af(n,t){const e=ro(n,t);if(e&gt;=0)return n[1|e]}function ro(n,t){return function(n,t,e){let i=0,r=n.length&gt;&gt;e;for(;r!==i;){const s=i+(r-i&gt;&gt;1),o=n[s&lt;&lt;e];if(t===o)return s&lt;&lt;e;o&gt;t?r=s:i=s+1}return~(r&lt;&lt;e)}(n,t,1)}const Na={},cf=&quot;__NG_DI_FLAG__&quot;,so=&quot;ngTempTokenPath&quot;,SI=/\n/gm,uf=&quot;__source&quot;,df=Re({provide:String,useValue:Re});let Va;function oo(n){const t=Va;return Va=n,t}function MI(n,t=z.Default){if(void 0===Va)throw new Error(&quot;inject() must be called from an injection context&quot;);return null===Va?ky(n,void 0,t):Va.get(n,t&amp;z.Optional?null:void 0,t)}function D(n,t=z.Default){return(Oh||MI)(H(n),t)}const _v=D;function os(n){const t=[];for(let e=0;e&lt;n.length;e++){const i=H(n[e]);if(Array.isArray(i)){if(0===i.length)throw new Error(&quot;Arguments array must have arguments.&quot;);let r,s=z.Default;for(let o=0;o&lt;i.length;o++){const a=i[o],l=AI(a);&quot;number&quot;==typeof l?-1===l?r=a.token:s|=l:r=a}t.push(D(r,s))}else t.push(D(i))}return t}function La(n,t){return n[cf]=t,n.prototype[cf]=t,n}function AI(n){return n[cf]}function yv(n,t,e,i){const r=n[so];throw t[uf]&amp;&amp;r.unshift(t[uf]),n.message=function(n,t,e,i=null){n=n&amp;&amp;&quot;\n&quot;===n.charAt(0)&amp;&amp;&quot;\u0275&quot;==n.charAt(1)?n.substr(2):n;let r=ge(t);if(Array.isArray(t))r=t.map(ge).join(&quot; -&gt; &quot;);else if(&quot;object&quot;==typeof t){let s=[];for(let o in t)if(t.hasOwnProperty(o)){let a=t[o];s.push(o+&quot;:&quot;+(&quot;string&quot;==typeof a?JSON.stringify(a):ge(a)))}r=`{${s.join(&quot;, &quot;)}}`}return`${e}${i?&quot;(&quot;+i+&quot;)&quot;:&quot;&quot;}[${r}]: ${n.replace(SI,&quot;\n  &quot;)}`}(&quot;\n&quot;+n.message,r,e,i),n.ngTokenPath=r,n[so]=null,n}const ao=La(rs(&quot;Inject&quot;,n=&gt;({token:n})),-1),It=La(rs(&quot;Optional&quot;),8),Xn=La(rs(&quot;SkipSelf&quot;),4);class as{constructor(t){this.changingThisBreaksApplicationSecurity=t}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}function mn(n){return n instanceof as?n.changingThisBreaksApplicationSecurity:n}function ki(n,t){const e=function(n){return n instanceof as&amp;&amp;n.getTypeName()||null}(n);if(null!=e&amp;&amp;e!==t){if(&quot;ResourceURL&quot;===e&amp;&amp;&quot;URL&quot;===t)return!0;throw new Error(`Required a safe ${t}, got a ${e} (see https://g.co/ng/security#xss)`)}return e===t}const JI=/^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&amp;:/?#]*(?:[/?#]|$))/gi,XI=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;var ze=(()=&gt;((ze=ze||{})[ze.NONE=0]=&quot;NONE&quot;,ze[ze.HTML=1]=&quot;HTML&quot;,ze[ze.STYLE=2]=&quot;STYLE&quot;,ze[ze.SCRIPT=3]=&quot;SCRIPT&quot;,ze[ze.URL=4]=&quot;URL&quot;,ze[ze.RESOURCE_URL=5]=&quot;RESOURCE_URL&quot;,ze))();function Nt(n){const t=function(){const n=x();return n&amp;&amp;n[12]}();return t?t.sanitize(ze.URL,n)||&quot;&quot;:ki(n,&quot;URL&quot;)?mn(n):function(n){return(n=String(n)).match(JI)||n.match(XI)?n:&quot;unsafe:&quot;+n}(le(n))}const Vv=&quot;__ngContext__&quot;;function Vt(n,t){n[Vv]=t}function bf(n){const t=function(n){return n[Vv]||null}(n);return t?Array.isArray(t)?t:t.lView:null}function Zc(n){return n.ngOriginalError}function Cx(n,...t){n.error(...t)}class ls{constructor(){this._console=console}handleError(t){const e=this._findOriginalError(t),i=this._findContext(t),r=function(n){return n&amp;&amp;n.ngErrorLogger||Cx}(t);r(this._console,&quot;ERROR&quot;,t),e&amp;&amp;r(this._console,&quot;ORIGINAL ERROR&quot;,e),i&amp;&amp;r(this._console,&quot;ERROR CONTEXT&quot;,i)}_findContext(t){return t?function(n){return n.ngDebugContext}(t)||this._findContext(Zc(t)):null}_findOriginalError(t){let e=t&amp;&amp;Zc(t);for(;e&amp;&amp;Zc(e);)e=Zc(e);return e||null}}const Wv=(()=&gt;(&quot;undefined&quot;!=typeof requestAnimationFrame&amp;&amp;requestAnimationFrame||setTimeout).bind(Ne))();function Ai(n){return n instanceof Function?n():n}var _n=(()=&gt;((_n=_n||{})[_n.Important=1]=&quot;Important&quot;,_n[_n.DashCase=2]=&quot;DashCase&quot;,_n))();function wf(n,t){return undefined(n,t)}function $a(n){const t=n[3];return Zn(t)?t[3]:t}function Ef(n){return Zv(n[13])}function Sf(n){return Zv(n[4])}function Zv(n){for(;null!==n&amp;&amp;!Zn(n);)n=n[4];return n}function ho(n,t,e,i,r){if(null!=i){let s,o=!1;Zn(i)?s=i:Di(i)&amp;&amp;(o=!0,i=i[0]);const a=dt(i);0===n&amp;&amp;null!==e?null==r?ib(t,e,a):cs(t,e,a,r||null,!0):1===n&amp;&amp;null!==e?cs(t,e,a,r||null,!0):2===n?function(n,t,e){const i=Xc(n,t);i&amp;&amp;function(n,t,e,i){et(n)?n.removeChild(t,e,i):t.removeChild(e)}(n,i,t,e)}(t,a,o):3===n&amp;&amp;t.destroyNode(a),null!=s&amp;&amp;function(n,t,e,i,r){const s=e[7];s!==dt(e)&amp;&amp;ho(t,n,i,s,r);for(let a=10;a&lt;e.length;a++){const l=e[a];Ga(l[1],l,n,t,i,s)}}(t,n,s,e,r)}}function Mf(n,t,e){return et(n)?n.createElement(t,e):null===e?n.createElement(t):n.createElementNS(e,t)}function Xv(n,t){const e=n[9],i=e.indexOf(t),r=t[3];1024&amp;t[2]&amp;&amp;(t[2]&amp;=-1025,Wh(r,-1)),e.splice(i,1)}function Af(n,t){if(n.length&lt;=10)return;const e=10+t,i=n[e];if(i){const r=i[17];null!==r&amp;&amp;r!==n&amp;&amp;Xv(r,i),t&gt;0&amp;&amp;(n[e-1][4]=i[4]);const s=ss(n,10+t);!function(n,t){Ga(n,t,t[11],2,null,null),t[0]=null,t[6]=null}(i[1],i);const o=s[19];null!==o&amp;&amp;o.detachView(s[1]),i[3]=null,i[4]=null,i[2]&amp;=-129}return i}function eb(n,t){if(!(256&amp;t[2])){const e=t[11];et(e)&amp;&amp;e.destroyNode&amp;&amp;Ga(n,t,e,3,null,null),function(n){let t=n[13];if(!t)return Tf(n[1],n);for(;t;){let e=null;if(Di(t))e=t[13];else{const i=t[10];i&amp;&amp;(e=i)}if(!e){for(;t&amp;&amp;!t[4]&amp;&amp;t!==n;)Di(t)&amp;&amp;Tf(t[1],t),t=t[3];null===t&amp;&amp;(t=n),Di(t)&amp;&amp;Tf(t[1],t),e=t&amp;&amp;t[4]}t=e}}(t)}}function Tf(n,t){if(!(256&amp;t[2])){t[2]&amp;=-129,t[2]|=256,function(n,t){let e;if(null!=n&amp;&amp;null!=(e=n.destroyHooks))for(let i=0;i&lt;e.length;i+=2){const r=t[e[i]];if(!(r instanceof Ta)){const s=e[i+1];if(Array.isArray(s))for(let o=0;o&lt;s.length;o+=2){const a=r[s[o]],l=s[o+1];try{l.call(a)}finally{}}else try{s.call(r)}finally{}}}}(n,t),function(n,t){const e=n.cleanup,i=t[7];let r=-1;if(null!==e)for(let s=0;s&lt;e.length-1;s+=2)if(&quot;string&quot;==typeof e[s]){const o=e[s+1],a=&quot;function&quot;==typeof o?o(t):dt(t[o]),l=i[r=e[s+2]],c=e[s+3];&quot;boolean&quot;==typeof c?a.removeEventListener(e[s],l,c):c&gt;=0?i[r=c]():i[r=-c].unsubscribe(),s+=2}else{const o=i[r=e[s+1]];e[s].call(o)}if(null!==i){for(let s=r+1;s&lt;i.length;s++)i[s]();t[7]=null}}(n,t),1===t[1].type&amp;&amp;et(t[11])&amp;&amp;t[11].destroy();const e=t[17];if(null!==e&amp;&amp;Zn(t[3])){e!==t[3]&amp;&amp;Xv(e,t);const i=t[19];null!==i&amp;&amp;i.detachView(n)}}}function tb(n,t,e){return function(n,t,e){let i=t;for(;null!==i&amp;&amp;40&amp;i.type;)i=(t=i).parent;if(null===i)return e[0];if(2&amp;i.flags){const r=n.data[i.directiveStart].encapsulation;if(r===ut.None||r===ut.Emulated)return null}return In(i,e)}(n,t.parent,e)}function cs(n,t,e,i,r){et(n)?n.insertBefore(t,e,i,r):t.insertBefore(e,i,r)}function ib(n,t,e){et(n)?n.appendChild(t,e):t.appendChild(e)}function rb(n,t,e,i,r){null!==i?cs(n,t,e,i,r):ib(n,t,e)}function Xc(n,t){return et(n)?n.parentNode(t):t.parentNode}function sb(n,t,e){return ab(n,t,e)}let ab=function(n,t,e){return 40&amp;n.type?In(n,e):null};function eu(n,t,e,i){const r=tb(n,i,t),s=t[11],a=sb(i.parent||t[6],i,t);if(null!=r)if(Array.isArray(e))for(let l=0;l&lt;e.length;l++)rb(s,r,e[l],a,!1);else rb(s,r,e,a,!1)}function tu(n,t){if(null!==t){const e=t.type;if(3&amp;e)return In(t,n);if(4&amp;e)return xf(-1,n[t.index]);if(8&amp;e){const i=t.child;if(null!==i)return tu(n,i);{const r=n[t.index];return Zn(r)?xf(-1,r):dt(r)}}if(32&amp;e)return wf(t,n)()||dt(n[t.index]);{const i=cb(n,t);return null!==i?Array.isArray(i)?i[0]:tu($a(n[16]),i):tu(n,t.next)}}return null}function cb(n,t){return null!==t?n[16][6].projection[t.projection]:null}function xf(n,t){const e=10+n+1;if(e&lt;t.length){const i=t[e],r=i[1].firstChild;if(null!==r)return tu(i,r)}return t[7]}function Rf(n,t,e,i,r,s,o){for(;null!=e;){const a=i[e.index],l=e.type;if(o&amp;&amp;0===t&amp;&amp;(a&amp;&amp;Vt(dt(a),i),e.flags|=4),64!=(64&amp;e.flags))if(8&amp;l)Rf(n,t,e.child,i,r,s,!1),ho(t,n,r,a,s);else if(32&amp;l){const c=wf(e,i);let u;for(;u=c();)ho(t,n,r,u,s);ho(t,n,r,a,s)}else 16&amp;l?db(n,t,i,e,r,s):ho(t,n,r,a,s);e=o?e.projectionNext:e.next}}function Ga(n,t,e,i,r,s){Rf(e,i,n.firstChild,t,r,s,!1)}function db(n,t,e,i,r,s){const o=e[16],l=o[6].projection[i.projection];if(Array.isArray(l))for(let c=0;c&lt;l.length;c++)ho(t,n,r,l[c],s);else Rf(n,t,l,o[3],r,s,!0)}function hb(n,t,e){et(n)?n.setAttribute(t,&quot;style&quot;,e):t.style.cssText=e}function Pf(n,t,e){et(n)?&quot;&quot;===e?n.removeAttribute(t,&quot;class&quot;):n.setAttribute(t,&quot;class&quot;,e):t.className=e}function fb(n,t,e){let i=n.length;for(;;){const r=n.indexOf(t,e);if(-1===r)return r;if(0===r||n.charCodeAt(r-1)&lt;=32){const s=t.length;if(r+s===i||n.charCodeAt(r+s)&lt;=32)return r}e=r+1}}const pb=&quot;ng-template&quot;;function qx(n,t,e){let i=0;for(;i&lt;n.length;){let r=n[i++];if(e&amp;&amp;&quot;class&quot;===r){if(r=n[i],-1!==fb(r.toLowerCase(),t,0))return!0}else if(1===r){for(;i&lt;n.length&amp;&amp;&quot;string&quot;==typeof(r=n[i++]);)if(r.toLowerCase()===t)return!0;return!1}}return!1}function gb(n){return 4===n.type&amp;&amp;n.value!==pb}function Yx(n,t,e){return t===(4!==n.type||e?n.value:pb)}function Kx(n,t,e){let i=4;const r=n.attrs||[],s=function(n){for(let t=0;t&lt;n.length;t++)if(ev(n[t]))return t;return n.length}(r);let o=!1;for(let a=0;a&lt;t.length;a++){const l=t[a];if(&quot;number&quot;!=typeof l){if(!o)if(4&amp;i){if(i=2|1&amp;i,&quot;&quot;!==l&amp;&amp;!Yx(n,l,e)||&quot;&quot;===l&amp;&amp;1===t.length){if(ei(i))return!1;o=!0}}else{const c=8&amp;i?l:t[++a];if(8&amp;i&amp;&amp;null!==n.attrs){if(!qx(n.attrs,c,e)){if(ei(i))return!1;o=!0}continue}const f=Qx(8&amp;i?&quot;class&quot;:l,r,gb(n),e);if(-1===f){if(ei(i))return!1;o=!0;continue}if(&quot;&quot;!==c){let p;p=f&gt;s?&quot;&quot;:r[f+1].toLowerCase();const g=8&amp;i?p:null;if(g&amp;&amp;-1!==fb(g,c,0)||2&amp;i&amp;&amp;c!==p){if(ei(i))return!1;o=!0}}}}else{if(!o&amp;&amp;!ei(i)&amp;&amp;!ei(l))return!1;if(o&amp;&amp;ei(l))continue;o=!1,i=l|1&amp;i}}return ei(i)||o}function ei(n){return 0==(1&amp;n)}function Qx(n,t,e,i){if(null===t)return-1;let r=0;if(i||!e){let s=!1;for(;r&lt;t.length;){const o=t[r];if(o===n)return r;if(3===o||6===o)s=!0;else{if(1===o||2===o){let a=t[++r];for(;&quot;string&quot;==typeof a;)a=t[++r];continue}if(4===o)break;if(0===o){r+=4;continue}}r+=s?1:2}return-1}return function(n,t){let e=n.indexOf(4);if(e&gt;-1)for(e++;e&lt;n.length;){const i=n[e];if(&quot;number&quot;==typeof i)return-1;if(i===t)return e;e++}return-1}(t,n)}function mb(n,t,e=!1){for(let i=0;i&lt;t.length;i++)if(Kx(n,t[i],e))return!0;return!1}function eR(n,t){e:for(let e=0;e&lt;t.length;e++){const i=t[e];if(n.length===i.length){for(let r=0;r&lt;n.length;r++)if(n[r]!==i[r])continue e;return!0}}return!1}function _b(n,t){return n?&quot;:not(&quot;+t.trim()+&quot;)&quot;:t}function tR(n){let t=n[0],e=1,i=2,r=&quot;&quot;,s=!1;for(;e&lt;n.length;){let o=n[e];if(&quot;string&quot;==typeof o)if(2&amp;i){const a=n[++e];r+=&quot;[&quot;+o+(a.length&gt;0?&#39;=&quot;&#39;+a+&#39;&quot;&#39;:&quot;&quot;)+&quot;]&quot;}else 8&amp;i?r+=&quot;.&quot;+o:4&amp;i&amp;&amp;(r+=&quot; &quot;+o);else&quot;&quot;!==r&amp;&amp;!ei(o)&amp;&amp;(t+=_b(s,r),r=&quot;&quot;),i=o,s=s||!ei(i);e++}return&quot;&quot;!==r&amp;&amp;(t+=_b(s,r)),t}const re={};function y(n){yb(Ae(),x(),Qt()+n,Tc())}function yb(n,t,e,i){if(!i)if(3==(3&amp;t[2])){const s=n.preOrderCheckHooks;null!==s&amp;&amp;Oc(t,s,e)}else{const s=n.preOrderHooks;null!==s&amp;&amp;Fc(t,s,0,e)}wr(e)}function nu(n,t){return n&lt;&lt;17|t&lt;&lt;2}function ti(n){return n&gt;&gt;17&amp;32767}function Of(n){return 2|n}function Qi(n){return(131068&amp;n)&gt;&gt;2}function Ff(n,t){return-131069&amp;n|t&lt;&lt;2}function Nf(n){return 1|n}function Ab(n,t){const e=n.contentQueries;if(null!==e)for(let i=0;i&lt;e.length;i+=2){const r=e[i],s=e[i+1];if(-1!==s){const o=n.data[s];Zh(r),o.contentQueries(2,t[s],s)}}}function Wa(n,t,e,i,r,s,o,a,l,c){const u=t.blueprint.slice();return u[0]=r,u[2]=140|i,Uy(u),u[3]=u[15]=n,u[8]=e,u[10]=o||n&amp;&amp;n[10],u[11]=a||n&amp;&amp;n[11],u[12]=l||n&amp;&amp;n[12]||null,u[9]=c||n&amp;&amp;n[9]||null,u[6]=s,u[16]=2==t.type?n[16]:u,u}function fo(n,t,e,i,r){let s=n.data[t];if(null===s)s=function(n,t,e,i,r){const s=zy(),o=qh(),l=n.data[t]=function(n,t,e,i,r,s){return{type:e,index:i,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:r,attrs:s,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,o?s:s&amp;&amp;s.parent,e,t,i,r);return null===n.firstChild&amp;&amp;(n.firstChild=l),null!==s&amp;&amp;(o?null==s.child&amp;&amp;null!==l.parent&amp;&amp;(s.child=l):null===s.next&amp;&amp;(s.next=l)),l}(n,t,e,i,r),te.lFrame.inI18n&amp;&amp;(s.flags|=64);else if(64&amp;s.type){s.type=e,s.value=i,s.attrs=r;const o=function(){const n=te.lFrame,t=n.currentTNode;return n.isParent?t:t.parent}();s.injectorIndex=null===o?-1:o.injectorIndex}return wi(s,!0),s}function po(n,t,e,i){if(0===e)return-1;const r=t.length;for(let s=0;s&lt;e;s++)t.push(i),n.blueprint.push(i),n.data.push(null);return r}function qa(n,t,e){xc(t);try{const i=n.viewQuery;null!==i&amp;&amp;Jf(1,i,e);const r=n.template;null!==r&amp;&amp;Tb(n,t,r,1,e),n.firstCreatePass&amp;&amp;(n.firstCreatePass=!1),n.staticContentQueries&amp;&amp;Ab(n,t),n.staticViewQueries&amp;&amp;Jf(2,n.viewQuery,e);const s=n.components;null!==s&amp;&amp;function(n,t){for(let e=0;e&lt;t.length;e++)OR(n,t[e])}(t,s)}catch(i){throw n.firstCreatePass&amp;&amp;(n.incompleteFirstPass=!0,n.firstCreatePass=!1),i}finally{t[2]&amp;=-5,Rc()}}function go(n,t,e,i){const r=t[2];if(256==(256&amp;r))return;xc(t);const s=Tc();try{Uy(t),function(n){te.lFrame.bindingIndex=n}(n.bindingStartIndex),null!==e&amp;&amp;Tb(n,t,e,2,i);const o=3==(3&amp;r);if(!s)if(o){const c=n.preOrderCheckHooks;null!==c&amp;&amp;Oc(t,c,null)}else{const c=n.preOrderHooks;null!==c&amp;&amp;Fc(t,c,0,null),Jh(t,0)}if(function(n){for(let t=Ef(n);null!==t;t=Sf(t)){if(!t[2])continue;const e=t[9];for(let i=0;i&lt;e.length;i++){const r=e[i],s=r[3];0==(1024&amp;r[2])&amp;&amp;Wh(s,1),r[2]|=1024}}}(t),function(n){for(let t=Ef(n);null!==t;t=Sf(t))for(let e=10;e&lt;t.length;e++){const i=t[e],r=i[1];Gh(i)&amp;&amp;go(r,i,r.template,i[8])}}(t),null!==n.contentQueries&amp;&amp;Ab(n,t),!s)if(o){const c=n.contentCheckHooks;null!==c&amp;&amp;Oc(t,c)}else{const c=n.contentHooks;null!==c&amp;&amp;Fc(t,c,1),Jh(t,1)}!function(n,t){const e=n.hostBindingOpCodes;if(null!==e)try{for(let i=0;i&lt;e.length;i++){const r=e[i];if(r&lt;0)wr(~r);else{const s=r,o=e[++i],a=e[++i];GT(o,s),a(2,t[s])}}}finally{wr(-1)}}(n,t);const a=n.components;null!==a&amp;&amp;function(n,t){for(let e=0;e&lt;t.length;e++)PR(n,t[e])}(t,a);const l=n.viewQuery;if(null!==l&amp;&amp;Jf(2,l,i),!s)if(o){const c=n.viewCheckHooks;null!==c&amp;&amp;Oc(t,c)}else{const c=n.viewHooks;null!==c&amp;&amp;Fc(t,c,2),Jh(t,2)}!0===n.firstUpdatePass&amp;&amp;(n.firstUpdatePass=!1),s||(t[2]&amp;=-73),1024&amp;t[2]&amp;&amp;(t[2]&amp;=-1025,Wh(t[3],-1))}finally{Rc()}}function pR(n,t,e,i){const r=t[10],s=!Tc(),o=By(t);try{s&amp;&amp;!o&amp;&amp;r.begin&amp;&amp;r.begin(),o&amp;&amp;qa(n,t,i),go(n,t,e,i)}finally{s&amp;&amp;!o&amp;&amp;r.end&amp;&amp;r.end()}}function Tb(n,t,e,i,r){const s=Qt(),o=2&amp;i;try{wr(-1),o&amp;&amp;t.length&gt;20&amp;&amp;yb(n,t,20,Tc()),e(i,r)}finally{wr(s)}}function Ib(n,t,e){if(jh(t)){const r=t.directiveEnd;for(let s=t.directiveStart;s&lt;r;s++){const o=n.data[s];o.contentQueries&amp;&amp;o.contentQueries(1,e[s],s)}}}function $f(n,t,e){!Hy()||(function(n,t,e,i){const r=e.directiveStart,s=e.directiveEnd;n.firstCreatePass||xa(e,t),Vt(i,t);const o=e.initialInputs;for(let a=r;a&lt;s;a++){const l=n.data[a],c=Jn(l);c&amp;&amp;AR(t,e,l);const u=Ra(t,n,a,e);Vt(u,t),null!==o&amp;&amp;TR(0,a-r,u,l,0,o),c&amp;&amp;(pn(e.index,t)[8]=u)}}(n,t,e,In(e,t)),128==(128&amp;e.flags)&amp;&amp;function(n,t,e){const i=e.directiveStart,r=e.directiveEnd,o=e.index,a=te.lFrame.currentDirectiveIndex;try{wr(o);for(let l=i;l&lt;r;l++){const c=n.data[l],u=t[l];Kh(l),(null!==c.hostBindings||0!==c.hostVars||null!==c.hostAttrs)&amp;&amp;Lb(c,u)}}finally{wr(-1),Kh(a)}}(n,t,e))}function Gf(n,t,e=In){const i=t.localNames;if(null!==i){let r=t.index+1;for(let s=0;s&lt;i.length;s+=2){const o=i[s+1],a=-1===o?e(t,n):n[o];n[r++]=a}}}function xb(n){const t=n.tView;return null===t||t.incompleteFirstPass?n.tView=su(1,null,n.template,n.decls,n.vars,n.directiveDefs,n.pipeDefs,n.viewQuery,n.schemas,n.consts):t}function su(n,t,e,i,r,s,o,a,l,c){const u=20+i,f=u+r,p=function(n,t){const e=[];for(let i=0;i&lt;t;i++)e.push(i&lt;n?null:re);return e}(u,f),g=&quot;function&quot;==typeof c?c():c;return p[1]={type:n,blueprint:p,template:e,queries:null,viewQuery:a,declTNode:t,data:p.slice().fill(null,u),bindingStartIndex:u,expandoStartIndex:f,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:&quot;function&quot;==typeof s?s():s,pipeRegistry:&quot;function&quot;==typeof o?o():o,firstChild:null,schemas:l,consts:g,incompleteFirstPass:!1}}function Ob(n,t,e,i){const r=$b(t);null===e?r.push(i):(r.push(e),n.firstCreatePass&amp;&amp;Gb(n).push(i,r.length-1))}function Fb(n,t,e){for(let i in n)if(n.hasOwnProperty(i)){const r=n[i];(e=null===e?{}:e).hasOwnProperty(i)?e[i].push(t,r):e[i]=[t,r]}return e}function yn(n,t,e,i,r,s,o,a){const l=In(t,e);let u,c=t.inputs;!a&amp;&amp;null!=c&amp;&amp;(u=c[i])?(Yb(n,e,u,i,r),kc(t)&amp;&amp;function(n,t){const e=pn(t,n);16&amp;e[2]||(e[2]|=64)}(e,t.index)):3&amp;t.type&amp;&amp;(i=function(n){return&quot;class&quot;===n?&quot;className&quot;:&quot;for&quot;===n?&quot;htmlFor&quot;:&quot;formaction&quot;===n?&quot;formAction&quot;:&quot;innerHtml&quot;===n?&quot;innerHTML&quot;:&quot;readonly&quot;===n?&quot;readOnly&quot;:&quot;tabindex&quot;===n?&quot;tabIndex&quot;:n}(i),r=null!=o?o(r,t.value||&quot;&quot;,i):r,et(s)?s.setProperty(l,i,r):ef(i)||(l.setProperty?l.setProperty(i,r):l[i]=r))}function Wf(n,t,e,i){let r=!1;if(Hy()){const s=function(n,t,e){const i=n.directiveRegistry;let r=null;if(i)for(let s=0;s&lt;i.length;s++){const o=i[s];mb(e,o.selectors,!1)&amp;&amp;(r||(r=[]),Bc(xa(e,t),n,o.type),Jn(o)?(jb(n,e),r.unshift(o)):r.push(o))}return r}(n,t,e),o=null===i?null:{&quot;&quot;:-1};if(null!==s){r=!0,Bb(e,n.data.length,s.length);for(let u=0;u&lt;s.length;u++){const f=s[u];f.providersResolver&amp;&amp;f.providersResolver(f)}let a=!1,l=!1,c=po(n,t,s.length,null);for(let u=0;u&lt;s.length;u++){const f=s[u];e.mergedAttrs=Vc(e.mergedAttrs,f.hostAttrs),Ub(n,e,t,c,f),MR(c,f,o),null!==f.contentQueries&amp;&amp;(e.flags|=8),(null!==f.hostBindings||null!==f.hostAttrs||0!==f.hostVars)&amp;&amp;(e.flags|=128);const p=f.type.prototype;!a&amp;&amp;(p.ngOnChanges||p.ngOnInit||p.ngDoCheck)&amp;&amp;((n.preOrderHooks||(n.preOrderHooks=[])).push(e.index),a=!0),!l&amp;&amp;(p.ngOnChanges||p.ngDoCheck)&amp;&amp;((n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e.index),l=!0),c++}!function(n,t){const i=t.directiveEnd,r=n.data,s=t.attrs,o=[];let a=null,l=null;for(let c=t.directiveStart;c&lt;i;c++){const u=r[c],f=u.inputs,p=null===s||gb(t)?null:IR(f,s);o.push(p),a=Fb(f,c,a),l=Fb(u.outputs,c,l)}null!==a&amp;&amp;(a.hasOwnProperty(&quot;class&quot;)&amp;&amp;(t.flags|=16),a.hasOwnProperty(&quot;style&quot;)&amp;&amp;(t.flags|=32)),t.initialInputs=o,t.inputs=a,t.outputs=l}(n,e)}o&amp;&amp;function(n,t,e){if(t){const i=n.localNames=[];for(let r=0;r&lt;t.length;r+=2){const s=e[t[r+1]];if(null==s)throw new Zr(&quot;301&quot;,`Export of name &#39;${t[r+1]}&#39; not found!`);i.push(t[r],s)}}}(e,i,o)}return e.mergedAttrs=Vc(e.mergedAttrs,e.attrs),r}function Vb(n,t,e,i,r,s){const o=s.hostBindings;if(o){let a=n.hostBindingOpCodes;null===a&amp;&amp;(a=n.hostBindingOpCodes=[]);const l=~t.index;(function(n){let t=n.length;for(;t&gt;0;){const e=n[--t];if(&quot;number&quot;==typeof e&amp;&amp;e&lt;0)return e}return 0})(a)!=l&amp;&amp;a.push(l),a.push(i,r,o)}}function Lb(n,t){null!==n.hostBindings&amp;&amp;n.hostBindings(1,t)}function jb(n,t){t.flags|=2,(n.components||(n.components=[])).push(t.index)}function MR(n,t,e){if(e){if(t.exportAs)for(let i=0;i&lt;t.exportAs.length;i++)e[t.exportAs[i]]=n;Jn(t)&amp;&amp;(e[&quot;&quot;]=n)}}function Bb(n,t,e){n.flags|=1,n.directiveStart=t,n.directiveEnd=t+e,n.providerIndexes=t}function Ub(n,t,e,i,r){n.data[i]=r;const s=r.factory||(r.factory=ns(r.type)),o=new Ta(s,Jn(r),null);n.blueprint[i]=o,e[i]=o,Vb(n,t,0,i,po(n,e,r.hostVars,re),r)}function AR(n,t,e){const i=In(t,n),r=xb(e),s=n[10],o=ou(n,Wa(n,r,null,e.onPush?64:16,i,t,s,s.createRenderer(i,e),null,null));n[t.index]=o}function Ti(n,t,e,i,r,s){const o=In(n,t);!function(n,t,e,i,r,s,o){if(null==s)et(n)?n.removeAttribute(t,r,e):t.removeAttribute(r);else{const a=null==o?le(s):o(s,i||&quot;&quot;,r);et(n)?n.setAttribute(t,r,a,e):e?t.setAttributeNS(e,r,a):t.setAttribute(r,a)}}(t[11],o,s,n.value,e,i,r)}function TR(n,t,e,i,r,s){const o=s[t];if(null!==o){const a=i.setInput;for(let l=0;l&lt;o.length;){const c=o[l++],u=o[l++],f=o[l++];null!==a?i.setInput(e,f,c,u):e[u]=f}}}function IR(n,t){let e=null,i=0;for(;i&lt;t.length;){const r=t[i];if(0!==r)if(5!==r){if(&quot;number&quot;==typeof r)break;n.hasOwnProperty(r)&amp;&amp;(null===e&amp;&amp;(e=[]),e.push(r,n[r],t[i+1])),i+=2}else i+=2;else i+=4}return e}function Hb(n,t,e,i){return new Array(n,!0,!1,t,null,0,i,e,null,null)}function PR(n,t){const e=pn(t,n);if(Gh(e)){const i=e[1];80&amp;e[2]?go(i,e,i.template,e[8]):e[5]&gt;0&amp;&amp;Yf(e)}}function Yf(n){for(let i=Ef(n);null!==i;i=Sf(i))for(let r=10;r&lt;i.length;r++){const s=i[r];if(1024&amp;s[2]){const o=s[1];go(o,s,o.template,s[8])}else s[5]&gt;0&amp;&amp;Yf(s)}const e=n[1].components;if(null!==e)for(let i=0;i&lt;e.length;i++){const r=pn(e[i],n);Gh(r)&amp;&amp;r[5]&gt;0&amp;&amp;Yf(r)}}function OR(n,t){const e=pn(t,n),i=e[1];(function(n,t){for(let e=t.length;e&lt;n.blueprint.length;e++)t.push(n.blueprint[e])})(i,e),qa(i,e,e[8])}function ou(n,t){return n[13]?n[14][4]=t:n[13]=t,n[14]=t,t}function Kf(n){for(;n;){n[2]|=64;const t=$a(n);if(kT(n)&amp;&amp;!t)return n;n=t}return null}function Zf(n,t,e){const i=t[10];i.begin&amp;&amp;i.begin();try{go(n,t,n.template,e)}catch(r){throw qb(t,r),r}finally{i.end&amp;&amp;i.end()}}function zb(n){!function(n){for(let t=0;t&lt;n.components.length;t++){const e=n.components[t],i=bf(e),r=i[1];pR(r,i,r.template,e)}}(n[8])}function Jf(n,t,e){Zh(0),t(n,e)}const jR=(()=&gt;Promise.resolve(null))();function $b(n){return n[7]||(n[7]=[])}function Gb(n){return n.cleanup||(n.cleanup=[])}function Wb(n,t,e){return(null===n||Jn(n))&amp;&amp;(e=function(n){for(;Array.isArray(n);){if(&quot;object&quot;==typeof n[1])return n;n=n[0]}return null}(e[t.index])),e[11]}function qb(n,t){const e=n[9],i=e?e.get(ls,null):null;i&amp;&amp;i.handleError(t)}function Yb(n,t,e,i,r){for(let s=0;s&lt;e.length;){const o=e[s++],a=e[s++],l=t[o],c=n.data[o];null!==c.setInput?c.setInput(l,r,i,a):l[a]=r}}function Ji(n,t,e){const i=Ac(t,n);!function(n,t,e){et(n)?n.setValue(t,e):t.textContent=e}(n[11],i,e)}function au(n,t,e){let i=e?n.styles:null,r=e?n.classes:null,s=0;if(null!==t)for(let o=0;o&lt;t.length;o++){const a=t[o];&quot;number&quot;==typeof a?s=a:1==s?r=xh(r,a):2==s&amp;&amp;(i=xh(i,a+&quot;: &quot;+t[++o]+&quot;;&quot;))}e?n.styles=i:n.stylesWithoutHost=i,e?n.classes=r:n.classesWithoutHost=r}const mo=new j(&quot;INJECTOR&quot;,-1);class Kb{get(t,e=Na){if(e===Na){const i=new Error(`NullInjectorError: No provider for ${ge(t)}!`);throw i.name=&quot;NullInjectorError&quot;,i}return e}}const Ya=new j(&quot;Set Injector scope.&quot;),Ka={},HR={};let Xf;function Qb(){return void 0===Xf&amp;&amp;(Xf=new Kb),Xf}function Zb(n,t=null,e=null,i){return new $R(n,e,t||Qb(),i)}class $R{constructor(t,e,i,r=null){this.parent=i,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const s=[];e&amp;&amp;Si(e,a=&gt;this.processProvider(a,t,e)),Si([t],a=&gt;this.processInjectorType(a,[],s)),this.records.set(mo,_o(void 0,this));const o=this.records.get(Ya);this.scope=null!=o?o.value:null,this.source=r||(&quot;object&quot;==typeof t?null:ge(t))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(t=&gt;t.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(t,e=Na,i=z.Default){this.assertNotDestroyed();const r=oo(this),s=vr(void 0);try{if(!(i&amp;z.SkipSelf)){let a=this.records.get(t);if(void 0===a){const l=function(n){return&quot;function&quot;==typeof n||&quot;object&quot;==typeof n&amp;&amp;n instanceof j}(t)&amp;&amp;qi(t);a=l&amp;&amp;this.injectableDefInScope(l)?_o(ep(t),Ka):null,this.records.set(t,a)}if(null!=a)return this.hydrate(t,a)}return(i&amp;z.Self?Qb():this.parent).get(t,e=i&amp;z.Optional&amp;&amp;e===Na?null:e)}catch(o){if(&quot;NullInjectorError&quot;===o.name){if((o[so]=o[so]||[]).unshift(ge(t)),r)throw o;return yv(o,t,&quot;R3InjectorError&quot;,this.source)}throw o}finally{vr(s),oo(r)}}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(t=&gt;this.get(t))}toString(){const t=[];return this.records.forEach((i,r)=&gt;t.push(ge(r))),`R3Injector[${t.join(&quot;, &quot;)}]`}assertNotDestroyed(){if(this._destroyed)throw new Error(&quot;Injector has already been destroyed.&quot;)}processInjectorType(t,e,i){if(!(t=H(t)))return!1;let r=Ey(t);const s=null==r&amp;&amp;t.ngModule||void 0,o=void 0===s?t:s,a=-1!==i.indexOf(o);if(void 0!==s&amp;&amp;(r=Ey(s)),null==r)return!1;if(null!=r.imports&amp;&amp;!a){let u;i.push(o);try{Si(r.imports,f=&gt;{this.processInjectorType(f,e,i)&amp;&amp;(void 0===u&amp;&amp;(u=[]),u.push(f))})}finally{}if(void 0!==u)for(let f=0;f&lt;u.length;f++){const{ngModule:p,providers:g}=u[f];Si(g,m=&gt;this.processProvider(m,p,g||Be))}}this.injectorDefTypes.add(o);const l=ns(o)||(()=&gt;new o);this.records.set(o,_o(l,Ka));const c=r.providers;if(null!=c&amp;&amp;!a){const u=t;Si(c,f=&gt;this.processProvider(f,u,c))}return void 0!==s&amp;&amp;void 0!==t.providers}processProvider(t,e,i){let r=yo(t=H(t))?t:H(t&amp;&amp;t.provide);const s=function(n,t,e){return Xb(n)?_o(void 0,n.useValue):_o(Jb(n),Ka)}(t);if(yo(t)||!0!==t.multi)this.records.get(r);else{let o=this.records.get(r);o||(o=_o(void 0,Ka,!0),o.factory=()=&gt;os(o.multi),this.records.set(r,o)),r=t,o.multi.push(t)}this.records.set(r,s)}hydrate(t,e){return e.value===Ka&amp;&amp;(e.value=HR,e.value=e.factory()),&quot;object&quot;==typeof e.value&amp;&amp;e.value&amp;&amp;function(n){return null!==n&amp;&amp;&quot;object&quot;==typeof n&amp;&amp;&quot;function&quot;==typeof n.ngOnDestroy}(e.value)&amp;&amp;this.onDestroy.add(e.value),e.value}injectableDefInScope(t){if(!t.providedIn)return!1;const e=H(t.providedIn);return&quot;string&quot;==typeof e?&quot;any&quot;===e||e===this.scope:this.injectorDefTypes.has(e)}}function ep(n){const t=qi(n),e=null!==t?t.factory:ns(n);if(null!==e)return e;if(n instanceof j)throw new Error(`Token ${ge(n)} is missing a \u0275prov definition.`);if(n instanceof Function)return function(n){const t=n.length;if(t&gt;0){const i=Sr(t,&quot;?&quot;);throw new Error(`Can&#39;t resolve all parameters for ${ge(n)}: (${i.join(&quot;, &quot;)}).`)}const e=function(n){const t=n&amp;&amp;(n[Cc]||n[Sy]);if(t){const e=function(n){if(n.hasOwnProperty(&quot;name&quot;))return n.name;const t=(&quot;&quot;+n).match(/^function\s*([^\s(]+)/);return null===t?&quot;&quot;:t[1]}(n);return console.warn(`DEPRECATED: DI is instantiating a token &quot;${e}&quot; that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the &quot;${e}&quot; class.`),t}return null}(n);return null!==e?()=&gt;e.factory(n):()=&gt;new n}(n);throw new Error(&quot;unreachable&quot;)}function Jb(n,t,e){let i;if(yo(n)){const r=H(n);return ns(r)||ep(r)}if(Xb(n))i=()=&gt;H(n.useValue);else if(function(n){return!(!n||!n.useFactory)}(n))i=()=&gt;n.useFactory(...os(n.deps||[]));else if(function(n){return!(!n||!n.useExisting)}(n))i=()=&gt;D(H(n.useExisting));else{const r=H(n&amp;&amp;(n.useClass||n.provide));if(!function(n){return!!n.deps}(n))return ns(r)||ep(r);i=()=&gt;new r(...os(n.deps))}return i}function _o(n,t,e=!1){return{factory:n,value:t,multi:e?[]:void 0}}function Xb(n){return null!==n&amp;&amp;&quot;object&quot;==typeof n&amp;&amp;df in n}function yo(n){return&quot;function&quot;==typeof n}const eC=function(n,t,e){return function(n,t=null,e=null,i){const r=Zb(n,t,e,i);return r._resolveInjectorDefTypes(),r}({name:e},t,n,e)};let ke=(()=&gt;{class n{static create(e,i){return Array.isArray(e)?eC(e,i,&quot;&quot;):eC(e.providers,e.parent,e.name||&quot;&quot;)}}return n.THROW_IF_NOT_FOUND=Na,n.NULL=new Kb,n.\u0275prov=P({token:n,providedIn:&quot;any&quot;,factory:()=&gt;D(mo)}),n.__NG_ELEMENT_ID__=-1,n})();function dP(n,t){Pc(bf(n)[1],_t())}function se(n){let t=function(n){return Object.getPrototypeOf(n.prototype).constructor}(n.type),e=!0;const i=[n];for(;t;){let r;if(Jn(n))r=t.\u0275cmp||t.\u0275dir;else{if(t.\u0275cmp)throw new Error(&quot;Directives cannot inherit Components&quot;);r=t.\u0275dir}if(r){if(e){i.push(r);const o=n;o.inputs=op(n.inputs),o.declaredInputs=op(n.declaredInputs),o.outputs=op(n.outputs);const a=r.hostBindings;a&amp;&amp;gP(n,a);const l=r.viewQuery,c=r.contentQueries;if(l&amp;&amp;fP(n,l),c&amp;&amp;pP(n,c),Ih(n.inputs,r.inputs),Ih(n.declaredInputs,r.declaredInputs),Ih(n.outputs,r.outputs),Jn(r)&amp;&amp;r.data.animation){const u=n.data;u.animation=(u.animation||[]).concat(r.data.animation)}}const s=r.features;if(s)for(let o=0;o&lt;s.length;o++){const a=s[o];a&amp;&amp;a.ngInherit&amp;&amp;a(n),a===se&amp;&amp;(e=!1)}}t=Object.getPrototypeOf(t)}!function(n){let t=0,e=null;for(let i=n.length-1;i&gt;=0;i--){const r=n[i];r.hostVars=t+=r.hostVars,r.hostAttrs=Vc(r.hostAttrs,e=Vc(e,r.hostAttrs))}}(i)}function op(n){return n===Gs?{}:n===Be?[]:n}function fP(n,t){const e=n.viewQuery;n.viewQuery=e?(i,r)=&gt;{t(i,r),e(i,r)}:t}function pP(n,t){const e=n.contentQueries;n.contentQueries=e?(i,r,s)=&gt;{t(i,r,s),e(i,r,s)}:t}function gP(n,t){const e=n.hostBindings;n.hostBindings=e?(i,r)=&gt;{t(i,r),e(i,r)}:t}let lu=null;function vo(){if(!lu){const n=Ne.Symbol;if(n&amp;&amp;n.iterator)lu=n.iterator;else{const t=Object.getOwnPropertyNames(Map.prototype);for(let e=0;e&lt;t.length;++e){const i=t[e];&quot;entries&quot;!==i&amp;&amp;&quot;size&quot;!==i&amp;&amp;Map.prototype[i]===Map.prototype.entries&amp;&amp;(lu=i)}}}return lu}class ii{constructor(t){this.wrapped=t}static wrap(t){return new ii(t)}static unwrap(t){return ii.isWrapped(t)?t.wrapped:t}static isWrapped(t){return t instanceof ii}}function Za(n){return!!ap(n)&amp;&amp;(Array.isArray(n)||!(n instanceof Map)&amp;&amp;vo()in n)}function ap(n){return null!==n&amp;&amp;(&quot;function&quot;==typeof n||&quot;object&quot;==typeof n)}function Ii(n,t,e){return n[t]=e}function Lt(n,t,e){return!Object.is(n[t],e)&amp;&amp;(n[t]=e,!0)}function us(n,t,e,i){const r=Lt(n,t,e);return Lt(n,t+1,i)||r}function Ce(n,t,e,i){const r=x();return Lt(r,Zs(),t)&amp;&amp;(Ae(),Ti(tt(),r,n,t,e,i)),Ce}function Co(n,t,e,i){return Lt(n,Zs(),e)?t+le(e)+i:re}function I(n,t,e,i,r,s,o,a){const l=x(),c=Ae(),u=n+20,f=c.firstCreatePass?function(n,t,e,i,r,s,o,a,l){const c=t.consts,u=fo(t,n,4,o||null,Dr(c,a));Wf(t,e,u,Dr(c,l)),Pc(t,u);const f=u.tViews=su(2,u,i,r,s,t.directiveRegistry,t.pipeRegistry,null,t.schemas,c);return null!==t.queries&amp;&amp;(t.queries.template(t,u),f.queries=t.queries.embeddedTView(u)),u}(u,c,l,t,e,i,r,s,o):c.data[u];wi(f,!1);const p=l[11].createComment(&quot;&quot;);eu(c,l,p,f),Vt(p,l),ou(l,l[u]=Hb(p,l,p,f)),Mc(f)&amp;&amp;$f(c,l,f),null!=o&amp;&amp;Gf(l,f,a)}function Ee(n){return Qs(te.lFrame.contextLView,20+n)}function _(n,t=z.Default){const e=x();return null===e?D(n,t):av(_t(),e,H(n),t)}function w(n,t,e){const i=x();return Lt(i,Zs(),t)&amp;&amp;yn(Ae(),tt(),i,n,t,i[11],e,!1),w}function hp(n,t,e,i,r){const o=r?&quot;class&quot;:&quot;style&quot;;Yb(n,e,t.inputs[o],o,i)}function d(n,t,e,i){const r=x(),s=Ae(),o=20+n,a=r[11],l=r[o]=Mf(a,t,te.lFrame.currentNamespace),c=s.firstCreatePass?function(n,t,e,i,r,s,o){const a=t.consts,c=fo(t,n,2,r,Dr(a,s));return Wf(t,e,c,Dr(a,o)),null!==c.attrs&amp;&amp;au(c,c.attrs,!1),null!==c.mergedAttrs&amp;&amp;au(c,c.mergedAttrs,!0),null!==t.queries&amp;&amp;t.queries.elementStart(t,c),c}(o,s,r,0,t,e,i):s.data[o];wi(c,!0);const u=c.mergedAttrs;null!==u&amp;&amp;Nc(a,l,u);const f=c.classes;null!==f&amp;&amp;Pf(a,l,f);const p=c.styles;null!==p&amp;&amp;hb(a,l,p),64!=(64&amp;c.flags)&amp;&amp;eu(s,r,l,c),0===te.lFrame.elementDepthCount&amp;&amp;Vt(l,r),te.lFrame.elementDepthCount++,Mc(c)&amp;&amp;($f(s,r,c),Ib(s,c,r)),null!==i&amp;&amp;Gf(r,c)}function h(){let n=_t();qh()?Yh():(n=n.parent,wi(n,!1));const t=n;te.lFrame.elementDepthCount--;const e=Ae();e.firstCreatePass&amp;&amp;(Pc(e,n),jh(n)&amp;&amp;e.queries.elementEnd(n)),null!=t.classesWithoutHost&amp;&amp;function(n){return 0!=(16&amp;n.flags)}(t)&amp;&amp;hp(e,t,x(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&amp;&amp;function(n){return 0!=(32&amp;n.flags)}(t)&amp;&amp;hp(e,t,x(),t.stylesWithoutHost,!1)}function k(n,t,e,i){d(n,t,e,i),h()}function Xa(n,t,e){const i=x(),r=Ae(),s=n+20,o=r.firstCreatePass?function(n,t,e,i,r){const s=t.consts,o=Dr(s,i),a=fo(t,n,8,&quot;ng-container&quot;,o);return null!==o&amp;&amp;au(a,o,!0),Wf(t,e,a,Dr(s,r)),null!==t.queries&amp;&amp;t.queries.elementStart(t,a),a}(s,r,i,t,e):r.data[s];wi(o,!0);const a=i[s]=i[11].createComment(&quot;&quot;);eu(r,i,a,o),Vt(a,i),Mc(o)&amp;&amp;($f(r,i,o),Ib(r,o,i)),null!=e&amp;&amp;Gf(i,o)}function el(){let n=_t();const t=Ae();qh()?Yh():(n=n.parent,wi(n,!1)),t.firstCreatePass&amp;&amp;(Pc(t,n),jh(n)&amp;&amp;t.queries.elementEnd(n))}function Ue(){return x()}function tl(n){return!!n&amp;&amp;&quot;function&quot;==typeof n.then}const du=function(n){return!!n&amp;&amp;&quot;function&quot;==typeof n.subscribe};function M(n,t,e,i){const r=x(),s=Ae(),o=_t();return jC(s,r,r[11],o,n,t,!!e,i),M}function fp(n,t){const e=_t(),i=x(),r=Ae();return jC(r,i,Wb(Qh(r.data),e,i),e,n,t,!1),fp}function jC(n,t,e,i,r,s,o,a){const l=Mc(i),u=n.firstCreatePass&amp;&amp;Gb(n),f=t[8],p=$b(t);let g=!0;if(3&amp;i.type||a){const v=In(i,t),S=a?a(v):v,E=p.length,R=a?F=&gt;a(dt(F[i.index])):i.index;if(et(e)){let F=null;if(!a&amp;&amp;l&amp;&amp;(F=function(n,t,e,i){const r=n.cleanup;if(null!=r)for(let s=0;s&lt;r.length-1;s+=2){const o=r[s];if(o===e&amp;&amp;r[s+1]===i){const a=t[7],l=r[s+2];return a.length&gt;l?a[l]:null}&quot;string&quot;==typeof o&amp;&amp;(s+=2)}return null}(n,t,r,i.index)),null!==F)(F.__ngLastListenerFn__||F).__ngNextListenerFn__=s,F.__ngLastListenerFn__=s,g=!1;else{s=pp(i,t,f,s,!1);const Q=e.listen(S,r,s);p.push(s,Q),u&amp;&amp;u.push(r,R,E,E+1)}}else s=pp(i,t,f,s,!0),S.addEventListener(r,s,o),p.push(s),u&amp;&amp;u.push(r,R,E,o)}else s=pp(i,t,f,s,!1);const m=i.outputs;let C;if(g&amp;&amp;null!==m&amp;&amp;(C=m[r])){const v=C.length;if(v)for(let S=0;S&lt;v;S+=2){const Le=t[C[S]][C[S+1]].subscribe(s),He=p.length;p.push(s,Le),u&amp;&amp;u.push(r,i.index,He,-(He+1))}}}function BC(n,t,e,i){try{return!1!==e(i)}catch(r){return qb(n,r),!1}}function pp(n,t,e,i,r){return function s(o){if(o===Function)return i;const a=2&amp;n.flags?pn(n.index,t):t;0==(32&amp;t[2])&amp;&amp;Kf(a);let l=BC(t,0,i,o),c=s.__ngNextListenerFn__;for(;c;)l=BC(t,0,c,o)&amp;&amp;l,c=c.__ngNextListenerFn__;return r&amp;&amp;!1===l&amp;&amp;(o.preventDefault(),o.returnValue=!1),l}}function T(n=1){return function(n){return(te.lFrame.contextLView=function(n,t){for(;n&gt;0;)t=t[15],n--;return t}(n,te.lFrame.contextLView))[8]}(n)}function QP(n,t){let e=null;const i=function(n){const t=n.attrs;if(null!=t){const e=t.indexOf(5);if(0==(1&amp;e))return t[e+1]}return null}(n);for(let r=0;r&lt;t.length;r++){const s=t[r];if(&quot;*&quot;!==s){if(null===i?mb(n,s,!0):eR(i,s))return r}else e=r}return e}function ri(n){const t=x()[16][6];if(!t.projection){const i=t.projection=Sr(n?n.length:1,null),r=i.slice();let s=t.child;for(;null!==s;){const o=n?QP(s,n):0;null!==o&amp;&amp;(r[o]?r[o].projectionNext=s:i[o]=s,r[o]=s),s=s.next}}}function ht(n,t=0,e){const i=x(),r=Ae(),s=fo(r,20+n,16,null,e||null);null===s.projection&amp;&amp;(s.projection=t),Yh(),64!=(64&amp;s.flags)&amp;&amp;function(n,t,e){db(t[11],0,t,e,tb(n,e,t),sb(e.parent||t[6],e,t))}(r,i,s)}function vn(n,t,e){return si(n,&quot;&quot;,t,&quot;&quot;,e),vn}function si(n,t,e,i,r){const s=x(),o=Co(s,t,e,i);return o!==re&amp;&amp;yn(Ae(),tt(),s,n,o,s[11],r,!1),si}function KC(n,t,e,i,r){const s=n[e+1],o=null===t;let a=i?ti(s):Qi(s),l=!1;for(;0!==a&amp;&amp;(!1===l||o);){const u=n[a+1];XP(n[a],t)&amp;&amp;(l=!0,n[a+1]=i?Nf(u):Of(u)),a=i?ti(u):Qi(u)}l&amp;&amp;(n[e+1]=i?Of(s):Nf(s))}function XP(n,t){return null===n||null==t||(Array.isArray(n)?n[1]:n)===t||!(!Array.isArray(n)||&quot;string&quot;!=typeof t)&amp;&amp;ro(n,t)&gt;=0}function xo(n,t,e){return oi(n,t,e,!1),xo}function Me(n,t){return oi(n,t,null,!0),Me}function oi(n,t,e,i){const r=x(),s=Ae(),o=Ki(2);s.firstUpdatePass&amp;&amp;function(n,t,e,i){const r=n.data;if(null===r[e+1]){const s=r[Qt()],o=function(n,t){return t&gt;=n.expandoStartIndex}(n,e);(function(n,t){return 0!=(n.flags&amp;(t?16:32))})(s,i)&amp;&amp;null===t&amp;&amp;!o&amp;&amp;(t=!1),t=function(n,t,e,i){const r=Qh(n);let s=i?t.residualClasses:t.residualStyles;if(null===r)0===(i?t.classBindings:t.styleBindings)&amp;&amp;(e=nl(e=gp(null,n,t,e,i),t.attrs,i),s=null);else{const o=t.directiveStylingLast;if(-1===o||n[o]!==r)if(e=gp(r,n,t,e,i),null===s){let l=function(n,t,e){const i=e?t.classBindings:t.styleBindings;if(0!==Qi(i))return n[ti(i)]}(n,t,i);void 0!==l&amp;&amp;Array.isArray(l)&amp;&amp;(l=gp(null,n,t,l[1],i),l=nl(l,t.attrs,i),function(n,t,e,i){n[ti(e?t.classBindings:t.styleBindings)]=i}(n,t,i,l))}else s=function(n,t,e){let i;const r=t.directiveEnd;for(let s=1+t.directiveStylingLast;s&lt;r;s++)i=nl(i,n[s].hostAttrs,e);return nl(i,t.attrs,e)}(n,t,i)}return void 0!==s&amp;&amp;(i?t.residualClasses=s:t.residualStyles=s),e}(r,s,t,i),function(n,t,e,i,r,s){let o=s?t.classBindings:t.styleBindings,a=ti(o),l=Qi(o);n[i]=e;let u,c=!1;if(Array.isArray(e)){const f=e;u=f[1],(null===u||ro(f,u)&gt;0)&amp;&amp;(c=!0)}else u=e;if(r)if(0!==l){const p=ti(n[a+1]);n[i+1]=nu(p,a),0!==p&amp;&amp;(n[p+1]=Ff(n[p+1],i)),n[a+1]=function(n,t){return 131071&amp;n|t&lt;&lt;17}(n[a+1],i)}else n[i+1]=nu(a,0),0!==a&amp;&amp;(n[a+1]=Ff(n[a+1],i)),a=i;else n[i+1]=nu(l,0),0===a?a=i:n[l+1]=Ff(n[l+1],i),l=i;c&amp;&amp;(n[i+1]=Of(n[i+1])),KC(n,u,i,!0),KC(n,u,i,!1),function(n,t,e,i,r){const s=r?n.residualClasses:n.residualStyles;null!=s&amp;&amp;&quot;string&quot;==typeof t&amp;&amp;ro(s,t)&gt;=0&amp;&amp;(e[i+1]=Nf(e[i+1]))}(t,u,n,i,s),o=nu(a,l),s?t.classBindings=o:t.styleBindings=o}(r,s,t,e,o,i)}}(s,n,o,i),t!==re&amp;&amp;Lt(r,o,t)&amp;&amp;function(n,t,e,i,r,s,o,a){if(!(3&amp;t.type))return;const l=n.data,c=l[a+1];hu(function(n){return 1==(1&amp;n)}(c)?oD(l,t,e,r,Qi(c),o):void 0)||(hu(s)||function(n){return 2==(2&amp;n)}(c)&amp;&amp;(s=oD(l,null,e,r,a,o)),function(n,t,e,i,r){const s=et(n);if(t)r?s?n.addClass(e,i):e.classList.add(i):s?n.removeClass(e,i):e.classList.remove(i);else{let o=-1===i.indexOf(&quot;-&quot;)?void 0:_n.DashCase;if(null==r)s?n.removeStyle(e,i,o):e.style.removeProperty(i);else{const a=&quot;string&quot;==typeof r&amp;&amp;r.endsWith(&quot;!important&quot;);a&amp;&amp;(r=r.slice(0,-10),o|=_n.Important),s?n.setStyle(e,i,r,o):e.style.setProperty(i,r,a?&quot;important&quot;:&quot;&quot;)}}}(i,o,Ac(Qt(),e),r,s))}(s,s.data[Qt()],r,r[11],n,r[o+1]=function(n,t){return null==n||(&quot;string&quot;==typeof t?n+=t:&quot;object&quot;==typeof n&amp;&amp;(n=ge(mn(n)))),n}(t,e),i,o)}function gp(n,t,e,i,r){let s=null;const o=e.directiveEnd;let a=e.directiveStylingLast;for(-1===a?a=e.directiveStart:a++;a&lt;o&amp;&amp;(s=t[a],i=nl(i,s.hostAttrs,r),s!==n);)a++;return null!==n&amp;&amp;(e.directiveStylingLast=a),i}function nl(n,t,e){const i=e?1:2;let r=-1;if(null!==t)for(let s=0;s&lt;t.length;s++){const o=t[s];&quot;number&quot;==typeof o?r=o:r===i&amp;&amp;(Array.isArray(n)||(n=void 0===n?[]:[&quot;&quot;,n]),gn(n,o,!!e||t[++s]))}return void 0===n?null:n}function oD(n,t,e,i,r,s){const o=null===t;let a;for(;r&gt;0;){const l=n[r],c=Array.isArray(l),u=c?l[1]:l,f=null===u;let p=e[r+1];p===re&amp;&amp;(p=f?Be:void 0);let g=f?af(p,i):u===i?p:void 0;if(c&amp;&amp;!hu(g)&amp;&amp;(g=af(l,i)),hu(g)&amp;&amp;(a=g,o))return a;const m=n[r+1];r=o?ti(m):Qi(m)}if(null!==t){let l=s?t.residualClasses:t.residualStyles;null!=l&amp;&amp;(a=af(l,i))}return a}function hu(n){return void 0!==n}function b(n,t=&quot;&quot;){const e=x(),i=Ae(),r=n+20,s=i.firstCreatePass?fo(i,r,1,t,null):i.data[r],o=e[r]=function(n,t){return et(n)?n.createText(t):n.createTextNode(t)}(e[11],t);eu(i,e,o,s),wi(s,!1)}function nt(n){return de(&quot;&quot;,n,&quot;&quot;),nt}function de(n,t,e){const i=x(),r=Co(i,n,t,e);return r!==re&amp;&amp;Ji(i,Qt(),r),de}function er(n,t,e,i,r){const s=x(),o=function(n,t,e,i,r,s){const a=us(n,Ei(),e,r);return Ki(2),a?t+le(e)+i+le(r)+s:re}(s,n,t,e,i,r);return o!==re&amp;&amp;Ji(s,Qt(),o),er}function Ar(n,t,e){const i=x();return Lt(i,Zs(),t)&amp;&amp;yn(Ae(),tt(),i,n,t,i[11],e,!0),Ar}function mp(n,t,e){const i=x();if(Lt(i,Zs(),t)){const s=Ae(),o=tt();yn(s,o,i,n,t,Wb(Qh(s.data),o,i),e,!0)}return mp}const ds=void 0;var OO=[&quot;en&quot;,[[&quot;a&quot;,&quot;p&quot;],[&quot;AM&quot;,&quot;PM&quot;],ds],[[&quot;AM&quot;,&quot;PM&quot;],ds,ds],[[&quot;S&quot;,&quot;M&quot;,&quot;T&quot;,&quot;W&quot;,&quot;T&quot;,&quot;F&quot;,&quot;S&quot;],[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;],[&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;],[&quot;Su&quot;,&quot;Mo&quot;,&quot;Tu&quot;,&quot;We&quot;,&quot;Th&quot;,&quot;Fr&quot;,&quot;Sa&quot;]],ds,[[&quot;J&quot;,&quot;F&quot;,&quot;M&quot;,&quot;A&quot;,&quot;M&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;S&quot;,&quot;O&quot;,&quot;N&quot;,&quot;D&quot;],[&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;],[&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;]],ds,[[&quot;B&quot;,&quot;A&quot;],[&quot;BC&quot;,&quot;AD&quot;],[&quot;Before Christ&quot;,&quot;Anno Domini&quot;]],0,[6,0],[&quot;M/d/yy&quot;,&quot;MMM d, y&quot;,&quot;MMMM d, y&quot;,&quot;EEEE, MMMM d, y&quot;],[&quot;h:mm a&quot;,&quot;h:mm:ss a&quot;,&quot;h:mm:ss a z&quot;,&quot;h:mm:ss a zzzz&quot;],[&quot;{1}, {0}&quot;,ds,&quot;{1} &#39;at&#39; {0}&quot;,ds],[&quot;.&quot;,&quot;,&quot;,&quot;;&quot;,&quot;%&quot;,&quot;+&quot;,&quot;-&quot;,&quot;E&quot;,&quot;\xd7&quot;,&quot;\u2030&quot;,&quot;\u221e&quot;,&quot;NaN&quot;,&quot;:&quot;],[&quot;#,##0.###&quot;,&quot;#,##0%&quot;,&quot;\xa4#,##0.00&quot;,&quot;#E0&quot;],&quot;USD&quot;,&quot;$&quot;,&quot;US Dollar&quot;,{},&quot;ltr&quot;,function(n){const t=Math.floor(Math.abs(n)),e=n.toString().replace(/^[^.]*\.?/,&quot;&quot;).length;return 1===t&amp;&amp;0===e?1:5}];let Ro={};function Jt(n){const t=function(n){return n.toLowerCase().replace(/_/g,&quot;-&quot;)}(n);let e=SD(t);if(e)return e;const i=t.split(&quot;-&quot;)[0];if(e=SD(i),e)return e;if(&quot;en&quot;===i)return OO;throw new Error(`Missing locale data for the locale &quot;${n}&quot;.`)}function SD(n){return n in Ro||(Ro[n]=Ne.ng&amp;&amp;Ne.ng.common&amp;&amp;Ne.ng.common.locales&amp;&amp;Ne.ng.common.locales[n]),Ro[n]}var V=(()=&gt;((V=V||{})[V.LocaleId=0]=&quot;LocaleId&quot;,V[V.DayPeriodsFormat=1]=&quot;DayPeriodsFormat&quot;,V[V.DayPeriodsStandalone=2]=&quot;DayPeriodsStandalone&quot;,V[V.DaysFormat=3]=&quot;DaysFormat&quot;,V[V.DaysStandalone=4]=&quot;DaysStandalone&quot;,V[V.MonthsFormat=5]=&quot;MonthsFormat&quot;,V[V.MonthsStandalone=6]=&quot;MonthsStandalone&quot;,V[V.Eras=7]=&quot;Eras&quot;,V[V.FirstDayOfWeek=8]=&quot;FirstDayOfWeek&quot;,V[V.WeekendRange=9]=&quot;WeekendRange&quot;,V[V.DateFormat=10]=&quot;DateFormat&quot;,V[V.TimeFormat=11]=&quot;TimeFormat&quot;,V[V.DateTimeFormat=12]=&quot;DateTimeFormat&quot;,V[V.NumberSymbols=13]=&quot;NumberSymbols&quot;,V[V.NumberFormats=14]=&quot;NumberFormats&quot;,V[V.CurrencyCode=15]=&quot;CurrencyCode&quot;,V[V.CurrencySymbol=16]=&quot;CurrencySymbol&quot;,V[V.CurrencyName=17]=&quot;CurrencyName&quot;,V[V.Currencies=18]=&quot;Currencies&quot;,V[V.Directionality=19]=&quot;Directionality&quot;,V[V.PluralCase=20]=&quot;PluralCase&quot;,V[V.ExtraData=21]=&quot;ExtraData&quot;,V))();const fu=&quot;en-US&quot;;let kD=fu;function _p(n){hn(n,&quot;Expected localeId to be defined&quot;),&quot;string&quot;==typeof n&amp;&amp;(kD=n.toLowerCase().replace(/_/g,&quot;-&quot;))}function bp(n,t,e,i,r){if(n=H(n),Array.isArray(n))for(let s=0;s&lt;n.length;s++)bp(n[s],t,e,i,r);else{const s=Ae(),o=x();let a=yo(n)?n:H(n.provide),l=Jb(n);const c=_t(),u=1048575&amp;c.providerIndexes,f=c.directiveStart,p=c.providerIndexes&gt;&gt;20;if(yo(n)||!n.multi){const g=new Ta(l,r,_),m=Dp(a,t,r?u:u+p,f);-1===m?(Bc(xa(c,o),s,a),Cp(s,n,t.length),t.push(a),c.directiveStart++,c.directiveEnd++,r&amp;&amp;(c.providerIndexes+=1048576),e.push(g),o.push(g)):(e[m]=g,o[m]=g)}else{const g=Dp(a,t,u+p,f),m=Dp(a,t,u,u+p),C=g&gt;=0&amp;&amp;e[g],v=m&gt;=0&amp;&amp;e[m];if(r&amp;&amp;!v||!r&amp;&amp;!C){Bc(xa(c,o),s,a);const S=function(n,t,e,i,r){const s=new Ta(n,e,_);return s.multi=[],s.index=t,s.componentProviders=0,QD(s,r,i&amp;&amp;!e),s}(r?xF:IF,e.length,r,i,l);!r&amp;&amp;v&amp;&amp;(e[m].providerFactory=S),Cp(s,n,t.length,0),t.push(a),c.directiveStart++,c.directiveEnd++,r&amp;&amp;(c.providerIndexes+=1048576),e.push(S),o.push(S)}else Cp(s,n,g&gt;-1?g:m,QD(e[r?m:g],l,!r&amp;&amp;i));!r&amp;&amp;i&amp;&amp;v&amp;&amp;e[m].componentProviders++}}}function Cp(n,t,e,i){const r=yo(t);if(r||function(n){return!!n.useClass}(t)){const o=(t.useClass||t).prototype.ngOnDestroy;if(o){const a=n.destroyHooks||(n.destroyHooks=[]);if(!r&amp;&amp;t.multi){const l=a.indexOf(e);-1===l?a.push(e,[i,o]):a[l+1].push(i,o)}else a.push(e,o)}}}function QD(n,t,e){return e&amp;&amp;n.componentProviders++,n.multi.push(t)-1}function Dp(n,t,e,i){for(let r=e;r&lt;i;r++)if(t[r]===n)return r;return-1}function IF(n,t,e,i){return wp(this.multi,[])}function xF(n,t,e,i){const r=this.multi;let s;if(this.providerFactory){const o=this.providerFactory.componentProviders,a=Ra(e,e[1],this.providerFactory.index,i);s=a.slice(0,o),wp(r,s);for(let l=o;l&lt;a.length;l++)s.push(a[l])}else s=[],wp(r,s);return s}function wp(n,t){for(let e=0;e&lt;n.length;e++)t.push((0,n[e])());return t}function ce(n,t=[]){return e=&gt;{e.providersResolver=(i,r)=&gt;function(n,t,e){const i=Ae();if(i.firstCreatePass){const r=Jn(n);bp(e,i.data,i.blueprint,r,!0),bp(t,i.data,i.blueprint,r,!1)}}(i,r?r(n):n,t)}}class ZD{}const XD=&quot;ngComponent&quot;;class OF{resolveComponentFactory(t){throw function(n){const t=Error(`No component factory found for ${ge(n)}. Did you add it to @NgModule.entryComponents?`);return t[XD]=n,t}(t)}}let tr=(()=&gt;{class n{}return n.NULL=new OF,n})();function yu(...n){}function Oo(n,t){return new X(In(n,t))}const VF=function(){return Oo(_t(),x())};let X=(()=&gt;{class n{constructor(e){this.nativeElement=e}}return n.__NG_ELEMENT_ID__=VF,n})();function ew(n){return n instanceof X?n.nativeElement:n}class hs{}let nr=(()=&gt;{class n{}return n.__NG_ELEMENT_ID__=()=&gt;jF(),n})();const jF=function(){const n=x(),e=pn(_t().index,n);return function(n){return n[11]}(Di(e)?e:n)};let Sp=(()=&gt;{class n{}return n.\u0275prov=P({token:n,providedIn:&quot;root&quot;,factory:()=&gt;null}),n})();class Tr{constructor(t){this.full=t,this.major=t.split(&quot;.&quot;)[0],this.minor=t.split(&quot;.&quot;)[1],this.patch=t.split(&quot;.&quot;).slice(2).join(&quot;.&quot;)}}const tw=new Tr(&quot;12.2.15&quot;);class nw{constructor(){}supports(t){return Za(t)}create(t){return new zF(t)}}const HF=(n,t)=&gt;t;class zF{constructor(t){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=t||HF}forEachItem(t){let e;for(e=this._itHead;null!==e;e=e._next)t(e)}forEachOperation(t){let e=this._itHead,i=this._removalsHead,r=0,s=null;for(;e||i;){const o=!i||e&amp;&amp;e.currentIndex&lt;rw(i,r,s)?e:i,a=rw(o,r,s),l=o.currentIndex;if(o===i)r--,i=i._nextRemoved;else if(e=e._next,null==o.previousIndex)r++;else{s||(s=[]);const c=a-r,u=l-r;if(c!=u){for(let p=0;p&lt;c;p++){const g=p&lt;s.length?s[p]:s[p]=0,m=g+p;u&lt;=m&amp;&amp;m&lt;c&amp;&amp;(s[p]=g+1)}s[o.previousIndex]=u-c}}a!==l&amp;&amp;t(o,a,l)}}forEachPreviousItem(t){let e;for(e=this._previousItHead;null!==e;e=e._nextPrevious)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachMovedItem(t){let e;for(e=this._movesHead;null!==e;e=e._nextMoved)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}forEachIdentityChange(t){let e;for(e=this._identityChangesHead;null!==e;e=e._nextIdentityChange)t(e)}diff(t){if(null==t&amp;&amp;(t=[]),!Za(t))throw new Error(`Error trying to diff &#39;${ge(t)}&#39;. Only arrays and iterables are allowed`);return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let r,s,o,e=this._itHead,i=!1;if(Array.isArray(t)){this.length=t.length;for(let a=0;a&lt;this.length;a++)s=t[a],o=this._trackByFn(a,s),null!==e&amp;&amp;Object.is(e.trackById,o)?(i&amp;&amp;(e=this._verifyReinsertion(e,s,o,a)),Object.is(e.item,s)||this._addIdentityChange(e,s)):(e=this._mismatch(e,s,o,a),i=!0),e=e._next}else r=0,function(n,t){if(Array.isArray(n))for(let e=0;e&lt;n.length;e++)t(n[e]);else{const e=n[vo()]();let i;for(;!(i=e.next()).done;)t(i.value)}}(t,a=&gt;{o=this._trackByFn(r,a),null!==e&amp;&amp;Object.is(e.trackById,o)?(i&amp;&amp;(e=this._verifyReinsertion(e,a,o,r)),Object.is(e.item,a)||this._addIdentityChange(e,a)):(e=this._mismatch(e,a,o,r),i=!0),e=e._next,r++}),this.length=r;return this._truncate(e),this.collection=t,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let t;for(t=this._previousItHead=this._itHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._additionsHead;null!==t;t=t._nextAdded)t.previousIndex=t.currentIndex;for(this._additionsHead=this._additionsTail=null,t=this._movesHead;null!==t;t=t._nextMoved)t.previousIndex=t.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(t,e,i,r){let s;return null===t?s=this._itTail:(s=t._prev,this._remove(t)),null!==(t=null===this._unlinkedRecords?null:this._unlinkedRecords.get(i,null))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._reinsertAfter(t,s,r)):null!==(t=null===this._linkedRecords?null:this._linkedRecords.get(i,r))?(Object.is(t.item,e)||this._addIdentityChange(t,e),this._moveAfter(t,s,r)):t=this._addAfter(new $F(e,i),s,r),t}_verifyReinsertion(t,e,i,r){let s=null===this._unlinkedRecords?null:this._unlinkedRecords.get(i,null);return null!==s?t=this._reinsertAfter(s,t._prev,r):t.currentIndex!=r&amp;&amp;(t.currentIndex=r,this._addToMoves(t,r)),t}_truncate(t){for(;null!==t;){const e=t._next;this._addToRemovals(this._unlink(t)),t=e}null!==this._unlinkedRecords&amp;&amp;this._unlinkedRecords.clear(),null!==this._additionsTail&amp;&amp;(this._additionsTail._nextAdded=null),null!==this._movesTail&amp;&amp;(this._movesTail._nextMoved=null),null!==this._itTail&amp;&amp;(this._itTail._next=null),null!==this._removalsTail&amp;&amp;(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&amp;&amp;(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(t,e,i){null!==this._unlinkedRecords&amp;&amp;this._unlinkedRecords.remove(t);const r=t._prevRemoved,s=t._nextRemoved;return null===r?this._removalsHead=s:r._nextRemoved=s,null===s?this._removalsTail=r:s._prevRemoved=r,this._insertAfter(t,e,i),this._addToMoves(t,i),t}_moveAfter(t,e,i){return this._unlink(t),this._insertAfter(t,e,i),this._addToMoves(t,i),t}_addAfter(t,e,i){return this._insertAfter(t,e,i),this._additionsTail=null===this._additionsTail?this._additionsHead=t:this._additionsTail._nextAdded=t,t}_insertAfter(t,e,i){const r=null===e?this._itHead:e._next;return t._next=r,t._prev=e,null===r?this._itTail=t:r._prev=t,null===e?this._itHead=t:e._next=t,null===this._linkedRecords&amp;&amp;(this._linkedRecords=new iw),this._linkedRecords.put(t),t.currentIndex=i,t}_remove(t){return this._addToRemovals(this._unlink(t))}_unlink(t){null!==this._linkedRecords&amp;&amp;this._linkedRecords.remove(t);const e=t._prev,i=t._next;return null===e?this._itHead=i:e._next=i,null===i?this._itTail=e:i._prev=e,t}_addToMoves(t,e){return t.previousIndex===e||(this._movesTail=null===this._movesTail?this._movesHead=t:this._movesTail._nextMoved=t),t}_addToRemovals(t){return null===this._unlinkedRecords&amp;&amp;(this._unlinkedRecords=new iw),this._unlinkedRecords.put(t),t.currentIndex=null,t._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=t,t._prevRemoved=null):(t._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=t),t}_addIdentityChange(t,e){return t.item=e,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=t:this._identityChangesTail._nextIdentityChange=t,t}}class $F{constructor(t,e){this.item=t,this.trackById=e,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class GF{constructor(){this._head=null,this._tail=null}add(t){null===this._head?(this._head=this._tail=t,t._nextDup=null,t._prevDup=null):(this._tail._nextDup=t,t._prevDup=this._tail,t._nextDup=null,this._tail=t)}get(t,e){let i;for(i=this._head;null!==i;i=i._nextDup)if((null===e||e&lt;=i.currentIndex)&amp;&amp;Object.is(i.trackById,t))return i;return null}remove(t){const e=t._prevDup,i=t._nextDup;return null===e?this._head=i:e._nextDup=i,null===i?this._tail=e:i._prevDup=e,null===this._head}}class iw{constructor(){this.map=new Map}put(t){const e=t.trackById;let i=this.map.get(e);i||(i=new GF,this.map.set(e,i)),i.add(t)}get(t,e){const r=this.map.get(t);return r?r.get(t,e):null}remove(t){const e=t.trackById;return this.map.get(e).remove(t)&amp;&amp;this.map.delete(e),t}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function rw(n,t,e){const i=n.previousIndex;if(null===i)return i;let r=0;return e&amp;&amp;i&lt;e.length&amp;&amp;(r=e[i]),i+t+r}class sw{constructor(){}supports(t){return t instanceof Map||ap(t)}create(){return new WF}}class WF{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(t){let e;for(e=this._mapHead;null!==e;e=e._next)t(e)}forEachPreviousItem(t){let e;for(e=this._previousMapHead;null!==e;e=e._nextPrevious)t(e)}forEachChangedItem(t){let e;for(e=this._changesHead;null!==e;e=e._nextChanged)t(e)}forEachAddedItem(t){let e;for(e=this._additionsHead;null!==e;e=e._nextAdded)t(e)}forEachRemovedItem(t){let e;for(e=this._removalsHead;null!==e;e=e._nextRemoved)t(e)}diff(t){if(t){if(!(t instanceof Map||ap(t)))throw new Error(`Error trying to diff &#39;${ge(t)}&#39;. Only maps and objects are allowed`)}else t=new Map;return this.check(t)?this:null}onDestroy(){}check(t){this._reset();let e=this._mapHead;if(this._appendAfter=null,this._forEach(t,(i,r)=&gt;{if(e&amp;&amp;e.key===r)this._maybeAddToChanges(e,i),this._appendAfter=e,e=e._next;else{const s=this._getOrCreateRecordForKey(r,i);e=this._insertBeforeOrAppend(e,s)}}),e){e._prev&amp;&amp;(e._prev._next=null),this._removalsHead=e;for(let i=e;null!==i;i=i._nextRemoved)i===this._mapHead&amp;&amp;(this._mapHead=null),this._records.delete(i.key),i._nextRemoved=i._next,i.previousValue=i.currentValue,i.currentValue=null,i._prev=null,i._next=null}return this._changesTail&amp;&amp;(this._changesTail._nextChanged=null),this._additionsTail&amp;&amp;(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(t,e){if(t){const i=t._prev;return e._next=t,e._prev=i,t._prev=e,i&amp;&amp;(i._next=e),t===this._mapHead&amp;&amp;(this._mapHead=e),this._appendAfter=t,t}return this._appendAfter?(this._appendAfter._next=e,e._prev=this._appendAfter):this._mapHead=e,this._appendAfter=e,null}_getOrCreateRecordForKey(t,e){if(this._records.has(t)){const r=this._records.get(t);this._maybeAddToChanges(r,e);const s=r._prev,o=r._next;return s&amp;&amp;(s._next=o),o&amp;&amp;(o._prev=s),r._next=null,r._prev=null,r}const i=new qF(t);return this._records.set(t,i),i.currentValue=e,this._addToAdditions(i),i}_reset(){if(this.isDirty){let t;for(this._previousMapHead=this._mapHead,t=this._previousMapHead;null!==t;t=t._next)t._nextPrevious=t._next;for(t=this._changesHead;null!==t;t=t._nextChanged)t.previousValue=t.currentValue;for(t=this._additionsHead;null!=t;t=t._nextAdded)t.previousValue=t.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(t,e){Object.is(e,t.currentValue)||(t.previousValue=t.currentValue,t.currentValue=e,this._addToChanges(t))}_addToAdditions(t){null===this._additionsHead?this._additionsHead=this._additionsTail=t:(this._additionsTail._nextAdded=t,this._additionsTail=t)}_addToChanges(t){null===this._changesHead?this._changesHead=this._changesTail=t:(this._changesTail._nextChanged=t,this._changesTail=t)}_forEach(t,e){t instanceof Map?t.forEach(e):Object.keys(t).forEach(i=&gt;e(t[i],i))}}class qF{constructor(t){this.key=t,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function ow(){return new Fo([new nw])}let Fo=(()=&gt;{class n{constructor(e){this.factories=e}static create(e,i){if(null!=i){const r=i.factories.slice();e=e.concat(r)}return new n(e)}static extend(e){return{provide:n,useFactory:i=&gt;n.create(e,i||ow()),deps:[[n,new Xn,new It]]}}find(e){const i=this.factories.find(r=&gt;r.supports(e));if(null!=i)return i;throw new Error(`Cannot find a differ supporting object &#39;${e}&#39; of type &#39;${function(n){return n.name||typeof n}(e)}&#39;`)}}return n.\u0275prov=P({token:n,providedIn:&quot;root&quot;,factory:ow}),n})();function aw(){return new No([new sw])}let No=(()=&gt;{class n{constructor(e){this.factories=e}static create(e,i){if(i){const r=i.factories.slice();e=e.concat(r)}return new n(e)}static extend(e){return{provide:n,useFactory:i=&gt;n.create(e,i||aw()),deps:[[n,new Xn,new It]]}}find(e){const i=this.factories.find(r=&gt;r.supports(e));if(i)return i;throw new Error(`Cannot find a differ supporting object &#39;${e}&#39;`)}}return n.\u0275prov=P({token:n,providedIn:&quot;root&quot;,factory:aw}),n})();function vu(n,t,e,i,r=!1){for(;null!==e;){const s=t[e.index];if(null!==s&amp;&amp;i.push(dt(s)),Zn(s))for(let a=10;a&lt;s.length;a++){const l=s[a],c=l[1].firstChild;null!==c&amp;&amp;vu(l[1],l,c,i)}const o=e.type;if(8&amp;o)vu(n,t,e.child,i);else if(32&amp;o){const a=wf(e,t);let l;for(;l=a();)i.push(l)}else if(16&amp;o){const a=cb(t,e);if(Array.isArray(a))i.push(...a);else{const l=$a(t[16]);vu(l[1],l,a,i,!0)}}e=r?e.projectionNext:e.next}return i}class al{constructor(t,e){this._lView=t,this._cdRefInjectingView=e,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const t=this._lView,e=t[1];return vu(e,t,e.firstChild,[])}get context(){return this._lView[8]}set context(t){this._lView[8]=t}get destroyed(){return 256==(256&amp;this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const t=this._lView[3];if(Zn(t)){const e=t[8],i=e?e.indexOf(this):-1;i&gt;-1&amp;&amp;(Af(t,i),ss(e,i))}this._attachedToViewContainer=!1}eb(this._lView[1],this._lView)}onDestroy(t){Ob(this._lView[1],this._lView,null,t)}markForCheck(){Kf(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&amp;=-129}reattach(){this._lView[2]|=128}detectChanges(){Zf(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(n,t,e){Ic(!0);try{Zf(n,t,e)}finally{Ic(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error(&quot;This view is already attached directly to the ApplicationRef!&quot;);this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function(n,t){Ga(n,t,t[11],2,null,null)}(this._lView[1],this._lView)}attachToAppRef(t){if(this._attachedToViewContainer)throw new Error(&quot;This view is already attached to a ViewContainer!&quot;);this._appRef=t}}class KF extends al{constructor(t){super(t),this._view=t}detectChanges(){zb(this._view)}checkNoChanges(){!function(n){Ic(!0);try{zb(n)}finally{Ic(!1)}}(this._view)}get context(){return null}}const ZF=function(n){return function(n,t,e){if(kc(n)&amp;&amp;!e){const i=pn(n.index,t);return new al(i,i)}return 47&amp;n.type?new al(t[16],t):null}(_t(),x(),16==(16&amp;n))};let xt=(()=&gt;{class n{}return n.__NG_ELEMENT_ID__=ZF,n})();const eN=[new sw],nN=new Fo([new nw]),iN=new No(eN),sN=function(){return bu(_t(),x())};let bn=(()=&gt;{class n{}return n.__NG_ELEMENT_ID__=sN,n})();const oN=bn,aN=class extends oN{constructor(t,e,i){super(),this._declarationLView=t,this._declarationTContainer=e,this.elementRef=i}createEmbeddedView(t){const e=this._declarationTContainer.tViews,i=Wa(this._declarationLView,e,t,16,null,e.declTNode,null,null,null,null);i[17]=this._declarationLView[this._declarationTContainer.index];const s=this._declarationLView[19];return null!==s&amp;&amp;(i[19]=s.createEmbeddedView(e)),qa(e,i,t),new al(i)}};function bu(n,t){return 4&amp;n.type?new aN(t,n,Oo(n,t)):null}class Pi{}class lw{}const uN=function(){return dw(_t(),x())};let Rt=(()=&gt;{class n{}return n.__NG_ELEMENT_ID__=uN,n})();const hN=Rt,cw=class extends hN{constructor(t,e,i){super(),this._lContainer=t,this._hostTNode=e,this._hostLView=i}get element(){return Oo(this._hostTNode,this._hostLView)}get injector(){return new eo(this._hostTNode,this._hostLView)}get parentInjector(){const t=jc(this._hostTNode,this._hostLView);if(nv(t)){const e=Xs(t,this._hostLView),i=Js(t);return new eo(e[1].data[i+8],e)}return new eo(null,this._hostLView)}clear(){for(;this.length&gt;0;)this.remove(this.length-1)}get(t){const e=uw(this._lContainer);return null!==e&amp;&amp;e[t]||null}get length(){return this._lContainer.length-10}createEmbeddedView(t,e,i){const r=t.createEmbeddedView(e||{});return this.insert(r,i),r}createComponent(t,e,i,r,s){const o=i||this.parentInjector;if(!s&amp;&amp;null==t.ngModule&amp;&amp;o){const l=o.get(Pi,null);l&amp;&amp;(s=l)}const a=t.create(o,r,void 0,s);return this.insert(a.hostView,e),a}insert(t,e){const i=t._lView,r=i[1];if(function(n){return Zn(n[3])}(i)){const u=this.indexOf(t);if(-1!==u)this.detach(u);else{const f=i[3],p=new cw(f,f[6],f[3]);p.detach(p.indexOf(t))}}const s=this._adjustIndex(e),o=this._lContainer;!function(n,t,e,i){const r=10+i,s=e.length;i&gt;0&amp;&amp;(e[r-1][4]=t),i&lt;s-10?(t[4]=e[r],$c(e,10+i,t)):(e.push(t),t[4]=null),t[3]=e;const o=t[17];null!==o&amp;&amp;e!==o&amp;&amp;function(n,t){const e=n[9];t[16]!==t[3][3][16]&amp;&amp;(n[2]=!0),null===e?n[9]=[t]:e.push(t)}(o,t);const a=t[19];null!==a&amp;&amp;a.insertView(n),t[2]|=128}(r,i,o,s);const a=xf(s,o),l=i[11],c=Xc(l,o[7]);return null!==c&amp;&amp;function(n,t,e,i,r,s){i[0]=r,i[6]=t,Ga(n,i,e,1,r,s)}(r,o[6],l,i,c,a),t.attachToViewContainerRef(),$c(kp(o),s,t),t}move(t,e){return this.insert(t,e)}indexOf(t){const e=uw(this._lContainer);return null!==e?e.indexOf(t):-1}remove(t){const e=this._adjustIndex(t,-1),i=Af(this._lContainer,e);i&amp;&amp;(ss(kp(this._lContainer),e),eb(i[1],i))}detach(t){const e=this._adjustIndex(t,-1),i=Af(this._lContainer,e);return i&amp;&amp;null!=ss(kp(this._lContainer),e)?new al(i):null}_adjustIndex(t,e=0){return null==t?this.length+e:t}};function uw(n){return n[8]}function kp(n){return n[8]||(n[8]=[])}function dw(n,t){let e;const i=t[n.index];if(Zn(i))e=i;else{let r;if(8&amp;n.type)r=dt(i);else{const s=t[11];r=s.createComment(&quot;&quot;);const o=In(n,t);cs(s,Xc(s,o),r,function(n,t){return et(n)?n.nextSibling(t):t.nextSibling}(s,o),!1)}t[n.index]=e=Hb(i,t,r,n),ou(t,e)}return new cw(e,n,t)}const Bo={};class xw extends tr{constructor(t){super(),this.ngModule=t}resolveComponentFactory(t){const e=Yt(t);return new Pw(e,this.ngModule)}}function Rw(n){const t=[];for(let e in n)n.hasOwnProperty(e)&amp;&amp;t.push({propName:n[e],templateName:e});return t}const c2=new j(&quot;SCHEDULER_TOKEN&quot;,{providedIn:&quot;root&quot;,factory:()=&gt;Wv});class Pw extends ZD{constructor(t,e){super(),this.componentDef=t,this.ngModule=e,this.componentType=t.type,this.selector=function(n){return n.map(tR).join(&quot;,&quot;)}(t.selectors),this.ngContentSelectors=t.ngContentSelectors?t.ngContentSelectors:[],this.isBoundToModule=!!e}get inputs(){return Rw(this.componentDef.inputs)}get outputs(){return Rw(this.componentDef.outputs)}create(t,e,i,r){const s=(r=r||this.ngModule)?function(n,t){return{get:(e,i,r)=&gt;{const s=n.get(e,Bo,r);return s!==Bo||i===Bo?s:t.get(e,i,r)}}}(t,r.injector):t,o=s.get(hs,jy),a=s.get(Sp,null),l=o.createRenderer(null,this.componentDef),c=this.componentDef.selectors[0][0]||&quot;div&quot;,u=i?function(n,t,e){if(et(n))return n.selectRootElement(t,e===ut.ShadowDom);let i=&quot;string&quot;==typeof t?n.querySelector(t):t;return i.textContent=&quot;&quot;,i}(l,i,this.componentDef.encapsulation):Mf(o.createRenderer(null,this.componentDef),c,function(n){const t=n.toLowerCase();return&quot;svg&quot;===t?Vy:&quot;math&quot;===t?&quot;http://www.w3.org/1998/MathML/&quot;:null}(c)),f=this.componentDef.onPush?576:528,p=function(n,t){return{components:[],scheduler:n||Wv,clean:jR,playerHandler:t||null,flags:0}}(),g=su(0,null,null,1,0,null,null,null,null,null),m=Wa(null,g,p,f,null,null,o,l,a,s);let C,v;xc(m);try{const S=function(n,t,e,i,r,s){const o=e[1];e[20]=n;const l=fo(o,20,2,&quot;#host&quot;,null),c=l.mergedAttrs=t.hostAttrs;null!==c&amp;&amp;(au(l,c,!0),null!==n&amp;&amp;(Nc(r,n,c),null!==l.classes&amp;&amp;Pf(r,n,l.classes),null!==l.styles&amp;&amp;hb(r,n,l.styles)));const u=i.createRenderer(n,t),f=Wa(e,xb(t),null,t.onPush?64:16,e[20],l,i,u,s||null,null);return o.firstCreatePass&amp;&amp;(Bc(xa(l,e),o,t.type),jb(o,l),Bb(l,e.length,1)),ou(e,f),e[20]=f}(u,this.componentDef,m,o,l);if(u)if(i)Nc(l,u,[&quot;ng-version&quot;,tw.full]);else{const{attrs:E,classes:R}=function(n){const t=[],e=[];let i=1,r=2;for(;i&lt;n.length;){let s=n[i];if(&quot;string&quot;==typeof s)2===r?&quot;&quot;!==s&amp;&amp;t.push(s,n[++i]):8===r&amp;&amp;e.push(s);else{if(!ei(r))break;r=s}i++}return{attrs:t,classes:e}}(this.componentDef.selectors[0]);E&amp;&amp;Nc(l,u,E),R&amp;&amp;R.length&gt;0&amp;&amp;Pf(l,u,R.join(&quot; &quot;))}if(v=$h(g,20),void 0!==e){const E=v.projection=[];for(let R=0;R&lt;this.ngContentSelectors.length;R++){const F=e[R];E.push(null!=F?Array.from(F):null)}}C=function(n,t,e,i,r){const s=e[1],o=function(n,t,e){const i=_t();n.firstCreatePass&amp;&amp;(e.providersResolver&amp;&amp;e.providersResolver(e),Ub(n,i,t,po(n,t,1,null),e));const r=Ra(t,n,i.directiveStart,i);Vt(r,t);const s=In(i,t);return s&amp;&amp;Vt(s,t),r}(s,e,t);if(i.components.push(o),n[8]=o,r&amp;&amp;r.forEach(l=&gt;l(o,t)),t.contentQueries){const l=_t();t.contentQueries(1,o,l.directiveStart)}const a=_t();return!s.firstCreatePass||null===t.hostBindings&amp;&amp;null===t.hostAttrs||(wr(a.index),Vb(e[1],a,0,a.directiveStart,a.directiveEnd,t),Lb(t,o)),o}(S,this.componentDef,m,p,[dP]),qa(g,m,null)}finally{Rc()}return new h2(this.componentType,C,Oo(v,m),m,v)}}class h2 extends class{}{constructor(t,e,i,r,s){super(),this.location=i,this._rootLView=r,this._tNode=s,this.instance=e,this.hostView=this.changeDetectorRef=new KF(r),this.componentType=t}get injector(){return new eo(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(t){this.hostView.onDestroy(t)}}const Uo=new Map;class g2 extends Pi{constructor(t,e){super(),this._parent=e,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new xw(this);const i=Mn(t),r=function(n){return n[yT]||null}(t);r&amp;&amp;_p(r),this._bootstrapComponents=Ai(i.bootstrap),this._r3Injector=Zb(t,e,[{provide:Pi,useValue:this},{provide:tr,useValue:this.componentFactoryResolver}],ge(t)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(t)}get(t,e=ke.THROW_IF_NOT_FOUND,i=z.Default){return t===ke||t===Pi||t===mo?this:this._r3Injector.get(t,e,i)}destroy(){const t=this._r3Injector;!t.destroyed&amp;&amp;t.destroy(),this.destroyCbs.forEach(e=&gt;e()),this.destroyCbs=null}onDestroy(t){this.destroyCbs.push(t)}}class jp extends lw{constructor(t){super(),this.moduleType=t,null!==Mn(t)&amp;&amp;function(n){const t=new Set;!function e(i){const r=Mn(i,!0),s=r.id;null!==s&amp;&amp;(function(n,t,e){if(t&amp;&amp;t!==e)throw new Error(`Duplicate module registered for ${n} - ${ge(t)} vs ${ge(t.name)}`)}(s,Uo.get(s),i),Uo.set(s,i));const o=Ai(r.imports);for(const a of o)t.has(a)||(t.add(a),e(a))}(n)}(t)}create(t){return new g2(this.moduleType,t)}}function Vw(n,t,e,i,r,s){return function(n,t,e,i,r,s,o,a){const l=t+e;return function(n,t,e,i,r){const s=us(n,t,e,i);return Lt(n,t+2,r)||s}(n,l,r,s,o)?Ii(n,l+3,a?i.call(a,r,s,o):i(r,s,o)):gl(n,l+3)}(x(),Kt(),n,t,e,i,r,s)}function gl(n,t){const e=n[t];return e===re?void 0:e}function Ut(n,t){const e=Ae();let i;const r=n+20;e.firstCreatePass?(i=function(n,t){if(t)for(let e=t.length-1;e&gt;=0;e--){const i=t[e];if(n===i.name)return i}throw new Zr(&quot;302&quot;,`The pipe &#39;${n}&#39; could not be found!`)}(t,e.pipeRegistry),e.data[r]=i,i.onDestroy&amp;&amp;(e.destroyHooks||(e.destroyHooks=[])).push(r,i.onDestroy)):i=e.data[r];const s=i.factory||(i.factory=ns(i.type)),o=vr(_);try{const a=Lc(!1),l=s();return Lc(a),function(n,t,e,i){e&gt;=n.data.length&amp;&amp;(n.data[e]=null,n.blueprint[e]=null),t[e]=i}(e,x(),r,l),l}finally{vr(o)}}function ir(n,t,e){const i=n+20,r=x(),s=Qs(r,i);return _l(r,ml(r,i)?function(n,t,e,i,r,s){const o=t+e;return Lt(n,o,r)?Ii(n,o+1,s?i.call(s,r):i(r)):gl(n,o+1)}(r,Kt(),t,s.transform,e,s):s.transform(e))}function xr(n,t,e,i){const r=n+20,s=x(),o=Qs(s,r);return _l(s,ml(s,r)?function(n,t,e,i,r,s,o){const a=t+e;return us(n,a,r,s)?Ii(n,a+2,o?i.call(o,r,s):i(r,s)):gl(n,a+2)}(s,Kt(),t,o.transform,e,i,o):o.transform(e,i))}function ml(n,t){return n[1].data[t].pure}function _l(n,t){return ii.isWrapped(t)&amp;&amp;(t=ii.unwrap(t),n[Ei()]=re),t}function Bp(n){return t=&gt;{setTimeout(n,void 0,t)}}const U=class extends ie{constructor(t=!1){super(),this.__isAsync=t}emit(t){super.next(t)}subscribe(t,e,i){var r,s,o;let a=t,l=e||(()=&gt;null),c=i;if(t&amp;&amp;&quot;object&quot;==typeof t){const f=t;a=null===(r=f.next)||void 0===r?void 0:r.bind(f),l=null===(s=f.error)||void 0===s?void 0:s.bind(f),c=null===(o=f.complete)||void 0===o?void 0:o.bind(f)}this.__isAsync&amp;&amp;(l=Bp(l),a&amp;&amp;(a=Bp(a)),c&amp;&amp;(c=Bp(c)));const u=super.subscribe({next:a,error:l,complete:c});return t instanceof ue&amp;&amp;t.add(u),u}};function T2(){return this._results[vo()]()}class Su{constructor(t=!1){this._emitDistinctChangesOnly=t,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const e=vo(),i=Su.prototype;i[e]||(i[e]=T2)}get changes(){return this._changes||(this._changes=new U)}get(t){return this._results[t]}map(t){return this._results.map(t)}filter(t){return this._results.filter(t)}find(t){return this._results.find(t)}reduce(t,e){return this._results.reduce(t,e)}forEach(t){this._results.forEach(t)}some(t){return this._results.some(t)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(t,e){const i=this;i.dirty=!1;const r=xn(t);(this._changesDetected=!function(n,t,e){if(n.length!==t.length)return!1;for(let i=0;i&lt;n.length;i++){let r=n[i],s=t[i];if(e&amp;&amp;(r=e(r),s=e(s)),s!==r)return!1}return!0}(i._results,r,e))&amp;&amp;(i._results=r,i.length=r.length,i.last=r[this.length-1],i.first=r[0])}notifyOnChanges(){this._changes&amp;&amp;(this._changesDetected||!this._emitDistinctChangesOnly)&amp;&amp;this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}Symbol;class Up{constructor(t){this.queryList=t,this.matches=null}clone(){return new Up(this.queryList)}setDirty(){this.queryList.setDirty()}}class Hp{constructor(t=[]){this.queries=t}createEmbeddedView(t){const e=t.queries;if(null!==e){const i=null!==t.contentQueries?t.contentQueries[0]:e.length,r=[];for(let s=0;s&lt;i;s++){const o=e.getByIndex(s);r.push(this.queries[o.indexInDeclarationView].clone())}return new Hp(r)}return null}insertView(t){this.dirtyQueriesWithMatches(t)}detachView(t){this.dirtyQueriesWithMatches(t)}dirtyQueriesWithMatches(t){for(let e=0;e&lt;this.queries.length;e++)null!==qw(t,e).matches&amp;&amp;this.queries[e].setDirty()}}class zw{constructor(t,e,i=null){this.predicate=t,this.flags=e,this.read=i}}class zp{constructor(t=[]){this.queries=t}elementStart(t,e){for(let i=0;i&lt;this.queries.length;i++)this.queries[i].elementStart(t,e)}elementEnd(t){for(let e=0;e&lt;this.queries.length;e++)this.queries[e].elementEnd(t)}embeddedTView(t){let e=null;for(let i=0;i&lt;this.length;i++){const r=null!==e?e.length:0,s=this.getByIndex(i).embeddedTView(t,r);s&amp;&amp;(s.indexInDeclarationView=i,null!==e?e.push(s):e=[s])}return null!==e?new zp(e):null}template(t,e){for(let i=0;i&lt;this.queries.length;i++)this.queries[i].template(t,e)}getByIndex(t){return this.queries[t]}get length(){return this.queries.length}track(t){this.queries.push(t)}}class $p{constructor(t,e=-1){this.metadata=t,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=e}elementStart(t,e){this.isApplyingToNode(e)&amp;&amp;this.matchTNode(t,e)}elementEnd(t){this._declarationNodeIndex===t.index&amp;&amp;(this._appliesToNextNode=!1)}template(t,e){this.elementStart(t,e)}embeddedTView(t,e){return this.isApplyingToNode(t)?(this.crossesNgTemplate=!0,this.addMatch(-t.index,e),new $p(this.metadata)):null}isApplyingToNode(t){if(this._appliesToNextNode&amp;&amp;1!=(1&amp;this.metadata.flags)){const e=this._declarationNodeIndex;let i=t.parent;for(;null!==i&amp;&amp;8&amp;i.type&amp;&amp;i.index!==e;)i=i.parent;return e===(null!==i?i.index:-1)}return this._appliesToNextNode}matchTNode(t,e){const i=this.metadata.predicate;if(Array.isArray(i))for(let r=0;r&lt;i.length;r++){const s=i[r];this.matchTNodeWithReadOption(t,e,R2(e,s)),this.matchTNodeWithReadOption(t,e,Uc(e,t,s,!1,!1))}else i===bn?4&amp;e.type&amp;&amp;this.matchTNodeWithReadOption(t,e,-1):this.matchTNodeWithReadOption(t,e,Uc(e,t,i,!1,!1))}matchTNodeWithReadOption(t,e,i){if(null!==i){const r=this.metadata.read;if(null!==r)if(r===X||r===Rt||r===bn&amp;&amp;4&amp;e.type)this.addMatch(e.index,-2);else{const s=Uc(e,t,r,!1,!1);null!==s&amp;&amp;this.addMatch(e.index,s)}else this.addMatch(e.index,i)}}addMatch(t,e){null===this.matches?this.matches=[t,e]:this.matches.push(t,e)}}function R2(n,t){const e=n.localNames;if(null!==e)for(let i=0;i&lt;e.length;i+=2)if(e[i]===t)return e[i+1];return null}function O2(n,t,e,i){return-1===e?function(n,t){return 11&amp;n.type?Oo(n,t):4&amp;n.type?bu(n,t):null}(t,n):-2===e?function(n,t,e){return e===X?Oo(t,n):e===bn?bu(t,n):e===Rt?dw(t,n):void 0}(n,t,i):Ra(n,n[1],e,t)}function $w(n,t,e,i){const r=t[19].queries[i];if(null===r.matches){const s=n.data,o=e.matches,a=[];for(let l=0;l&lt;o.length;l+=2){const c=o[l];a.push(c&lt;0?null:O2(t,s[c],o[l+1],e.metadata.read))}r.matches=a}return r.matches}function Gp(n,t,e,i){const r=n.queries.getByIndex(e),s=r.matches;if(null!==s){const o=$w(n,t,r,e);for(let a=0;a&lt;s.length;a+=2){const l=s[a];if(l&gt;0)i.push(o[a/2]);else{const c=s[a+1],u=t[-l];for(let f=10;f&lt;u.length;f++){const p=u[f];p[17]===p[3]&amp;&amp;Gp(p[1],p,c,i)}if(null!==u[9]){const f=u[9];for(let p=0;p&lt;f.length;p++){const g=f[p];Gp(g[1],g,c,i)}}}}}return i}function Pe(n){const t=x(),e=Ae(),i=Wy();Zh(i+1);const r=qw(e,i);if(n.dirty&amp;&amp;By(t)===(2==(2&amp;r.metadata.flags))){if(null===r.matches)n.reset([]);else{const s=r.crossesNgTemplate?Gp(e,t,i,[]):$w(e,t,r,i);n.reset(s,ew),n.notifyOnChanges()}return!0}return!1}function Pt(n,t,e){const i=Ae();i.firstCreatePass&amp;&amp;(Ww(i,new zw(n,t,e),-1),2==(2&amp;t)&amp;&amp;(i.staticViewQueries=!0)),Gw(i,x(),t)}function Xt(n,t,e,i){const r=Ae();if(r.firstCreatePass){const s=_t();Ww(r,new zw(t,e,i),s.index),function(n,t){const e=n.contentQueries||(n.contentQueries=[]);t!==(e.length?e[e.length-1]:-1)&amp;&amp;e.push(n.queries.length-1,t)}(r,n),2==(2&amp;e)&amp;&amp;(r.staticContentQueries=!0)}Gw(r,x(),e)}function Oe(){return function(n,t){return n[19].queries[t].queryList}(x(),Wy())}function Gw(n,t,e){const i=new Su(4==(4&amp;e));Ob(n,t,i,i.destroy),null===t[19]&amp;&amp;(t[19]=new Hp),t[19].queries.push(new Up(i))}function Ww(n,t,e){null===n.queries&amp;&amp;(n.queries=new zp),n.queries.track(new $p(t,e))}function qw(n,t){return n.queries.getByIndex(t)}function Nn(n,t){return bu(n,t)}const Vn=dv(&quot;Input&quot;,n=&gt;({bindingPropertyName:n})),Au=dv(&quot;Output&quot;,n=&gt;({bindingPropertyName:n})),zo=new j(&quot;Application Initializer&quot;);let $o=(()=&gt;{class n{constructor(e){this.appInits=e,this.resolve=yu,this.reject=yu,this.initialized=!1,this.done=!1,this.donePromise=new Promise((i,r)=&gt;{this.resolve=i,this.reject=r})}runInitializers(){if(this.initialized)return;const e=[],i=()=&gt;{this.done=!0,this.resolve()};if(this.appInits)for(let r=0;r&lt;this.appInits.length;r++){const s=this.appInits[r]();if(tl(s))e.push(s);else if(du(s)){const o=new Promise((a,l)=&gt;{s.subscribe({complete:a,error:l})});e.push(o)}}Promise.all(e).then(()=&gt;{i()}).catch(r=&gt;{this.reject(r)}),0===e.length&amp;&amp;i(),this.initialized=!0}}return n.\u0275fac=function(e){return new(e||n)(D(zo,8))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const vl=new j(&quot;AppId&quot;),uV={provide:vl,useFactory:function(){return`${Zp()}${Zp()}${Zp()}`},deps:[]};function Zp(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const dE=new j(&quot;Platform Initializer&quot;),Rr=new j(&quot;Platform ID&quot;),hE=new j(&quot;appBootstrapListener&quot;);let Tu=(()=&gt;{class n{log(e){console.log(e)}warn(e){console.warn(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const rr=new j(&quot;LocaleId&quot;),fE=new j(&quot;DefaultCurrencyCode&quot;);class hV{constructor(t,e){this.ngModuleFactory=t,this.componentFactories=e}}const Jp=function(n){return new jp(n)},fV=Jp,pV=function(n){return Promise.resolve(Jp(n))},pE=function(n){const t=Jp(n),i=Ai(Mn(n).declarations).reduce((r,s)=&gt;{const o=Yt(s);return o&amp;&amp;r.push(new Pw(o)),r},[]);return new hV(t,i)},gV=pE,mV=function(n){return Promise.resolve(pE(n))};let gs=(()=&gt;{class n{constructor(){this.compileModuleSync=fV,this.compileModuleAsync=pV,this.compileModuleAndAllComponentsSync=gV,this.compileModuleAndAllComponentsAsync=mV}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const vV=(()=&gt;Promise.resolve(0))();function Xp(n){&quot;undefined&quot;==typeof Zone?vV.then(()=&gt;{n&amp;&amp;n.apply(null,null)}):Zone.current.scheduleMicroTask(&quot;scheduleMicrotask&quot;,n)}class Y{constructor({enableLongStackTrace:t=!1,shouldCoalesceEventChangeDetection:e=!1,shouldCoalesceRunChangeDetection:i=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new U(!1),this.onMicrotaskEmpty=new U(!1),this.onStable=new U(!1),this.onError=new U(!1),&quot;undefined&quot;==typeof Zone)throw new Error(&quot;In this configuration Angular requires Zone.js&quot;);Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&amp;&amp;(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),t&amp;&amp;Zone.longStackTraceZoneSpec&amp;&amp;(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!i&amp;&amp;e,r.shouldCoalesceRunChangeDetection=i,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function(){let n=Ne.requestAnimationFrame,t=Ne.cancelAnimationFrame;if(&quot;undefined&quot;!=typeof Zone&amp;&amp;n&amp;&amp;t){const e=n[Zone.__symbol__(&quot;OriginalDelegate&quot;)];e&amp;&amp;(n=e);const i=t[Zone.__symbol__(&quot;OriginalDelegate&quot;)];i&amp;&amp;(t=i)}return{nativeRequestAnimationFrame:n,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(n){const t=()=&gt;{!function(n){n.isCheckStableRunning||-1!==n.lastRequestAnimationFrameId||(n.lastRequestAnimationFrameId=n.nativeRequestAnimationFrame.call(Ne,()=&gt;{n.fakeTopEventTask||(n.fakeTopEventTask=Zone.root.scheduleEventTask(&quot;fakeTopEventTask&quot;,()=&gt;{n.lastRequestAnimationFrameId=-1,tg(n),n.isCheckStableRunning=!0,eg(n),n.isCheckStableRunning=!1},void 0,()=&gt;{},()=&gt;{})),n.fakeTopEventTask.invoke()}),tg(n))}(n)};n._inner=n._inner.fork({name:&quot;angular&quot;,properties:{isAngularZone:!0},onInvokeTask:(e,i,r,s,o,a)=&gt;{try{return gE(n),e.invokeTask(r,s,o,a)}finally{(n.shouldCoalesceEventChangeDetection&amp;&amp;&quot;eventTask&quot;===s.type||n.shouldCoalesceRunChangeDetection)&amp;&amp;t(),mE(n)}},onInvoke:(e,i,r,s,o,a,l)=&gt;{try{return gE(n),e.invoke(r,s,o,a,l)}finally{n.shouldCoalesceRunChangeDetection&amp;&amp;t(),mE(n)}},onHasTask:(e,i,r,s)=&gt;{e.hasTask(r,s),i===r&amp;&amp;(&quot;microTask&quot;==s.change?(n._hasPendingMicrotasks=s.microTask,tg(n),eg(n)):&quot;macroTask&quot;==s.change&amp;&amp;(n.hasPendingMacrotasks=s.macroTask))},onHandleError:(e,i,r,s)=&gt;(e.handleError(r,s),n.runOutsideAngular(()=&gt;n.onError.emit(s)),!1)})}(r)}static isInAngularZone(){return!0===Zone.current.get(&quot;isAngularZone&quot;)}static assertInAngularZone(){if(!Y.isInAngularZone())throw new Error(&quot;Expected to be in Angular Zone, but it is not!&quot;)}static assertNotInAngularZone(){if(Y.isInAngularZone())throw new Error(&quot;Expected to not be in Angular Zone, but it is!&quot;)}run(t,e,i){return this._inner.run(t,e,i)}runTask(t,e,i,r){const s=this._inner,o=s.scheduleEventTask(&quot;NgZoneEvent: &quot;+r,t,CV,yu,yu);try{return s.runTask(o,e,i)}finally{s.cancelTask(o)}}runGuarded(t,e,i){return this._inner.runGuarded(t,e,i)}runOutsideAngular(t){return this._outer.run(t)}}const CV={};function eg(n){if(0==n._nesting&amp;&amp;!n.hasPendingMicrotasks&amp;&amp;!n.isStable)try{n._nesting++,n.onMicrotaskEmpty.emit(null)}finally{if(n._nesting--,!n.hasPendingMicrotasks)try{n.runOutsideAngular(()=&gt;n.onStable.emit(null))}finally{n.isStable=!0}}}function tg(n){n.hasPendingMicrotasks=!!(n._hasPendingMicrotasks||(n.shouldCoalesceEventChangeDetection||n.shouldCoalesceRunChangeDetection)&amp;&amp;-1!==n.lastRequestAnimationFrameId)}function gE(n){n._nesting++,n.isStable&amp;&amp;(n.isStable=!1,n.onUnstable.emit(null))}function mE(n){n._nesting--,eg(n)}class EV{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new U,this.onMicrotaskEmpty=new U,this.onStable=new U,this.onError=new U}run(t,e,i){return t.apply(e,i)}runGuarded(t,e,i){return t.apply(e,i)}runOutsideAngular(t){return t()}runTask(t,e,i,r){return t.apply(e,i)}}let ng=(()=&gt;{class n{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=&gt;{this.taskTrackingZone=&quot;undefined&quot;==typeof Zone?null:Zone.current.get(&quot;TaskTrackingZone&quot;)})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=&gt;{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=&gt;{this._ngZone.onStable.subscribe({next:()=&gt;{Y.assertNotInAngularZone(),Xp(()=&gt;{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount&lt;0)throw new Error(&quot;pending async requests below zero&quot;);return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&amp;&amp;0===this._pendingCount&amp;&amp;!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Xp(()=&gt;{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(i=&gt;!i.updateCb||!i.updateCb(e)||(clearTimeout(i.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=&gt;({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,i,r){let s=-1;i&amp;&amp;i&gt;0&amp;&amp;(s=setTimeout(()=&gt;{this._callbacks=this._callbacks.filter(o=&gt;o.timeoutId!==s),e(this._didWork,this.getPendingTasks())},i)),this._callbacks.push({doneCb:e,timeoutId:s,updateCb:r})}whenStable(e,i,r){if(r&amp;&amp;!this.taskTrackingZone)throw new Error(&#39;Task tracking zone is required when passing an update callback to whenStable(). Is &quot;zone.js/plugins/task-tracking&quot; loaded?&#39;);this.addCallback(e,i,r),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,i,r){return[]}}return n.\u0275fac=function(e){return new(e||n)(D(Y))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),_E=(()=&gt;{class n{constructor(){this._applications=new Map,ig.addToWindow(this)}registerApplication(e,i){this._applications.set(e,i)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,i=!0){return ig.findTestabilityInTree(this,e,i)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();class SV{addToWindow(t){}findTestabilityInTree(t,e,i){return null}}let ig=new SV,yE=!0,vE=!1;function rg(){return vE=!0,yE}let ui;const bE=new j(&quot;AllowMultipleToken&quot;);class sg{constructor(t,e){this.name=t,this.token=e}}function CE(n,t,e=[]){const i=`Platform: ${t}`,r=new j(i);return(s=[])=&gt;{let o=DE();if(!o||o.injector.get(bE,!1))if(n)n(e.concat(s).concat({provide:r,useValue:!0}));else{const a=e.concat(s).concat({provide:r,useValue:!0},{provide:Ya,useValue:&quot;platform&quot;});!function(n){if(ui&amp;&amp;!ui.destroyed&amp;&amp;!ui.injector.get(bE,!1))throw new Error(&quot;There can be only one platform. Destroy the previous one to create a new one.&quot;);ui=n.get(wE);const t=n.get(dE,null);t&amp;&amp;t.forEach(e=&gt;e())}(ke.create({providers:a,name:i}))}return function(n){const t=DE();if(!t)throw new Error(&quot;No platform exists!&quot;);if(!t.injector.get(n,null))throw new Error(&quot;A platform with a different configuration has been created. Please destroy it first.&quot;);return t}(r)}}function DE(){return ui&amp;&amp;!ui.destroyed?ui:null}let wE=(()=&gt;{class n{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,i){const a=function(n,t){let e;return e=&quot;noop&quot;===n?new EV:(&quot;zone.js&quot;===n?void 0:n)||new Y({enableLongStackTrace:rg(),shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),e}(i?i.ngZone:void 0,{ngZoneEventCoalescing:i&amp;&amp;i.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:i&amp;&amp;i.ngZoneRunCoalescing||!1}),l=[{provide:Y,useValue:a}];return a.run(()=&gt;{const c=ke.create({providers:l,parent:this.injector,name:e.moduleType.name}),u=e.create(c),f=u.injector.get(ls,null);if(!f)throw new Error(&quot;No ErrorHandler. Is platform module (BrowserModule) included?&quot;);return a.runOutsideAngular(()=&gt;{const p=a.onError.subscribe({next:g=&gt;{f.handleError(g)}});u.onDestroy(()=&gt;{og(this._modules,u),p.unsubscribe()})}),function(n,t,e){try{const i=e();return tl(i)?i.catch(r=&gt;{throw t.runOutsideAngular(()=&gt;n.handleError(r)),r}):i}catch(i){throw t.runOutsideAngular(()=&gt;n.handleError(i)),i}}(f,a,()=&gt;{const p=u.injector.get($o);return p.runInitializers(),p.donePromise.then(()=&gt;(_p(u.injector.get(rr,fu)||fu),this._moduleDoBootstrap(u),u))})})}bootstrapModule(e,i=[]){const r=EE({},i);return function(n,t,e){const i=new jp(e);return Promise.resolve(i)}(0,0,e).then(s=&gt;this.bootstrapModuleFactory(s,r))}_moduleDoBootstrap(e){const i=e.injector.get(Pr);if(e._bootstrapComponents.length&gt;0)e._bootstrapComponents.forEach(r=&gt;i.bootstrap(r));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${ge(e.instance.constructor)} was bootstrapped, but it does not declare &quot;@NgModule.bootstrap&quot; components nor a &quot;ngDoBootstrap&quot; method. Please define one of these.`);e.instance.ngDoBootstrap(i)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error(&quot;The platform has already been destroyed!&quot;);this._modules.slice().forEach(e=&gt;e.destroy()),this._destroyListeners.forEach(e=&gt;e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return n.\u0275fac=function(e){return new(e||n)(D(ke))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();function EE(n,t){return Array.isArray(t)?t.reduce(EE,n):Object.assign(Object.assign({},n),t)}let Pr=(()=&gt;{class n{constructor(e,i,r,s,o){this._zone=e,this._injector=i,this._exceptionHandler=r,this._componentFactoryResolver=s,this._initStatus=o,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=&gt;{this._zone.run(()=&gt;{this.tick()})}});const a=new ye(c=&gt;{this._stable=this._zone.isStable&amp;&amp;!this._zone.hasPendingMacrotasks&amp;&amp;!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=&gt;{c.next(this._stable),c.complete()})}),l=new ye(c=&gt;{let u;this._zone.runOutsideAngular(()=&gt;{u=this._zone.onStable.subscribe(()=&gt;{Y.assertNotInAngularZone(),Xp(()=&gt;{!this._stable&amp;&amp;!this._zone.hasPendingMacrotasks&amp;&amp;!this._zone.hasPendingMicrotasks&amp;&amp;(this._stable=!0,c.next(!0))})})});const f=this._zone.onUnstable.subscribe(()=&gt;{Y.assertInAngularZone(),this._stable&amp;&amp;(this._stable=!1,this._zone.runOutsideAngular(()=&gt;{c.next(!1)}))});return()=&gt;{u.unsubscribe(),f.unsubscribe()}});this.isStable=Ci(a,l.pipe(n=&gt;Ah()(Th(rT)(n))))}bootstrap(e,i){if(!this._initStatus.done)throw new Error(&quot;Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.&quot;);let r;r=e instanceof ZD?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(r.componentType);const s=function(n){return n.isBoundToModule}(r)?void 0:this._injector.get(Pi),a=r.create(ke.NULL,[],i||r.selector,s),l=a.location.nativeElement,c=a.injector.get(ng,null),u=c&amp;&amp;a.injector.get(_E);return c&amp;&amp;u&amp;&amp;u.registerApplication(l,c),a.onDestroy(()=&gt;{this.detachView(a.hostView),og(this.components,a),u&amp;&amp;u.unregisterApplication(l)}),this._loadComponent(a),a}tick(){if(this._runningTick)throw new Error(&quot;ApplicationRef.tick is called recursively&quot;);try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=&gt;this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const i=e;this._views.push(i),i.attachToAppRef(this)}detachView(e){const i=e;og(this._views,i),i.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(hE,[]).concat(this._bootstrapListeners).forEach(r=&gt;r(e))}ngOnDestroy(){this._views.slice().forEach(e=&gt;e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return n.\u0275fac=function(e){return new(e||n)(D(Y),D(ke),D(ls),D(tr),D($o))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();function og(n,t){const e=n.indexOf(t);e&gt;-1&amp;&amp;n.splice(e,1)}class xu{}class BV{}const UV={factoryPathPrefix:&quot;&quot;,factoryPathSuffix:&quot;.ngfactory&quot;};let HV=(()=&gt;{class n{constructor(e,i){this._compiler=e,this._config=i||UV}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[i,r]=e.split(&quot;#&quot;);return void 0===r&amp;&amp;(r=&quot;default&quot;),ya(255)(i).then(s=&gt;s[r]).then(s=&gt;AE(s,i,r)).then(s=&gt;this._compiler.compileModuleAsync(s))}loadFactory(e){let[i,r]=e.split(&quot;#&quot;),s=&quot;NgFactory&quot;;return void 0===r&amp;&amp;(r=&quot;default&quot;,s=&quot;&quot;),ya(255)(this._config.factoryPathPrefix+i+this._config.factoryPathSuffix).then(o=&gt;o[r+s]).then(o=&gt;AE(o,i,r))}}return n.\u0275fac=function(e){return new(e||n)(D(gs),D(BV,8))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();function AE(n,t,e){if(!n)throw new Error(`Cannot find &#39;${e}&#39; in &#39;${t}&#39;`);return n}const JV=CE(null,&quot;core&quot;,[{provide:Rr,useValue:&quot;unknown&quot;},{provide:wE,deps:[ke]},{provide:_E,deps:[]},{provide:Tu,deps:[]}]),iL=[{provide:Pr,useClass:Pr,deps:[Y,ke,ls,tr,$o]},{provide:c2,deps:[Y],useFactory:function(n){let t=[];return n.onStable.subscribe(()=&gt;{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:$o,useClass:$o,deps:[[new It,zo]]},{provide:gs,useClass:gs,deps:[]},uV,{provide:Fo,useFactory:function(){return nN},deps:[]},{provide:No,useFactory:function(){return iN},deps:[]},{provide:rr,useFactory:function(n){return _p(n=n||&quot;undefined&quot;!=typeof $localize&amp;&amp;$localize.locale||fu),n},deps:[[new ao(rr),new It,new Xn]]},{provide:fE,useValue:&quot;USD&quot;}];let sL=(()=&gt;{class n{constructor(e){}}return n.\u0275fac=function(e){return new(e||n)(D(Pr))},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:iL}),n})(),Uu=null;function Oi(){return Uu}const W=new j(&quot;DocumentToken&quot;);let ys=(()=&gt;{class n{historyGo(e){throw new Error(&quot;Not implemented&quot;)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({factory:r3,token:n,providedIn:&quot;platform&quot;}),n})();function r3(){return D(JE)}const s3=new j(&quot;Location Initialized&quot;);let JE=(()=&gt;{class n extends ys{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Oi().getBaseHref(this._doc)}onPopState(e){const i=Oi().getGlobalEventTarget(this._doc,&quot;window&quot;);return i.addEventListener(&quot;popstate&quot;,e,!1),()=&gt;i.removeEventListener(&quot;popstate&quot;,e)}onHashChange(e){const i=Oi().getGlobalEventTarget(this._doc,&quot;window&quot;);return i.addEventListener(&quot;hashchange&quot;,e,!1),()=&gt;i.removeEventListener(&quot;hashchange&quot;,e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,i,r){XE()?this._history.pushState(e,i,r):this.location.hash=r}replaceState(e,i,r){XE()?this._history.replaceState(e,i,r):this.location.hash=r}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return n.\u0275fac=function(e){return new(e||n)(D(W))},n.\u0275prov=P({factory:o3,token:n,providedIn:&quot;platform&quot;}),n})();function XE(){return!!window.history.pushState}function o3(){return new JE(D(W))}function Cg(n,t){if(0==n.length)return t;if(0==t.length)return n;let e=0;return n.endsWith(&quot;/&quot;)&amp;&amp;e++,t.startsWith(&quot;/&quot;)&amp;&amp;e++,2==e?n+t.substring(1):1==e?n+t:n+&quot;/&quot;+t}function e0(n){const t=n.match(/#|\?|$/),e=t&amp;&amp;t.index||n.length;return n.slice(0,e-(&quot;/&quot;===n[e-1]?1:0))+n.slice(e)}function or(n){return n&amp;&amp;&quot;?&quot;!==n[0]?&quot;?&quot;+n:n}let qo=(()=&gt;{class n{historyGo(e){throw new Error(&quot;Not implemented&quot;)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({factory:a3,token:n,providedIn:&quot;root&quot;}),n})();function a3(n){const t=D(W).location;return new t0(D(ys),t&amp;&amp;t.origin||&quot;&quot;)}const Dg=new j(&quot;appBaseHref&quot;);let t0=(()=&gt;{class n extends qo{constructor(e,i){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==i&amp;&amp;(i=this._platformLocation.getBaseHrefFromDOM()),null==i)throw new Error(&quot;No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.&quot;);this._baseHref=i}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return Cg(this._baseHref,e)}path(e=!1){const i=this._platformLocation.pathname+or(this._platformLocation.search),r=this._platformLocation.hash;return r&amp;&amp;e?`${i}${r}`:i}pushState(e,i,r,s){const o=this.prepareExternalUrl(r+or(s));this._platformLocation.pushState(e,i,o)}replaceState(e,i,r,s){const o=this.prepareExternalUrl(r+or(s));this._platformLocation.replaceState(e,i,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var i,r;null===(r=(i=this._platformLocation).historyGo)||void 0===r||r.call(i,e)}}return n.\u0275fac=function(e){return new(e||n)(D(ys),D(Dg,8))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),l3=(()=&gt;{class n extends qo{constructor(e,i){super(),this._platformLocation=e,this._baseHref=&quot;&quot;,this._removeListenerFns=[],null!=i&amp;&amp;(this._baseHref=i)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let i=this._platformLocation.hash;return null==i&amp;&amp;(i=&quot;#&quot;),i.length&gt;0?i.substring(1):i}prepareExternalUrl(e){const i=Cg(this._baseHref,e);return i.length&gt;0?&quot;#&quot;+i:i}pushState(e,i,r,s){let o=this.prepareExternalUrl(r+or(s));0==o.length&amp;&amp;(o=this._platformLocation.pathname),this._platformLocation.pushState(e,i,o)}replaceState(e,i,r,s){let o=this.prepareExternalUrl(r+or(s));0==o.length&amp;&amp;(o=this._platformLocation.pathname),this._platformLocation.replaceState(e,i,o)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var i,r;null===(r=(i=this._platformLocation).historyGo)||void 0===r||r.call(i,e)}}return n.\u0275fac=function(e){return new(e||n)(D(ys),D(Dg,8))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),vs=(()=&gt;{class n{constructor(e,i){this._subject=new U,this._urlChangeListeners=[],this._platformStrategy=e;const r=this._platformStrategy.getBaseHref();this._platformLocation=i,this._baseHref=e0(n0(r)),this._platformStrategy.onPopState(s=&gt;{this._subject.emit({url:this.path(!0),pop:!0,state:s.state,type:s.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,i=&quot;&quot;){return this.path()==this.normalize(e+or(i))}normalize(e){return n.stripTrailingSlash(function(n,t){return n&amp;&amp;t.startsWith(n)?t.substring(n.length):t}(this._baseHref,n0(e)))}prepareExternalUrl(e){return e&amp;&amp;&quot;/&quot;!==e[0]&amp;&amp;(e=&quot;/&quot;+e),this._platformStrategy.prepareExternalUrl(e)}go(e,i=&quot;&quot;,r=null){this._platformStrategy.pushState(r,&quot;&quot;,e,i),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+or(i)),r)}replaceState(e,i=&quot;&quot;,r=null){this._platformStrategy.replaceState(r,&quot;&quot;,e,i),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+or(i)),r)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var i,r;null===(r=(i=this._platformStrategy).historyGo)||void 0===r||r.call(i,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(i=&gt;{this._notifyUrlChangeListeners(i.url,i.state)}))}_notifyUrlChangeListeners(e=&quot;&quot;,i){this._urlChangeListeners.forEach(r=&gt;r(e,i))}subscribe(e,i,r){return this._subject.subscribe({next:e,error:i,complete:r})}}return n.\u0275fac=function(e){return new(e||n)(D(qo),D(ys))},n.normalizeQueryParams=or,n.joinWithSlash=Cg,n.stripTrailingSlash=e0,n.\u0275prov=P({factory:c3,token:n,providedIn:&quot;root&quot;}),n})();function c3(){return new vs(D(qo),D(ys))}function n0(n){return n.replace(/\/index.html$/,&quot;&quot;)}var ln=(()=&gt;((ln=ln||{})[ln.Decimal=0]=&quot;Decimal&quot;,ln[ln.Percent=1]=&quot;Percent&quot;,ln[ln.Currency=2]=&quot;Currency&quot;,ln[ln.Scientific=3]=&quot;Scientific&quot;,ln))(),ft=(()=&gt;((ft=ft||{})[ft.Zero=0]=&quot;Zero&quot;,ft[ft.One=1]=&quot;One&quot;,ft[ft.Two=2]=&quot;Two&quot;,ft[ft.Few=3]=&quot;Few&quot;,ft[ft.Many=4]=&quot;Many&quot;,ft[ft.Other=5]=&quot;Other&quot;,ft))(),K=(()=&gt;((K=K||{})[K.Decimal=0]=&quot;Decimal&quot;,K[K.Group=1]=&quot;Group&quot;,K[K.List=2]=&quot;List&quot;,K[K.PercentSign=3]=&quot;PercentSign&quot;,K[K.PlusSign=4]=&quot;PlusSign&quot;,K[K.MinusSign=5]=&quot;MinusSign&quot;,K[K.Exponential=6]=&quot;Exponential&quot;,K[K.SuperscriptingExponent=7]=&quot;SuperscriptingExponent&quot;,K[K.PerMille=8]=&quot;PerMille&quot;,K[K.Infinity=9]=&quot;Infinity&quot;,K[K.NaN=10]=&quot;NaN&quot;,K[K.TimeSeparator=11]=&quot;TimeSeparator&quot;,K[K.CurrencyDecimal=12]=&quot;CurrencyDecimal&quot;,K[K.CurrencyGroup=13]=&quot;CurrencyGroup&quot;,K))();function Ln(n,t){const e=Jt(n),i=e[V.NumberSymbols][t];if(void 0===i){if(t===K.CurrencyDecimal)return e[V.NumberSymbols][K.Decimal];if(t===K.CurrencyGroup)return e[V.NumberSymbols][K.Group]}return i}const _3=function(n){return Jt(n)[V.PluralCase]},N3=/^(\d+)?\.((\d+)(-(\d+))?)?$/;function Ig(n){const t=parseInt(n);if(isNaN(t))throw new Error(&quot;Invalid integer literal when parsing &quot;+n);return t}class Zu{}let W3=(()=&gt;{class n extends Zu{constructor(e){super(),this.locale=e}getPluralCategory(e,i){switch(_3(i||this.locale)(e)){case ft.Zero:return&quot;zero&quot;;case ft.One:return&quot;one&quot;;case ft.Two:return&quot;two&quot;;case ft.Few:return&quot;few&quot;;case ft.Many:return&quot;many&quot;;default:return&quot;other&quot;}}}return n.\u0275fac=function(e){return new(e||n)(D(rr))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();function h0(n,t){t=encodeURIComponent(t);for(const e of n.split(&quot;;&quot;)){const i=e.indexOf(&quot;=&quot;),[r,s]=-1==i?[e,&quot;&quot;]:[e.slice(0,i),e.slice(i+1)];if(r.trim()===t)return decodeURIComponent(s)}return null}let xg=(()=&gt;{class n{constructor(e,i,r,s){this._iterableDiffers=e,this._keyValueDiffers=i,this._ngEl=r,this._renderer=s,this._iterableDiffer=null,this._keyValueDiffer=null,this._initialClasses=[],this._rawClass=null}set klass(e){this._removeClasses(this._initialClasses),this._initialClasses=&quot;string&quot;==typeof e?e.split(/\s+/):[],this._applyClasses(this._initialClasses),this._applyClasses(this._rawClass)}set ngClass(e){this._removeClasses(this._rawClass),this._applyClasses(this._initialClasses),this._iterableDiffer=null,this._keyValueDiffer=null,this._rawClass=&quot;string&quot;==typeof e?e.split(/\s+/):e,this._rawClass&amp;&amp;(Za(this._rawClass)?this._iterableDiffer=this._iterableDiffers.find(this._rawClass).create():this._keyValueDiffer=this._keyValueDiffers.find(this._rawClass).create())}ngDoCheck(){if(this._iterableDiffer){const e=this._iterableDiffer.diff(this._rawClass);e&amp;&amp;this._applyIterableChanges(e)}else if(this._keyValueDiffer){const e=this._keyValueDiffer.diff(this._rawClass);e&amp;&amp;this._applyKeyValueChanges(e)}}_applyKeyValueChanges(e){e.forEachAddedItem(i=&gt;this._toggleClass(i.key,i.currentValue)),e.forEachChangedItem(i=&gt;this._toggleClass(i.key,i.currentValue)),e.forEachRemovedItem(i=&gt;{i.previousValue&amp;&amp;this._toggleClass(i.key,!1)})}_applyIterableChanges(e){e.forEachAddedItem(i=&gt;{if(&quot;string&quot;!=typeof i.item)throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${ge(i.item)}`);this._toggleClass(i.item,!0)}),e.forEachRemovedItem(i=&gt;this._toggleClass(i.item,!1))}_applyClasses(e){e&amp;&amp;(Array.isArray(e)||e instanceof Set?e.forEach(i=&gt;this._toggleClass(i,!0)):Object.keys(e).forEach(i=&gt;this._toggleClass(i,!!e[i])))}_removeClasses(e){e&amp;&amp;(Array.isArray(e)||e instanceof Set?e.forEach(i=&gt;this._toggleClass(i,!1)):Object.keys(e).forEach(i=&gt;this._toggleClass(i,!1)))}_toggleClass(e,i){(e=e.trim())&amp;&amp;e.split(/\s+/g).forEach(r=&gt;{i?this._renderer.addClass(this._ngEl.nativeElement,r):this._renderer.removeClass(this._ngEl.nativeElement,r)})}}return n.\u0275fac=function(e){return new(e||n)(_(Fo),_(No),_(X),_(nr))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;ngClass&quot;,&quot;&quot;]],inputs:{klass:[&quot;class&quot;,&quot;klass&quot;],ngClass:&quot;ngClass&quot;}}),n})();class Y3{constructor(t,e,i,r){this.$implicit=t,this.ngForOf=e,this.index=i,this.count=r}get first(){return 0===this.index}get last(){return this.index===this.count-1}get even(){return this.index%2==0}get odd(){return!this.even}}let Fi=(()=&gt;{class n{constructor(e,i,r){this._viewContainer=e,this._template=i,this._differs=r,this._ngForOf=null,this._ngForOfDirty=!0,this._differ=null}set ngForOf(e){this._ngForOf=e,this._ngForOfDirty=!0}set ngForTrackBy(e){this._trackByFn=e}get ngForTrackBy(){return this._trackByFn}set ngForTemplate(e){e&amp;&amp;(this._template=e)}ngDoCheck(){if(this._ngForOfDirty){this._ngForOfDirty=!1;const e=this._ngForOf;if(!this._differ&amp;&amp;e)try{this._differ=this._differs.find(e).create(this.ngForTrackBy)}catch(i){throw new Error(`Cannot find a differ supporting object &#39;${e}&#39; of type &#39;${function(n){return n.name||typeof n}(e)}&#39;. NgFor only supports binding to Iterables such as Arrays.`)}}if(this._differ){const e=this._differ.diff(this._ngForOf);e&amp;&amp;this._applyChanges(e)}}_applyChanges(e){const i=[];e.forEachOperation((r,s,o)=&gt;{if(null==r.previousIndex){const a=this._viewContainer.createEmbeddedView(this._template,new Y3(null,this._ngForOf,-1,-1),null===o?void 0:o),l=new f0(r,a);i.push(l)}else if(null==o)this._viewContainer.remove(null===s?void 0:s);else if(null!==s){const a=this._viewContainer.get(s);this._viewContainer.move(a,o);const l=new f0(r,a);i.push(l)}});for(let r=0;r&lt;i.length;r++)this._perViewChange(i[r].view,i[r].record);for(let r=0,s=this._viewContainer.length;r&lt;s;r++){const o=this._viewContainer.get(r);o.context.index=r,o.context.count=s,o.context.ngForOf=this._ngForOf}e.forEachIdentityChange(r=&gt;{this._viewContainer.get(r.currentIndex).context.$implicit=r.item})}_perViewChange(e,i){e.context.$implicit=i.item}static ngTemplateContextGuard(e,i){return!0}}return n.\u0275fac=function(e){return new(e||n)(_(Rt),_(bn),_(Fo))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;ngFor&quot;,&quot;&quot;,&quot;ngForOf&quot;,&quot;&quot;]],inputs:{ngForOf:&quot;ngForOf&quot;,ngForTrackBy:&quot;ngForTrackBy&quot;,ngForTemplate:&quot;ngForTemplate&quot;}}),n})();class f0{constructor(t,e){this.record=t,this.view=e}}let rt=(()=&gt;{class n{constructor(e,i){this._viewContainer=e,this._context=new Q3,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=i}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){p0(&quot;ngIfThen&quot;,e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){p0(&quot;ngIfElse&quot;,e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&amp;&amp;(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&amp;&amp;(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,i){return!0}}return n.\u0275fac=function(e){return new(e||n)(_(Rt),_(bn))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;ngIf&quot;,&quot;&quot;]],inputs:{ngIf:&quot;ngIf&quot;,ngIfThen:&quot;ngIfThen&quot;,ngIfElse:&quot;ngIfElse&quot;}}),n})();class Q3{constructor(){this.$implicit=null,this.ngIf=null}}function p0(n,t){if(t&amp;&amp;!t.createEmbeddedView)throw new Error(`${n} must be a TemplateRef, but received &#39;${ge(t)}&#39;.`)}class Rg{constructor(t,e){this._viewContainerRef=t,this._templateRef=e,this._created=!1}create(){this._created=!0,this._viewContainerRef.createEmbeddedView(this._templateRef)}destroy(){this._created=!1,this._viewContainerRef.clear()}enforceState(t){t&amp;&amp;!this._created?this.create():!t&amp;&amp;this._created&amp;&amp;this.destroy()}}let Yo=(()=&gt;{class n{constructor(){this._defaultUsed=!1,this._caseCount=0,this._lastCaseCheckIndex=0,this._lastCasesMatched=!1}set ngSwitch(e){this._ngSwitch=e,0===this._caseCount&amp;&amp;this._updateDefaultCases(!0)}_addCase(){return this._caseCount++}_addDefault(e){this._defaultViews||(this._defaultViews=[]),this._defaultViews.push(e)}_matchCase(e){const i=e==this._ngSwitch;return this._lastCasesMatched=this._lastCasesMatched||i,this._lastCaseCheckIndex++,this._lastCaseCheckIndex===this._caseCount&amp;&amp;(this._updateDefaultCases(!this._lastCasesMatched),this._lastCaseCheckIndex=0,this._lastCasesMatched=!1),i}_updateDefaultCases(e){if(this._defaultViews&amp;&amp;e!==this._defaultUsed){this._defaultUsed=e;for(let i=0;i&lt;this._defaultViews.length;i++)this._defaultViews[i].enforceState(e)}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;ngSwitch&quot;,&quot;&quot;]],inputs:{ngSwitch:&quot;ngSwitch&quot;}}),n})(),Ju=(()=&gt;{class n{constructor(e,i,r){this.ngSwitch=r,r._addCase(),this._view=new Rg(e,i)}ngDoCheck(){this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))}}return n.\u0275fac=function(e){return new(e||n)(_(Rt),_(bn),_(Yo,9))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;ngSwitchCase&quot;,&quot;&quot;]],inputs:{ngSwitchCase:&quot;ngSwitchCase&quot;}}),n})(),g0=(()=&gt;{class n{constructor(e,i,r){r._addDefault(new Rg(e,i))}}return n.\u0275fac=function(e){return new(e||n)(_(Rt),_(bn),_(Yo,9))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;ngSwitchDefault&quot;,&quot;&quot;]]}),n})();let y0=(()=&gt;{class n{constructor(e){this._locale=e}transform(e,i,r){if(!function(n){return!(null==n||&quot;&quot;===n||n!=n)}(e))return null;r=r||this._locale;try{return function(n,t,e){return function(n,t,e,i,r,s,o=!1){let a=&quot;&quot;,l=!1;if(isFinite(n)){let c=function(n){let i,r,s,o,a,t=Math.abs(n)+&quot;&quot;,e=0;for((r=t.indexOf(&quot;.&quot;))&gt;-1&amp;&amp;(t=t.replace(&quot;.&quot;,&quot;&quot;)),(s=t.search(/e/i))&gt;0?(r&lt;0&amp;&amp;(r=s),r+=+t.slice(s+1),t=t.substring(0,s)):r&lt;0&amp;&amp;(r=t.length),s=0;&quot;0&quot;===t.charAt(s);s++);if(s===(a=t.length))i=[0],r=1;else{for(a--;&quot;0&quot;===t.charAt(a);)a--;for(r-=s,i=[],o=0;s&lt;=a;s++,o++)i[o]=Number(t.charAt(s))}return r&gt;22&amp;&amp;(i=i.splice(0,21),e=r-1,r=1),{digits:i,exponent:e,integerLen:r}}(n);o&amp;&amp;(c=function(n){if(0===n.digits[0])return n;const t=n.digits.length-n.integerLen;return n.exponent?n.exponent+=2:(0===t?n.digits.push(0,0):1===t&amp;&amp;n.digits.push(0),n.integerLen+=2),n}(c));let u=t.minInt,f=t.minFrac,p=t.maxFrac;if(s){const E=s.match(N3);if(null===E)throw new Error(`${s} is not a valid digit info`);const R=E[1],F=E[3],Q=E[5];null!=R&amp;&amp;(u=Ig(R)),null!=F&amp;&amp;(f=Ig(F)),null!=Q?p=Ig(Q):null!=F&amp;&amp;f&gt;p&amp;&amp;(p=f)}!function(n,t,e){if(t&gt;e)throw new Error(`The minimum number of digits after fraction (${t}) is higher than the maximum (${e}).`);let i=n.digits,r=i.length-n.integerLen;const s=Math.min(Math.max(t,r),e);let o=s+n.integerLen,a=i[o];if(o&gt;0){i.splice(Math.max(n.integerLen,o));for(let f=o;f&lt;i.length;f++)i[f]=0}else{r=Math.max(0,r),n.integerLen=1,i.length=Math.max(1,o=s+1),i[0]=0;for(let f=1;f&lt;o;f++)i[f]=0}if(a&gt;=5)if(o-1&lt;0){for(let f=0;f&gt;o;f--)i.unshift(0),n.integerLen++;i.unshift(1),n.integerLen++}else i[o-1]++;for(;r&lt;Math.max(0,s);r++)i.push(0);let l=0!==s;const c=t+n.integerLen,u=i.reduceRight(function(f,p,g,m){return m[g]=(p+=f)&lt;10?p:p-10,l&amp;&amp;(0===m[g]&amp;&amp;g&gt;=c?m.pop():l=!1),p&gt;=10?1:0},0);u&amp;&amp;(i.unshift(u),n.integerLen++)}(c,f,p);let g=c.digits,m=c.integerLen;const C=c.exponent;let v=[];for(l=g.every(E=&gt;!E);m&lt;u;m++)g.unshift(0);for(;m&lt;0;m++)g.unshift(0);m&gt;0?v=g.splice(m,g.length):(v=g,g=[0]);const S=[];for(g.length&gt;=t.lgSize&amp;&amp;S.unshift(g.splice(-t.lgSize,g.length).join(&quot;&quot;));g.length&gt;t.gSize;)S.unshift(g.splice(-t.gSize,g.length).join(&quot;&quot;));g.length&amp;&amp;S.unshift(g.join(&quot;&quot;)),a=S.join(Ln(e,i)),v.length&amp;&amp;(a+=Ln(e,r)+v.join(&quot;&quot;)),C&amp;&amp;(a+=Ln(e,K.Exponential)+&quot;+&quot;+C)}else a=Ln(e,K.Infinity);return a=n&lt;0&amp;&amp;!l?t.negPre+a+t.negSuf:t.posPre+a+t.posSuf,a}(n,function(n,t=&quot;-&quot;){const e={minInt:1,minFrac:0,maxFrac:0,posPre:&quot;&quot;,posSuf:&quot;&quot;,negPre:&quot;&quot;,negSuf:&quot;&quot;,gSize:0,lgSize:0},i=n.split(&quot;;&quot;),r=i[0],s=i[1],o=-1!==r.indexOf(&quot;.&quot;)?r.split(&quot;.&quot;):[r.substring(0,r.lastIndexOf(&quot;0&quot;)+1),r.substring(r.lastIndexOf(&quot;0&quot;)+1)],a=o[0],l=o[1]||&quot;&quot;;e.posPre=a.substr(0,a.indexOf(&quot;#&quot;));for(let u=0;u&lt;l.length;u++){const f=l.charAt(u);&quot;0&quot;===f?e.minFrac=e.maxFrac=u+1:&quot;#&quot;===f?e.maxFrac=u+1:e.posSuf+=f}const c=a.split(&quot;,&quot;);if(e.gSize=c[1]?c[1].length:0,e.lgSize=c[2]||c[1]?(c[2]||c[1]).length:0,s){const u=r.length-e.posPre.length-e.posSuf.length,f=s.indexOf(&quot;#&quot;);e.negPre=s.substr(0,f).replace(/&#39;/g,&quot;&quot;),e.negSuf=s.substr(f+u).replace(/&#39;/g,&quot;&quot;)}else e.negPre=t+e.posPre,e.negSuf=e.posSuf;return e}(function(n,t){return Jt(n)[V.NumberFormats][t]}(t,ln.Decimal),Ln(t,K.MinusSign)),t,K.Group,K.Decimal,e)}(function(n){if(&quot;string&quot;==typeof n&amp;&amp;!isNaN(Number(n)-parseFloat(n)))return Number(n);if(&quot;number&quot;!=typeof n)throw new Error(`${n} is not a number`);return n}(e),r,i)}catch(s){throw function(n,t){return Error(`InvalidPipeArgument: &#39;${t}&#39; for pipe &#39;${ge(n)}&#39;`)}(n,s.message)}}}return n.\u0275fac=function(e){return new(e||n)(_(rr,16))},n.\u0275pipe=at({name:&quot;number&quot;,type:n,pure:!0}),n})();let Ko=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[{provide:Zu,useClass:W3}]}),n})();const v0=&quot;browser&quot;;function Fg(n){return n===v0}let Ng=(()=&gt;{class n{}return n.\u0275prov=P({token:n,providedIn:&quot;root&quot;,factory:()=&gt;new Dj(D(W),window)}),n})();class Dj{constructor(t,e){this.document=t,this.window=e,this.offset=()=&gt;[0,0]}setOffset(t){this.offset=Array.isArray(t)?()=&gt;t:t}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(t){this.supportsScrolling()&amp;&amp;this.window.scrollTo(t[0],t[1])}scrollToAnchor(t){if(!this.supportsScrolling())return;const e=function(n,t){const e=n.getElementById(t)||n.getElementsByName(t)[0];if(e)return e;if(&quot;function&quot;==typeof n.createTreeWalker&amp;&amp;n.body&amp;&amp;(n.body.createShadowRoot||n.body.attachShadow)){const i=n.createTreeWalker(n.body,NodeFilter.SHOW_ELEMENT);let r=i.currentNode;for(;r;){const s=r.shadowRoot;if(s){const o=s.getElementById(t)||s.querySelector(`[name=&quot;${t}&quot;]`);if(o)return o}r=i.nextNode()}}return null}(this.document,t);e&amp;&amp;(this.scrollToElement(e),this.attemptFocus(e))}setHistoryScrollRestoration(t){if(this.supportScrollRestoration()){const e=this.window.history;e&amp;&amp;e.scrollRestoration&amp;&amp;(e.scrollRestoration=t)}}scrollToElement(t){const e=t.getBoundingClientRect(),i=e.left+this.window.pageXOffset,r=e.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(i-s[0],r-s[1])}attemptFocus(t){return t.focus(),this.document.activeElement===t}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const t=b0(this.window.history)||b0(Object.getPrototypeOf(this.window.history));return!(!t||!t.writable&amp;&amp;!t.set)}catch(t){return!1}}supportsScrolling(){try{return!!this.window&amp;&amp;!!this.window.scrollTo&amp;&amp;&quot;pageXOffset&quot;in this.window}catch(t){return!1}}}function b0(n){return Object.getOwnPropertyDescriptor(n,&quot;scrollRestoration&quot;)}class C0{}class Vg extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){!function(n){Uu||(Uu=n)}(new Vg)}onAndCancel(t,e,i){return t.addEventListener(e,i,!1),()=&gt;{t.removeEventListener(e,i,!1)}}dispatchEvent(t,e){t.dispatchEvent(e)}remove(t){t.parentNode&amp;&amp;t.parentNode.removeChild(t)}createElement(t,e){return(e=e||this.getDefaultDocument()).createElement(t)}createHtmlDocument(){return document.implementation.createHTMLDocument(&quot;fakeTitle&quot;)}getDefaultDocument(){return document}isElementNode(t){return t.nodeType===Node.ELEMENT_NODE}isShadowRoot(t){return t instanceof DocumentFragment}getGlobalEventTarget(t,e){return&quot;window&quot;===e?window:&quot;document&quot;===e?t:&quot;body&quot;===e?t.body:null}getBaseHref(t){const e=(kl=kl||document.querySelector(&quot;base&quot;),kl?kl.getAttribute(&quot;href&quot;):null);return null==e?null:function(n){Xu=Xu||document.createElement(&quot;a&quot;),Xu.setAttribute(&quot;href&quot;,n);const t=Xu.pathname;return&quot;/&quot;===t.charAt(0)?t:`/${t}`}(e)}resetBaseElement(){kl=null}getUserAgent(){return window.navigator.userAgent}getCookie(t){return h0(document.cookie,t)}}let Xu,kl=null;const D0=new j(&quot;TRANSITION_ID&quot;),Aj=[{provide:zo,useFactory:function(n,t,e){return()=&gt;{e.get($o).donePromise.then(()=&gt;{const i=Oi(),r=t.querySelectorAll(`style[ng-transition=&quot;${n}&quot;]`);for(let s=0;s&lt;r.length;s++)i.remove(r[s])})}},deps:[D0,W,ke],multi:!0}];class Lg{static init(){!function(n){ig=n}(new Lg)}addToWindow(t){Ne.getAngularTestability=(i,r=!0)=&gt;{const s=t.findTestabilityInTree(i,r);if(null==s)throw new Error(&quot;Could not find testability for element.&quot;);return s},Ne.getAllAngularTestabilities=()=&gt;t.getAllTestabilities(),Ne.getAllAngularRootElements=()=&gt;t.getAllRootElements(),Ne.frameworkStabilizers||(Ne.frameworkStabilizers=[]),Ne.frameworkStabilizers.push(i=&gt;{const r=Ne.getAllAngularTestabilities();let s=r.length,o=!1;const a=function(l){o=o||l,s--,0==s&amp;&amp;i(o)};r.forEach(function(l){l.whenStable(a)})})}findTestabilityInTree(t,e,i){if(null==e)return null;const r=t.getTestability(e);return null!=r?r:i?Oi().isShadowRoot(e)?this.findTestabilityInTree(t,e.host,!0):this.findTestabilityInTree(t,e.parentElement,!0):null}}let Tj=(()=&gt;{class n{build(){return new XMLHttpRequest}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const Ml=new j(&quot;EventManagerPlugins&quot;);let td=(()=&gt;{class n{constructor(e,i){this._zone=i,this._eventNameToPlugin=new Map,e.forEach(r=&gt;r.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,i,r){return this._findPluginFor(i).addEventListener(e,i,r)}addGlobalEventListener(e,i,r){return this._findPluginFor(i).addGlobalEventListener(e,i,r)}getZone(){return this._zone}_findPluginFor(e){const i=this._eventNameToPlugin.get(e);if(i)return i;const r=this._plugins;for(let s=0;s&lt;r.length;s++){const o=r[s];if(o.supports(e))return this._eventNameToPlugin.set(e,o),o}throw new Error(`No event manager plugin found for event ${e}`)}}return n.\u0275fac=function(e){return new(e||n)(D(Ml),D(Y))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();class jg{constructor(t){this._doc=t}addGlobalEventListener(t,e,i){const r=Oi().getGlobalEventTarget(this._doc,t);if(!r)throw new Error(`Unsupported event target ${r} for event ${e}`);return this.addEventListener(r,e,i)}}let E0=(()=&gt;{class n{constructor(){this._stylesSet=new Set}addStyles(e){const i=new Set;e.forEach(r=&gt;{this._stylesSet.has(r)||(this._stylesSet.add(r),i.add(r))}),this.onStylesAdded(i)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),Al=(()=&gt;{class n extends E0{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,i,r){e.forEach(s=&gt;{const o=this._doc.createElement(&quot;style&quot;);o.textContent=s,r.push(i.appendChild(o))})}addHost(e){const i=[];this._addStylesToHost(this._stylesSet,e,i),this._hostNodes.set(e,i)}removeHost(e){const i=this._hostNodes.get(e);i&amp;&amp;i.forEach(S0),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((i,r)=&gt;{this._addStylesToHost(e,r,i)})}ngOnDestroy(){this._hostNodes.forEach(e=&gt;e.forEach(S0))}}return n.\u0275fac=function(e){return new(e||n)(D(W))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();function S0(n){Oi().remove(n)}const Bg={svg:&quot;http://www.w3.org/2000/svg&quot;,xhtml:&quot;http://www.w3.org/1999/xhtml&quot;,xlink:&quot;http://www.w3.org/1999/xlink&quot;,xml:&quot;http://www.w3.org/XML/1998/namespace&quot;,xmlns:&quot;http://www.w3.org/2000/xmlns/&quot;},Ug=/%COMP%/g;function nd(n,t,e){for(let i=0;i&lt;t.length;i++){let r=t[i];Array.isArray(r)?nd(n,r,e):(r=r.replace(Ug,n),e.push(r))}return e}function A0(n){return t=&gt;{if(&quot;__ngUnwrap__&quot;===t)return n;!1===n(t)&amp;&amp;(t.preventDefault(),t.returnValue=!1)}}let id=(()=&gt;{class n{constructor(e,i,r){this.eventManager=e,this.sharedStylesHost=i,this.appId=r,this.rendererByCompId=new Map,this.defaultRenderer=new Hg(e)}createRenderer(e,i){if(!e||!i)return this.defaultRenderer;switch(i.encapsulation){case ut.Emulated:{let r=this.rendererByCompId.get(i.id);return r||(r=new $j(this.eventManager,this.sharedStylesHost,i,this.appId),this.rendererByCompId.set(i.id,r)),r.applyToHost(e),r}case 1:case ut.ShadowDom:return new Gj(this.eventManager,this.sharedStylesHost,e,i);default:if(!this.rendererByCompId.has(i.id)){const r=nd(i.id,i.styles,[]);this.sharedStylesHost.addStyles(r),this.rendererByCompId.set(i.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return n.\u0275fac=function(e){return new(e||n)(D(td),D(Al),D(vl))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();class Hg{constructor(t){this.eventManager=t,this.data=Object.create(null)}destroy(){}createElement(t,e){return e?document.createElementNS(Bg[e]||e,t):document.createElement(t)}createComment(t){return document.createComment(t)}createText(t){return document.createTextNode(t)}appendChild(t,e){t.appendChild(e)}insertBefore(t,e,i){t&amp;&amp;t.insertBefore(e,i)}removeChild(t,e){t&amp;&amp;t.removeChild(e)}selectRootElement(t,e){let i=&quot;string&quot;==typeof t?document.querySelector(t):t;if(!i)throw new Error(`The selector &quot;${t}&quot; did not match any elements`);return e||(i.textContent=&quot;&quot;),i}parentNode(t){return t.parentNode}nextSibling(t){return t.nextSibling}setAttribute(t,e,i,r){if(r){e=r+&quot;:&quot;+e;const s=Bg[r];s?t.setAttributeNS(s,e,i):t.setAttribute(e,i)}else t.setAttribute(e,i)}removeAttribute(t,e,i){if(i){const r=Bg[i];r?t.removeAttributeNS(r,e):t.removeAttribute(`${i}:${e}`)}else t.removeAttribute(e)}addClass(t,e){t.classList.add(e)}removeClass(t,e){t.classList.remove(e)}setStyle(t,e,i,r){r&amp;(_n.DashCase|_n.Important)?t.style.setProperty(e,i,r&amp;_n.Important?&quot;important&quot;:&quot;&quot;):t.style[e]=i}removeStyle(t,e,i){i&amp;_n.DashCase?t.style.removeProperty(e):t.style[e]=&quot;&quot;}setProperty(t,e,i){t[e]=i}setValue(t,e){t.nodeValue=e}listen(t,e,i){return&quot;string&quot;==typeof t?this.eventManager.addGlobalEventListener(t,e,A0(i)):this.eventManager.addEventListener(t,e,A0(i))}}class $j extends Hg{constructor(t,e,i,r){super(t),this.component=i;const s=nd(r+&quot;-&quot;+i.id,i.styles,[]);e.addStyles(s),this.contentAttr=function(n){return&quot;_ngcontent-%COMP%&quot;.replace(Ug,n)}(r+&quot;-&quot;+i.id),this.hostAttr=function(n){return&quot;_nghost-%COMP%&quot;.replace(Ug,n)}(r+&quot;-&quot;+i.id)}applyToHost(t){super.setAttribute(t,this.hostAttr,&quot;&quot;)}createElement(t,e){const i=super.createElement(t,e);return super.setAttribute(i,this.contentAttr,&quot;&quot;),i}}class Gj extends Hg{constructor(t,e,i,r){super(t),this.sharedStylesHost=e,this.hostEl=i,this.shadowRoot=i.attachShadow({mode:&quot;open&quot;}),this.sharedStylesHost.addHost(this.shadowRoot);const s=nd(r.id,r.styles,[]);for(let o=0;o&lt;s.length;o++){const a=document.createElement(&quot;style&quot;);a.textContent=s[o],this.shadowRoot.appendChild(a)}}nodeOrShadowRoot(t){return t===this.hostEl?this.shadowRoot:t}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(t,e){return super.appendChild(this.nodeOrShadowRoot(t),e)}insertBefore(t,e,i){return super.insertBefore(this.nodeOrShadowRoot(t),e,i)}removeChild(t,e){return super.removeChild(this.nodeOrShadowRoot(t),e)}parentNode(t){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)))}}let Wj=(()=&gt;{class n extends jg{constructor(e){super(e)}supports(e){return!0}addEventListener(e,i,r){return e.addEventListener(i,r,!1),()=&gt;this.removeEventListener(e,i,r)}removeEventListener(e,i,r){return e.removeEventListener(i,r)}}return n.\u0275fac=function(e){return new(e||n)(D(W))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const x0=[&quot;alt&quot;,&quot;control&quot;,&quot;meta&quot;,&quot;shift&quot;],Xj={&quot;\b&quot;:&quot;Backspace&quot;,&quot;\t&quot;:&quot;Tab&quot;,&quot;\x7f&quot;:&quot;Delete&quot;,&quot;\x1b&quot;:&quot;Escape&quot;,Del:&quot;Delete&quot;,Esc:&quot;Escape&quot;,Left:&quot;ArrowLeft&quot;,Right:&quot;ArrowRight&quot;,Up:&quot;ArrowUp&quot;,Down:&quot;ArrowDown&quot;,Menu:&quot;ContextMenu&quot;,Scroll:&quot;ScrollLock&quot;,Win:&quot;OS&quot;},R0={A:&quot;1&quot;,B:&quot;2&quot;,C:&quot;3&quot;,D:&quot;4&quot;,E:&quot;5&quot;,F:&quot;6&quot;,G:&quot;7&quot;,H:&quot;8&quot;,I:&quot;9&quot;,J:&quot;*&quot;,K:&quot;+&quot;,M:&quot;-&quot;,N:&quot;.&quot;,O:&quot;/&quot;,&quot;`&quot;:&quot;0&quot;,&quot;\x90&quot;:&quot;NumLock&quot;},eB={alt:n=&gt;n.altKey,control:n=&gt;n.ctrlKey,meta:n=&gt;n.metaKey,shift:n=&gt;n.shiftKey};let tB=(()=&gt;{class n extends jg{constructor(e){super(e)}supports(e){return null!=n.parseEventName(e)}addEventListener(e,i,r){const s=n.parseEventName(i),o=n.eventCallback(s.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=&gt;Oi().onAndCancel(e,s.domEventName,o))}static parseEventName(e){const i=e.toLowerCase().split(&quot;.&quot;),r=i.shift();if(0===i.length||&quot;keydown&quot;!==r&amp;&amp;&quot;keyup&quot;!==r)return null;const s=n._normalizeKey(i.pop());let o=&quot;&quot;;if(x0.forEach(l=&gt;{const c=i.indexOf(l);c&gt;-1&amp;&amp;(i.splice(c,1),o+=l+&quot;.&quot;)}),o+=s,0!=i.length||0===s.length)return null;const a={};return a.domEventName=r,a.fullKey=o,a}static getEventFullKey(e){let i=&quot;&quot;,r=function(n){let t=n.key;if(null==t){if(t=n.keyIdentifier,null==t)return&quot;Unidentified&quot;;t.startsWith(&quot;U+&quot;)&amp;&amp;(t=String.fromCharCode(parseInt(t.substring(2),16)),3===n.location&amp;&amp;R0.hasOwnProperty(t)&amp;&amp;(t=R0[t]))}return Xj[t]||t}(e);return r=r.toLowerCase(),&quot; &quot;===r?r=&quot;space&quot;:&quot;.&quot;===r&amp;&amp;(r=&quot;dot&quot;),x0.forEach(s=&gt;{s!=r&amp;&amp;eB[s](e)&amp;&amp;(i+=s+&quot;.&quot;)}),i+=r,i}static eventCallback(e,i,r){return s=&gt;{n.getEventFullKey(s)===e&amp;&amp;r.runGuarded(()=&gt;i(s))}}static _normalizeKey(e){switch(e){case&quot;esc&quot;:return&quot;escape&quot;;default:return e}}}return n.\u0275fac=function(e){return new(e||n)(D(W))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const cB=CE(JV,&quot;browser&quot;,[{provide:Rr,useValue:v0},{provide:dE,useValue:function(){Vg.makeCurrent(),Lg.init()},multi:!0},{provide:W,useFactory:function(){return function(n){Hh=n}(document),document},deps:[]}]),uB=[[],{provide:Ya,useValue:&quot;root&quot;},{provide:ls,useFactory:function(){return new ls},deps:[]},{provide:Ml,useClass:Wj,multi:!0,deps:[W,Y,Rr]},{provide:Ml,useClass:tB,multi:!0,deps:[W]},[],{provide:id,useClass:id,deps:[td,Al,vl]},{provide:hs,useExisting:id},{provide:E0,useExisting:Al},{provide:Al,useClass:Al,deps:[W]},{provide:ng,useClass:ng,deps:[Y]},{provide:td,useClass:td,deps:[Ml,Y]},{provide:C0,useClass:Tj,deps:[]},[]];let Wg=(()=&gt;{class n{constructor(e){if(e)throw new Error(&quot;BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.&quot;)}static withServerTransition(e){return{ngModule:n,providers:[{provide:vl,useValue:e.appId},{provide:D0,useExisting:vl},Aj]}}}return n.\u0275fac=function(e){return new(e||n)(D(n,12))},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:uB,imports:[Ko,sL]}),n})();function G(...n){let t=n[n.length-1];return $s(t)?(n.pop(),kh(n,t)):Mh(n)}function Qo(n,t){return Tt(n,t,1)}function cn(n,t){return function(i){return i.lift(new yB(n,t))}}&quot;undefined&quot;!=typeof window&amp;&amp;window;class yB{constructor(t,e){this.predicate=t,this.thisArg=e}call(t,e){return e.subscribe(new vB(t,this.predicate,this.thisArg))}}class vB extends xe{constructor(t,e,i){super(t),this.predicate=e,this.thisArg=i,this.count=0}_next(t){let e;try{e=this.predicate.call(this.thisArg,t,this.count++)}catch(i){return void this.destination.error(i)}e&amp;&amp;this.destination.next(t)}}class O0{}class F0{}class Ct{constructor(t){this.normalizedNames=new Map,this.lazyUpdate=null,t?this.lazyInit=&quot;string&quot;==typeof t?()=&gt;{this.headers=new Map,t.split(&quot;\n&quot;).forEach(e=&gt;{const i=e.indexOf(&quot;:&quot;);if(i&gt;0){const r=e.slice(0,i),s=r.toLowerCase(),o=e.slice(i+1).trim();this.maybeSetNormalizedName(r,s),this.headers.has(s)?this.headers.get(s).push(o):this.headers.set(s,[o])}})}:()=&gt;{this.headers=new Map,Object.keys(t).forEach(e=&gt;{let i=t[e];const r=e.toLowerCase();&quot;string&quot;==typeof i&amp;&amp;(i=[i]),i.length&gt;0&amp;&amp;(this.headers.set(r,i),this.maybeSetNormalizedName(e,r))})}:this.headers=new Map}has(t){return this.init(),this.headers.has(t.toLowerCase())}get(t){this.init();const e=this.headers.get(t.toLowerCase());return e&amp;&amp;e.length&gt;0?e[0]:null}keys(){return this.init(),Array.from(this.normalizedNames.values())}getAll(t){return this.init(),this.headers.get(t.toLowerCase())||null}append(t,e){return this.clone({name:t,value:e,op:&quot;a&quot;})}set(t,e){return this.clone({name:t,value:e,op:&quot;s&quot;})}delete(t,e){return this.clone({name:t,value:e,op:&quot;d&quot;})}maybeSetNormalizedName(t,e){this.normalizedNames.has(e)||this.normalizedNames.set(e,t)}init(){this.lazyInit&amp;&amp;(this.lazyInit instanceof Ct?this.copyFrom(this.lazyInit):this.lazyInit(),this.lazyInit=null,this.lazyUpdate&amp;&amp;(this.lazyUpdate.forEach(t=&gt;this.applyUpdate(t)),this.lazyUpdate=null))}copyFrom(t){t.init(),Array.from(t.headers.keys()).forEach(e=&gt;{this.headers.set(e,t.headers.get(e)),this.normalizedNames.set(e,t.normalizedNames.get(e))})}clone(t){const e=new Ct;return e.lazyInit=this.lazyInit&amp;&amp;this.lazyInit instanceof Ct?this.lazyInit:this,e.lazyUpdate=(this.lazyUpdate||[]).concat([t]),e}applyUpdate(t){const e=t.name.toLowerCase();switch(t.op){case&quot;a&quot;:case&quot;s&quot;:let i=t.value;if(&quot;string&quot;==typeof i&amp;&amp;(i=[i]),0===i.length)return;this.maybeSetNormalizedName(t.name,e);const r=(&quot;a&quot;===t.op?this.headers.get(e):void 0)||[];r.push(...i),this.headers.set(e,r);break;case&quot;d&quot;:const s=t.value;if(s){let o=this.headers.get(e);if(!o)return;o=o.filter(a=&gt;-1===s.indexOf(a)),0===o.length?(this.headers.delete(e),this.normalizedNames.delete(e)):this.headers.set(e,o)}else this.headers.delete(e),this.normalizedNames.delete(e)}}forEach(t){this.init(),Array.from(this.normalizedNames.keys()).forEach(e=&gt;t(this.normalizedNames.get(e),this.headers.get(e)))}}class bB{encodeKey(t){return N0(t)}encodeValue(t){return N0(t)}decodeKey(t){return decodeURIComponent(t)}decodeValue(t){return decodeURIComponent(t)}}const DB=/%(\d[a-f0-9])/gi,wB={40:&quot;@&quot;,&quot;3A&quot;:&quot;:&quot;,24:&quot;$&quot;,&quot;2C&quot;:&quot;,&quot;,&quot;3B&quot;:&quot;;&quot;,&quot;2B&quot;:&quot;+&quot;,&quot;3D&quot;:&quot;=&quot;,&quot;3F&quot;:&quot;?&quot;,&quot;2F&quot;:&quot;/&quot;};function N0(n){return encodeURIComponent(n).replace(DB,(t,e)=&gt;{var i;return null!==(i=wB[e])&amp;&amp;void 0!==i?i:t})}function V0(n){return`${n}`}class Nr{constructor(t={}){if(this.updates=null,this.cloneFrom=null,this.encoder=t.encoder||new bB,t.fromString){if(t.fromObject)throw new Error(&quot;Cannot specify both fromString and fromObject.&quot;);this.map=function(n,t){const e=new Map;return n.length&gt;0&amp;&amp;n.replace(/^\?/,&quot;&quot;).split(&quot;&amp;&quot;).forEach(r=&gt;{const s=r.indexOf(&quot;=&quot;),[o,a]=-1==s?[t.decodeKey(r),&quot;&quot;]:[t.decodeKey(r.slice(0,s)),t.decodeValue(r.slice(s+1))],l=e.get(o)||[];l.push(a),e.set(o,l)}),e}(t.fromString,this.encoder)}else t.fromObject?(this.map=new Map,Object.keys(t.fromObject).forEach(e=&gt;{const i=t.fromObject[e];this.map.set(e,Array.isArray(i)?i:[i])})):this.map=null}has(t){return this.init(),this.map.has(t)}get(t){this.init();const e=this.map.get(t);return e?e[0]:null}getAll(t){return this.init(),this.map.get(t)||null}keys(){return this.init(),Array.from(this.map.keys())}append(t,e){return this.clone({param:t,value:e,op:&quot;a&quot;})}appendAll(t){const e=[];return Object.keys(t).forEach(i=&gt;{const r=t[i];Array.isArray(r)?r.forEach(s=&gt;{e.push({param:i,value:s,op:&quot;a&quot;})}):e.push({param:i,value:r,op:&quot;a&quot;})}),this.clone(e)}set(t,e){return this.clone({param:t,value:e,op:&quot;s&quot;})}delete(t,e){return this.clone({param:t,value:e,op:&quot;d&quot;})}toString(){return this.init(),this.keys().map(t=&gt;{const e=this.encoder.encodeKey(t);return this.map.get(t).map(i=&gt;e+&quot;=&quot;+this.encoder.encodeValue(i)).join(&quot;&amp;&quot;)}).filter(t=&gt;&quot;&quot;!==t).join(&quot;&amp;&quot;)}clone(t){const e=new Nr({encoder:this.encoder});return e.cloneFrom=this.cloneFrom||this,e.updates=(this.updates||[]).concat(t),e}init(){null===this.map&amp;&amp;(this.map=new Map),null!==this.cloneFrom&amp;&amp;(this.cloneFrom.init(),this.cloneFrom.keys().forEach(t=&gt;this.map.set(t,this.cloneFrom.map.get(t))),this.updates.forEach(t=&gt;{switch(t.op){case&quot;a&quot;:case&quot;s&quot;:const e=(&quot;a&quot;===t.op?this.map.get(t.param):void 0)||[];e.push(V0(t.value)),this.map.set(t.param,e);break;case&quot;d&quot;:if(void 0===t.value){this.map.delete(t.param);break}{let i=this.map.get(t.param)||[];const r=i.indexOf(V0(t.value));-1!==r&amp;&amp;i.splice(r,1),i.length&gt;0?this.map.set(t.param,i):this.map.delete(t.param)}}}),this.cloneFrom=this.updates=null)}}class EB{constructor(){this.map=new Map}set(t,e){return this.map.set(t,e),this}get(t){return this.map.has(t)||this.map.set(t,t.defaultValue()),this.map.get(t)}delete(t){return this.map.delete(t),this}keys(){return this.map.keys()}}function L0(n){return&quot;undefined&quot;!=typeof ArrayBuffer&amp;&amp;n instanceof ArrayBuffer}function j0(n){return&quot;undefined&quot;!=typeof Blob&amp;&amp;n instanceof Blob}function B0(n){return&quot;undefined&quot;!=typeof FormData&amp;&amp;n instanceof FormData}class Tl{constructor(t,e,i,r){let s;if(this.url=e,this.body=null,this.reportProgress=!1,this.withCredentials=!1,this.responseType=&quot;json&quot;,this.method=t.toUpperCase(),function(n){switch(n){case&quot;DELETE&quot;:case&quot;GET&quot;:case&quot;HEAD&quot;:case&quot;OPTIONS&quot;:case&quot;JSONP&quot;:return!1;default:return!0}}(this.method)||r?(this.body=void 0!==i?i:null,s=r):s=i,s&amp;&amp;(this.reportProgress=!!s.reportProgress,this.withCredentials=!!s.withCredentials,s.responseType&amp;&amp;(this.responseType=s.responseType),s.headers&amp;&amp;(this.headers=s.headers),s.context&amp;&amp;(this.context=s.context),s.params&amp;&amp;(this.params=s.params)),this.headers||(this.headers=new Ct),this.context||(this.context=new EB),this.params){const o=this.params.toString();if(0===o.length)this.urlWithParams=e;else{const a=e.indexOf(&quot;?&quot;);this.urlWithParams=e+(-1===a?&quot;?&quot;:a&lt;e.length-1?&quot;&amp;&quot;:&quot;&quot;)+o}}else this.params=new Nr,this.urlWithParams=e}serializeBody(){return null===this.body?null:L0(this.body)||j0(this.body)||B0(this.body)||function(n){return&quot;undefined&quot;!=typeof URLSearchParams&amp;&amp;n instanceof URLSearchParams}(this.body)||&quot;string&quot;==typeof this.body?this.body:this.body instanceof Nr?this.body.toString():&quot;object&quot;==typeof this.body||&quot;boolean&quot;==typeof this.body||Array.isArray(this.body)?JSON.stringify(this.body):this.body.toString()}detectContentTypeHeader(){return null===this.body||B0(this.body)?null:j0(this.body)?this.body.type||null:L0(this.body)?null:&quot;string&quot;==typeof this.body?&quot;text/plain&quot;:this.body instanceof Nr?&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;:&quot;object&quot;==typeof this.body||&quot;number&quot;==typeof this.body||&quot;boolean&quot;==typeof this.body?&quot;application/json&quot;:null}clone(t={}){var e;const i=t.method||this.method,r=t.url||this.url,s=t.responseType||this.responseType,o=void 0!==t.body?t.body:this.body,a=void 0!==t.withCredentials?t.withCredentials:this.withCredentials,l=void 0!==t.reportProgress?t.reportProgress:this.reportProgress;let c=t.headers||this.headers,u=t.params||this.params;const f=null!==(e=t.context)&amp;&amp;void 0!==e?e:this.context;return void 0!==t.setHeaders&amp;&amp;(c=Object.keys(t.setHeaders).reduce((p,g)=&gt;p.set(g,t.setHeaders[g]),c)),t.setParams&amp;&amp;(u=Object.keys(t.setParams).reduce((p,g)=&gt;p.set(g,t.setParams[g]),u)),new Tl(i,r,o,{params:u,headers:c,context:f,reportProgress:l,responseType:s,withCredentials:a})}}var gt=(()=&gt;((gt=gt||{})[gt.Sent=0]=&quot;Sent&quot;,gt[gt.UploadProgress=1]=&quot;UploadProgress&quot;,gt[gt.ResponseHeader=2]=&quot;ResponseHeader&quot;,gt[gt.DownloadProgress=3]=&quot;DownloadProgress&quot;,gt[gt.Response=4]=&quot;Response&quot;,gt[gt.User=5]=&quot;User&quot;,gt))();class Yg{constructor(t,e=200,i=&quot;OK&quot;){this.headers=t.headers||new Ct,this.status=void 0!==t.status?t.status:e,this.statusText=t.statusText||i,this.url=t.url||null,this.ok=this.status&gt;=200&amp;&amp;this.status&lt;300}}class Kg extends Yg{constructor(t={}){super(t),this.type=gt.ResponseHeader}clone(t={}){return new Kg({headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class rd extends Yg{constructor(t={}){super(t),this.type=gt.Response,this.body=void 0!==t.body?t.body:null}clone(t={}){return new rd({body:void 0!==t.body?t.body:this.body,headers:t.headers||this.headers,status:void 0!==t.status?t.status:this.status,statusText:t.statusText||this.statusText,url:t.url||this.url||void 0})}}class U0 extends Yg{constructor(t){super(t,0,&quot;Unknown Error&quot;),this.name=&quot;HttpErrorResponse&quot;,this.ok=!1,this.message=this.status&gt;=200&amp;&amp;this.status&lt;300?`Http failure during parsing for ${t.url||&quot;(unknown url)&quot;}`:`Http failure response for ${t.url||&quot;(unknown url)&quot;}: ${t.status} ${t.statusText}`,this.error=t.error||null}}function Qg(n,t){return{body:t,headers:n.headers,context:n.context,observe:n.observe,params:n.params,reportProgress:n.reportProgress,responseType:n.responseType,withCredentials:n.withCredentials}}let Zo=(()=&gt;{class n{constructor(e){this.handler=e}request(e,i,r={}){let s;if(e instanceof Tl)s=e;else{let l,c;l=r.headers instanceof Ct?r.headers:new Ct(r.headers),r.params&amp;&amp;(c=r.params instanceof Nr?r.params:new Nr({fromObject:r.params})),s=new Tl(e,i,void 0!==r.body?r.body:null,{headers:l,context:r.context,params:c,reportProgress:r.reportProgress,responseType:r.responseType||&quot;json&quot;,withCredentials:r.withCredentials})}const o=G(s).pipe(Qo(l=&gt;this.handler.handle(l)));if(e instanceof Tl||&quot;events&quot;===r.observe)return o;const a=o.pipe(cn(l=&gt;l instanceof rd));switch(r.observe||&quot;body&quot;){case&quot;body&quot;:switch(s.responseType){case&quot;arraybuffer&quot;:return a.pipe(pe(l=&gt;{if(null!==l.body&amp;&amp;!(l.body instanceof ArrayBuffer))throw new Error(&quot;Response is not an ArrayBuffer.&quot;);return l.body}));case&quot;blob&quot;:return a.pipe(pe(l=&gt;{if(null!==l.body&amp;&amp;!(l.body instanceof Blob))throw new Error(&quot;Response is not a Blob.&quot;);return l.body}));case&quot;text&quot;:return a.pipe(pe(l=&gt;{if(null!==l.body&amp;&amp;&quot;string&quot;!=typeof l.body)throw new Error(&quot;Response is not a string.&quot;);return l.body}));case&quot;json&quot;:default:return a.pipe(pe(l=&gt;l.body))}case&quot;response&quot;:return a;default:throw new Error(`Unreachable: unhandled observe type ${r.observe}}`)}}delete(e,i={}){return this.request(&quot;DELETE&quot;,e,i)}get(e,i={}){return this.request(&quot;GET&quot;,e,i)}head(e,i={}){return this.request(&quot;HEAD&quot;,e,i)}jsonp(e,i){return this.request(&quot;JSONP&quot;,e,{params:(new Nr).append(i,&quot;JSONP_CALLBACK&quot;),observe:&quot;body&quot;,responseType:&quot;json&quot;})}options(e,i={}){return this.request(&quot;OPTIONS&quot;,e,i)}patch(e,i,r={}){return this.request(&quot;PATCH&quot;,e,Qg(r,i))}post(e,i,r={}){return this.request(&quot;POST&quot;,e,Qg(r,i))}put(e,i,r={}){return this.request(&quot;PUT&quot;,e,Qg(r,i))}}return n.\u0275fac=function(e){return new(e||n)(D(O0))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();class H0{constructor(t,e){this.next=t,this.interceptor=e}handle(t){return this.interceptor.intercept(t,this.next)}}const z0=new j(&quot;HTTP_INTERCEPTORS&quot;);let MB=(()=&gt;{class n{intercept(e,i){return i.handle(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const AB=/^\)\]\}&#39;,?\n/;let $0=(()=&gt;{class n{constructor(e){this.xhrFactory=e}handle(e){if(&quot;JSONP&quot;===e.method)throw new Error(&quot;Attempted to construct Jsonp request without HttpClientJsonpModule installed.&quot;);return new ye(i=&gt;{const r=this.xhrFactory.build();if(r.open(e.method,e.urlWithParams),e.withCredentials&amp;&amp;(r.withCredentials=!0),e.headers.forEach((g,m)=&gt;r.setRequestHeader(g,m.join(&quot;,&quot;))),e.headers.has(&quot;Accept&quot;)||r.setRequestHeader(&quot;Accept&quot;,&quot;application/json, text/plain, */*&quot;),!e.headers.has(&quot;Content-Type&quot;)){const g=e.detectContentTypeHeader();null!==g&amp;&amp;r.setRequestHeader(&quot;Content-Type&quot;,g)}if(e.responseType){const g=e.responseType.toLowerCase();r.responseType=&quot;json&quot;!==g?g:&quot;text&quot;}const s=e.serializeBody();let o=null;const a=()=&gt;{if(null!==o)return o;const g=1223===r.status?204:r.status,m=r.statusText||&quot;OK&quot;,C=new Ct(r.getAllResponseHeaders()),v=function(n){return&quot;responseURL&quot;in n&amp;&amp;n.responseURL?n.responseURL:/^X-Request-URL:/m.test(n.getAllResponseHeaders())?n.getResponseHeader(&quot;X-Request-URL&quot;):null}(r)||e.url;return o=new Kg({headers:C,status:g,statusText:m,url:v}),o},l=()=&gt;{let{headers:g,status:m,statusText:C,url:v}=a(),S=null;204!==m&amp;&amp;(S=void 0===r.response?r.responseText:r.response),0===m&amp;&amp;(m=S?200:0);let E=m&gt;=200&amp;&amp;m&lt;300;if(&quot;json&quot;===e.responseType&amp;&amp;&quot;string&quot;==typeof S){const R=S;S=S.replace(AB,&quot;&quot;);try{S=&quot;&quot;!==S?JSON.parse(S):null}catch(F){S=R,E&amp;&amp;(E=!1,S={error:F,text:S})}}E?(i.next(new rd({body:S,headers:g,status:m,statusText:C,url:v||void 0})),i.complete()):i.error(new U0({error:S,headers:g,status:m,statusText:C,url:v||void 0}))},c=g=&gt;{const{url:m}=a(),C=new U0({error:g,status:r.status||0,statusText:r.statusText||&quot;Unknown Error&quot;,url:m||void 0});i.error(C)};let u=!1;const f=g=&gt;{u||(i.next(a()),u=!0);let m={type:gt.DownloadProgress,loaded:g.loaded};g.lengthComputable&amp;&amp;(m.total=g.total),&quot;text&quot;===e.responseType&amp;&amp;!!r.responseText&amp;&amp;(m.partialText=r.responseText),i.next(m)},p=g=&gt;{let m={type:gt.UploadProgress,loaded:g.loaded};g.lengthComputable&amp;&amp;(m.total=g.total),i.next(m)};return r.addEventListener(&quot;load&quot;,l),r.addEventListener(&quot;error&quot;,c),r.addEventListener(&quot;timeout&quot;,c),r.addEventListener(&quot;abort&quot;,c),e.reportProgress&amp;&amp;(r.addEventListener(&quot;progress&quot;,f),null!==s&amp;&amp;r.upload&amp;&amp;r.upload.addEventListener(&quot;progress&quot;,p)),r.send(s),i.next({type:gt.Sent}),()=&gt;{r.removeEventListener(&quot;error&quot;,c),r.removeEventListener(&quot;abort&quot;,c),r.removeEventListener(&quot;load&quot;,l),r.removeEventListener(&quot;timeout&quot;,c),e.reportProgress&amp;&amp;(r.removeEventListener(&quot;progress&quot;,f),null!==s&amp;&amp;r.upload&amp;&amp;r.upload.removeEventListener(&quot;progress&quot;,p)),r.readyState!==r.DONE&amp;&amp;r.abort()}})}}return n.\u0275fac=function(e){return new(e||n)(D(C0))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const Zg=new j(&quot;XSRF_COOKIE_NAME&quot;),Jg=new j(&quot;XSRF_HEADER_NAME&quot;);class G0{}let IB=(()=&gt;{class n{constructor(e,i,r){this.doc=e,this.platform=i,this.cookieName=r,this.lastCookieString=&quot;&quot;,this.lastToken=null,this.parseCount=0}getToken(){if(&quot;server&quot;===this.platform)return null;const e=this.doc.cookie||&quot;&quot;;return e!==this.lastCookieString&amp;&amp;(this.parseCount++,this.lastToken=h0(e,this.cookieName),this.lastCookieString=e),this.lastToken}}return n.\u0275fac=function(e){return new(e||n)(D(W),D(Rr),D(Zg))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),Xg=(()=&gt;{class n{constructor(e,i){this.tokenService=e,this.headerName=i}intercept(e,i){const r=e.url.toLowerCase();if(&quot;GET&quot;===e.method||&quot;HEAD&quot;===e.method||r.startsWith(&quot;http://&quot;)||r.startsWith(&quot;https://&quot;))return i.handle(e);const s=this.tokenService.getToken();return null!==s&amp;&amp;!e.headers.has(this.headerName)&amp;&amp;(e=e.clone({headers:e.headers.set(this.headerName,s)})),i.handle(e)}}return n.\u0275fac=function(e){return new(e||n)(D(G0),D(Jg))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),xB=(()=&gt;{class n{constructor(e,i){this.backend=e,this.injector=i,this.chain=null}handle(e){if(null===this.chain){const i=this.injector.get(z0,[]);this.chain=i.reduceRight((r,s)=&gt;new H0(r,s),this.backend)}return this.chain.handle(e)}}return n.\u0275fac=function(e){return new(e||n)(D(F0),D(ke))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),RB=(()=&gt;{class n{static disable(){return{ngModule:n,providers:[{provide:Xg,useClass:MB}]}}static withOptions(e={}){return{ngModule:n,providers:[e.cookieName?{provide:Zg,useValue:e.cookieName}:[],e.headerName?{provide:Jg,useValue:e.headerName}:[]]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[Xg,{provide:z0,useExisting:Xg,multi:!0},{provide:G0,useClass:IB},{provide:Zg,useValue:&quot;XSRF-TOKEN&quot;},{provide:Jg,useValue:&quot;X-XSRF-TOKEN&quot;}]}),n})(),PB=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[Zo,{provide:O0,useClass:xB},$0,{provide:F0,useExisting:$0}],imports:[[RB.withOptions({cookieName:&quot;XSRF-TOKEN&quot;,headerName:&quot;X-XSRF-TOKEN&quot;})]]}),n})();function sd(n,t){return new ye(e=&gt;{const i=n.length;if(0===i)return void e.complete();const r=new Array(i);let s=0,o=0;for(let a=0;a&lt;i;a++){const l=At(n[a]);let c=!1;e.add(l.subscribe({next:u=&gt;{c||(c=!0,o++),r[a]=u},error:u=&gt;e.error(u),complete:()=&gt;{s++,(s===i||!c)&amp;&amp;(o===i&amp;&amp;e.next(t?t.reduce((u,f,p)=&gt;(u[f]=r[p],u),{}):r),e.complete())}}))}})}let W0=(()=&gt;{class n{constructor(e,i){this._renderer=e,this._elementRef=i,this.onChange=r=&gt;{},this.onTouched=()=&gt;{}}setProperty(e,i){this._renderer.setProperty(this._elementRef.nativeElement,e,i)}registerOnTouched(e){this.onTouched=e}registerOnChange(e){this.onChange=e}setDisabledState(e){this.setProperty(&quot;disabled&quot;,e)}}return n.\u0275fac=function(e){return new(e||n)(_(nr),_(X))},n.\u0275dir=O({type:n}),n})(),bs=(()=&gt;{class n extends W0{}return n.\u0275fac=function(){let t;return function(i){return(t||(t=Et(n)))(i||n)}}(),n.\u0275dir=O({type:n,features:[se]}),n})();const Cn=new j(&quot;NgValueAccessor&quot;),NB={provide:Cn,useExisting:Fe(()=&gt;Bn),multi:!0},LB=new j(&quot;CompositionEventMode&quot;);let Bn=(()=&gt;{class n extends W0{constructor(e,i,r){super(e,i),this._compositionMode=r,this._composing=!1,null==this._compositionMode&amp;&amp;(this._compositionMode=!function(){const n=Oi()?Oi().getUserAgent():&quot;&quot;;return/android (\d+)/.test(n.toLowerCase())}())}writeValue(e){this.setProperty(&quot;value&quot;,null==e?&quot;&quot;:e)}_handleInput(e){(!this._compositionMode||this._compositionMode&amp;&amp;!this._composing)&amp;&amp;this.onChange(e)}_compositionStart(){this._composing=!0}_compositionEnd(e){this._composing=!1,this._compositionMode&amp;&amp;this.onChange(e)}}return n.\u0275fac=function(e){return new(e||n)(_(nr),_(X),_(LB,8))},n.\u0275dir=O({type:n,selectors:[[&quot;input&quot;,&quot;formControlName&quot;,&quot;&quot;,3,&quot;type&quot;,&quot;checkbox&quot;],[&quot;textarea&quot;,&quot;formControlName&quot;,&quot;&quot;],[&quot;input&quot;,&quot;formControl&quot;,&quot;&quot;,3,&quot;type&quot;,&quot;checkbox&quot;],[&quot;textarea&quot;,&quot;formControl&quot;,&quot;&quot;],[&quot;input&quot;,&quot;ngModel&quot;,&quot;&quot;,3,&quot;type&quot;,&quot;checkbox&quot;],[&quot;textarea&quot;,&quot;ngModel&quot;,&quot;&quot;],[&quot;&quot;,&quot;ngDefaultControl&quot;,&quot;&quot;]],hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;input&quot;,function(s){return i._handleInput(s.target.value)})(&quot;blur&quot;,function(){return i.onTouched()})(&quot;compositionstart&quot;,function(){return i._compositionStart()})(&quot;compositionend&quot;,function(s){return i._compositionEnd(s.target.value)})},features:[ce([NB]),se]}),n})();function Vr(n){return null==n||0===n.length}function Y0(n){return null!=n&amp;&amp;&quot;number&quot;==typeof n.length}const Dt=new j(&quot;NgValidators&quot;),Lr=new j(&quot;NgAsyncValidators&quot;),jB=/^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;class od{static min(t){return K0(t)}static max(t){return function(n){return t=&gt;{if(Vr(t.value)||Vr(n))return null;const e=parseFloat(t.value);return!isNaN(e)&amp;&amp;e&gt;n?{max:{max:n,actual:t.value}}:null}}(t)}static required(t){return function(n){return Vr(n.value)?{required:!0}:null}(t)}static requiredTrue(t){return function(n){return!0===n.value?null:{required:!0}}(t)}static email(t){return function(n){return Vr(n.value)||jB.test(n.value)?null:{email:!0}}(t)}static minLength(t){return function(n){return t=&gt;Vr(t.value)||!Y0(t.value)?null:t.value.length&lt;n?{minlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static maxLength(t){return function(n){return t=&gt;Y0(t.value)&amp;&amp;t.value.length&gt;n?{maxlength:{requiredLength:n,actualLength:t.value.length}}:null}(t)}static pattern(t){return function(n){if(!n)return jr;let t,e;return&quot;string&quot;==typeof n?(e=&quot;&quot;,&quot;^&quot;!==n.charAt(0)&amp;&amp;(e+=&quot;^&quot;),e+=n,&quot;$&quot;!==n.charAt(n.length-1)&amp;&amp;(e+=&quot;$&quot;),t=new RegExp(e)):(e=n.toString(),t=n),i=&gt;{if(Vr(i.value))return null;const r=i.value;return t.test(r)?null:{pattern:{requiredPattern:e,actualValue:r}}}}(t)}static nullValidator(t){return null}static compose(t){return lS(t)}static composeAsync(t){return cS(t)}}function K0(n){return t=&gt;{if(Vr(t.value)||Vr(n))return null;const e=parseFloat(t.value);return!isNaN(e)&amp;&amp;e&lt;n?{min:{min:n,actual:t.value}}:null}}function jr(n){return null}function iS(n){return null!=n}function rS(n){const t=tl(n)?At(n):n;return du(t),t}function sS(n){let t={};return n.forEach(e=&gt;{t=null!=e?Object.assign(Object.assign({},t),e):t}),0===Object.keys(t).length?null:t}function oS(n,t){return t.map(e=&gt;e(n))}function aS(n){return n.map(t=&gt;function(n){return!n.validate}(t)?t:e=&gt;t.validate(e))}function lS(n){if(!n)return null;const t=n.filter(iS);return 0==t.length?null:function(e){return sS(oS(e,t))}}function em(n){return null!=n?lS(aS(n)):null}function cS(n){if(!n)return null;const t=n.filter(iS);return 0==t.length?null:function(e){return function(...n){if(1===n.length){const t=n[0];if(zs(t))return sd(t,null);if(Eh(t)&amp;&amp;Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);return sd(e.map(i=&gt;t[i]),e)}}if(&quot;function&quot;==typeof n[n.length-1]){const t=n.pop();return sd(n=1===n.length&amp;&amp;zs(n[0])?n[0]:n,null).pipe(pe(e=&gt;t(...e)))}return sd(n,null)}(oS(e,t).map(rS)).pipe(pe(sS))}}function tm(n){return null!=n?cS(aS(n)):null}function uS(n,t){return null===n?[t]:Array.isArray(n)?[...n,t]:[n,t]}function dS(n){return n._rawValidators}function hS(n){return n._rawAsyncValidators}function nm(n){return n?Array.isArray(n)?n:[n]:[]}function ad(n,t){return Array.isArray(n)?n.includes(t):n===t}function fS(n,t){const e=nm(t);return nm(n).forEach(r=&gt;{ad(e,r)||e.push(r)}),e}function pS(n,t){return nm(t).filter(e=&gt;!ad(n,e))}let gS=(()=&gt;{class n{constructor(){this._rawValidators=[],this._rawAsyncValidators=[],this._onDestroyCallbacks=[]}get value(){return this.control?this.control.value:null}get valid(){return this.control?this.control.valid:null}get invalid(){return this.control?this.control.invalid:null}get pending(){return this.control?this.control.pending:null}get disabled(){return this.control?this.control.disabled:null}get enabled(){return this.control?this.control.enabled:null}get errors(){return this.control?this.control.errors:null}get pristine(){return this.control?this.control.pristine:null}get dirty(){return this.control?this.control.dirty:null}get touched(){return this.control?this.control.touched:null}get status(){return this.control?this.control.status:null}get untouched(){return this.control?this.control.untouched:null}get statusChanges(){return this.control?this.control.statusChanges:null}get valueChanges(){return this.control?this.control.valueChanges:null}get path(){return null}_setValidators(e){this._rawValidators=e||[],this._composedValidatorFn=em(this._rawValidators)}_setAsyncValidators(e){this._rawAsyncValidators=e||[],this._composedAsyncValidatorFn=tm(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn||null}get asyncValidator(){return this._composedAsyncValidatorFn||null}_registerOnDestroy(e){this._onDestroyCallbacks.push(e)}_invokeOnDestroyCallbacks(){this._onDestroyCallbacks.forEach(e=&gt;e()),this._onDestroyCallbacks=[]}reset(e){this.control&amp;&amp;this.control.reset(e)}hasError(e,i){return!!this.control&amp;&amp;this.control.hasError(e,i)}getError(e,i){return this.control?this.control.getError(e,i):null}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n}),n})(),Ht=(()=&gt;{class n extends gS{get formDirective(){return null}get path(){return null}}return n.\u0275fac=function(){let t;return function(i){return(t||(t=Et(n)))(i||n)}}(),n.\u0275dir=O({type:n,features:[se]}),n})();class Ni extends gS{constructor(){super(...arguments),this._parent=null,this.name=null,this.valueAccessor=null}}class mS{constructor(t){this._cd=t}is(t){var e,i,r;return&quot;submitted&quot;===t?!!(null===(e=this._cd)||void 0===e?void 0:e.submitted):!!(null===(r=null===(i=this._cd)||void 0===i?void 0:i.control)||void 0===r?void 0:r[t])}}let Vi=(()=&gt;{class n extends mS{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(_(Ni,2))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;formControlName&quot;,&quot;&quot;],[&quot;&quot;,&quot;ngModel&quot;,&quot;&quot;],[&quot;&quot;,&quot;formControl&quot;,&quot;&quot;]],hostVars:14,hostBindings:function(e,i){2&amp;e&amp;&amp;Me(&quot;ng-untouched&quot;,i.is(&quot;untouched&quot;))(&quot;ng-touched&quot;,i.is(&quot;touched&quot;))(&quot;ng-pristine&quot;,i.is(&quot;pristine&quot;))(&quot;ng-dirty&quot;,i.is(&quot;dirty&quot;))(&quot;ng-valid&quot;,i.is(&quot;valid&quot;))(&quot;ng-invalid&quot;,i.is(&quot;invalid&quot;))(&quot;ng-pending&quot;,i.is(&quot;pending&quot;))},features:[se]}),n})(),Jo=(()=&gt;{class n extends mS{constructor(e){super(e)}}return n.\u0275fac=function(e){return new(e||n)(_(Ht,10))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;formGroupName&quot;,&quot;&quot;],[&quot;&quot;,&quot;formArrayName&quot;,&quot;&quot;],[&quot;&quot;,&quot;ngModelGroup&quot;,&quot;&quot;],[&quot;&quot;,&quot;formGroup&quot;,&quot;&quot;],[&quot;form&quot;,3,&quot;ngNoForm&quot;,&quot;&quot;],[&quot;&quot;,&quot;ngForm&quot;,&quot;&quot;]],hostVars:16,hostBindings:function(e,i){2&amp;e&amp;&amp;Me(&quot;ng-untouched&quot;,i.is(&quot;untouched&quot;))(&quot;ng-touched&quot;,i.is(&quot;touched&quot;))(&quot;ng-pristine&quot;,i.is(&quot;pristine&quot;))(&quot;ng-dirty&quot;,i.is(&quot;dirty&quot;))(&quot;ng-valid&quot;,i.is(&quot;valid&quot;))(&quot;ng-invalid&quot;,i.is(&quot;invalid&quot;))(&quot;ng-pending&quot;,i.is(&quot;pending&quot;))(&quot;ng-submitted&quot;,i.is(&quot;submitted&quot;))},features:[se]}),n})();function cd(n,t){return[...t.path,n]}function Il(n,t){sm(n,t),t.valueAccessor.writeValue(n.value),function(n,t){t.valueAccessor.registerOnChange(e=&gt;{n._pendingValue=e,n._pendingChange=!0,n._pendingDirty=!0,&quot;change&quot;===n.updateOn&amp;&amp;_S(n,t)})}(n,t),function(n,t){const e=(i,r)=&gt;{t.valueAccessor.writeValue(i),r&amp;&amp;t.viewToModelUpdate(i)};n.registerOnChange(e),t._registerOnDestroy(()=&gt;{n._unregisterOnChange(e)})}(n,t),function(n,t){t.valueAccessor.registerOnTouched(()=&gt;{n._pendingTouched=!0,&quot;blur&quot;===n.updateOn&amp;&amp;n._pendingChange&amp;&amp;_S(n,t),&quot;submit&quot;!==n.updateOn&amp;&amp;n.markAsTouched()})}(n,t),function(n,t){if(t.valueAccessor.setDisabledState){const e=i=&gt;{t.valueAccessor.setDisabledState(i)};n.registerOnDisabledChange(e),t._registerOnDestroy(()=&gt;{n._unregisterOnDisabledChange(e)})}}(n,t)}function ud(n,t,e=!0){const i=()=&gt;{};t.valueAccessor&amp;&amp;(t.valueAccessor.registerOnChange(i),t.valueAccessor.registerOnTouched(i)),hd(n,t),n&amp;&amp;(t._invokeOnDestroyCallbacks(),n._registerOnCollectionChange(()=&gt;{}))}function dd(n,t){n.forEach(e=&gt;{e.registerOnValidatorChange&amp;&amp;e.registerOnValidatorChange(t)})}function sm(n,t){const e=dS(n);null!==t.validator?n.setValidators(uS(e,t.validator)):&quot;function&quot;==typeof e&amp;&amp;n.setValidators([e]);const i=hS(n);null!==t.asyncValidator?n.setAsyncValidators(uS(i,t.asyncValidator)):&quot;function&quot;==typeof i&amp;&amp;n.setAsyncValidators([i]);const r=()=&gt;n.updateValueAndValidity();dd(t._rawValidators,r),dd(t._rawAsyncValidators,r)}function hd(n,t){let e=!1;if(null!==n){if(null!==t.validator){const r=dS(n);if(Array.isArray(r)&amp;&amp;r.length&gt;0){const s=r.filter(o=&gt;o!==t.validator);s.length!==r.length&amp;&amp;(e=!0,n.setValidators(s))}}if(null!==t.asyncValidator){const r=hS(n);if(Array.isArray(r)&amp;&amp;r.length&gt;0){const s=r.filter(o=&gt;o!==t.asyncValidator);s.length!==r.length&amp;&amp;(e=!0,n.setAsyncValidators(s))}}}const i=()=&gt;{};return dd(t._rawValidators,i),dd(t._rawAsyncValidators,i),e}function _S(n,t){n._pendingDirty&amp;&amp;n.markAsDirty(),n.setValue(n._pendingValue,{emitModelToViewChange:!1}),t.viewToModelUpdate(n._pendingValue),n._pendingChange=!1}function yS(n,t){sm(n,t)}function om(n,t){if(!n.hasOwnProperty(&quot;model&quot;))return!1;const e=n.model;return!!e.isFirstChange()||!Object.is(t,e.currentValue)}function vS(n,t){n._syncPendingControls(),t.forEach(e=&gt;{const i=e.control;&quot;submit&quot;===i.updateOn&amp;&amp;i._pendingChange&amp;&amp;(e.viewToModelUpdate(i._pendingValue),i._pendingChange=!1)})}function am(n,t){if(!t)return null;let e,i,r;return Array.isArray(t),t.forEach(s=&gt;{s.constructor===Bn?e=s:function(n){return Object.getPrototypeOf(n.constructor)===bs}(s)?i=s:r=s}),r||i||e||null}function fd(n,t){const e=n.indexOf(t);e&gt;-1&amp;&amp;n.splice(e,1)}const xl=&quot;VALID&quot;,pd=&quot;INVALID&quot;,Xo=&quot;PENDING&quot;,Rl=&quot;DISABLED&quot;;function lm(n){return(um(n)?n.validators:n)||null}function bS(n){return Array.isArray(n)?em(n):n||null}function cm(n,t){return(um(t)?t.asyncValidators:n)||null}function CS(n){return Array.isArray(n)?tm(n):n||null}function um(n){return null!=n&amp;&amp;!Array.isArray(n)&amp;&amp;&quot;object&quot;==typeof n}class dm{constructor(t,e){this._hasOwnPendingAsyncValidator=!1,this._onCollectionChange=()=&gt;{},this._parent=null,this.pristine=!0,this.touched=!1,this._onDisabledChange=[],this._rawValidators=t,this._rawAsyncValidators=e,this._composedValidatorFn=bS(this._rawValidators),this._composedAsyncValidatorFn=CS(this._rawAsyncValidators)}get validator(){return this._composedValidatorFn}set validator(t){this._rawValidators=this._composedValidatorFn=t}get asyncValidator(){return this._composedAsyncValidatorFn}set asyncValidator(t){this._rawAsyncValidators=this._composedAsyncValidatorFn=t}get parent(){return this._parent}get valid(){return this.status===xl}get invalid(){return this.status===pd}get pending(){return this.status==Xo}get disabled(){return this.status===Rl}get enabled(){return this.status!==Rl}get dirty(){return!this.pristine}get untouched(){return!this.touched}get updateOn(){return this._updateOn?this._updateOn:this.parent?this.parent.updateOn:&quot;change&quot;}setValidators(t){this._rawValidators=t,this._composedValidatorFn=bS(t)}setAsyncValidators(t){this._rawAsyncValidators=t,this._composedAsyncValidatorFn=CS(t)}addValidators(t){this.setValidators(fS(t,this._rawValidators))}addAsyncValidators(t){this.setAsyncValidators(fS(t,this._rawAsyncValidators))}removeValidators(t){this.setValidators(pS(t,this._rawValidators))}removeAsyncValidators(t){this.setAsyncValidators(pS(t,this._rawAsyncValidators))}hasValidator(t){return ad(this._rawValidators,t)}hasAsyncValidator(t){return ad(this._rawAsyncValidators,t)}clearValidators(){this.validator=null}clearAsyncValidators(){this.asyncValidator=null}markAsTouched(t={}){this.touched=!0,this._parent&amp;&amp;!t.onlySelf&amp;&amp;this._parent.markAsTouched(t)}markAllAsTouched(){this.markAsTouched({onlySelf:!0}),this._forEachChild(t=&gt;t.markAllAsTouched())}markAsUntouched(t={}){this.touched=!1,this._pendingTouched=!1,this._forEachChild(e=&gt;{e.markAsUntouched({onlySelf:!0})}),this._parent&amp;&amp;!t.onlySelf&amp;&amp;this._parent._updateTouched(t)}markAsDirty(t={}){this.pristine=!1,this._parent&amp;&amp;!t.onlySelf&amp;&amp;this._parent.markAsDirty(t)}markAsPristine(t={}){this.pristine=!0,this._pendingDirty=!1,this._forEachChild(e=&gt;{e.markAsPristine({onlySelf:!0})}),this._parent&amp;&amp;!t.onlySelf&amp;&amp;this._parent._updatePristine(t)}markAsPending(t={}){this.status=Xo,!1!==t.emitEvent&amp;&amp;this.statusChanges.emit(this.status),this._parent&amp;&amp;!t.onlySelf&amp;&amp;this._parent.markAsPending(t)}disable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=Rl,this.errors=null,this._forEachChild(i=&gt;{i.disable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this._updateValue(),!1!==t.emitEvent&amp;&amp;(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(i=&gt;i(!0))}enable(t={}){const e=this._parentMarkedDirty(t.onlySelf);this.status=xl,this._forEachChild(i=&gt;{i.enable(Object.assign(Object.assign({},t),{onlySelf:!0}))}),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent}),this._updateAncestors(Object.assign(Object.assign({},t),{skipPristineCheck:e})),this._onDisabledChange.forEach(i=&gt;i(!1))}_updateAncestors(t){this._parent&amp;&amp;!t.onlySelf&amp;&amp;(this._parent.updateValueAndValidity(t),t.skipPristineCheck||this._parent._updatePristine(),this._parent._updateTouched())}setParent(t){this._parent=t}updateValueAndValidity(t={}){this._setInitialStatus(),this._updateValue(),this.enabled&amp;&amp;(this._cancelExistingSubscription(),this.errors=this._runValidator(),this.status=this._calculateStatus(),(this.status===xl||this.status===Xo)&amp;&amp;this._runAsyncValidator(t.emitEvent)),!1!==t.emitEvent&amp;&amp;(this.valueChanges.emit(this.value),this.statusChanges.emit(this.status)),this._parent&amp;&amp;!t.onlySelf&amp;&amp;this._parent.updateValueAndValidity(t)}_updateTreeValidity(t={emitEvent:!0}){this._forEachChild(e=&gt;e._updateTreeValidity(t)),this.updateValueAndValidity({onlySelf:!0,emitEvent:t.emitEvent})}_setInitialStatus(){this.status=this._allControlsDisabled()?Rl:xl}_runValidator(){return this.validator?this.validator(this):null}_runAsyncValidator(t){if(this.asyncValidator){this.status=Xo,this._hasOwnPendingAsyncValidator=!0;const e=rS(this.asyncValidator(this));this._asyncValidationSubscription=e.subscribe(i=&gt;{this._hasOwnPendingAsyncValidator=!1,this.setErrors(i,{emitEvent:t})})}}_cancelExistingSubscription(){this._asyncValidationSubscription&amp;&amp;(this._asyncValidationSubscription.unsubscribe(),this._hasOwnPendingAsyncValidator=!1)}setErrors(t,e={}){this.errors=t,this._updateControlsErrors(!1!==e.emitEvent)}get(t){return function(n,t,e){if(null==t||(Array.isArray(t)||(t=t.split(&quot;.&quot;)),Array.isArray(t)&amp;&amp;0===t.length))return null;let i=n;return t.forEach(r=&gt;{i=i instanceof Pl?i.controls.hasOwnProperty(r)?i.controls[r]:null:i instanceof hm&amp;&amp;i.at(r)||null}),i}(this,t)}getError(t,e){const i=e?this.get(e):this;return i&amp;&amp;i.errors?i.errors[t]:null}hasError(t,e){return!!this.getError(t,e)}get root(){let t=this;for(;t._parent;)t=t._parent;return t}_updateControlsErrors(t){this.status=this._calculateStatus(),t&amp;&amp;this.statusChanges.emit(this.status),this._parent&amp;&amp;this._parent._updateControlsErrors(t)}_initObservables(){this.valueChanges=new U,this.statusChanges=new U}_calculateStatus(){return this._allControlsDisabled()?Rl:this.errors?pd:this._hasOwnPendingAsyncValidator||this._anyControlsHaveStatus(Xo)?Xo:this._anyControlsHaveStatus(pd)?pd:xl}_anyControlsHaveStatus(t){return this._anyControls(e=&gt;e.status===t)}_anyControlsDirty(){return this._anyControls(t=&gt;t.dirty)}_anyControlsTouched(){return this._anyControls(t=&gt;t.touched)}_updatePristine(t={}){this.pristine=!this._anyControlsDirty(),this._parent&amp;&amp;!t.onlySelf&amp;&amp;this._parent._updatePristine(t)}_updateTouched(t={}){this.touched=this._anyControlsTouched(),this._parent&amp;&amp;!t.onlySelf&amp;&amp;this._parent._updateTouched(t)}_isBoxedValue(t){return&quot;object&quot;==typeof t&amp;&amp;null!==t&amp;&amp;2===Object.keys(t).length&amp;&amp;&quot;value&quot;in t&amp;&amp;&quot;disabled&quot;in t}_registerOnCollectionChange(t){this._onCollectionChange=t}_setUpdateStrategy(t){um(t)&amp;&amp;null!=t.updateOn&amp;&amp;(this._updateOn=t.updateOn)}_parentMarkedDirty(t){return!t&amp;&amp;!(!this._parent||!this._parent.dirty)&amp;&amp;!this._parent._anyControlsDirty()}}class ea extends dm{constructor(t=null,e,i){super(lm(e),cm(i,e)),this._onChange=[],this._applyFormState(t),this._setUpdateStrategy(e),this._initObservables(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}setValue(t,e={}){this.value=this._pendingValue=t,this._onChange.length&amp;&amp;!1!==e.emitModelToViewChange&amp;&amp;this._onChange.forEach(i=&gt;i(this.value,!1!==e.emitViewToModelChange)),this.updateValueAndValidity(e)}patchValue(t,e={}){this.setValue(t,e)}reset(t=null,e={}){this._applyFormState(t),this.markAsPristine(e),this.markAsUntouched(e),this.setValue(this.value,e),this._pendingChange=!1}_updateValue(){}_anyControls(t){return!1}_allControlsDisabled(){return this.disabled}registerOnChange(t){this._onChange.push(t)}_unregisterOnChange(t){fd(this._onChange,t)}registerOnDisabledChange(t){this._onDisabledChange.push(t)}_unregisterOnDisabledChange(t){fd(this._onDisabledChange,t)}_forEachChild(t){}_syncPendingControls(){return!(&quot;submit&quot;!==this.updateOn||(this._pendingDirty&amp;&amp;this.markAsDirty(),this._pendingTouched&amp;&amp;this.markAsTouched(),!this._pendingChange)||(this.setValue(this._pendingValue,{onlySelf:!0,emitModelToViewChange:!1}),0))}_applyFormState(t){this._isBoxedValue(t)?(this.value=this._pendingValue=t.value,t.disabled?this.disable({onlySelf:!0,emitEvent:!1}):this.enable({onlySelf:!0,emitEvent:!1})):this.value=this._pendingValue=t}}class Pl extends dm{constructor(t,e,i){super(lm(e),cm(i,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}registerControl(t,e){return this.controls[t]?this.controls[t]:(this.controls[t]=e,e.setParent(this),e._registerOnCollectionChange(this._onCollectionChange),e)}addControl(t,e,i={}){this.registerControl(t,e),this.updateValueAndValidity({emitEvent:i.emitEvent}),this._onCollectionChange()}removeControl(t,e={}){this.controls[t]&amp;&amp;this.controls[t]._registerOnCollectionChange(()=&gt;{}),delete this.controls[t],this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}setControl(t,e,i={}){this.controls[t]&amp;&amp;this.controls[t]._registerOnCollectionChange(()=&gt;{}),delete this.controls[t],e&amp;&amp;this.registerControl(t,e),this.updateValueAndValidity({emitEvent:i.emitEvent}),this._onCollectionChange()}contains(t){return this.controls.hasOwnProperty(t)&amp;&amp;this.controls[t].enabled}setValue(t,e={}){this._checkAllValuesPresent(t),Object.keys(t).forEach(i=&gt;{this._throwIfControlMissing(i),this.controls[i].setValue(t[i],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&amp;&amp;(Object.keys(t).forEach(i=&gt;{this.controls[i]&amp;&amp;this.controls[i].patchValue(t[i],{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t={},e={}){this._forEachChild((i,r)=&gt;{i.reset(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this._reduceChildren({},(t,e,i)=&gt;(t[i]=e instanceof ea?e.value:e.getRawValue(),t))}_syncPendingControls(){let t=this._reduceChildren(!1,(e,i)=&gt;!!i._syncPendingControls()||e);return t&amp;&amp;this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!Object.keys(this.controls).length)throw new Error(&quot;\n        There are no form controls registered with this group yet. If you&#39;re using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      &quot;);if(!this.controls[t])throw new Error(`Cannot find form control with name: ${t}.`)}_forEachChild(t){Object.keys(this.controls).forEach(e=&gt;{const i=this.controls[e];i&amp;&amp;t(i,e)})}_setUpControls(){this._forEachChild(t=&gt;{t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)})}_updateValue(){this.value=this._reduceValue()}_anyControls(t){for(const e of Object.keys(this.controls)){const i=this.controls[e];if(this.contains(e)&amp;&amp;t(i))return!0}return!1}_reduceValue(){return this._reduceChildren({},(t,e,i)=&gt;((e.enabled||this.disabled)&amp;&amp;(t[i]=e.value),t))}_reduceChildren(t,e){let i=t;return this._forEachChild((r,s)=&gt;{i=e(i,r,s)}),i}_allControlsDisabled(){for(const t of Object.keys(this.controls))if(this.controls[t].enabled)return!1;return Object.keys(this.controls).length&gt;0||this.disabled}_checkAllValuesPresent(t){this._forEachChild((e,i)=&gt;{if(void 0===t[i])throw new Error(`Must supply a value for form control with name: &#39;${i}&#39;.`)})}}class hm extends dm{constructor(t,e,i){super(lm(e),cm(i,e)),this.controls=t,this._initObservables(),this._setUpdateStrategy(e),this._setUpControls(),this.updateValueAndValidity({onlySelf:!0,emitEvent:!!this.asyncValidator})}at(t){return this.controls[t]}push(t,e={}){this.controls.push(t),this._registerControl(t),this.updateValueAndValidity({emitEvent:e.emitEvent}),this._onCollectionChange()}insert(t,e,i={}){this.controls.splice(t,0,e),this._registerControl(e),this.updateValueAndValidity({emitEvent:i.emitEvent})}removeAt(t,e={}){this.controls[t]&amp;&amp;this.controls[t]._registerOnCollectionChange(()=&gt;{}),this.controls.splice(t,1),this.updateValueAndValidity({emitEvent:e.emitEvent})}setControl(t,e,i={}){this.controls[t]&amp;&amp;this.controls[t]._registerOnCollectionChange(()=&gt;{}),this.controls.splice(t,1),e&amp;&amp;(this.controls.splice(t,0,e),this._registerControl(e)),this.updateValueAndValidity({emitEvent:i.emitEvent}),this._onCollectionChange()}get length(){return this.controls.length}setValue(t,e={}){this._checkAllValuesPresent(t),t.forEach((i,r)=&gt;{this._throwIfControlMissing(r),this.at(r).setValue(i,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e)}patchValue(t,e={}){null!=t&amp;&amp;(t.forEach((i,r)=&gt;{this.at(r)&amp;&amp;this.at(r).patchValue(i,{onlySelf:!0,emitEvent:e.emitEvent})}),this.updateValueAndValidity(e))}reset(t=[],e={}){this._forEachChild((i,r)=&gt;{i.reset(t[r],{onlySelf:!0,emitEvent:e.emitEvent})}),this._updatePristine(e),this._updateTouched(e),this.updateValueAndValidity(e)}getRawValue(){return this.controls.map(t=&gt;t instanceof ea?t.value:t.getRawValue())}clear(t={}){this.controls.length&lt;1||(this._forEachChild(e=&gt;e._registerOnCollectionChange(()=&gt;{})),this.controls.splice(0),this.updateValueAndValidity({emitEvent:t.emitEvent}))}_syncPendingControls(){let t=this.controls.reduce((e,i)=&gt;!!i._syncPendingControls()||e,!1);return t&amp;&amp;this.updateValueAndValidity({onlySelf:!0}),t}_throwIfControlMissing(t){if(!this.controls.length)throw new Error(&quot;\n        There are no form controls registered with this array yet. If you&#39;re using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      &quot;);if(!this.at(t))throw new Error(`Cannot find form control at index ${t}`)}_forEachChild(t){this.controls.forEach((e,i)=&gt;{t(e,i)})}_updateValue(){this.value=this.controls.filter(t=&gt;t.enabled||this.disabled).map(t=&gt;t.value)}_anyControls(t){return this.controls.some(e=&gt;e.enabled&amp;&amp;t(e))}_setUpControls(){this._forEachChild(t=&gt;this._registerControl(t))}_checkAllValuesPresent(t){this._forEachChild((e,i)=&gt;{if(void 0===t[i])throw new Error(`Must supply a value for form control at index: ${i}.`)})}_allControlsDisabled(){for(const t of this.controls)if(t.enabled)return!1;return this.controls.length&gt;0||this.disabled}_registerControl(t){t.setParent(this),t._registerOnCollectionChange(this._onCollectionChange)}}const JB={provide:Ht,useExisting:Fe(()=&gt;gi)},Ol=(()=&gt;Promise.resolve(null))();let gi=(()=&gt;{class n extends Ht{constructor(e,i){super(),this.submitted=!1,this._directives=[],this.ngSubmit=new U,this.form=new Pl({},em(e),tm(i))}ngAfterViewInit(){this._setUpdateStrategy()}get formDirective(){return this}get control(){return this.form}get path(){return[]}get controls(){return this.form.controls}addControl(e){Ol.then(()=&gt;{const i=this._findContainer(e.path);e.control=i.registerControl(e.name,e.control),Il(e.control,e),e.control.updateValueAndValidity({emitEvent:!1}),this._directives.push(e)})}getControl(e){return this.form.get(e.path)}removeControl(e){Ol.then(()=&gt;{const i=this._findContainer(e.path);i&amp;&amp;i.removeControl(e.name),fd(this._directives,e)})}addFormGroup(e){Ol.then(()=&gt;{const i=this._findContainer(e.path),r=new Pl({});yS(r,e),i.registerControl(e.name,r),r.updateValueAndValidity({emitEvent:!1})})}removeFormGroup(e){Ol.then(()=&gt;{const i=this._findContainer(e.path);i&amp;&amp;i.removeControl(e.name)})}getFormGroup(e){return this.form.get(e.path)}updateModel(e,i){Ol.then(()=&gt;{this.form.get(e.path).setValue(i)})}setValue(e){this.control.setValue(e)}onSubmit(e){return this.submitted=!0,vS(this.form,this._directives),this.ngSubmit.emit(e),!1}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_setUpdateStrategy(){this.options&amp;&amp;null!=this.options.updateOn&amp;&amp;(this.form._updateOn=this.options.updateOn)}_findContainer(e){return e.pop(),e.length?this.form.get(e):this.form}}return n.\u0275fac=function(e){return new(e||n)(_(Dt,10),_(Lr,10))},n.\u0275dir=O({type:n,selectors:[[&quot;form&quot;,3,&quot;ngNoForm&quot;,&quot;&quot;,3,&quot;formGroup&quot;,&quot;&quot;],[&quot;ng-form&quot;],[&quot;&quot;,&quot;ngForm&quot;,&quot;&quot;]],hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;submit&quot;,function(s){return i.onSubmit(s)})(&quot;reset&quot;,function(){return i.onReset()})},inputs:{options:[&quot;ngFormOptions&quot;,&quot;options&quot;]},outputs:{ngSubmit:&quot;ngSubmit&quot;},exportAs:[&quot;ngForm&quot;],features:[ce([JB]),se]}),n})();const eU={provide:Ni,useExisting:Fe(()=&gt;mi)},ES=(()=&gt;Promise.resolve(null))();let mi=(()=&gt;{class n extends Ni{constructor(e,i,r,s){super(),this.control=new ea,this._registered=!1,this.update=new U,this._parent=e,this._setValidators(i),this._setAsyncValidators(r),this.valueAccessor=am(0,s)}ngOnChanges(e){this._checkForErrors(),this._registered||this._setUpControl(),&quot;isDisabled&quot;in e&amp;&amp;this._updateDisabled(e),om(e,this.viewModel)&amp;&amp;(this._updateValue(this.model),this.viewModel=this.model)}ngOnDestroy(){this.formDirective&amp;&amp;this.formDirective.removeControl(this)}get path(){return this._parent?cd(this.name,this._parent):[this.name]}get formDirective(){return this._parent?this._parent.formDirective:null}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}_setUpControl(){this._setUpdateStrategy(),this._isStandalone()?this._setUpStandalone():this.formDirective.addControl(this),this._registered=!0}_setUpdateStrategy(){this.options&amp;&amp;null!=this.options.updateOn&amp;&amp;(this.control._updateOn=this.options.updateOn)}_isStandalone(){return!this._parent||!(!this.options||!this.options.standalone)}_setUpStandalone(){Il(this.control,this),this.control.updateValueAndValidity({emitEvent:!1})}_checkForErrors(){this._isStandalone()||this._checkParentType(),this._checkName()}_checkParentType(){}_checkName(){this.options&amp;&amp;this.options.name&amp;&amp;(this.name=this.options.name),this._isStandalone()}_updateValue(e){ES.then(()=&gt;{this.control.setValue(e,{emitViewToModelChange:!1})})}_updateDisabled(e){const i=e.isDisabled.currentValue,r=&quot;&quot;===i||i&amp;&amp;&quot;false&quot;!==i;ES.then(()=&gt;{r&amp;&amp;!this.control.disabled?this.control.disable():!r&amp;&amp;this.control.disabled&amp;&amp;this.control.enable()})}}return n.\u0275fac=function(e){return new(e||n)(_(Ht,9),_(Dt,10),_(Lr,10),_(Cn,10))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;ngModel&quot;,&quot;&quot;,3,&quot;formControlName&quot;,&quot;&quot;,3,&quot;formControl&quot;,&quot;&quot;]],inputs:{name:&quot;name&quot;,isDisabled:[&quot;disabled&quot;,&quot;isDisabled&quot;],model:[&quot;ngModel&quot;,&quot;model&quot;],options:[&quot;ngModelOptions&quot;,&quot;options&quot;]},outputs:{update:&quot;ngModelChange&quot;},exportAs:[&quot;ngModel&quot;],features:[ce([eU]),se,je]}),n})(),ta=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n,selectors:[[&quot;form&quot;,3,&quot;ngNoForm&quot;,&quot;&quot;,3,&quot;ngNativeValidate&quot;,&quot;&quot;]],hostAttrs:[&quot;novalidate&quot;,&quot;&quot;]}),n})();const tU={provide:Cn,useExisting:Fe(()=&gt;fm),multi:!0};let fm=(()=&gt;{class n extends bs{writeValue(e){this.setProperty(&quot;value&quot;,null==e?&quot;&quot;:e)}registerOnChange(e){this.onChange=i=&gt;{e(&quot;&quot;==i?null:parseFloat(i))}}}return n.\u0275fac=function(){let t;return function(i){return(t||(t=Et(n)))(i||n)}}(),n.\u0275dir=O({type:n,selectors:[[&quot;input&quot;,&quot;type&quot;,&quot;number&quot;,&quot;formControlName&quot;,&quot;&quot;],[&quot;input&quot;,&quot;type&quot;,&quot;number&quot;,&quot;formControl&quot;,&quot;&quot;],[&quot;input&quot;,&quot;type&quot;,&quot;number&quot;,&quot;ngModel&quot;,&quot;&quot;]],hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;input&quot;,function(s){return i.onChange(s.target.value)})(&quot;blur&quot;,function(){return i.onTouched()})},features:[ce([tU]),se]}),n})(),SS=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({}),n})();const rU={provide:Cn,useExisting:Fe(()=&gt;gd),multi:!0};let gd=(()=&gt;{class n extends bs{writeValue(e){this.setProperty(&quot;value&quot;,parseFloat(e))}registerOnChange(e){this.onChange=i=&gt;{e(&quot;&quot;==i?null:parseFloat(i))}}}return n.\u0275fac=function(){let t;return function(i){return(t||(t=Et(n)))(i||n)}}(),n.\u0275dir=O({type:n,selectors:[[&quot;input&quot;,&quot;type&quot;,&quot;range&quot;,&quot;formControlName&quot;,&quot;&quot;],[&quot;input&quot;,&quot;type&quot;,&quot;range&quot;,&quot;formControl&quot;,&quot;&quot;],[&quot;input&quot;,&quot;type&quot;,&quot;range&quot;,&quot;ngModel&quot;,&quot;&quot;]],hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;change&quot;,function(s){return i.onChange(s.target.value)})(&quot;input&quot;,function(s){return i.onChange(s.target.value)})(&quot;blur&quot;,function(){return i.onTouched()})},features:[ce([rU]),se]}),n})();const pm=new j(&quot;NgModelWithFormControlWarning&quot;),oU={provide:Ht,useExisting:Fe(()=&gt;Br)};let Br=(()=&gt;{class n extends Ht{constructor(e,i){super(),this.validators=e,this.asyncValidators=i,this.submitted=!1,this._onCollectionChange=()=&gt;this._updateDomValue(),this.directives=[],this.form=null,this.ngSubmit=new U,this._setValidators(e),this._setAsyncValidators(i)}ngOnChanges(e){this._checkFormPresent(),e.hasOwnProperty(&quot;form&quot;)&amp;&amp;(this._updateValidators(),this._updateDomValue(),this._updateRegistrations(),this._oldForm=this.form)}ngOnDestroy(){this.form&amp;&amp;(hd(this.form,this),this.form._onCollectionChange===this._onCollectionChange&amp;&amp;this.form._registerOnCollectionChange(()=&gt;{}))}get formDirective(){return this}get control(){return this.form}get path(){return[]}addControl(e){const i=this.form.get(e.path);return Il(i,e),i.updateValueAndValidity({emitEvent:!1}),this.directives.push(e),i}getControl(e){return this.form.get(e.path)}removeControl(e){ud(e.control||null,e,!1),fd(this.directives,e)}addFormGroup(e){this._setUpFormContainer(e)}removeFormGroup(e){this._cleanUpFormContainer(e)}getFormGroup(e){return this.form.get(e.path)}addFormArray(e){this._setUpFormContainer(e)}removeFormArray(e){this._cleanUpFormContainer(e)}getFormArray(e){return this.form.get(e.path)}updateModel(e,i){this.form.get(e.path).setValue(i)}onSubmit(e){return this.submitted=!0,vS(this.form,this.directives),this.ngSubmit.emit(e),!1}onReset(){this.resetForm()}resetForm(e){this.form.reset(e),this.submitted=!1}_updateDomValue(){this.directives.forEach(e=&gt;{const i=e.control,r=this.form.get(e.path);i!==r&amp;&amp;(ud(i||null,e),r instanceof ea&amp;&amp;(Il(r,e),e.control=r))}),this.form._updateTreeValidity({emitEvent:!1})}_setUpFormContainer(e){const i=this.form.get(e.path);yS(i,e),i.updateValueAndValidity({emitEvent:!1})}_cleanUpFormContainer(e){if(this.form){const i=this.form.get(e.path);i&amp;&amp;function(n,t){return hd(n,t)}(i,e)&amp;&amp;i.updateValueAndValidity({emitEvent:!1})}}_updateRegistrations(){this.form._registerOnCollectionChange(this._onCollectionChange),this._oldForm&amp;&amp;this._oldForm._registerOnCollectionChange(()=&gt;{})}_updateValidators(){sm(this.form,this),this._oldForm&amp;&amp;hd(this._oldForm,this)}_checkFormPresent(){}}return n.\u0275fac=function(e){return new(e||n)(_(Dt,10),_(Lr,10))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;formGroup&quot;,&quot;&quot;]],hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;submit&quot;,function(s){return i.onSubmit(s)})(&quot;reset&quot;,function(){return i.onReset()})},inputs:{form:[&quot;formGroup&quot;,&quot;form&quot;]},outputs:{ngSubmit:&quot;ngSubmit&quot;},exportAs:[&quot;ngForm&quot;],features:[ce([oU]),se,je]}),n})();const cU={provide:Ni,useExisting:Fe(()=&gt;_m)};let _m=(()=&gt;{class n extends Ni{constructor(e,i,r,s,o){super(),this._ngModelWarningConfig=o,this._added=!1,this.update=new U,this._ngModelWarningSent=!1,this._parent=e,this._setValidators(i),this._setAsyncValidators(r),this.valueAccessor=am(0,s)}set isDisabled(e){}ngOnChanges(e){this._added||this._setUpControl(),om(e,this.viewModel)&amp;&amp;(this.viewModel=this.model,this.formDirective.updateModel(this,this.model))}ngOnDestroy(){this.formDirective&amp;&amp;this.formDirective.removeControl(this)}viewToModelUpdate(e){this.viewModel=e,this.update.emit(e)}get path(){return cd(null==this.name?this.name:this.name.toString(),this._parent)}get formDirective(){return this._parent?this._parent.formDirective:null}_checkParentType(){}_setUpControl(){this._checkParentType(),this.control=this.formDirective.addControl(this),this.control.disabled&amp;&amp;this.valueAccessor.setDisabledState&amp;&amp;this.valueAccessor.setDisabledState(!0),this._added=!0}}return n.\u0275fac=function(e){return new(e||n)(_(Ht,13),_(Dt,10),_(Lr,10),_(Cn,10),_(pm,8))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;formControlName&quot;,&quot;&quot;]],inputs:{isDisabled:[&quot;disabled&quot;,&quot;isDisabled&quot;],name:[&quot;formControlName&quot;,&quot;name&quot;],model:[&quot;ngModel&quot;,&quot;model&quot;]},outputs:{update:&quot;ngModelChange&quot;},features:[ce([cU]),se,je]}),n._ngModelWarningSentOnce=!1,n})();const uU={provide:Cn,useExisting:Fe(()=&gt;ym),multi:!0};function TS(n,t){return null==n?`${t}`:(t&amp;&amp;&quot;object&quot;==typeof t&amp;&amp;(t=&quot;Object&quot;),`${n}: ${t}`.slice(0,50))}let ym=(()=&gt;{class n extends bs{constructor(){super(...arguments),this._optionMap=new Map,this._idCounter=0,this._compareWith=Object.is}set compareWith(e){this._compareWith=e}writeValue(e){this.value=e;const i=this._getOptionId(e);null==i&amp;&amp;this.setProperty(&quot;selectedIndex&quot;,-1);const r=TS(i,e);this.setProperty(&quot;value&quot;,r)}registerOnChange(e){this.onChange=i=&gt;{this.value=this._getOptionValue(i),e(this.value)}}_registerOption(){return(this._idCounter++).toString()}_getOptionId(e){for(const i of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(i),e))return i;return null}_getOptionValue(e){const i=function(n){return n.split(&quot;:&quot;)[0]}(e);return this._optionMap.has(i)?this._optionMap.get(i):e}}return n.\u0275fac=function(){let t;return function(i){return(t||(t=Et(n)))(i||n)}}(),n.\u0275dir=O({type:n,selectors:[[&quot;select&quot;,&quot;formControlName&quot;,&quot;&quot;,3,&quot;multiple&quot;,&quot;&quot;],[&quot;select&quot;,&quot;formControl&quot;,&quot;&quot;,3,&quot;multiple&quot;,&quot;&quot;],[&quot;select&quot;,&quot;ngModel&quot;,&quot;&quot;,3,&quot;multiple&quot;,&quot;&quot;]],hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;change&quot;,function(s){return i.onChange(s.target.value)})(&quot;blur&quot;,function(){return i.onTouched()})},inputs:{compareWith:&quot;compareWith&quot;},features:[ce([uU]),se]}),n})(),IS=(()=&gt;{class n{constructor(e,i,r){this._element=e,this._renderer=i,this._select=r,this._select&amp;&amp;(this.id=this._select._registerOption())}set ngValue(e){null!=this._select&amp;&amp;(this._select._optionMap.set(this.id,e),this._setElementValue(TS(this.id,e)),this._select.writeValue(this._select.value))}set value(e){this._setElementValue(e),this._select&amp;&amp;this._select.writeValue(this._select.value)}_setElementValue(e){this._renderer.setProperty(this._element.nativeElement,&quot;value&quot;,e)}ngOnDestroy(){this._select&amp;&amp;(this._select._optionMap.delete(this.id),this._select.writeValue(this._select.value))}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(nr),_(ym,9))},n.\u0275dir=O({type:n,selectors:[[&quot;option&quot;]],inputs:{ngValue:&quot;ngValue&quot;,value:&quot;value&quot;}}),n})();const hU={provide:Cn,useExisting:Fe(()=&gt;vm),multi:!0};function xS(n,t){return null==n?`${t}`:(&quot;string&quot;==typeof t&amp;&amp;(t=`&#39;${t}&#39;`),t&amp;&amp;&quot;object&quot;==typeof t&amp;&amp;(t=&quot;Object&quot;),`${n}: ${t}`.slice(0,50))}let vm=(()=&gt;{class n extends bs{constructor(){super(...arguments),this._optionMap=new Map,this._idCounter=0,this._compareWith=Object.is}set compareWith(e){this._compareWith=e}writeValue(e){let i;if(this.value=e,Array.isArray(e)){const r=e.map(s=&gt;this._getOptionId(s));i=(s,o)=&gt;{s._setSelected(r.indexOf(o.toString())&gt;-1)}}else i=(r,s)=&gt;{r._setSelected(!1)};this._optionMap.forEach(i)}registerOnChange(e){this.onChange=i=&gt;{const r=[];if(void 0!==i.selectedOptions){const s=i.selectedOptions;for(let o=0;o&lt;s.length;o++){const a=s.item(o),l=this._getOptionValue(a.value);r.push(l)}}else{const s=i.options;for(let o=0;o&lt;s.length;o++){const a=s.item(o);if(a.selected){const l=this._getOptionValue(a.value);r.push(l)}}}this.value=r,e(r)}}_registerOption(e){const i=(this._idCounter++).toString();return this._optionMap.set(i,e),i}_getOptionId(e){for(const i of Array.from(this._optionMap.keys()))if(this._compareWith(this._optionMap.get(i)._value,e))return i;return null}_getOptionValue(e){const i=function(n){return n.split(&quot;:&quot;)[0]}(e);return this._optionMap.has(i)?this._optionMap.get(i)._value:e}}return n.\u0275fac=function(){let t;return function(i){return(t||(t=Et(n)))(i||n)}}(),n.\u0275dir=O({type:n,selectors:[[&quot;select&quot;,&quot;multiple&quot;,&quot;&quot;,&quot;formControlName&quot;,&quot;&quot;],[&quot;select&quot;,&quot;multiple&quot;,&quot;&quot;,&quot;formControl&quot;,&quot;&quot;],[&quot;select&quot;,&quot;multiple&quot;,&quot;&quot;,&quot;ngModel&quot;,&quot;&quot;]],hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;change&quot;,function(s){return i.onChange(s.target)})(&quot;blur&quot;,function(){return i.onTouched()})},inputs:{compareWith:&quot;compareWith&quot;},features:[ce([hU]),se]}),n})(),RS=(()=&gt;{class n{constructor(e,i,r){this._element=e,this._renderer=i,this._select=r,this._select&amp;&amp;(this.id=this._select._registerOption(this))}set ngValue(e){null!=this._select&amp;&amp;(this._value=e,this._setElementValue(xS(this.id,e)),this._select.writeValue(this._select.value))}set value(e){this._select?(this._value=e,this._setElementValue(xS(this.id,e)),this._select.writeValue(this._select.value)):this._setElementValue(e)}_setElementValue(e){this._renderer.setProperty(this._element.nativeElement,&quot;value&quot;,e)}_setSelected(e){this._renderer.setProperty(this._element.nativeElement,&quot;selected&quot;,e)}ngOnDestroy(){this._select&amp;&amp;(this._select._optionMap.delete(this.id),this._select.writeValue(this._select.value))}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(nr),_(vm,9))},n.\u0275dir=O({type:n,selectors:[[&quot;option&quot;]],inputs:{ngValue:&quot;ngValue&quot;,value:&quot;value&quot;}}),n})(),OS=(()=&gt;{class n{constructor(){this._validator=jr}handleChanges(e){if(this.inputName in e){const i=this.normalizeInput(e[this.inputName].currentValue);this._validator=this.createValidator(i),this._onChange&amp;&amp;this._onChange()}}validate(e){return this._validator(e)}registerOnValidatorChange(e){this._onChange=e}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n}),n})();const gU={provide:Dt,useExisting:Fe(()=&gt;bm),multi:!0};let bm=(()=&gt;{class n extends OS{constructor(){super(...arguments),this.inputName=&quot;min&quot;,this.normalizeInput=e=&gt;parseFloat(e),this.createValidator=e=&gt;K0(e)}ngOnChanges(e){this.handleChanges(e)}}return n.\u0275fac=function(){let t;return function(i){return(t||(t=Et(n)))(i||n)}}(),n.\u0275dir=O({type:n,selectors:[[&quot;input&quot;,&quot;type&quot;,&quot;number&quot;,&quot;min&quot;,&quot;&quot;,&quot;formControlName&quot;,&quot;&quot;],[&quot;input&quot;,&quot;type&quot;,&quot;number&quot;,&quot;min&quot;,&quot;&quot;,&quot;formControl&quot;,&quot;&quot;],[&quot;input&quot;,&quot;type&quot;,&quot;number&quot;,&quot;min&quot;,&quot;&quot;,&quot;ngModel&quot;,&quot;&quot;]],hostVars:1,hostBindings:function(e,i){if(2&amp;e){let r;Ce(&quot;min&quot;,null!==(r=i.min)&amp;&amp;void 0!==r?r:null)}},inputs:{min:&quot;min&quot;},features:[ce([gU]),se,je]}),n})(),US=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[SS]]}),n})(),DU=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[US]}),n})(),HS=(()=&gt;{class n{static withConfig(e){return{ngModule:n,providers:[{provide:pm,useValue:e.warnOnNgModelWithFormControl}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[US]}),n})(),EU=(()=&gt;{class n{group(e,i=null){const r=this._reduceControls(e);let a,s=null,o=null;return null!=i&amp;&amp;(function(n){return void 0!==n.asyncValidators||void 0!==n.validators||void 0!==n.updateOn}(i)?(s=null!=i.validators?i.validators:null,o=null!=i.asyncValidators?i.asyncValidators:null,a=null!=i.updateOn?i.updateOn:void 0):(s=null!=i.validator?i.validator:null,o=null!=i.asyncValidator?i.asyncValidator:null)),new Pl(r,{asyncValidators:o,updateOn:a,validators:s})}control(e,i,r){return new ea(e,i,r)}array(e,i,r){const s=e.map(o=&gt;this._createControl(o));return new hm(s,i,r)}_reduceControls(e){const i={};return Object.keys(e).forEach(r=&gt;{i[r]=this._createControl(e[r])}),i}_createControl(e){return e instanceof ea||e instanceof Pl||e instanceof hm?e:Array.isArray(e)?this.control(e[0],e.length&gt;1?e[1]:null,e.length&gt;2?e[2]:null):this.control(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({factory:function(){return new n},token:n,providedIn:HS}),n})();class Un extends ie{constructor(t){super(),this._value=t}get value(){return this.getValue()}_subscribe(t){const e=super._subscribe(t);return e&amp;&amp;!e.closed&amp;&amp;t.next(this._value),e}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new Qr;return this._value}next(t){super.next(this._value=t)}}class SU extends xe{notifyNext(t,e,i,r,s){this.destination.next(e)}notifyError(t,e){this.destination.error(t)}notifyComplete(t){this.destination.complete()}}class kU extends xe{constructor(t,e,i){super(),this.parent=t,this.outerValue=e,this.outerIndex=i,this.index=0}_next(t){this.parent.notifyNext(this.outerValue,t,this.outerIndex,this.index++,this)}_error(t){this.parent.notifyError(t,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function MU(n,t,e,i,r=new kU(n,e,i)){if(!r.closed)return t instanceof ye?t.subscribe(r):Sh(t)(r)}const zS={};class TU{constructor(t){this.resultSelector=t}call(t,e){return e.subscribe(new IU(t,this.resultSelector))}}class IU extends SU{constructor(t,e){super(t),this.resultSelector=e,this.active=0,this.values=[],this.observables=[]}_next(t){this.values.push(zS),this.observables.push(t)}_complete(){const t=this.observables,e=t.length;if(0===e)this.destination.complete();else{this.active=e,this.toRespond=e;for(let i=0;i&lt;e;i++)this.add(MU(this,t[i],void 0,i))}}notifyComplete(t){0==(this.active-=1)&amp;&amp;this.destination.complete()}notifyNext(t,e,i){const r=this.values,o=this.toRespond?r[i]===zS?--this.toRespond:this.toRespond:0;r[i]=e,0===o&amp;&amp;(this.resultSelector?this._tryResultSelector(r):this.destination.next(r.slice()))}_tryResultSelector(t){let e;try{e=this.resultSelector.apply(this,t)}catch(i){return void this.destination.error(i)}this.destination.next(e)}}const md=(()=&gt;{function n(){return Error.call(this),this.message=&quot;no elements in sequence&quot;,this.name=&quot;EmptyError&quot;,this}return n.prototype=Object.create(Error.prototype),n})();function _d(...n){return wa(1)(G(...n))}const Cs=new ye(n=&gt;n.complete());function yd(n){return n?function(n){return new ye(t=&gt;n.schedule(()=&gt;t.complete()))}(n):Cs}function vd(n){return new ye(t=&gt;{let e;try{e=n()}catch(r){return void t.error(r)}return(e?At(e):yd()).subscribe(t)})}function nn(n,t){return&quot;function&quot;==typeof t?e=&gt;e.pipe(nn((i,r)=&gt;At(n(i,r)).pipe(pe((s,o)=&gt;t(i,s,r,o))))):e=&gt;e.lift(new PU(n))}class PU{constructor(t){this.project=t}call(t,e){return e.subscribe(new OU(t,this.project))}}class OU extends Ca{constructor(t,e){super(t),this.project=e,this.index=0}_next(t){let e;const i=this.index++;try{e=this.project(t,i)}catch(r){return void this.destination.error(r)}this._innerSub(e)}_innerSub(t){const e=this.innerSubscription;e&amp;&amp;e.unsubscribe();const i=new ba(this),r=this.destination;r.add(i),this.innerSubscription=Da(t,i),this.innerSubscription!==i&amp;&amp;r.add(this.innerSubscription)}_complete(){const{innerSubscription:t}=this;(!t||t.closed)&amp;&amp;super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&amp;&amp;super._complete()}notifyNext(t){this.destination.next(t)}}const $S=(()=&gt;{function n(){return Error.call(this),this.message=&quot;argument out of range&quot;,this.name=&quot;ArgumentOutOfRangeError&quot;,this}return n.prototype=Object.create(Error.prototype),n})();function rn(n){return t=&gt;0===n?yd():t.lift(new FU(n))}class FU{constructor(t){if(this.total=t,this.total&lt;0)throw new $S}call(t,e){return e.subscribe(new NU(t,this.total))}}class NU extends xe{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){const e=this.total,i=++this.count;i&lt;=e&amp;&amp;(this.destination.next(t),i===e&amp;&amp;(this.destination.complete(),this.unsubscribe()))}}function lr(...n){const t=n[n.length-1];return $s(t)?(n.pop(),e=&gt;_d(n,e,t)):e=&gt;_d(n,e)}function GS(n,t){let e=!1;return arguments.length&gt;=2&amp;&amp;(e=!0),function(r){return r.lift(new VU(n,t,e))}}class VU{constructor(t,e,i=!1){this.accumulator=t,this.seed=e,this.hasSeed=i}call(t,e){return e.subscribe(new LU(t,this.accumulator,this.seed,this.hasSeed))}}class LU extends xe{constructor(t,e,i,r){super(t),this.accumulator=e,this._seed=i,this.hasSeed=r,this.index=0}get seed(){return this._seed}set seed(t){this.hasSeed=!0,this._seed=t}_next(t){if(this.hasSeed)return this._tryNext(t);this.seed=t,this.destination.next(t)}_tryNext(t){const e=this.index++;let i;try{i=this.accumulator(this.seed,t,e)}catch(r){this.destination.error(r)}this.seed=i,this.destination.next(i)}}function Ie(n){return function(e){const i=new jU(n),r=e.lift(i);return i.caught=r}}class jU{constructor(t){this.selector=t}call(t,e){return e.subscribe(new BU(t,this.selector,this.caught))}}class BU extends Ca{constructor(t,e,i){super(t),this.selector=e,this.caught=i}error(t){if(!this.isStopped){let e;try{e=this.selector(t,this.caught)}catch(s){return void super.error(s)}this._unsubscribeAndRecycle();const i=new ba(this);this.add(i);const r=Da(e,i);r!==i&amp;&amp;this.add(r)}}}function Dm(n){return function(e){return 0===n?yd():e.lift(new UU(n))}}class UU{constructor(t){if(this.total=t,this.total&lt;0)throw new $S}call(t,e){return e.subscribe(new HU(t,this.total))}}class HU extends xe{constructor(t,e){super(t),this.total=e,this.ring=new Array,this.count=0}_next(t){const e=this.ring,i=this.total,r=this.count++;e.length&lt;i?e.push(t):e[r%i]=t}_complete(){const t=this.destination;let e=this.count;if(e&gt;0){const i=this.count&gt;=this.total?this.total:this.count,r=this.ring;for(let s=0;s&lt;i;s++){const o=e++%i;t.next(r[o])}}t.complete()}}function WS(n=GU){return t=&gt;t.lift(new zU(n))}class zU{constructor(t){this.errorFactory=t}call(t,e){return e.subscribe(new $U(t,this.errorFactory))}}class $U extends xe{constructor(t,e){super(t),this.errorFactory=e,this.hasValue=!1}_next(t){this.hasValue=!0,this.destination.next(t)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function GU(){return new md}function qS(n=null){return t=&gt;t.lift(new WU(n))}class WU{constructor(t){this.defaultValue=t}call(t,e){return e.subscribe(new qU(t,this.defaultValue))}}class qU extends xe{constructor(t,e){super(t),this.defaultValue=e,this.isEmpty=!0}_next(t){this.isEmpty=!1,this.destination.next(t)}_complete(){this.isEmpty&amp;&amp;this.destination.next(this.defaultValue),this.destination.complete()}}function na(n,t){const e=arguments.length&gt;=2;return i=&gt;i.pipe(n?cn((r,s)=&gt;n(r,s,i)):yc,rn(1),e?qS(t):WS(()=&gt;new md))}function cr(){}function zt(n,t,e){return function(r){return r.lift(new KU(n,t,e))}}class KU{constructor(t,e,i){this.nextOrObserver=t,this.error=e,this.complete=i}call(t,e){return e.subscribe(new QU(t,this.nextOrObserver,this.error,this.complete))}}class QU extends xe{constructor(t,e,i,r){super(t),this._tapNext=cr,this._tapError=cr,this._tapComplete=cr,this._tapError=i||cr,this._tapComplete=r||cr,bi(e)?(this._context=this,this._tapNext=e):e&amp;&amp;(this._context=e,this._tapNext=e.next||cr,this._tapError=e.error||cr,this._tapComplete=e.complete||cr)}_next(t){try{this._tapNext.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.next(t)}_error(t){try{this._tapError.call(this._context,t)}catch(e){return void this.destination.error(e)}this.destination.error(t)}_complete(){try{this._tapComplete.call(this._context)}catch(t){return void this.destination.error(t)}return this.destination.complete()}}class JU{constructor(t){this.callback=t}call(t,e){return e.subscribe(new XU(t,this.callback))}}class XU extends xe{constructor(t,e){super(t),this.add(new ue(e))}}class ur{constructor(t,e){this.id=t,this.url=e}}class wm extends ur{constructor(t,e,i=&quot;imperative&quot;,r=null){super(t,e),this.navigationTrigger=i,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: &#39;${this.url}&#39;)`}}class Fl extends ur{constructor(t,e,i){super(t,e),this.urlAfterRedirects=i}toString(){return`NavigationEnd(id: ${this.id}, url: &#39;${this.url}&#39;, urlAfterRedirects: &#39;${this.urlAfterRedirects}&#39;)`}}class YS extends ur{constructor(t,e,i){super(t,e),this.reason=i}toString(){return`NavigationCancel(id: ${this.id}, url: &#39;${this.url}&#39;)`}}class eH extends ur{constructor(t,e,i){super(t,e),this.error=i}toString(){return`NavigationError(id: ${this.id}, url: &#39;${this.url}&#39;, error: ${this.error})`}}class tH extends ur{constructor(t,e,i,r){super(t,e),this.urlAfterRedirects=i,this.state=r}toString(){return`RoutesRecognized(id: ${this.id}, url: &#39;${this.url}&#39;, urlAfterRedirects: &#39;${this.urlAfterRedirects}&#39;, state: ${this.state})`}}class nH extends ur{constructor(t,e,i,r){super(t,e),this.urlAfterRedirects=i,this.state=r}toString(){return`GuardsCheckStart(id: ${this.id}, url: &#39;${this.url}&#39;, urlAfterRedirects: &#39;${this.urlAfterRedirects}&#39;, state: ${this.state})`}}class iH extends ur{constructor(t,e,i,r,s){super(t,e),this.urlAfterRedirects=i,this.state=r,this.shouldActivate=s}toString(){return`GuardsCheckEnd(id: ${this.id}, url: &#39;${this.url}&#39;, urlAfterRedirects: &#39;${this.urlAfterRedirects}&#39;, state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class rH extends ur{constructor(t,e,i,r){super(t,e),this.urlAfterRedirects=i,this.state=r}toString(){return`ResolveStart(id: ${this.id}, url: &#39;${this.url}&#39;, urlAfterRedirects: &#39;${this.urlAfterRedirects}&#39;, state: ${this.state})`}}class sH extends ur{constructor(t,e,i,r){super(t,e),this.urlAfterRedirects=i,this.state=r}toString(){return`ResolveEnd(id: ${this.id}, url: &#39;${this.url}&#39;, urlAfterRedirects: &#39;${this.urlAfterRedirects}&#39;, state: ${this.state})`}}class KS{constructor(t){this.route=t}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class QS{constructor(t){this.route=t}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class oH{constructor(t){this.snapshot=t}toString(){return`ChildActivationStart(path: &#39;${this.snapshot.routeConfig&amp;&amp;this.snapshot.routeConfig.path||&quot;&quot;}&#39;)`}}class aH{constructor(t){this.snapshot=t}toString(){return`ChildActivationEnd(path: &#39;${this.snapshot.routeConfig&amp;&amp;this.snapshot.routeConfig.path||&quot;&quot;}&#39;)`}}class lH{constructor(t){this.snapshot=t}toString(){return`ActivationStart(path: &#39;${this.snapshot.routeConfig&amp;&amp;this.snapshot.routeConfig.path||&quot;&quot;}&#39;)`}}class cH{constructor(t){this.snapshot=t}toString(){return`ActivationEnd(path: &#39;${this.snapshot.routeConfig&amp;&amp;this.snapshot.routeConfig.path||&quot;&quot;}&#39;)`}}class ZS{constructor(t,e,i){this.routerEvent=t,this.position=e,this.anchor=i}toString(){return`Scroll(anchor: &#39;${this.anchor}&#39;, position: &#39;${this.position?`${this.position[0]}, ${this.position[1]}`:null}&#39;)`}}const De=&quot;primary&quot;;class uH{constructor(t){this.params=t||{}}has(t){return Object.prototype.hasOwnProperty.call(this.params,t)}get(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e[0]:e}return null}getAll(t){if(this.has(t)){const e=this.params[t];return Array.isArray(e)?e:[e]}return[]}get keys(){return Object.keys(this.params)}}function ia(n){return new uH(n)}const JS=&quot;ngNavigationCancelingError&quot;;function Em(n){const t=Error(&quot;NavigationCancelingError: &quot;+n);return t[JS]=!0,t}function hH(n,t,e){const i=e.path.split(&quot;/&quot;);if(i.length&gt;n.length||&quot;full&quot;===e.pathMatch&amp;&amp;(t.hasChildren()||i.length&lt;n.length))return null;const r={};for(let s=0;s&lt;i.length;s++){const o=i[s],a=n[s];if(o.startsWith(&quot;:&quot;))r[o.substring(1)]=a;else if(o!==a.path)return null}return{consumed:n.slice(0,i.length),posParams:r}}function Li(n,t){const e=n?Object.keys(n):void 0,i=t?Object.keys(t):void 0;if(!e||!i||e.length!=i.length)return!1;let r;for(let s=0;s&lt;e.length;s++)if(r=e[s],!XS(n[r],t[r]))return!1;return!0}function XS(n,t){if(Array.isArray(n)&amp;&amp;Array.isArray(t)){if(n.length!==t.length)return!1;const e=[...n].sort(),i=[...t].sort();return e.every((r,s)=&gt;i[s]===r)}return n===t}function ek(n){return Array.prototype.concat.apply([],n)}function tk(n){return n.length&gt;0?n[n.length-1]:null}function Ot(n,t){for(const e in n)n.hasOwnProperty(e)&amp;&amp;t(n[e],e)}function ji(n){return du(n)?n:tl(n)?At(Promise.resolve(n)):G(n)}const gH={exact:function rk(n,t,e){if(!ws(n.segments,t.segments)||!bd(n.segments,t.segments,e)||n.numberOfChildren!==t.numberOfChildren)return!1;for(const i in t.children)if(!n.children[i]||!rk(n.children[i],t.children[i],e))return!1;return!0},subset:sk},nk={exact:function(n,t){return Li(n,t)},subset:function(n,t){return Object.keys(t).length&lt;=Object.keys(n).length&amp;&amp;Object.keys(t).every(e=&gt;XS(n[e],t[e]))},ignored:()=&gt;!0};function ik(n,t,e){return gH[e.paths](n.root,t.root,e.matrixParams)&amp;&amp;nk[e.queryParams](n.queryParams,t.queryParams)&amp;&amp;!(&quot;exact&quot;===e.fragment&amp;&amp;n.fragment!==t.fragment)}function sk(n,t,e){return ok(n,t,t.segments,e)}function ok(n,t,e,i){if(n.segments.length&gt;e.length){const r=n.segments.slice(0,e.length);return!(!ws(r,e)||t.hasChildren()||!bd(r,e,i))}if(n.segments.length===e.length){if(!ws(n.segments,e)||!bd(n.segments,e,i))return!1;for(const r in t.children)if(!n.children[r]||!sk(n.children[r],t.children[r],i))return!1;return!0}{const r=e.slice(0,n.segments.length),s=e.slice(n.segments.length);return!!(ws(n.segments,r)&amp;&amp;bd(n.segments,r,i)&amp;&amp;n.children[De])&amp;&amp;ok(n.children[De],t,s,i)}}function bd(n,t,e){return t.every((i,r)=&gt;nk[e](n[r].parameters,i.parameters))}class Ds{constructor(t,e,i){this.root=t,this.queryParams=e,this.fragment=i}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=ia(this.queryParams)),this._queryParamMap}toString(){return bH.serialize(this)}}class Se{constructor(t,e){this.segments=t,this.children=e,this.parent=null,Ot(e,(i,r)=&gt;i.parent=this)}hasChildren(){return this.numberOfChildren&gt;0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Cd(this)}}class Nl{constructor(t,e){this.path=t,this.parameters=e}get parameterMap(){return this._parameterMap||(this._parameterMap=ia(this.parameters)),this._parameterMap}toString(){return uk(this)}}function ws(n,t){return n.length===t.length&amp;&amp;n.every((e,i)=&gt;e.path===t[i].path)}class Sm{}class ak{parse(t){const e=new TH(t);return new Ds(e.parseRootSegment(),e.parseQueryParams(),e.parseFragment())}serialize(t){return`${`/${Vl(t.root,!0)}`}${function(n){const t=Object.keys(n).map(e=&gt;{const i=n[e];return Array.isArray(i)?i.map(r=&gt;`${Dd(e)}=${Dd(r)}`).join(&quot;&amp;&quot;):`${Dd(e)}=${Dd(i)}`}).filter(e=&gt;!!e);return t.length?`?${t.join(&quot;&amp;&quot;)}`:&quot;&quot;}(t.queryParams)}${&quot;string&quot;==typeof t.fragment?`#${function(n){return encodeURI(n)}(t.fragment)}`:&quot;&quot;}`}}const bH=new ak;function Cd(n){return n.segments.map(t=&gt;uk(t)).join(&quot;/&quot;)}function Vl(n,t){if(!n.hasChildren())return Cd(n);if(t){const e=n.children[De]?Vl(n.children[De],!1):&quot;&quot;,i=[];return Ot(n.children,(r,s)=&gt;{s!==De&amp;&amp;i.push(`${s}:${Vl(r,!1)}`)}),i.length&gt;0?`${e}(${i.join(&quot;//&quot;)})`:e}{const e=function(n,t){let e=[];return Ot(n.children,(i,r)=&gt;{r===De&amp;&amp;(e=e.concat(t(i,r)))}),Ot(n.children,(i,r)=&gt;{r!==De&amp;&amp;(e=e.concat(t(i,r)))}),e}(n,(i,r)=&gt;r===De?[Vl(n.children[De],!1)]:[`${r}:${Vl(i,!1)}`]);return 1===Object.keys(n.children).length&amp;&amp;null!=n.children[De]?`${Cd(n)}/${e[0]}`:`${Cd(n)}/(${e.join(&quot;//&quot;)})`}}function lk(n){return encodeURIComponent(n).replace(/%40/g,&quot;@&quot;).replace(/%3A/gi,&quot;:&quot;).replace(/%24/g,&quot;$&quot;).replace(/%2C/gi,&quot;,&quot;)}function Dd(n){return lk(n).replace(/%3B/gi,&quot;;&quot;)}function km(n){return lk(n).replace(/\(/g,&quot;%28&quot;).replace(/\)/g,&quot;%29&quot;).replace(/%26/gi,&quot;&amp;&quot;)}function wd(n){return decodeURIComponent(n)}function ck(n){return wd(n.replace(/\+/g,&quot;%20&quot;))}function uk(n){return`${km(n.path)}${function(n){return Object.keys(n).map(t=&gt;`;${km(t)}=${km(n[t])}`).join(&quot;&quot;)}(n.parameters)}`}const EH=/^[^\/()?;=#]+/;function Ed(n){const t=n.match(EH);return t?t[0]:&quot;&quot;}const SH=/^[^=?&amp;#]+/,MH=/^[^?&amp;#]+/;class TH{constructor(t){this.url=t,this.remaining=t}parseRootSegment(){return this.consumeOptional(&quot;/&quot;),&quot;&quot;===this.remaining||this.peekStartsWith(&quot;?&quot;)||this.peekStartsWith(&quot;#&quot;)?new Se([],{}):new Se([],this.parseChildren())}parseQueryParams(){const t={};if(this.consumeOptional(&quot;?&quot;))do{this.parseQueryParam(t)}while(this.consumeOptional(&quot;&amp;&quot;));return t}parseFragment(){return this.consumeOptional(&quot;#&quot;)?decodeURIComponent(this.remaining):null}parseChildren(){if(&quot;&quot;===this.remaining)return{};this.consumeOptional(&quot;/&quot;);const t=[];for(this.peekStartsWith(&quot;(&quot;)||t.push(this.parseSegment());this.peekStartsWith(&quot;/&quot;)&amp;&amp;!this.peekStartsWith(&quot;//&quot;)&amp;&amp;!this.peekStartsWith(&quot;/(&quot;);)this.capture(&quot;/&quot;),t.push(this.parseSegment());let e={};this.peekStartsWith(&quot;/(&quot;)&amp;&amp;(this.capture(&quot;/&quot;),e=this.parseParens(!0));let i={};return this.peekStartsWith(&quot;(&quot;)&amp;&amp;(i=this.parseParens(!1)),(t.length&gt;0||Object.keys(e).length&gt;0)&amp;&amp;(i[De]=new Se(t,e)),i}parseSegment(){const t=Ed(this.remaining);if(&quot;&quot;===t&amp;&amp;this.peekStartsWith(&quot;;&quot;))throw new Error(`Empty path url segment cannot have parameters: &#39;${this.remaining}&#39;.`);return this.capture(t),new Nl(wd(t),this.parseMatrixParams())}parseMatrixParams(){const t={};for(;this.consumeOptional(&quot;;&quot;);)this.parseParam(t);return t}parseParam(t){const e=Ed(this.remaining);if(!e)return;this.capture(e);let i=&quot;&quot;;if(this.consumeOptional(&quot;=&quot;)){const r=Ed(this.remaining);r&amp;&amp;(i=r,this.capture(i))}t[wd(e)]=wd(i)}parseQueryParam(t){const e=function(n){const t=n.match(SH);return t?t[0]:&quot;&quot;}(this.remaining);if(!e)return;this.capture(e);let i=&quot;&quot;;if(this.consumeOptional(&quot;=&quot;)){const o=function(n){const t=n.match(MH);return t?t[0]:&quot;&quot;}(this.remaining);o&amp;&amp;(i=o,this.capture(i))}const r=ck(e),s=ck(i);if(t.hasOwnProperty(r)){let o=t[r];Array.isArray(o)||(o=[o],t[r]=o),o.push(s)}else t[r]=s}parseParens(t){const e={};for(this.capture(&quot;(&quot;);!this.consumeOptional(&quot;)&quot;)&amp;&amp;this.remaining.length&gt;0;){const i=Ed(this.remaining),r=this.remaining[i.length];if(&quot;/&quot;!==r&amp;&amp;&quot;)&quot;!==r&amp;&amp;&quot;;&quot;!==r)throw new Error(`Cannot parse url &#39;${this.url}&#39;`);let s;i.indexOf(&quot;:&quot;)&gt;-1?(s=i.substr(0,i.indexOf(&quot;:&quot;)),this.capture(s),this.capture(&quot;:&quot;)):t&amp;&amp;(s=De);const o=this.parseChildren();e[s]=1===Object.keys(o).length?o[De]:new Se([],o),this.consumeOptional(&quot;//&quot;)}return e}peekStartsWith(t){return this.remaining.startsWith(t)}consumeOptional(t){return!!this.peekStartsWith(t)&amp;&amp;(this.remaining=this.remaining.substring(t.length),!0)}capture(t){if(!this.consumeOptional(t))throw new Error(`Expected &quot;${t}&quot;.`)}}class dk{constructor(t){this._root=t}get root(){return this._root.value}parent(t){const e=this.pathFromRoot(t);return e.length&gt;1?e[e.length-2]:null}children(t){const e=Mm(t,this._root);return e?e.children.map(i=&gt;i.value):[]}firstChild(t){const e=Mm(t,this._root);return e&amp;&amp;e.children.length&gt;0?e.children[0].value:null}siblings(t){const e=Am(t,this._root);return e.length&lt;2?[]:e[e.length-2].children.map(r=&gt;r.value).filter(r=&gt;r!==t)}pathFromRoot(t){return Am(t,this._root).map(e=&gt;e.value)}}function Mm(n,t){if(n===t.value)return t;for(const e of t.children){const i=Mm(n,e);if(i)return i}return null}function Am(n,t){if(n===t.value)return[t];for(const e of t.children){const i=Am(n,e);if(i.length)return i.unshift(t),i}return[]}class dr{constructor(t,e){this.value=t,this.children=e}toString(){return`TreeNode(${this.value})`}}function Ll(n){const t={};return n&amp;&amp;n.children.forEach(e=&gt;t[e.value.outlet]=e),t}class hk extends dk{constructor(t,e){super(t),this.snapshot=e,Tm(this,t)}toString(){return this.snapshot.toString()}}function fk(n,t){const e=function(n,t){const o=new Sd([],{},{},&quot;&quot;,{},De,t,null,n.root,-1,{});return new gk(&quot;&quot;,new dr(o,[]))}(n,t),i=new Un([new Nl(&quot;&quot;,{})]),r=new Un({}),s=new Un({}),o=new Un({}),a=new Un(&quot;&quot;),l=new Ur(i,r,o,a,s,De,t,e.root);return l.snapshot=e.root,new hk(new dr(l,[]),e)}class Ur{constructor(t,e,i,r,s,o,a,l){this.url=t,this.params=e,this.queryParams=i,this.fragment=r,this.data=s,this.outlet=o,this.component=a,this._futureSnapshot=l}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(pe(t=&gt;ia(t)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(pe(t=&gt;ia(t)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function pk(n,t=&quot;emptyOnly&quot;){const e=n.pathFromRoot;let i=0;if(&quot;always&quot;!==t)for(i=e.length-1;i&gt;=1;){const r=e[i],s=e[i-1];if(r.routeConfig&amp;&amp;&quot;&quot;===r.routeConfig.path)i--;else{if(s.component)break;i--}}return function(n){return n.reduce((t,e)=&gt;({params:Object.assign(Object.assign({},t.params),e.params),data:Object.assign(Object.assign({},t.data),e.data),resolve:Object.assign(Object.assign({},t.resolve),e._resolvedData)}),{params:{},data:{},resolve:{}})}(e.slice(i))}class Sd{constructor(t,e,i,r,s,o,a,l,c,u,f){this.url=t,this.params=e,this.queryParams=i,this.fragment=r,this.data=s,this.outlet=o,this.component=a,this.routeConfig=l,this._urlSegment=c,this._lastPathIndex=u,this._resolve=f}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=ia(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=ia(this.queryParams)),this._queryParamMap}toString(){return`Route(url:&#39;${this.url.map(i=&gt;i.toString()).join(&quot;/&quot;)}&#39;, path:&#39;${this.routeConfig?this.routeConfig.path:&quot;&quot;}&#39;)`}}class gk extends dk{constructor(t,e){super(e),this.url=t,Tm(this,e)}toString(){return mk(this._root)}}function Tm(n,t){t.value._routerState=n,t.children.forEach(e=&gt;Tm(n,e))}function mk(n){const t=n.children.length&gt;0?` { ${n.children.map(mk).join(&quot;, &quot;)} } `:&quot;&quot;;return`${n.value}${t}`}function Im(n){if(n.snapshot){const t=n.snapshot,e=n._futureSnapshot;n.snapshot=e,Li(t.queryParams,e.queryParams)||n.queryParams.next(e.queryParams),t.fragment!==e.fragment&amp;&amp;n.fragment.next(e.fragment),Li(t.params,e.params)||n.params.next(e.params),function(n,t){if(n.length!==t.length)return!1;for(let e=0;e&lt;n.length;++e)if(!Li(n[e],t[e]))return!1;return!0}(t.url,e.url)||n.url.next(e.url),Li(t.data,e.data)||n.data.next(e.data)}else n.snapshot=n._futureSnapshot,n.data.next(n._futureSnapshot.data)}function xm(n,t){return Li(n.params,t.params)&amp;&amp;function(n,t){return ws(n,t)&amp;&amp;n.every((e,i)=&gt;Li(e.parameters,t[i].parameters))}(n.url,t.url)&amp;&amp;!(!n.parent!=!t.parent)&amp;&amp;(!n.parent||xm(n.parent,t.parent))}function kd(n,t,e){if(e&amp;&amp;n.shouldReuseRoute(t.value,e.value.snapshot)){const i=e.value;i._futureSnapshot=t.value;const r=function(n,t,e){return t.children.map(i=&gt;{for(const r of e.children)if(n.shouldReuseRoute(i.value,r.value.snapshot))return kd(n,i,r);return kd(n,i)})}(n,t,e);return new dr(i,r)}{if(n.shouldAttach(t.value)){const s=n.retrieve(t.value);if(null!==s){const o=s.route;return _k(t,o),o}}const i=function(n){return new Ur(new Un(n.url),new Un(n.params),new Un(n.queryParams),new Un(n.fragment),new Un(n.data),n.outlet,n.component,n)}(t.value),r=t.children.map(s=&gt;kd(n,s));return new dr(i,r)}}function _k(n,t){if(n.value.routeConfig!==t.value.routeConfig)throw new Error(&quot;Cannot reattach ActivatedRouteSnapshot created from a different route&quot;);if(n.children.length!==t.children.length)throw new Error(&quot;Cannot reattach ActivatedRouteSnapshot with a different number of children&quot;);t.value._futureSnapshot=n.value;for(let e=0;e&lt;n.children.length;++e)_k(n.children[e],t.children[e])}function Md(n){return&quot;object&quot;==typeof n&amp;&amp;null!=n&amp;&amp;!n.outlets&amp;&amp;!n.segmentPath}function jl(n){return&quot;object&quot;==typeof n&amp;&amp;null!=n&amp;&amp;n.outlets}function Rm(n,t,e,i,r){let s={};return i&amp;&amp;Ot(i,(o,a)=&gt;{s[a]=Array.isArray(o)?o.map(l=&gt;`${l}`):`${o}`}),new Ds(e.root===n?t:yk(e.root,n,t),s,r)}function yk(n,t,e){const i={};return Ot(n.children,(r,s)=&gt;{i[s]=r===t?e:yk(r,t,e)}),new Se(n.segments,i)}class vk{constructor(t,e,i){if(this.isAbsolute=t,this.numberOfDoubleDots=e,this.commands=i,t&amp;&amp;i.length&gt;0&amp;&amp;Md(i[0]))throw new Error(&quot;Root segment cannot have matrix parameters&quot;);const r=i.find(jl);if(r&amp;&amp;r!==tk(i))throw new Error(&quot;{outlets:{}} has to be the last command&quot;)}toRoot(){return this.isAbsolute&amp;&amp;1===this.commands.length&amp;&amp;&quot;/&quot;==this.commands[0]}}class Pm{constructor(t,e,i){this.segmentGroup=t,this.processChildren=e,this.index=i}}function bk(n,t,e){if(n||(n=new Se([],{})),0===n.segments.length&amp;&amp;n.hasChildren())return Ad(n,t,e);const i=function(n,t,e){let i=0,r=t;const s={match:!1,pathIndex:0,commandIndex:0};for(;r&lt;n.segments.length;){if(i&gt;=e.length)return s;const o=n.segments[r],a=e[i];if(jl(a))break;const l=`${a}`,c=i&lt;e.length-1?e[i+1]:null;if(r&gt;0&amp;&amp;void 0===l)break;if(l&amp;&amp;c&amp;&amp;&quot;object&quot;==typeof c&amp;&amp;void 0===c.outlets){if(!Dk(l,c,o))return s;i+=2}else{if(!Dk(l,{},o))return s;i++}r++}return{match:!0,pathIndex:r,commandIndex:i}}(n,t,e),r=e.slice(i.commandIndex);if(i.match&amp;&amp;i.pathIndex&lt;n.segments.length){const s=new Se(n.segments.slice(0,i.pathIndex),{});return s.children[De]=new Se(n.segments.slice(i.pathIndex),n.children),Ad(s,0,r)}return i.match&amp;&amp;0===r.length?new Se(n.segments,{}):i.match&amp;&amp;!n.hasChildren()?Om(n,t,e):i.match?Ad(n,0,r):Om(n,t,e)}function Ad(n,t,e){if(0===e.length)return new Se(n.segments,{});{const i=function(n){return jl(n[0])?n[0].outlets:{[De]:n}}(e),r={};return Ot(i,(s,o)=&gt;{&quot;string&quot;==typeof s&amp;&amp;(s=[s]),null!==s&amp;&amp;(r[o]=bk(n.children[o],t,s))}),Ot(n.children,(s,o)=&gt;{void 0===i[o]&amp;&amp;(r[o]=s)}),new Se(n.segments,r)}}function Om(n,t,e){const i=n.segments.slice(0,t);let r=0;for(;r&lt;e.length;){const s=e[r];if(jl(s)){const l=UH(s.outlets);return new Se(i,l)}if(0===r&amp;&amp;Md(e[0])){i.push(new Nl(n.segments[t].path,Ck(e[0]))),r++;continue}const o=jl(s)?s.outlets[De]:`${s}`,a=r&lt;e.length-1?e[r+1]:null;o&amp;&amp;a&amp;&amp;Md(a)?(i.push(new Nl(o,Ck(a))),r+=2):(i.push(new Nl(o,{})),r++)}return new Se(i,{})}function UH(n){const t={};return Ot(n,(e,i)=&gt;{&quot;string&quot;==typeof e&amp;&amp;(e=[e]),null!==e&amp;&amp;(t[i]=Om(new Se([],{}),0,e))}),t}function Ck(n){const t={};return Ot(n,(e,i)=&gt;t[i]=`${e}`),t}function Dk(n,t,e){return n==e.path&amp;&amp;Li(t,e.parameters)}class zH{constructor(t,e,i,r){this.routeReuseStrategy=t,this.futureState=e,this.currState=i,this.forwardEvent=r}activate(t){const e=this.futureState._root,i=this.currState?this.currState._root:null;this.deactivateChildRoutes(e,i,t),Im(this.futureState.root),this.activateChildRoutes(e,i,t)}deactivateChildRoutes(t,e,i){const r=Ll(e);t.children.forEach(s=&gt;{const o=s.value.outlet;this.deactivateRoutes(s,r[o],i),delete r[o]}),Ot(r,(s,o)=&gt;{this.deactivateRouteAndItsChildren(s,i)})}deactivateRoutes(t,e,i){const r=t.value,s=e?e.value:null;if(r===s)if(r.component){const o=i.getContext(r.outlet);o&amp;&amp;this.deactivateChildRoutes(t,e,o.children)}else this.deactivateChildRoutes(t,e,i);else s&amp;&amp;this.deactivateRouteAndItsChildren(e,i)}deactivateRouteAndItsChildren(t,e){this.routeReuseStrategy.shouldDetach(t.value.snapshot)?this.detachAndStoreRouteSubtree(t,e):this.deactivateRouteAndOutlet(t,e)}detachAndStoreRouteSubtree(t,e){const i=e.getContext(t.value.outlet);if(i&amp;&amp;i.outlet){const r=i.outlet.detach(),s=i.children.onOutletDeactivated();this.routeReuseStrategy.store(t.value.snapshot,{componentRef:r,route:t,contexts:s})}}deactivateRouteAndOutlet(t,e){const i=e.getContext(t.value.outlet),r=i&amp;&amp;t.value.component?i.children:e,s=Ll(t);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],r);i&amp;&amp;i.outlet&amp;&amp;(i.outlet.deactivate(),i.children.onOutletDeactivated(),i.attachRef=null,i.resolver=null,i.route=null)}activateChildRoutes(t,e,i){const r=Ll(e);t.children.forEach(s=&gt;{this.activateRoutes(s,r[s.value.outlet],i),this.forwardEvent(new cH(s.value.snapshot))}),t.children.length&amp;&amp;this.forwardEvent(new aH(t.value.snapshot))}activateRoutes(t,e,i){const r=t.value,s=e?e.value:null;if(Im(r),r===s)if(r.component){const o=i.getOrCreateContext(r.outlet);this.activateChildRoutes(t,e,o.children)}else this.activateChildRoutes(t,e,i);else if(r.component){const o=i.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const a=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),o.children.onOutletReAttached(a.contexts),o.attachRef=a.componentRef,o.route=a.route.value,o.outlet&amp;&amp;o.outlet.attach(a.componentRef,a.route.value),wk(a.route)}else{const a=function(n){for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e&amp;&amp;e._loadedConfig)return e._loadedConfig;if(e&amp;&amp;e.component)return null}return null}(r.snapshot),l=a?a.module.componentFactoryResolver:null;o.attachRef=null,o.route=r,o.resolver=l,o.outlet&amp;&amp;o.outlet.activateWith(r,l),this.activateChildRoutes(t,null,o.children)}}else this.activateChildRoutes(t,null,i)}}function wk(n){Im(n.value),n.children.forEach(wk)}class Fm{constructor(t,e){this.routes=t,this.module=e}}function Hr(n){return&quot;function&quot;==typeof n}function Es(n){return n instanceof Ds}const Bl=Symbol(&quot;INITIAL_VALUE&quot;);function Ul(){return nn(n=&gt;function(...n){let t,e;return $s(n[n.length-1])&amp;&amp;(e=n.pop()),&quot;function&quot;==typeof n[n.length-1]&amp;&amp;(t=n.pop()),1===n.length&amp;&amp;zs(n[0])&amp;&amp;(n=n[0]),Mh(n,e).lift(new TU(t))}(n.map(t=&gt;t.pipe(rn(1),lr(Bl)))).pipe(GS((t,e)=&gt;{let i=!1;return e.reduce((r,s,o)=&gt;r!==Bl?r:(s===Bl&amp;&amp;(i=!0),i||!1!==s&amp;&amp;o!==e.length-1&amp;&amp;!Es(s)?r:s),t)},Bl),cn(t=&gt;t!==Bl),pe(t=&gt;Es(t)?t:!0===t),rn(1)))}let Ek=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ee({type:n,selectors:[[&quot;ng-component&quot;]],decls:1,vars:0,template:function(e,i){1&amp;e&amp;&amp;k(0,&quot;router-outlet&quot;)},directives:function(){return[Um]},encapsulation:2}),n})();function Sk(n,t=&quot;&quot;){for(let e=0;e&lt;n.length;e++){const i=n[e];QH(i,ZH(t,i))}}function QH(n,t){n.children&amp;&amp;Sk(n.children,t)}function ZH(n,t){return t?n||t.path?n&amp;&amp;!t.path?`${n}/`:!n&amp;&amp;t.path?t.path:`${n}/${t.path}`:&quot;&quot;:n}function Nm(n){const t=n.children&amp;&amp;n.children.map(Nm),e=t?Object.assign(Object.assign({},n),{children:t}):Object.assign({},n);return!e.component&amp;&amp;(t||e.loadChildren)&amp;&amp;e.outlet&amp;&amp;e.outlet!==De&amp;&amp;(e.component=Ek),e}function Hn(n){return n.outlet||De}function kk(n,t){const e=n.filter(i=&gt;Hn(i)===t);return e.push(...n.filter(i=&gt;Hn(i)!==t)),e}const Mk={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function Td(n,t,e){var i;if(&quot;&quot;===t.path)return&quot;full&quot;===t.pathMatch&amp;&amp;(n.hasChildren()||e.length&gt;0)?Object.assign({},Mk):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const s=(t.matcher||hH)(e,n,t);if(!s)return Object.assign({},Mk);const o={};Ot(s.posParams,(l,c)=&gt;{o[c]=l.path});const a=s.consumed.length&gt;0?Object.assign(Object.assign({},o),s.consumed[s.consumed.length-1].parameters):o;return{matched:!0,consumedSegments:s.consumed,lastChild:s.consumed.length,parameters:a,positionalParamSegments:null!==(i=s.posParams)&amp;&amp;void 0!==i?i:{}}}function Id(n,t,e,i,r=&quot;corrected&quot;){if(e.length&gt;0&amp;&amp;function(n,t,e){return e.some(i=&gt;xd(n,t,i)&amp;&amp;Hn(i)!==De)}(n,e,i)){const o=new Se(t,function(n,t,e,i){const r={};r[De]=i,i._sourceSegment=n,i._segmentIndexShift=t.length;for(const s of e)if(&quot;&quot;===s.path&amp;&amp;Hn(s)!==De){const o=new Se([],{});o._sourceSegment=n,o._segmentIndexShift=t.length,r[Hn(s)]=o}return r}(n,t,i,new Se(e,n.children)));return o._sourceSegment=n,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:[]}}if(0===e.length&amp;&amp;function(n,t,e){return e.some(i=&gt;xd(n,t,i))}(n,e,i)){const o=new Se(n.segments,function(n,t,e,i,r,s){const o={};for(const a of i)if(xd(n,e,a)&amp;&amp;!r[Hn(a)]){const l=new Se([],{});l._sourceSegment=n,l._segmentIndexShift=&quot;legacy&quot;===s?n.segments.length:t.length,o[Hn(a)]=l}return Object.assign(Object.assign({},r),o)}(n,t,e,i,n.children,r));return o._sourceSegment=n,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:e}}const s=new Se(n.segments,n.children);return s._sourceSegment=n,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:e}}function xd(n,t,e){return(!(n.hasChildren()||t.length&gt;0)||&quot;full&quot;!==e.pathMatch)&amp;&amp;&quot;&quot;===e.path}function Ak(n,t,e,i){return!!(Hn(n)===i||i!==De&amp;&amp;xd(t,e,n))&amp;&amp;(&quot;**&quot;===n.path||Td(t,n,e).matched)}function Tk(n,t,e){return 0===t.length&amp;&amp;!n.children[e]}class Hl{constructor(t){this.segmentGroup=t||null}}class Ik{constructor(t){this.urlTree=t}}function Rd(n){return new ye(t=&gt;t.error(new Hl(n)))}function xk(n){return new ye(t=&gt;t.error(new Ik(n)))}function nz(n){return new ye(t=&gt;t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: &#39;${n}&#39;`)))}class sz{constructor(t,e,i,r,s){this.configLoader=e,this.urlSerializer=i,this.urlTree=r,this.config=s,this.allowRedirects=!0,this.ngModule=t.get(Pi)}apply(){const t=Id(this.urlTree.root,[],[],this.config).segmentGroup,e=new Se(t.segments,t.children);return this.expandSegmentGroup(this.ngModule,this.config,e,De).pipe(pe(s=&gt;this.createUrlTree(Vm(s),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Ie(s=&gt;{if(s instanceof Ik)return this.allowRedirects=!1,this.match(s.urlTree);throw s instanceof Hl?this.noMatchError(s):s}))}match(t){return this.expandSegmentGroup(this.ngModule,this.config,t.root,De).pipe(pe(r=&gt;this.createUrlTree(Vm(r),t.queryParams,t.fragment))).pipe(Ie(r=&gt;{throw r instanceof Hl?this.noMatchError(r):r}))}noMatchError(t){return new Error(`Cannot match any routes. URL Segment: &#39;${t.segmentGroup}&#39;`)}createUrlTree(t,e,i){const r=t.segments.length&gt;0?new Se([],{[De]:t}):t;return new Ds(r,e,i)}expandSegmentGroup(t,e,i,r){return 0===i.segments.length&amp;&amp;i.hasChildren()?this.expandChildren(t,e,i).pipe(pe(s=&gt;new Se([],s))):this.expandSegment(t,i,e,i.segments,r,!0)}expandChildren(t,e,i){const r=[];for(const s of Object.keys(i.children))&quot;primary&quot;===s?r.unshift(s):r.push(s);return At(r).pipe(Qo(s=&gt;{const o=i.children[s],a=kk(e,s);return this.expandSegmentGroup(t,a,o,s).pipe(pe(l=&gt;({segment:l,outlet:s})))}),GS((s,o)=&gt;(s[o.outlet]=o.segment,s),{}),function(n,t){const e=arguments.length&gt;=2;return i=&gt;i.pipe(n?cn((r,s)=&gt;n(r,s,i)):yc,Dm(1),e?qS(t):WS(()=&gt;new md))}())}expandSegment(t,e,i,r,s,o){return At(i).pipe(Qo(a=&gt;this.expandSegmentAgainstRoute(t,e,i,a,r,s,o).pipe(Ie(c=&gt;{if(c instanceof Hl)return G(null);throw c}))),na(a=&gt;!!a),Ie((a,l)=&gt;{if(a instanceof md||&quot;EmptyError&quot;===a.name){if(Tk(e,r,s))return G(new Se([],{}));throw new Hl(e)}throw a}))}expandSegmentAgainstRoute(t,e,i,r,s,o,a){return Ak(r,e,s,o)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(t,e,r,s,o):a&amp;&amp;this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(t,e,i,r,s,o):Rd(e):Rd(e)}expandSegmentAgainstRouteUsingRedirect(t,e,i,r,s,o){return&quot;**&quot;===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(t,i,r,o):this.expandRegularSegmentAgainstRouteUsingRedirect(t,e,i,r,s,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(t,e,i,r){const s=this.applyRedirectCommands([],i.redirectTo,{});return i.redirectTo.startsWith(&quot;/&quot;)?xk(s):this.lineralizeSegments(i,s).pipe(Tt(o=&gt;{const a=new Se(o,{});return this.expandSegment(t,a,e,o,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(t,e,i,r,s,o){const{matched:a,consumedSegments:l,lastChild:c,positionalParamSegments:u}=Td(e,r,s);if(!a)return Rd(e);const f=this.applyRedirectCommands(l,r.redirectTo,u);return r.redirectTo.startsWith(&quot;/&quot;)?xk(f):this.lineralizeSegments(r,f).pipe(Tt(p=&gt;this.expandSegment(t,e,i,p.concat(s.slice(c)),o,!1)))}matchSegmentAgainstRoute(t,e,i,r,s){if(&quot;**&quot;===i.path)return i.loadChildren?(i._loadedConfig?G(i._loadedConfig):this.configLoader.load(t.injector,i)).pipe(pe(p=&gt;(i._loadedConfig=p,new Se(r,{})))):G(new Se(r,{}));const{matched:o,consumedSegments:a,lastChild:l}=Td(e,i,r);if(!o)return Rd(e);const c=r.slice(l);return this.getChildConfig(t,i,r).pipe(Tt(f=&gt;{const p=f.module,g=f.routes,{segmentGroup:m,slicedSegments:C}=Id(e,a,c,g),v=new Se(m.segments,m.children);if(0===C.length&amp;&amp;v.hasChildren())return this.expandChildren(p,g,v).pipe(pe(F=&gt;new Se(a,F)));if(0===g.length&amp;&amp;0===C.length)return G(new Se(a,{}));const S=Hn(i)===s;return this.expandSegment(p,v,g,C,S?De:s,!0).pipe(pe(R=&gt;new Se(a.concat(R.segments),R.children)))}))}getChildConfig(t,e,i){return e.children?G(new Fm(e.children,t)):e.loadChildren?void 0!==e._loadedConfig?G(e._loadedConfig):this.runCanLoadGuards(t.injector,e,i).pipe(Tt(r=&gt;r?this.configLoader.load(t.injector,e).pipe(pe(s=&gt;(e._loadedConfig=s,s))):function(n){return new ye(t=&gt;t.error(Em(`Cannot load children because the guard of the route &quot;path: &#39;${n.path}&#39;&quot; returned false`)))}(e))):G(new Fm([],t))}runCanLoadGuards(t,e,i){const r=e.canLoad;return r&amp;&amp;0!==r.length?G(r.map(o=&gt;{const a=t.get(o);let l;if(function(n){return n&amp;&amp;Hr(n.canLoad)}(a))l=a.canLoad(e,i);else{if(!Hr(a))throw new Error(&quot;Invalid CanLoad guard&quot;);l=a(e,i)}return ji(l)})).pipe(Ul(),zt(o=&gt;{if(!Es(o))return;const a=Em(`Redirecting to &quot;${this.urlSerializer.serialize(o)}&quot;`);throw a.url=o,a}),pe(o=&gt;!0===o)):G(!0)}lineralizeSegments(t,e){let i=[],r=e.root;for(;;){if(i=i.concat(r.segments),0===r.numberOfChildren)return G(i);if(r.numberOfChildren&gt;1||!r.children[De])return nz(t.redirectTo);r=r.children[De]}}applyRedirectCommands(t,e,i){return this.applyRedirectCreatreUrlTree(e,this.urlSerializer.parse(e),t,i)}applyRedirectCreatreUrlTree(t,e,i,r){const s=this.createSegmentGroup(t,e.root,i,r);return new Ds(s,this.createQueryParams(e.queryParams,this.urlTree.queryParams),e.fragment)}createQueryParams(t,e){const i={};return Ot(t,(r,s)=&gt;{if(&quot;string&quot;==typeof r&amp;&amp;r.startsWith(&quot;:&quot;)){const a=r.substring(1);i[s]=e[a]}else i[s]=r}),i}createSegmentGroup(t,e,i,r){const s=this.createSegments(t,e.segments,i,r);let o={};return Ot(e.children,(a,l)=&gt;{o[l]=this.createSegmentGroup(t,a,i,r)}),new Se(s,o)}createSegments(t,e,i,r){return e.map(s=&gt;s.path.startsWith(&quot;:&quot;)?this.findPosParam(t,s,r):this.findOrReturn(s,i))}findPosParam(t,e,i){const r=i[e.path.substring(1)];if(!r)throw new Error(`Cannot redirect to &#39;${t}&#39;. Cannot find &#39;${e.path}&#39;.`);return r}findOrReturn(t,e){let i=0;for(const r of e){if(r.path===t.path)return e.splice(i),r;i++}return t}}function Vm(n){const t={};for(const i of Object.keys(n.children)){const s=Vm(n.children[i]);(s.segments.length&gt;0||s.hasChildren())&amp;&amp;(t[i]=s)}return function(n){if(1===n.numberOfChildren&amp;&amp;n.children[De]){const t=n.children[De];return new Se(n.segments.concat(t.segments),t.children)}return n}(new Se(n.segments,t))}class Rk{constructor(t){this.path=t,this.route=this.path[this.path.length-1]}}class Pd{constructor(t,e){this.component=t,this.route=e}}function lz(n,t,e){const i=n._root;return zl(i,t?t._root:null,e,[i.value])}function Od(n,t,e){const i=function(n){if(!n)return null;for(let t=n.parent;t;t=t.parent){const e=t.routeConfig;if(e&amp;&amp;e._loadedConfig)return e._loadedConfig}return null}(t);return(i?i.module.injector:e).get(n)}function zl(n,t,e,i,r={canDeactivateChecks:[],canActivateChecks:[]}){const s=Ll(t);return n.children.forEach(o=&gt;{(function(n,t,e,i,r={canDeactivateChecks:[],canActivateChecks:[]}){const s=n.value,o=t?t.value:null,a=e?e.getContext(n.value.outlet):null;if(o&amp;&amp;s.routeConfig===o.routeConfig){const l=function(n,t,e){if(&quot;function&quot;==typeof e)return e(n,t);switch(e){case&quot;pathParamsChange&quot;:return!ws(n.url,t.url);case&quot;pathParamsOrQueryParamsChange&quot;:return!ws(n.url,t.url)||!Li(n.queryParams,t.queryParams);case&quot;always&quot;:return!0;case&quot;paramsOrQueryParamsChange&quot;:return!xm(n,t)||!Li(n.queryParams,t.queryParams);case&quot;paramsChange&quot;:default:return!xm(n,t)}}(o,s,s.routeConfig.runGuardsAndResolvers);l?r.canActivateChecks.push(new Rk(i)):(s.data=o.data,s._resolvedData=o._resolvedData),zl(n,t,s.component?a?a.children:null:e,i,r),l&amp;&amp;a&amp;&amp;a.outlet&amp;&amp;a.outlet.isActivated&amp;&amp;r.canDeactivateChecks.push(new Pd(a.outlet.component,o))}else o&amp;&amp;$l(t,a,r),r.canActivateChecks.push(new Rk(i)),zl(n,null,s.component?a?a.children:null:e,i,r)})(o,s[o.value.outlet],e,i.concat([o.value]),r),delete s[o.value.outlet]}),Ot(s,(o,a)=&gt;$l(o,e.getContext(a),r)),r}function $l(n,t,e){const i=Ll(n),r=n.value;Ot(i,(s,o)=&gt;{$l(s,r.component?t?t.children.getContext(o):null:t,e)}),e.canDeactivateChecks.push(new Pd(r.component&amp;&amp;t&amp;&amp;t.outlet&amp;&amp;t.outlet.isActivated?t.outlet.component:null,r))}class Cz{}function Pk(n){return new ye(t=&gt;t.error(n))}class wz{constructor(t,e,i,r,s,o){this.rootComponentType=t,this.config=e,this.urlTree=i,this.url=r,this.paramsInheritanceStrategy=s,this.relativeLinkResolution=o}recognize(){const t=Id(this.urlTree.root,[],[],this.config.filter(o=&gt;void 0===o.redirectTo),this.relativeLinkResolution).segmentGroup,e=this.processSegmentGroup(this.config,t,De);if(null===e)return null;const i=new Sd([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},De,this.rootComponentType,null,this.urlTree.root,-1,{}),r=new dr(i,e),s=new gk(this.url,r);return this.inheritParamsAndData(s._root),s}inheritParamsAndData(t){const e=t.value,i=pk(e,this.paramsInheritanceStrategy);e.params=Object.freeze(i.params),e.data=Object.freeze(i.data),t.children.forEach(r=&gt;this.inheritParamsAndData(r))}processSegmentGroup(t,e,i){return 0===e.segments.length&amp;&amp;e.hasChildren()?this.processChildren(t,e):this.processSegment(t,e,e.segments,i)}processChildren(t,e){const i=[];for(const s of Object.keys(e.children)){const o=e.children[s],a=kk(t,s),l=this.processSegmentGroup(a,o,s);if(null===l)return null;i.push(...l)}const r=Ok(i);return function(n){n.sort((t,e)=&gt;t.value.outlet===De?-1:e.value.outlet===De?1:t.value.outlet.localeCompare(e.value.outlet))}(r),r}processSegment(t,e,i,r){for(const s of t){const o=this.processSegmentAgainstRoute(s,e,i,r);if(null!==o)return o}return Tk(e,i,r)?[]:null}processSegmentAgainstRoute(t,e,i,r){if(t.redirectTo||!Ak(t,e,i,r))return null;let s,o=[],a=[];if(&quot;**&quot;===t.path){const g=i.length&gt;0?tk(i).parameters:{};s=new Sd(i,g,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Vk(t),Hn(t),t.component,t,Fk(e),Nk(e)+i.length,Lk(t))}else{const g=Td(e,t,i);if(!g.matched)return null;o=g.consumedSegments,a=i.slice(g.lastChild),s=new Sd(o,g.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Vk(t),Hn(t),t.component,t,Fk(e),Nk(e)+o.length,Lk(t))}const l=function(n){return n.children?n.children:n.loadChildren?n._loadedConfig.routes:[]}(t),{segmentGroup:c,slicedSegments:u}=Id(e,o,a,l.filter(g=&gt;void 0===g.redirectTo),this.relativeLinkResolution);if(0===u.length&amp;&amp;c.hasChildren()){const g=this.processChildren(l,c);return null===g?null:[new dr(s,g)]}if(0===l.length&amp;&amp;0===u.length)return[new dr(s,[])];const f=Hn(t)===r,p=this.processSegment(l,c,u,f?De:r);return null===p?null:[new dr(s,p)]}}function kz(n){const t=n.value.routeConfig;return t&amp;&amp;&quot;&quot;===t.path&amp;&amp;void 0===t.redirectTo}function Ok(n){const t=[],e=new Set;for(const i of n){if(!kz(i)){t.push(i);continue}const r=t.find(s=&gt;i.value.routeConfig===s.value.routeConfig);void 0!==r?(r.children.push(...i.children),e.add(r)):t.push(i)}for(const i of e){const r=Ok(i.children);t.push(new dr(i.value,r))}return t.filter(i=&gt;!e.has(i))}function Fk(n){let t=n;for(;t._sourceSegment;)t=t._sourceSegment;return t}function Nk(n){let t=n,e=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,e+=t._segmentIndexShift?t._segmentIndexShift:0;return e-1}function Vk(n){return n.data||{}}function Lk(n){return n.resolve||{}}function Lm(n){return nn(t=&gt;{const e=n(t);return e?At(e).pipe(pe(()=&gt;t)):G(t)})}class Oz extends class{shouldDetach(t){return!1}store(t,e){}shouldAttach(t){return!1}retrieve(t){return null}shouldReuseRoute(t,e){return t.routeConfig===e.routeConfig}}{}const jm=new j(&quot;ROUTES&quot;);class jk{constructor(t,e,i,r){this.loader=t,this.compiler=e,this.onLoadStartListener=i,this.onLoadEndListener=r}load(t,e){if(e._loader$)return e._loader$;this.onLoadStartListener&amp;&amp;this.onLoadStartListener(e);const r=this.loadModuleFactory(e.loadChildren).pipe(pe(s=&gt;{this.onLoadEndListener&amp;&amp;this.onLoadEndListener(e);const o=s.create(t);return new Fm(ek(o.injector.get(jm,void 0,z.Self|z.Optional)).map(Nm),o)}),Ie(s=&gt;{throw e._loader$=void 0,s}));return e._loader$=new Cy(r,()=&gt;new ie).pipe(Ah()),e._loader$}loadModuleFactory(t){return&quot;string&quot;==typeof t?At(this.loader.load(t)):ji(t()).pipe(Tt(e=&gt;e instanceof lw?G(e):At(this.compiler.compileModuleAsync(e))))}}class Fz{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new ra,this.attachRef=null}}class ra{constructor(){this.contexts=new Map}onChildOutletCreated(t,e){const i=this.getOrCreateContext(t);i.outlet=e,this.contexts.set(t,i)}onChildOutletDestroyed(t){const e=this.getContext(t);e&amp;&amp;(e.outlet=null,e.attachRef=null)}onOutletDeactivated(){const t=this.contexts;return this.contexts=new Map,t}onOutletReAttached(t){this.contexts=t}getOrCreateContext(t){let e=this.getContext(t);return e||(e=new Fz,this.contexts.set(t,e)),e}getContext(t){return this.contexts.get(t)||null}}class Vz{shouldProcessUrl(t){return!0}extract(t){return t}merge(t,e){return t}}function Lz(n){throw n}function jz(n,t,e){return t.parse(&quot;/&quot;)}function Bk(n,t){return G(null)}const Bz={paths:&quot;exact&quot;,fragment:&quot;ignored&quot;,matrixParams:&quot;ignored&quot;,queryParams:&quot;exact&quot;},Uz={paths:&quot;subset&quot;,fragment:&quot;ignored&quot;,matrixParams:&quot;ignored&quot;,queryParams:&quot;subset&quot;};let Xe=(()=&gt;{class n{constructor(e,i,r,s,o,a,l,c){this.rootComponentType=e,this.urlSerializer=i,this.rootContexts=r,this.location=s,this.config=c,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new ie,this.errorHandler=Lz,this.malformedUriErrorHandler=jz,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:Bk,afterPreactivation:Bk},this.urlHandlingStrategy=new Vz,this.routeReuseStrategy=new Oz,this.onSameUrlNavigation=&quot;ignore&quot;,this.paramsInheritanceStrategy=&quot;emptyOnly&quot;,this.urlUpdateStrategy=&quot;deferred&quot;,this.relativeLinkResolution=&quot;corrected&quot;,this.canceledNavigationResolution=&quot;replace&quot;,this.ngModule=o.get(Pi),this.console=o.get(Tu);const p=o.get(Y);this.isNgZoneEnabled=p instanceof Y&amp;&amp;Y.isInAngularZone(),this.resetConfig(c),this.currentUrlTree=new Ds(new Se([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new jk(a,l,g=&gt;this.triggerEvent(new KS(g)),g=&gt;this.triggerEvent(new QS(g))),this.routerState=fk(this.currentUrlTree,this.rootComponentType),this.transitions=new Un({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:&quot;imperative&quot;,restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}get browserPageId(){var e;return null===(e=this.location.getState())||void 0===e?void 0:e.\u0275routerPageId}setupNavigations(e){const i=this.events;return e.pipe(cn(r=&gt;0!==r.id),pe(r=&gt;Object.assign(Object.assign({},r),{extractedUrl:this.urlHandlingStrategy.extract(r.rawUrl)})),nn(r=&gt;{let s=!1,o=!1;return G(r).pipe(zt(a=&gt;{this.currentNavigation={id:a.id,initialUrl:a.currentRawUrl,extractedUrl:a.extractedUrl,trigger:a.source,extras:a.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),nn(a=&gt;{const l=this.browserUrlTree.toString(),c=!this.navigated||a.extractedUrl.toString()!==l||l!==this.currentUrlTree.toString();if((&quot;reload&quot;===this.onSameUrlNavigation||c)&amp;&amp;this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl))return Fd(a.source)&amp;&amp;(this.browserUrlTree=a.extractedUrl),G(a).pipe(nn(f=&gt;{const p=this.transitions.getValue();return i.next(new wm(f.id,this.serializeUrl(f.extractedUrl),f.source,f.restoredState)),p!==this.transitions.getValue()?Cs:Promise.resolve(f)}),function(n,t,e,i){return nn(r=&gt;function(n,t,e,i,r){return new sz(n,t,e,i,r).apply()}(n,t,e,r.extractedUrl,i).pipe(pe(s=&gt;Object.assign(Object.assign({},r),{urlAfterRedirects:s}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),zt(f=&gt;{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:f.urlAfterRedirects})}),function(n,t,e,i,r){return Tt(s=&gt;function(n,t,e,i,r=&quot;emptyOnly&quot;,s=&quot;legacy&quot;){try{const o=new wz(n,t,e,i,r,s).recognize();return null===o?Pk(new Cz):G(o)}catch(o){return Pk(o)}}(n,t,s.urlAfterRedirects,e(s.urlAfterRedirects),i,r).pipe(pe(o=&gt;Object.assign(Object.assign({},s),{targetSnapshot:o}))))}(this.rootComponentType,this.config,f=&gt;this.serializeUrl(f),this.paramsInheritanceStrategy,this.relativeLinkResolution),zt(f=&gt;{&quot;eager&quot;===this.urlUpdateStrategy&amp;&amp;(f.extras.skipLocationChange||this.setBrowserUrl(f.urlAfterRedirects,f),this.browserUrlTree=f.urlAfterRedirects);const p=new tH(f.id,this.serializeUrl(f.extractedUrl),this.serializeUrl(f.urlAfterRedirects),f.targetSnapshot);i.next(p)}));if(c&amp;&amp;this.rawUrlTree&amp;&amp;this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:p,extractedUrl:g,source:m,restoredState:C,extras:v}=a,S=new wm(p,this.serializeUrl(g),m,C);i.next(S);const E=fk(g,this.rootComponentType).snapshot;return G(Object.assign(Object.assign({},a),{targetSnapshot:E,urlAfterRedirects:g,extras:Object.assign(Object.assign({},v),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=a.rawUrl,this.browserUrlTree=a.urlAfterRedirects,a.resolve(null),Cs}),Lm(a=&gt;{const{targetSnapshot:l,id:c,extractedUrl:u,rawUrl:f,extras:{skipLocationChange:p,replaceUrl:g}}=a;return this.hooks.beforePreactivation(l,{navigationId:c,appliedUrlTree:u,rawUrlTree:f,skipLocationChange:!!p,replaceUrl:!!g})}),zt(a=&gt;{const l=new nH(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot);this.triggerEvent(l)}),pe(a=&gt;Object.assign(Object.assign({},a),{guards:lz(a.targetSnapshot,a.currentSnapshot,this.rootContexts)})),function(n,t){return Tt(e=&gt;{const{targetSnapshot:i,currentSnapshot:r,guards:{canActivateChecks:s,canDeactivateChecks:o}}=e;return 0===o.length&amp;&amp;0===s.length?G(Object.assign(Object.assign({},e),{guardsResult:!0})):function(n,t,e,i){return At(n).pipe(Tt(r=&gt;function(n,t,e,i,r){const s=t&amp;&amp;t.routeConfig?t.routeConfig.canDeactivate:null;return s&amp;&amp;0!==s.length?G(s.map(a=&gt;{const l=Od(a,t,r);let c;if(function(n){return n&amp;&amp;Hr(n.canDeactivate)}(l))c=ji(l.canDeactivate(n,t,e,i));else{if(!Hr(l))throw new Error(&quot;Invalid CanDeactivate guard&quot;);c=ji(l(n,t,e,i))}return c.pipe(na())})).pipe(Ul()):G(!0)}(r.component,r.route,e,t,i)),na(r=&gt;!0!==r,!0))}(o,i,r,n).pipe(Tt(a=&gt;a&amp;&amp;function(n){return&quot;boolean&quot;==typeof n}(a)?function(n,t,e,i){return At(t).pipe(Qo(r=&gt;_d(function(n,t){return null!==n&amp;&amp;t&amp;&amp;t(new oH(n)),G(!0)}(r.route.parent,i),function(n,t){return null!==n&amp;&amp;t&amp;&amp;t(new lH(n)),G(!0)}(r.route,i),function(n,t,e){const i=t[t.length-1],s=t.slice(0,t.length-1).reverse().map(o=&gt;function(n){const t=n.routeConfig?n.routeConfig.canActivateChild:null;return t&amp;&amp;0!==t.length?{node:n,guards:t}:null}(o)).filter(o=&gt;null!==o).map(o=&gt;vd(()=&gt;G(o.guards.map(l=&gt;{const c=Od(l,o.node,e);let u;if(function(n){return n&amp;&amp;Hr(n.canActivateChild)}(c))u=ji(c.canActivateChild(i,n));else{if(!Hr(c))throw new Error(&quot;Invalid CanActivateChild guard&quot;);u=ji(c(i,n))}return u.pipe(na())})).pipe(Ul())));return G(s).pipe(Ul())}(n,r.path,e),function(n,t,e){const i=t.routeConfig?t.routeConfig.canActivate:null;return i&amp;&amp;0!==i.length?G(i.map(s=&gt;vd(()=&gt;{const o=Od(s,t,e);let a;if(function(n){return n&amp;&amp;Hr(n.canActivate)}(o))a=ji(o.canActivate(t,n));else{if(!Hr(o))throw new Error(&quot;Invalid CanActivate guard&quot;);a=ji(o(t,n))}return a.pipe(na())}))).pipe(Ul()):G(!0)}(n,r.route,e))),na(r=&gt;!0!==r,!0))}(i,s,n,t):G(a)),pe(a=&gt;Object.assign(Object.assign({},e),{guardsResult:a})))})}(this.ngModule.injector,a=&gt;this.triggerEvent(a)),zt(a=&gt;{if(Es(a.guardsResult)){const c=Em(`Redirecting to &quot;${this.serializeUrl(a.guardsResult)}&quot;`);throw c.url=a.guardsResult,c}const l=new iH(a.id,this.serializeUrl(a.extractedUrl),this.serializeUrl(a.urlAfterRedirects),a.targetSnapshot,!!a.guardsResult);this.triggerEvent(l)}),cn(a=&gt;!!a.guardsResult||(this.restoreHistory(a),this.cancelNavigationTransition(a,&quot;&quot;),!1)),Lm(a=&gt;{if(a.guards.canActivateChecks.length)return G(a).pipe(zt(l=&gt;{const c=new rH(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(c)}),nn(l=&gt;{let c=!1;return G(l).pipe(function(n,t){return Tt(e=&gt;{const{targetSnapshot:i,guards:{canActivateChecks:r}}=e;if(!r.length)return G(e);let s=0;return At(r).pipe(Qo(o=&gt;function(n,t,e,i){return function(n,t,e,i){const r=Object.keys(n);if(0===r.length)return G({});const s={};return At(r).pipe(Tt(o=&gt;function(n,t,e,i){const r=Od(n,t,i);return ji(r.resolve?r.resolve(t,e):r(t,e))}(n[o],t,e,i).pipe(zt(a=&gt;{s[o]=a}))),Dm(1),Tt(()=&gt;Object.keys(s).length===r.length?G(s):Cs))}(n._resolve,n,t,i).pipe(pe(s=&gt;(n._resolvedData=s,n.data=Object.assign(Object.assign({},n.data),pk(n,e).resolve),null)))}(o.route,i,n,t)),zt(()=&gt;s++),Dm(1),Tt(o=&gt;s===r.length?G(e):Cs))})}(this.paramsInheritanceStrategy,this.ngModule.injector),zt({next:()=&gt;c=!0,complete:()=&gt;{c||(this.restoreHistory(l),this.cancelNavigationTransition(l,&quot;At least one route resolver didn&#39;t emit any value.&quot;))}}))}),zt(l=&gt;{const c=new sH(l.id,this.serializeUrl(l.extractedUrl),this.serializeUrl(l.urlAfterRedirects),l.targetSnapshot);this.triggerEvent(c)}))}),Lm(a=&gt;{const{targetSnapshot:l,id:c,extractedUrl:u,rawUrl:f,extras:{skipLocationChange:p,replaceUrl:g}}=a;return this.hooks.afterPreactivation(l,{navigationId:c,appliedUrlTree:u,rawUrlTree:f,skipLocationChange:!!p,replaceUrl:!!g})}),pe(a=&gt;{const l=function(n,t,e){const i=kd(n,t._root,e?e._root:void 0);return new hk(i,t)}(this.routeReuseStrategy,a.targetSnapshot,a.currentRouterState);return Object.assign(Object.assign({},a),{targetRouterState:l})}),zt(a=&gt;{this.currentUrlTree=a.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(a.urlAfterRedirects,a.rawUrl),this.routerState=a.targetRouterState,&quot;deferred&quot;===this.urlUpdateStrategy&amp;&amp;(a.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,a),this.browserUrlTree=a.urlAfterRedirects)}),((n,t,e)=&gt;pe(i=&gt;(new zH(t,i.targetRouterState,i.currentRouterState,e).activate(n),i)))(this.rootContexts,this.routeReuseStrategy,a=&gt;this.triggerEvent(a)),zt({next(){s=!0},complete(){s=!0}}),function(n){return t=&gt;t.lift(new JU(n))}(()=&gt;{var a;if(!s&amp;&amp;!o){const l=`Navigation ID ${r.id} is not equal to the current navigation id ${this.navigationId}`;&quot;replace&quot;===this.canceledNavigationResolution?(this.restoreHistory(r),this.cancelNavigationTransition(r,l)):this.cancelNavigationTransition(r,l)}(null===(a=this.currentNavigation)||void 0===a?void 0:a.id)===r.id&amp;&amp;(this.currentNavigation=null)}),Ie(a=&gt;{if(o=!0,function(n){return n&amp;&amp;n[JS]}(a)){const l=Es(a.url);l||(this.navigated=!0,this.restoreHistory(r,!0));const c=new YS(r.id,this.serializeUrl(r.extractedUrl),a.message);i.next(c),l?setTimeout(()=&gt;{const u=this.urlHandlingStrategy.merge(a.url,this.rawUrlTree),f={skipLocationChange:r.extras.skipLocationChange,replaceUrl:&quot;eager&quot;===this.urlUpdateStrategy||Fd(r.source)};this.scheduleNavigation(u,&quot;imperative&quot;,null,f,{resolve:r.resolve,reject:r.reject,promise:r.promise})},0):r.resolve(!1)}else{this.restoreHistory(r,!0);const l=new eH(r.id,this.serializeUrl(r.extractedUrl),a);i.next(l);try{r.resolve(this.errorHandler(a))}catch(c){r.reject(c)}}return Cs}))}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&amp;&amp;this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=&gt;{const i=this.extractLocationChangeInfoFromEvent(e);this.shouldScheduleNavigation(this.lastLocationChangeInfo,i)&amp;&amp;setTimeout(()=&gt;{const{source:r,state:s,urlTree:o}=i,a={replaceUrl:!0};if(s){const l=Object.assign({},s);delete l.navigationId,delete l.\u0275routerPageId,0!==Object.keys(l).length&amp;&amp;(a.state=l)}this.scheduleNavigation(o,r,s,a)},0),this.lastLocationChangeInfo=i}))}extractLocationChangeInfoFromEvent(e){var i;return{source:&quot;popstate&quot;===e.type?&quot;popstate&quot;:&quot;hashchange&quot;,urlTree:this.parseUrl(e.url),state:(null===(i=e.state)||void 0===i?void 0:i.navigationId)?e.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(e,i){if(!e)return!0;const r=i.urlTree.toString()===e.urlTree.toString();return i.transitionId!==e.transitionId||!r||!(&quot;hashchange&quot;===i.source&amp;&amp;&quot;popstate&quot;===e.source||&quot;popstate&quot;===i.source&amp;&amp;&quot;hashchange&quot;===e.source)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){Sk(e),this.config=e.map(Nm),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&amp;&amp;(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,i={}){const{relativeTo:r,queryParams:s,fragment:o,queryParamsHandling:a,preserveFragment:l}=i,c=r||this.routerState.root,u=l?this.currentUrlTree.fragment:o;let f=null;switch(a){case&quot;merge&quot;:f=Object.assign(Object.assign({},this.currentUrlTree.queryParams),s);break;case&quot;preserve&quot;:f=this.currentUrlTree.queryParams;break;default:f=s||null}return null!==f&amp;&amp;(f=this.removeEmptyProps(f)),function(n,t,e,i,r){if(0===e.length)return Rm(t.root,t.root,t,i,r);const s=function(n){if(&quot;string&quot;==typeof n[0]&amp;&amp;1===n.length&amp;&amp;&quot;/&quot;===n[0])return new vk(!0,0,n);let t=0,e=!1;const i=n.reduce((r,s,o)=&gt;{if(&quot;object&quot;==typeof s&amp;&amp;null!=s){if(s.outlets){const a={};return Ot(s.outlets,(l,c)=&gt;{a[c]=&quot;string&quot;==typeof l?l.split(&quot;/&quot;):l}),[...r,{outlets:a}]}if(s.segmentPath)return[...r,s.segmentPath]}return&quot;string&quot;!=typeof s?[...r,s]:0===o?(s.split(&quot;/&quot;).forEach((a,l)=&gt;{0==l&amp;&amp;&quot;.&quot;===a||(0==l&amp;&amp;&quot;&quot;===a?e=!0:&quot;..&quot;===a?t++:&quot;&quot;!=a&amp;&amp;r.push(a))}),r):[...r,s]},[]);return new vk(e,t,i)}(e);if(s.toRoot())return Rm(t.root,new Se([],{}),t,i,r);const o=function(n,t,e){if(n.isAbsolute)return new Pm(t.root,!0,0);if(-1===e.snapshot._lastPathIndex){const s=e.snapshot._urlSegment;return new Pm(s,s===t.root,0)}const i=Md(n.commands[0])?0:1;return function(n,t,e){let i=n,r=t,s=e;for(;s&gt;r;){if(s-=r,i=i.parent,!i)throw new Error(&quot;Invalid number of &#39;../&#39;&quot;);r=i.segments.length}return new Pm(i,!1,r-s)}(e.snapshot._urlSegment,e.snapshot._lastPathIndex+i,n.numberOfDoubleDots)}(s,t,n),a=o.processChildren?Ad(o.segmentGroup,o.index,s.commands):bk(o.segmentGroup,o.index,s.commands);return Rm(o.segmentGroup,a,t,i,r)}(c,this.currentUrlTree,e,f,null!=u?u:null)}navigateByUrl(e,i={skipLocationChange:!1}){const r=Es(e)?e:this.parseUrl(e),s=this.urlHandlingStrategy.merge(r,this.rawUrlTree);return this.scheduleNavigation(s,&quot;imperative&quot;,null,i)}navigate(e,i={skipLocationChange:!1}){return function(n){for(let t=0;t&lt;n.length;t++){const e=n[t];if(null==e)throw new Error(`The requested path contains ${e} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,i),i)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let i;try{i=this.urlSerializer.parse(e)}catch(r){i=this.malformedUriErrorHandler(r,this.urlSerializer,e)}return i}isActive(e,i){let r;if(r=!0===i?Object.assign({},Bz):!1===i?Object.assign({},Uz):i,Es(e))return ik(this.currentUrlTree,e,r);const s=this.parseUrl(e);return ik(this.currentUrlTree,s,r)}removeEmptyProps(e){return Object.keys(e).reduce((i,r)=&gt;{const s=e[r];return null!=s&amp;&amp;(i[r]=s),i},{})}processNavigations(){this.navigations.subscribe(e=&gt;{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new Fl(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=&gt;{this.console.warn(`Unhandled Navigation Error: ${e}`)})}scheduleNavigation(e,i,r,s,o){var a,l;if(this.disposed)return Promise.resolve(!1);const c=this.getTransition(),u=Fd(i)&amp;&amp;c&amp;&amp;!Fd(c.source),g=(this.lastSuccessfulId===c.id||this.currentNavigation?c.rawUrl:c.urlAfterRedirects).toString()===e.toString();if(u&amp;&amp;g)return Promise.resolve(!0);let m,C,v;o?(m=o.resolve,C=o.reject,v=o.promise):v=new Promise((R,F)=&gt;{m=R,C=F});const S=++this.navigationId;let E;return&quot;computed&quot;===this.canceledNavigationResolution?(0===this.currentPageId&amp;&amp;(r=this.location.getState()),E=r&amp;&amp;r.\u0275routerPageId?r.\u0275routerPageId:s.replaceUrl||s.skipLocationChange?null!==(a=this.browserPageId)&amp;&amp;void 0!==a?a:0:(null!==(l=this.browserPageId)&amp;&amp;void 0!==l?l:0)+1):E=0,this.setTransition({id:S,targetPageId:E,source:i,restoredState:r,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:s,resolve:m,reject:C,promise:v,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),v.catch(R=&gt;Promise.reject(R))}setBrowserUrl(e,i){const r=this.urlSerializer.serialize(e),s=Object.assign(Object.assign({},i.extras.state),this.generateNgRouterState(i.id,i.targetPageId));this.location.isCurrentPathEqualTo(r)||i.extras.replaceUrl?this.location.replaceState(r,&quot;&quot;,s):this.location.go(r,&quot;&quot;,s)}restoreHistory(e,i=!1){var r,s;if(&quot;computed&quot;===this.canceledNavigationResolution){const o=this.currentPageId-e.targetPageId;&quot;popstate&quot;!==e.source&amp;&amp;&quot;eager&quot;!==this.urlUpdateStrategy&amp;&amp;this.currentUrlTree!==(null===(r=this.currentNavigation)||void 0===r?void 0:r.finalUrl)||0===o?this.currentUrlTree===(null===(s=this.currentNavigation)||void 0===s?void 0:s.finalUrl)&amp;&amp;0===o&amp;&amp;(this.resetState(e),this.browserUrlTree=e.currentUrlTree,this.resetUrlToCurrentUrlTree()):this.location.historyGo(o)}else&quot;replace&quot;===this.canceledNavigationResolution&amp;&amp;(i&amp;&amp;this.resetState(e),this.resetUrlToCurrentUrlTree())}resetState(e){this.routerState=e.currentRouterState,this.currentUrlTree=e.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),&quot;&quot;,this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,i){const r=new YS(e.id,this.serializeUrl(e.extractedUrl),i);this.triggerEvent(r),e.resolve(!1)}generateNgRouterState(e,i){return&quot;computed&quot;===this.canceledNavigationResolution?{navigationId:e,\u0275routerPageId:i}:{navigationId:e}}}return n.\u0275fac=function(e){return new(e||n)(D(Hc),D(Sm),D(ra),D(vs),D(ke),D(xu),D(gs),D(void 0))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();function Fd(n){return&quot;imperative&quot;!==n}let zn=(()=&gt;{class n{constructor(e,i,r){this.router=e,this.route=i,this.locationStrategy=r,this.commands=[],this.onChanges=new ie,this.subscription=e.events.subscribe(s=&gt;{s instanceof Fl&amp;&amp;this.updateTargetUrlAndHref()})}set routerLink(e){this.commands=null!=e?Array.isArray(e)?e:[e]:[]}ngOnChanges(e){this.updateTargetUrlAndHref(),this.onChanges.next(this)}ngOnDestroy(){this.subscription.unsubscribe()}onClick(e,i,r,s,o){if(0!==e||i||r||s||o||&quot;string&quot;==typeof this.target&amp;&amp;&quot;_self&quot;!=this.target)return!0;const a={skipLocationChange:sa(this.skipLocationChange),replaceUrl:sa(this.replaceUrl),state:this.state};return this.router.navigateByUrl(this.urlTree,a),!1}updateTargetUrlAndHref(){this.href=this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree))}get urlTree(){return this.router.createUrlTree(this.commands,{relativeTo:void 0!==this.relativeTo?this.relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:sa(this.preserveFragment)})}}return n.\u0275fac=function(e){return new(e||n)(_(Xe),_(Ur),_(qo))},n.\u0275dir=O({type:n,selectors:[[&quot;a&quot;,&quot;routerLink&quot;,&quot;&quot;],[&quot;area&quot;,&quot;routerLink&quot;,&quot;&quot;]],hostVars:2,hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;click&quot;,function(s){return i.onClick(s.button,s.ctrlKey,s.shiftKey,s.altKey,s.metaKey)}),2&amp;e&amp;&amp;(Ar(&quot;href&quot;,i.href,Nt),Ce(&quot;target&quot;,i.target))},inputs:{routerLink:&quot;routerLink&quot;,target:&quot;target&quot;,queryParams:&quot;queryParams&quot;,fragment:&quot;fragment&quot;,queryParamsHandling:&quot;queryParamsHandling&quot;,preserveFragment:&quot;preserveFragment&quot;,skipLocationChange:&quot;skipLocationChange&quot;,replaceUrl:&quot;replaceUrl&quot;,state:&quot;state&quot;,relativeTo:&quot;relativeTo&quot;},features:[je]}),n})();function sa(n){return&quot;&quot;===n||!!n}let Um=(()=&gt;{class n{constructor(e,i,r,s,o){this.parentContexts=e,this.location=i,this.resolver=r,this.changeDetector=o,this.activated=null,this._activatedRoute=null,this.activateEvents=new U,this.deactivateEvents=new U,this.name=s||De,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&amp;&amp;e.route&amp;&amp;(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error(&quot;Outlet is not activated&quot;);return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error(&quot;Outlet is not activated&quot;);return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error(&quot;Outlet is not activated&quot;);this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,i){this.activated=e,this._activatedRoute=i,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,i){if(this.isActivated)throw new Error(&quot;Cannot activate an already activated outlet&quot;);this._activatedRoute=e;const o=(i=i||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),a=this.parentContexts.getOrCreateContext(this.name).children,l=new Gz(e,a,this.location.injector);this.activated=this.location.createComponent(o,this.location.length,l),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return n.\u0275fac=function(e){return new(e||n)(_(ra),_(Rt),_(tr),is(&quot;name&quot;),_(xt))},n.\u0275dir=O({type:n,selectors:[[&quot;router-outlet&quot;]],outputs:{activateEvents:&quot;activate&quot;,deactivateEvents:&quot;deactivate&quot;},exportAs:[&quot;outlet&quot;]}),n})();class Gz{constructor(t,e,i){this.route=t,this.childContexts=e,this.parent=i}get(t,e){return t===Ur?this.route:t===ra?this.childContexts:this.parent.get(t,e)}}class Uk{}class Hk{preload(t,e){return G(null)}}let zk=(()=&gt;{class n{constructor(e,i,r,s,o){this.router=e,this.injector=s,this.preloadingStrategy=o,this.loader=new jk(i,r,c=&gt;e.triggerEvent(new KS(c)),c=&gt;e.triggerEvent(new QS(c)))}setUpPreloading(){this.subscription=this.router.events.pipe(cn(e=&gt;e instanceof Fl),Qo(()=&gt;this.preload())).subscribe(()=&gt;{})}preload(){const e=this.injector.get(Pi);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&amp;&amp;this.subscription.unsubscribe()}processRoutes(e,i){const r=[];for(const s of i)if(s.loadChildren&amp;&amp;!s.canLoad&amp;&amp;s._loadedConfig){const o=s._loadedConfig;r.push(this.processRoutes(o.module,o.routes))}else s.loadChildren&amp;&amp;!s.canLoad?r.push(this.preloadConfig(e,s)):s.children&amp;&amp;r.push(this.processRoutes(e,s.children));return At(r).pipe(wa(),pe(s=&gt;{}))}preloadConfig(e,i){return this.preloadingStrategy.preload(i,()=&gt;(i._loadedConfig?G(i._loadedConfig):this.loader.load(e.injector,i)).pipe(Tt(s=&gt;(i._loadedConfig=s,this.processRoutes(s.module,s.routes)))))}}return n.\u0275fac=function(e){return new(e||n)(D(Xe),D(xu),D(gs),D(ke),D(Uk))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),Hm=(()=&gt;{class n{constructor(e,i,r={}){this.router=e,this.viewportScroller=i,this.options=r,this.lastId=0,this.lastSource=&quot;imperative&quot;,this.restoredId=0,this.store={},r.scrollPositionRestoration=r.scrollPositionRestoration||&quot;disabled&quot;,r.anchorScrolling=r.anchorScrolling||&quot;disabled&quot;}init(){&quot;disabled&quot;!==this.options.scrollPositionRestoration&amp;&amp;this.viewportScroller.setHistoryScrollRestoration(&quot;manual&quot;),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=&gt;{e instanceof wm?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Fl&amp;&amp;(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=&gt;{e instanceof ZS&amp;&amp;(e.position?&quot;top&quot;===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):&quot;enabled&quot;===this.options.scrollPositionRestoration&amp;&amp;this.viewportScroller.scrollToPosition(e.position):e.anchor&amp;&amp;&quot;enabled&quot;===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):&quot;disabled&quot;!==this.options.scrollPositionRestoration&amp;&amp;this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,i){this.router.triggerEvent(new ZS(e,&quot;popstate&quot;===this.lastSource?this.store[this.restoredId]:null,i))}ngOnDestroy(){this.routerEventsSubscription&amp;&amp;this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&amp;&amp;this.scrollEventsSubscription.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(D(Xe),D(Ng),D(void 0))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const Ss=new j(&quot;ROUTER_CONFIGURATION&quot;),$k=new j(&quot;ROUTER_FORROOT_GUARD&quot;),qz=[vs,{provide:Sm,useClass:ak},{provide:Xe,useFactory:function(n,t,e,i,r,s,o,a={},l,c){const u=new Xe(null,n,t,e,i,r,s,ek(o));return l&amp;&amp;(u.urlHandlingStrategy=l),c&amp;&amp;(u.routeReuseStrategy=c),function(n,t){n.errorHandler&amp;&amp;(t.errorHandler=n.errorHandler),n.malformedUriErrorHandler&amp;&amp;(t.malformedUriErrorHandler=n.malformedUriErrorHandler),n.onSameUrlNavigation&amp;&amp;(t.onSameUrlNavigation=n.onSameUrlNavigation),n.paramsInheritanceStrategy&amp;&amp;(t.paramsInheritanceStrategy=n.paramsInheritanceStrategy),n.relativeLinkResolution&amp;&amp;(t.relativeLinkResolution=n.relativeLinkResolution),n.urlUpdateStrategy&amp;&amp;(t.urlUpdateStrategy=n.urlUpdateStrategy)}(a,u),a.enableTracing&amp;&amp;u.events.subscribe(f=&gt;{var p,g;null===(p=console.group)||void 0===p||p.call(console,`Router Event: ${f.constructor.name}`),console.log(f.toString()),console.log(f),null===(g=console.groupEnd)||void 0===g||g.call(console)}),u},deps:[Sm,ra,vs,ke,xu,gs,jm,Ss,[class{},new It],[class{},new It]]},ra,{provide:Ur,useFactory:function(n){return n.routerState.root},deps:[Xe]},{provide:xu,useClass:HV},zk,Hk,class{preload(t,e){return e().pipe(Ie(()=&gt;G(null)))}},{provide:Ss,useValue:{enableTracing:!1}}];function Yz(){return new sg(&quot;Router&quot;,Xe)}let Gk=(()=&gt;{class n{constructor(e,i){}static forRoot(e,i){return{ngModule:n,providers:[qz,Wk(e),{provide:$k,useFactory:Zz,deps:[[Xe,new It,new Xn]]},{provide:Ss,useValue:i||{}},{provide:qo,useFactory:Qz,deps:[ys,[new ao(Dg),new It],Ss]},{provide:Hm,useFactory:Kz,deps:[Xe,Ng,Ss]},{provide:Uk,useExisting:i&amp;&amp;i.preloadingStrategy?i.preloadingStrategy:Hk},{provide:sg,multi:!0,useFactory:Yz},[zm,{provide:zo,multi:!0,useFactory:t4,deps:[zm]},{provide:qk,useFactory:n4,deps:[zm]},{provide:hE,multi:!0,useExisting:qk}]]}}static forChild(e){return{ngModule:n,providers:[Wk(e)]}}}return n.\u0275fac=function(e){return new(e||n)(D($k,8),D(Xe,8))},n.\u0275mod=ve({type:n}),n.\u0275inj=me({}),n})();function Kz(n,t,e){return e.scrollOffset&amp;&amp;t.setOffset(e.scrollOffset),new Hm(n,t,e)}function Qz(n,t,e={}){return e.useHash?new l3(n,t):new t0(n,t)}function Zz(n){return&quot;guarded&quot;}function Wk(n){return[{provide:gI,multi:!0,useValue:n},{provide:jm,multi:!0,useValue:n}]}let zm=(()=&gt;{class n{constructor(e){this.injector=e,this.initNavigation=!1,this.destroyed=!1,this.resultOfPreactivationDone=new ie}appInitializer(){return this.injector.get(s3,Promise.resolve(null)).then(()=&gt;{if(this.destroyed)return Promise.resolve(!0);let i=null;const r=new Promise(a=&gt;i=a),s=this.injector.get(Xe),o=this.injector.get(Ss);return&quot;disabled&quot;===o.initialNavigation?(s.setUpLocationChangeListener(),i(!0)):&quot;enabled&quot;===o.initialNavigation||&quot;enabledBlocking&quot;===o.initialNavigation?(s.hooks.afterPreactivation=()=&gt;this.initNavigation?G(null):(this.initNavigation=!0,i(!0),this.resultOfPreactivationDone),s.initialNavigation()):i(!0),r})}bootstrapListener(e){const i=this.injector.get(Ss),r=this.injector.get(zk),s=this.injector.get(Hm),o=this.injector.get(Xe),a=this.injector.get(Pr);e===a.components[0]&amp;&amp;((&quot;enabledNonBlocking&quot;===i.initialNavigation||void 0===i.initialNavigation)&amp;&amp;o.initialNavigation(),r.setUpPreloading(),s.init(),o.resetRootComponentType(a.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}ngOnDestroy(){this.destroyed=!0}}return n.\u0275fac=function(e){return new(e||n)(D(ke))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();function t4(n){return n.appInitializer.bind(n)}function n4(n){return n.bootstrapListener.bind(n)}const qk=new j(&quot;Router Initializer&quot;);function zr(n,t){return new ye(t?e=&gt;t.schedule(r4,0,{error:n,subscriber:e}):e=&gt;e.error(n))}function r4({error:n,subscriber:t}){t.error(n)}function qe(n=-1){return t=&gt;t.lift(new s4(n,t))}class s4{constructor(t,e){this.count=t,this.source=e}call(t,e){return e.subscribe(new o4(t,this.count,this.source))}}class o4 extends xe{constructor(t,e,i){super(t),this.count=e,this.source=i}error(t){if(!this.isStopped){const{source:e,count:i}=this;if(0===i)return super.error(t);i&gt;-1&amp;&amp;(this.count=i-1),e.subscribe(this._unsubscribeAndRecycle())}}}const Nd=new j(&quot;Shramba brskalnika&quot;,{providedIn:&quot;root&quot;,factory:()=&gt;localStorage}),oa_apiUrl=&quot;https://goodmeets.herokuapp.com/api&quot;;class ks{}let $n=(()=&gt;{class n{constructor(e,i){this.http=e,this.shramba=i,this.loggedUser=new ks,this.apiUrl=oa_apiUrl}preveriObstojEmail(e){return this.http.post(`${this.apiUrl}/uporabniki/email`,e).pipe(qe(1),Ie(this.obdelajNapako))}preveriObstojUporabniskoIme(e){return this.http.post(`${this.apiUrl}/uporabniki/uporabniskoIme`,e).pipe(qe(1),Ie(this.obdelajNapako))}posodobiUporabnika(e){const i=`${this.apiUrl}/uporabniki/${e._id}`,r={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.put(i,e,r).pipe(qe(1),Ie(this.obdelajNapako))}posliEmail(e){const i=`${this.apiUrl}/uporabniki/potrditveni_email`,r={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.post(i,e,r).pipe(qe(1),Ie(this.obdelajNapako))}getLoggedUser(){var e=this.shramba.getItem(&quot;uporabnik&quot;);return null!=e?(this.loggedUser=JSON.parse(e),JSON.parse(e)):null}setLoggedUser(e){this.loggedUser=e,this.shramba.setItem(&quot;uporabnik&quot;,JSON.stringify(this.loggedUser))}narediKopijoUporabnika(e,i){e._id=i._id,e.ime=i.ime,e.priimek=i.priimek,e.email=i.email,e.uporabniskoIme=i.uporabniskoIme,e.slika=i.slika,e.geslo=i.geslo,e.created=i.created,e.joined=i.joined}getUsers(){return this.http.get(`${this.apiUrl}/uporabniki`).pipe(qe(1),Ie(this.obdelajNapako))}deleteUser(e){const i={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.delete(`${this.apiUrl}/uporabniki/${e}`,i).pipe(qe(1),Ie(this.obdelajNapako))}prijava(e){return this.loggedUser=new ks,this.avtentikacija(&quot;prijava&quot;,e)}registracija(e){return this.loggedUser=new ks,this.avtentikacija(&quot;registracija&quot;,e)}avtentikacija(e,i){return this.http.post(`${this.apiUrl}/${e}`,i).pipe(qe(1),Ie(this.vrniNapako))}vrniNapako(e){return zr(`${e.error.sporo\u010dilo||e.statusText}`)}obdelajNapako(e){return zr(`Pri\u0161lo je do napake ${e.status} z opisom ${e.error.sporo\u010dilo||e.statusText}`)}}return n.\u0275fac=function(e){return new(e||n)(D(Zo),D(Nd))},n.\u0275prov=P({token:n,factory:n.\u0275fac,providedIn:&quot;root&quot;}),n})(),$r=(()=&gt;{class n{constructor(e,i,r){this.http=e,this.shramba=i,this.uporabnikService=r,this.apiUrl=oa_apiUrl}getDogodki(e){return this.http.get(`${this.apiUrl}/dogodki`,{params:e}).pipe(qe(1),Ie(this.obdelajNapako))}getDogodek(e){return 0==e.trim().length?new ye:this.http.get(`${this.apiUrl}/dogodki/${e}`).pipe(qe(1),Ie(this.obdelajNapako))}addDogodek(e){console.log(e);const i=`${this.apiUrl}/dogodki`,r={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.post(i,{userId:this.uporabnikService.getLoggedUser()._id,event:e},r).pipe(qe(1),Ie(this.obdelajNapako))}updateDogodek(e){const i=`${this.apiUrl}/dogodki/${e._id}`,r={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.put(i,e,r).pipe(qe(1),Ie(this.obdelajNapako))}deleteDogodek(e){const i=`${this.apiUrl}/dogodki/${e}`,r={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.delete(i,r).pipe(qe(1),Ie(this.obdelajNapako))}joinDogodek(e){const i=`${this.apiUrl}/dogodek/pridruzi`,r={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.put(i,{userId:this.uporabnikService.getLoggedUser()._id,eventId:e},r).pipe(qe(1),Ie(this.obdelajNapako))}leaveDogodek(e){const i=`${this.apiUrl}/dogodek/odjavi`,r={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.put(i,{userId:this.uporabnikService.getLoggedUser()._id,eventId:e},r).pipe(qe(1),Ie(this.obdelajNapako))}getPridruzeniDogodki(e){const i=`${this.apiUrl}/dogodki/pridruzeni/${this.uporabnikService.getLoggedUser()._id}`;return this.http.get(i,{params:e}).pipe(qe(1),Ie(this.obdelajNapako))}getUstvarjeniDogodki(e){const i=`${this.apiUrl}/dogodki/ustvarjeni/${this.uporabnikService.getLoggedUser()._id}`;return this.http.get(i,{params:e}).pipe(qe(1),Ie(this.obdelajNapako))}getDogodkiFiltered(e){return this.http.get(&quot;&quot;===e.location?`${this.apiUrl}/dogodkiFilter?q=619bd4d477f724f7b1c6efe2&amp;startDate=${e.startDate}&amp;endDate=${e.endDate}&amp;page=${e.page}&amp;size=${e.pageSize}`:`${this.apiUrl}/dogodkiFilter?q=619bd4d477f724f7b1c6efe2&amp;startDate=${e.startDate}&amp;endDate=${e.endDate}&amp;lng=${e.lng}&amp;lat=${e.lat}&amp;razdalja=${e.razdalja}&amp;page=${e.page}&amp;size=${e.pageSize}`).pipe(qe(1),Ie(this.obdelajNapako))}dogodekVreme(e){return this.http.get(`https://api.openweathermap.org/data/2.5/onecall?lat=${e[1]}&amp;lon=${e[0]}&amp;exclude=current,minutely,hourly&amp;appid=096504780fe605e465031f9803d0b902`).pipe(qe(1),Ie(this.obdelajNapako))}dogodekLokacija(e){return this.http.get(`https://api.openweathermap.org/geo/1.0/direct?q=${e}&amp;limit=1&amp;appid=14472f0ae561d135238e5d43702a22a8`).pipe(qe(1),Ie(this.obdelajNapako))}obdelajNapako(e){return zr(`Pri\u0161lo je do napake ${e.status} z opisom ${e.error.sporo\u010dilo||e.statusText}`)}}return n.\u0275fac=function(e){return new(e||n)(D(Zo),D(Nd),D($n))},n.\u0275prov=P({token:n,factory:n.\u0275fac,providedIn:&quot;root&quot;}),n})();function Ye(n){return null!=n&amp;&amp;&quot;false&quot;!=`${n}`}function Yk(n){return Array.isArray(n)?n:[n]}function mt(n){return null==n?&quot;&quot;:&quot;string&quot;==typeof n?n:`${n}px`}function hr(n){return n instanceof X?n.nativeElement:n}class c4 extends ue{constructor(t,e){super()}schedule(t,e=0){return this}}class Vd extends c4{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const i=this.id,r=this.scheduler;return null!=i&amp;&amp;(this.id=this.recycleAsyncId(r,i,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(r,this.id,e),this}requestAsyncId(t,e,i=0){return setInterval(t.flush.bind(t,this),i)}recycleAsyncId(t,e,i=0){if(null!==i&amp;&amp;this.delay===i&amp;&amp;!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error(&quot;executing a cancelled action&quot;);this.pending=!1;const i=this._execute(t,e);if(i)return i;!1===this.pending&amp;&amp;null!=this.id&amp;&amp;(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let r,i=!1;try{this.work(t)}catch(s){i=!0,r=!!s&amp;&amp;s||new Error(s)}if(i)return this.unsubscribe(),r}_unsubscribe(){const t=this.id,e=this.scheduler,i=e.actions,r=i.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==r&amp;&amp;i.splice(r,1),null!=t&amp;&amp;(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}let Kk=(()=&gt;{class n{constructor(e,i=n.now){this.SchedulerAction=e,this.now=i}schedule(e,i=0,r){return new this.SchedulerAction(this,e).schedule(r,i)}}return n.now=()=&gt;Date.now(),n})();class _i extends Kk{constructor(t,e=Kk.now){super(t,()=&gt;_i.delegate&amp;&amp;_i.delegate!==this?_i.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,i){return _i.delegate&amp;&amp;_i.delegate!==this?_i.delegate.schedule(t,e,i):super.schedule(t,e,i)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let i;this.active=!0;do{if(i=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,i){for(;t=e.shift();)t.unsubscribe();throw i}}}const aa=new _i(Vd);class d4{constructor(t,e){this.dueTime=t,this.scheduler=e}call(t,e){return e.subscribe(new h4(t,this.dueTime,this.scheduler))}}class h4 extends xe{constructor(t,e,i){super(t),this.dueTime=e,this.scheduler=i,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(t){this.clearDebounce(),this.lastValue=t,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(f4,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:t}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(t)}}clearDebounce(){const t=this.debouncedSubscription;null!==t&amp;&amp;(this.remove(t),t.unsubscribe(),this.debouncedSubscription=null)}}function f4(n){n.debouncedNext()}let Jm,$m=(()=&gt;{class n{create(e){return&quot;undefined&quot;==typeof MutationObserver?null:new MutationObserver(e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({factory:function(){return new n},token:n,providedIn:&quot;root&quot;}),n})(),Qk=(()=&gt;{class n{constructor(e){this._mutationObserverFactory=e,this._observedElements=new Map}ngOnDestroy(){this._observedElements.forEach((e,i)=&gt;this._cleanupObserver(i))}observe(e){const i=hr(e);return new ye(r=&gt;{const o=this._observeElement(i).subscribe(r);return()=&gt;{o.unsubscribe(),this._unobserveElement(i)}})}_observeElement(e){if(this._observedElements.has(e))this._observedElements.get(e).count++;else{const i=new ie,r=this._mutationObserverFactory.create(s=&gt;i.next(s));r&amp;&amp;r.observe(e,{characterData:!0,childList:!0,subtree:!0}),this._observedElements.set(e,{observer:r,stream:i,count:1})}return this._observedElements.get(e).stream}_unobserveElement(e){this._observedElements.has(e)&amp;&amp;(this._observedElements.get(e).count--,this._observedElements.get(e).count||this._cleanupObserver(e))}_cleanupObserver(e){if(this._observedElements.has(e)){const{observer:i,stream:r}=this._observedElements.get(e);i&amp;&amp;i.disconnect(),r.complete(),this._observedElements.delete(e)}}}return n.\u0275fac=function(e){return new(e||n)(D($m))},n.\u0275prov=P({factory:function(){return new n(D($m))},token:n,providedIn:&quot;root&quot;}),n})(),p4=(()=&gt;{class n{constructor(e,i,r){this._contentObserver=e,this._elementRef=i,this._ngZone=r,this.event=new U,this._disabled=!1,this._currentSubscription=null}get disabled(){return this._disabled}set disabled(e){this._disabled=Ye(e),this._disabled?this._unsubscribe():this._subscribe()}get debounce(){return this._debounce}set debounce(e){this._debounce=function(n,t=0){return function(n){return!isNaN(parseFloat(n))&amp;&amp;!isNaN(Number(n))}(n)?Number(n):t}(e),this._subscribe()}ngAfterContentInit(){!this._currentSubscription&amp;&amp;!this.disabled&amp;&amp;this._subscribe()}ngOnDestroy(){this._unsubscribe()}_subscribe(){this._unsubscribe();const e=this._contentObserver.observe(this._elementRef);this._ngZone.runOutsideAngular(()=&gt;{this._currentSubscription=(this.debounce?e.pipe(function(n,t=aa){return e=&gt;e.lift(new d4(n,t))}(this.debounce)):e).subscribe(this.event)})}_unsubscribe(){var e;null===(e=this._currentSubscription)||void 0===e||e.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(_(Qk),_(X),_(Y))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;cdkObserveContent&quot;,&quot;&quot;]],inputs:{disabled:[&quot;cdkObserveContentDisabled&quot;,&quot;disabled&quot;],debounce:&quot;debounce&quot;},outputs:{event:&quot;cdkObserveContent&quot;},exportAs:[&quot;cdkObserveContent&quot;]}),n})(),Zk=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[$m]}),n})();function Gl(n,...t){return t.length?t.some(e=&gt;n[e]):n.altKey||n.shiftKey||n.ctrlKey||n.metaKey}class D4{constructor(t){this.total=t}call(t,e){return e.subscribe(new w4(t,this.total))}}class w4 extends xe{constructor(t,e){super(t),this.total=e,this.count=0}_next(t){++this.count&gt;this.total&amp;&amp;this.destination.next(t)}}class E4{constructor(t,e){this.compare=t,this.keySelector=e}call(t,e){return e.subscribe(new S4(t,this.compare,this.keySelector))}}class S4 extends xe{constructor(t,e,i){super(t),this.keySelector=i,this.hasKey=!1,&quot;function&quot;==typeof e&amp;&amp;(this.compare=e)}compare(t,e){return t===e}_next(t){let e;try{const{keySelector:r}=this;e=r?r(t):t}catch(r){return this.destination.error(r)}let i=!1;if(this.hasKey)try{const{compare:r}=this;i=r(this.key,e)}catch(r){return this.destination.error(r)}else this.hasKey=!0;i||(this.key=e,this.destination.next(t))}}function fr(n){return t=&gt;t.lift(new k4(n))}class k4{constructor(t){this.notifier=t}call(t,e){const i=new M4(t),r=Da(this.notifier,new ba(i));return r&amp;&amp;!i.seenValue?(i.add(r),e.subscribe(i)):i}}class M4 extends Ca{constructor(t){super(t),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}try{Jm=&quot;undefined&quot;!=typeof Intl&amp;&amp;Intl.v8BreakIterator}catch(n){Jm=!1}let la,Ke=(()=&gt;{class n{constructor(e){this._platformId=e,this.isBrowser=this._platformId?Fg(this._platformId):&quot;object&quot;==typeof document&amp;&amp;!!document,this.EDGE=this.isBrowser&amp;&amp;/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&amp;&amp;/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&amp;&amp;!(!window.chrome&amp;&amp;!Jm)&amp;&amp;&quot;undefined&quot;!=typeof CSS&amp;&amp;!this.EDGE&amp;&amp;!this.TRIDENT,this.WEBKIT=this.isBrowser&amp;&amp;/AppleWebKit/i.test(navigator.userAgent)&amp;&amp;!this.BLINK&amp;&amp;!this.EDGE&amp;&amp;!this.TRIDENT,this.IOS=this.isBrowser&amp;&amp;/iPad|iPhone|iPod/.test(navigator.userAgent)&amp;&amp;!(&quot;MSStream&quot;in window),this.FIREFOX=this.isBrowser&amp;&amp;/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&amp;&amp;/android/i.test(navigator.userAgent)&amp;&amp;!this.TRIDENT,this.SAFARI=this.isBrowser&amp;&amp;/safari/i.test(navigator.userAgent)&amp;&amp;this.WEBKIT}}return n.\u0275fac=function(e){return new(e||n)(D(Rr))},n.\u0275prov=P({factory:function(){return new n(D(Rr))},token:n,providedIn:&quot;root&quot;}),n})(),Wl=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({}),n})();const Xk=[&quot;color&quot;,&quot;button&quot;,&quot;checkbox&quot;,&quot;date&quot;,&quot;datetime-local&quot;,&quot;email&quot;,&quot;file&quot;,&quot;hidden&quot;,&quot;image&quot;,&quot;month&quot;,&quot;number&quot;,&quot;password&quot;,&quot;radio&quot;,&quot;range&quot;,&quot;reset&quot;,&quot;search&quot;,&quot;submit&quot;,&quot;tel&quot;,&quot;text&quot;,&quot;time&quot;,&quot;url&quot;,&quot;week&quot;];function e1(){if(la)return la;if(&quot;object&quot;!=typeof document||!document)return la=new Set(Xk),la;let n=document.createElement(&quot;input&quot;);return la=new Set(Xk.filter(t=&gt;(n.setAttribute(&quot;type&quot;,t),n.type===t))),la}let ql,Is,Xm;function Bd(n){return function(){if(null==ql&amp;&amp;&quot;undefined&quot;!=typeof window)try{window.addEventListener(&quot;test&quot;,null,Object.defineProperty({},&quot;passive&quot;,{get:()=&gt;ql=!0}))}finally{ql=ql||!1}return ql}()?n:!!n.capture}function t1(){if(null==Is){if(&quot;object&quot;!=typeof document||!document||&quot;function&quot;!=typeof Element||!Element)return Is=!1,Is;if(&quot;scrollBehavior&quot;in document.documentElement.style)Is=!0;else{const n=Element.prototype.scrollTo;Is=!!n&amp;&amp;!/\{\s*\[native code\]\s*\}/.test(n.toString())}}return Is}function n1(){let n=&quot;undefined&quot;!=typeof document&amp;&amp;document?document.activeElement:null;for(;n&amp;&amp;n.shadowRoot;){const t=n.shadowRoot.activeElement;if(t===n)break;n=t}return n}function xs(n){return n.composedPath?n.composedPath()[0]:n.target}function e_(){return&quot;undefined&quot;!=typeof __karma__&amp;&amp;!!__karma__||&quot;undefined&quot;!=typeof jasmine&amp;&amp;!!jasmine||&quot;undefined&quot;!=typeof jest&amp;&amp;!!jest||&quot;undefined&quot;!=typeof Mocha&amp;&amp;!!Mocha}let s1=(()=&gt;{class n{constructor(e){this._platform=e}isDisabled(e){return e.hasAttribute(&quot;disabled&quot;)}isVisible(e){return function(n){return!!(n.offsetWidth||n.offsetHeight||&quot;function&quot;==typeof n.getClientRects&amp;&amp;n.getClientRects().length)}(e)&amp;&amp;&quot;visible&quot;===getComputedStyle(e).visibility}isTabbable(e){if(!this._platform.isBrowser)return!1;const i=function(n){try{return n.frameElement}catch(t){return null}}(function(n){return n.ownerDocument&amp;&amp;n.ownerDocument.defaultView||window}(e));if(i&amp;&amp;(-1===a1(i)||!this.isVisible(i)))return!1;let r=e.nodeName.toLowerCase(),s=a1(e);return e.hasAttribute(&quot;contenteditable&quot;)?-1!==s:!(&quot;iframe&quot;===r||&quot;object&quot;===r||this._platform.WEBKIT&amp;&amp;this._platform.IOS&amp;&amp;!function(n){let t=n.nodeName.toLowerCase(),e=&quot;input&quot;===t&amp;&amp;n.type;return&quot;text&quot;===e||&quot;password&quot;===e||&quot;select&quot;===t||&quot;textarea&quot;===t}(e))&amp;&amp;(&quot;audio&quot;===r?!!e.hasAttribute(&quot;controls&quot;)&amp;&amp;-1!==s:&quot;video&quot;===r?-1!==s&amp;&amp;(null!==s||this._platform.FIREFOX||e.hasAttribute(&quot;controls&quot;)):e.tabIndex&gt;=0)}isFocusable(e,i){return function(n){return!function(n){return function(n){return&quot;input&quot;==n.nodeName.toLowerCase()}(n)&amp;&amp;&quot;hidden&quot;==n.type}(n)&amp;&amp;(function(n){let t=n.nodeName.toLowerCase();return&quot;input&quot;===t||&quot;select&quot;===t||&quot;button&quot;===t||&quot;textarea&quot;===t}(n)||function(n){return function(n){return&quot;a&quot;==n.nodeName.toLowerCase()}(n)&amp;&amp;n.hasAttribute(&quot;href&quot;)}(n)||n.hasAttribute(&quot;contenteditable&quot;)||o1(n))}(e)&amp;&amp;!this.isDisabled(e)&amp;&amp;((null==i?void 0:i.ignoreVisibility)||this.isVisible(e))}}return n.\u0275fac=function(e){return new(e||n)(D(Ke))},n.\u0275prov=P({factory:function(){return new n(D(Ke))},token:n,providedIn:&quot;root&quot;}),n})();function o1(n){if(!n.hasAttribute(&quot;tabindex&quot;)||void 0===n.tabIndex)return!1;let t=n.getAttribute(&quot;tabindex&quot;);return&quot;-32768&quot;!=t&amp;&amp;!(!t||isNaN(parseInt(t,10)))}function a1(n){if(!o1(n))return null;const t=parseInt(n.getAttribute(&quot;tabindex&quot;)||&quot;&quot;,10);return isNaN(t)?-1:t}class z4{constructor(t,e,i,r,s=!1){this._element=t,this._checker=e,this._ngZone=i,this._document=r,this._hasAttached=!1,this.startAnchorListener=()=&gt;this.focusLastTabbableElement(),this.endAnchorListener=()=&gt;this.focusFirstTabbableElement(),this._enabled=!0,s||this.attachAnchors()}get enabled(){return this._enabled}set enabled(t){this._enabled=t,this._startAnchor&amp;&amp;this._endAnchor&amp;&amp;(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}destroy(){const t=this._startAnchor,e=this._endAnchor;t&amp;&amp;(t.removeEventListener(&quot;focus&quot;,this.startAnchorListener),t.parentNode&amp;&amp;t.parentNode.removeChild(t)),e&amp;&amp;(e.removeEventListener(&quot;focus&quot;,this.endAnchorListener),e.parentNode&amp;&amp;e.parentNode.removeChild(e)),this._startAnchor=this._endAnchor=null,this._hasAttached=!1}attachAnchors(){return!!this._hasAttached||(this._ngZone.runOutsideAngular(()=&gt;{this._startAnchor||(this._startAnchor=this._createAnchor(),this._startAnchor.addEventListener(&quot;focus&quot;,this.startAnchorListener)),this._endAnchor||(this._endAnchor=this._createAnchor(),this._endAnchor.addEventListener(&quot;focus&quot;,this.endAnchorListener))}),this._element.parentNode&amp;&amp;(this._element.parentNode.insertBefore(this._startAnchor,this._element),this._element.parentNode.insertBefore(this._endAnchor,this._element.nextSibling),this._hasAttached=!0),this._hasAttached)}focusInitialElementWhenReady(t){return new Promise(e=&gt;{this._executeOnStable(()=&gt;e(this.focusInitialElement(t)))})}focusFirstTabbableElementWhenReady(t){return new Promise(e=&gt;{this._executeOnStable(()=&gt;e(this.focusFirstTabbableElement(t)))})}focusLastTabbableElementWhenReady(t){return new Promise(e=&gt;{this._executeOnStable(()=&gt;e(this.focusLastTabbableElement(t)))})}_getRegionBoundary(t){let e=this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);for(let i=0;i&lt;e.length;i++)e[i].hasAttribute(`cdk-focus-${t}`)?console.warn(`Found use of deprecated attribute &#39;cdk-focus-${t}&#39;, use &#39;cdkFocusRegion${t}&#39; instead. The deprecated attribute will be removed in 8.0.0.`,e[i]):e[i].hasAttribute(`cdk-focus-region-${t}`)&amp;&amp;console.warn(`Found use of deprecated attribute &#39;cdk-focus-region-${t}&#39;, use &#39;cdkFocusRegion${t}&#39; instead. The deprecated attribute will be removed in 8.0.0.`,e[i]);return&quot;start&quot;==t?e.length?e[0]:this._getFirstTabbableElement(this._element):e.length?e[e.length-1]:this._getLastTabbableElement(this._element)}focusInitialElement(t){const e=this._element.querySelector(&quot;[cdk-focus-initial], [cdkFocusInitial]&quot;);if(e){if(e.hasAttribute(&quot;cdk-focus-initial&quot;)&amp;&amp;console.warn(&quot;Found use of deprecated attribute &#39;cdk-focus-initial&#39;, use &#39;cdkFocusInitial&#39; instead. The deprecated attribute will be removed in 8.0.0&quot;,e),!this._checker.isFocusable(e)){const i=this._getFirstTabbableElement(e);return null==i||i.focus(t),!!i}return e.focus(t),!0}return this.focusFirstTabbableElement(t)}focusFirstTabbableElement(t){const e=this._getRegionBoundary(&quot;start&quot;);return e&amp;&amp;e.focus(t),!!e}focusLastTabbableElement(t){const e=this._getRegionBoundary(&quot;end&quot;);return e&amp;&amp;e.focus(t),!!e}hasAttached(){return this._hasAttached}_getFirstTabbableElement(t){if(this._checker.isFocusable(t)&amp;&amp;this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let i=0;i&lt;e.length;i++){let r=e[i].nodeType===this._document.ELEMENT_NODE?this._getFirstTabbableElement(e[i]):null;if(r)return r}return null}_getLastTabbableElement(t){if(this._checker.isFocusable(t)&amp;&amp;this._checker.isTabbable(t))return t;let e=t.children||t.childNodes;for(let i=e.length-1;i&gt;=0;i--){let r=e[i].nodeType===this._document.ELEMENT_NODE?this._getLastTabbableElement(e[i]):null;if(r)return r}return null}_createAnchor(){const t=this._document.createElement(&quot;div&quot;);return this._toggleAnchorTabIndex(this._enabled,t),t.classList.add(&quot;cdk-visually-hidden&quot;),t.classList.add(&quot;cdk-focus-trap-anchor&quot;),t.setAttribute(&quot;aria-hidden&quot;,&quot;true&quot;),t}_toggleAnchorTabIndex(t,e){t?e.setAttribute(&quot;tabindex&quot;,&quot;0&quot;):e.removeAttribute(&quot;tabindex&quot;)}toggleAnchors(t){this._startAnchor&amp;&amp;this._endAnchor&amp;&amp;(this._toggleAnchorTabIndex(t,this._startAnchor),this._toggleAnchorTabIndex(t,this._endAnchor))}_executeOnStable(t){this._ngZone.isStable?t():this._ngZone.onStable.pipe(rn(1)).subscribe(t)}}let $4=(()=&gt;{class n{constructor(e,i,r){this._checker=e,this._ngZone=i,this._document=r}create(e,i=!1){return new z4(e,this._checker,this._ngZone,this._document,i)}}return n.\u0275fac=function(e){return new(e||n)(D(s1),D(Y),D(W))},n.\u0275prov=P({factory:function(){return new n(D(s1),D(Y),D(W))},token:n,providedIn:&quot;root&quot;}),n})(),G4=(()=&gt;{class n{constructor(e,i,r){this._elementRef=e,this._focusTrapFactory=i,this._previouslyFocusedElement=null,this.focusTrap=this._focusTrapFactory.create(this._elementRef.nativeElement,!0)}get enabled(){return this.focusTrap.enabled}set enabled(e){this.focusTrap.enabled=Ye(e)}get autoCapture(){return this._autoCapture}set autoCapture(e){this._autoCapture=Ye(e)}ngOnDestroy(){this.focusTrap.destroy(),this._previouslyFocusedElement&amp;&amp;(this._previouslyFocusedElement.focus(),this._previouslyFocusedElement=null)}ngAfterContentInit(){this.focusTrap.attachAnchors(),this.autoCapture&amp;&amp;this._captureFocus()}ngDoCheck(){this.focusTrap.hasAttached()||this.focusTrap.attachAnchors()}ngOnChanges(e){const i=e.autoCapture;i&amp;&amp;!i.firstChange&amp;&amp;this.autoCapture&amp;&amp;this.focusTrap.hasAttached()&amp;&amp;this._captureFocus()}_captureFocus(){this._previouslyFocusedElement=n1(),this.focusTrap.focusInitialElementWhenReady()}}return n.\u0275fac=function(e){return new(e||n)(_(X),_($4),_(W))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;cdkTrapFocus&quot;,&quot;&quot;]],inputs:{enabled:[&quot;cdkTrapFocus&quot;,&quot;enabled&quot;],autoCapture:[&quot;cdkTrapFocusAutoCapture&quot;,&quot;autoCapture&quot;]},exportAs:[&quot;cdkTrapFocus&quot;],features:[je]}),n})();function l1(n){return 0===n.offsetX&amp;&amp;0===n.offsetY}function c1(n){const t=n.touches&amp;&amp;n.touches[0]||n.changedTouches&amp;&amp;n.changedTouches[0];return!(!t||-1!==t.identifier||null!=t.radiusX&amp;&amp;1!==t.radiusX||null!=t.radiusY&amp;&amp;1!==t.radiusY)}&quot;undefined&quot;!=typeof Element&amp;&amp;Element;const u1=new j(&quot;cdk-input-modality-detector-options&quot;),Q4={ignoreKeys:[18,17,224,91,16]},ca=Bd({passive:!0,capture:!0});let h1=(()=&gt;{class n{constructor(e,i,r,s){this._platform=e,this._mostRecentTarget=null,this._modality=new Un(null),this._lastTouchMs=0,this._onKeydown=o=&gt;{var a,l;(null===(l=null===(a=this._options)||void 0===a?void 0:a.ignoreKeys)||void 0===l?void 0:l.some(c=&gt;c===o.keyCode))||(this._modality.next(&quot;keyboard&quot;),this._mostRecentTarget=xs(o))},this._onMousedown=o=&gt;{Date.now()-this._lastTouchMs&lt;650||(this._modality.next(l1(o)?&quot;keyboard&quot;:&quot;mouse&quot;),this._mostRecentTarget=xs(o))},this._onTouchstart=o=&gt;{c1(o)?this._modality.next(&quot;keyboard&quot;):(this._lastTouchMs=Date.now(),this._modality.next(&quot;touch&quot;),this._mostRecentTarget=xs(o))},this._options=Object.assign(Object.assign({},Q4),s),this.modalityDetected=this._modality.pipe(t=&gt;t.lift(new D4(1))),this.modalityChanged=this.modalityDetected.pipe(function(n,t){return e=&gt;e.lift(new E4(n,t))}()),e.isBrowser&amp;&amp;i.runOutsideAngular(()=&gt;{r.addEventListener(&quot;keydown&quot;,this._onKeydown,ca),r.addEventListener(&quot;mousedown&quot;,this._onMousedown,ca),r.addEventListener(&quot;touchstart&quot;,this._onTouchstart,ca)})}get mostRecentModality(){return this._modality.value}ngOnDestroy(){this._modality.complete(),this._platform.isBrowser&amp;&amp;(document.removeEventListener(&quot;keydown&quot;,this._onKeydown,ca),document.removeEventListener(&quot;mousedown&quot;,this._onMousedown,ca),document.removeEventListener(&quot;touchstart&quot;,this._onTouchstart,ca))}}return n.\u0275fac=function(e){return new(e||n)(D(Ke),D(Y),D(W),D(u1,8))},n.\u0275prov=P({factory:function(){return new n(D(Ke),D(Y),D(W),D(u1,8))},token:n,providedIn:&quot;root&quot;}),n})();const f1=new j(&quot;liveAnnouncerElement&quot;,{providedIn:&quot;root&quot;,factory:function(){return null}}),p1=new j(&quot;LIVE_ANNOUNCER_DEFAULT_OPTIONS&quot;);let J4=(()=&gt;{class n{constructor(e,i,r,s){this._ngZone=i,this._defaultOptions=s,this._document=r,this._liveElement=e||this._createLiveElement()}announce(e,...i){const r=this._defaultOptions;let s,o;return 1===i.length&amp;&amp;&quot;number&quot;==typeof i[0]?o=i[0]:[s,o]=i,this.clear(),clearTimeout(this._previousTimeout),s||(s=r&amp;&amp;r.politeness?r.politeness:&quot;polite&quot;),null==o&amp;&amp;r&amp;&amp;(o=r.duration),this._liveElement.setAttribute(&quot;aria-live&quot;,s),this._ngZone.runOutsideAngular(()=&gt;new Promise(a=&gt;{clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=&gt;{this._liveElement.textContent=e,a(),&quot;number&quot;==typeof o&amp;&amp;(this._previousTimeout=setTimeout(()=&gt;this.clear(),o))},100)}))}clear(){this._liveElement&amp;&amp;(this._liveElement.textContent=&quot;&quot;)}ngOnDestroy(){clearTimeout(this._previousTimeout),this._liveElement&amp;&amp;this._liveElement.parentNode&amp;&amp;(this._liveElement.parentNode.removeChild(this._liveElement),this._liveElement=null)}_createLiveElement(){const e=&quot;cdk-live-announcer-element&quot;,i=this._document.getElementsByClassName(e),r=this._document.createElement(&quot;div&quot;);for(let s=0;s&lt;i.length;s++)i[s].parentNode.removeChild(i[s]);return r.classList.add(e),r.classList.add(&quot;cdk-visually-hidden&quot;),r.setAttribute(&quot;aria-atomic&quot;,&quot;true&quot;),r.setAttribute(&quot;aria-live&quot;,&quot;polite&quot;),this._document.body.appendChild(r),r}}return n.\u0275fac=function(e){return new(e||n)(D(f1,8),D(Y),D(W),D(p1,8))},n.\u0275prov=P({factory:function(){return new n(D(f1,8),D(Y),D(W),D(p1,8))},token:n,providedIn:&quot;root&quot;}),n})(),X4=(()=&gt;{class n{constructor(e,i,r,s){this._elementRef=e,this._liveAnnouncer=i,this._contentObserver=r,this._ngZone=s,this._politeness=&quot;polite&quot;}get politeness(){return this._politeness}set politeness(e){this._politeness=&quot;off&quot;===e||&quot;assertive&quot;===e?e:&quot;polite&quot;,&quot;off&quot;===this._politeness?this._subscription&amp;&amp;(this._subscription.unsubscribe(),this._subscription=null):this._subscription||(this._subscription=this._ngZone.runOutsideAngular(()=&gt;this._contentObserver.observe(this._elementRef).subscribe(()=&gt;{const i=this._elementRef.nativeElement.textContent;i!==this._previousAnnouncedText&amp;&amp;(this._liveAnnouncer.announce(i,this._politeness),this._previousAnnouncedText=i)})))}ngOnDestroy(){this._subscription&amp;&amp;this._subscription.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(J4),_(Qk),_(Y))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;cdkAriaLive&quot;,&quot;&quot;]],inputs:{politeness:[&quot;cdkAriaLive&quot;,&quot;politeness&quot;]},exportAs:[&quot;cdkAriaLive&quot;]}),n})();const g1=new j(&quot;cdk-focus-monitor-default-options&quot;),Hd=Bd({passive:!0,capture:!0});let t_=(()=&gt;{class n{constructor(e,i,r,s,o){this._ngZone=e,this._platform=i,this._inputModalityDetector=r,this._origin=null,this._windowFocused=!1,this._originFromTouchInteraction=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._windowFocusListener=()=&gt;{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=&gt;this._windowFocused=!1)},this._stopInputModalityDetector=new ie,this._rootNodeFocusAndBlurListener=a=&gt;{const l=xs(a),c=&quot;focus&quot;===a.type?this._onFocus:this._onBlur;for(let u=l;u;u=u.parentElement)c.call(this,a,u)},this._document=s,this._detectionMode=(null==o?void 0:o.detectionMode)||0}monitor(e,i=!1){const r=hr(e);if(!this._platform.isBrowser||1!==r.nodeType)return G(null);const s=function(n){if(function(){if(null==Xm){const n=&quot;undefined&quot;!=typeof document?document.head:null;Xm=!(!n||!n.createShadowRoot&amp;&amp;!n.attachShadow)}return Xm}()){const t=n.getRootNode?n.getRootNode():null;if(&quot;undefined&quot;!=typeof ShadowRoot&amp;&amp;ShadowRoot&amp;&amp;t instanceof ShadowRoot)return t}return null}(r)||this._getDocument(),o=this._elementInfo.get(r);if(o)return i&amp;&amp;(o.checkChildren=!0),o.subject;const a={checkChildren:i,subject:new ie,rootNode:s};return this._elementInfo.set(r,a),this._registerGlobalListeners(a),a.subject}stopMonitoring(e){const i=hr(e),r=this._elementInfo.get(i);r&amp;&amp;(r.subject.complete(),this._setClasses(i),this._elementInfo.delete(i),this._removeGlobalListeners(r))}focusVia(e,i,r){const s=hr(e);s===this._getDocument().activeElement?this._getClosestElementsInfo(s).forEach(([a,l])=&gt;this._originChanged(a,i,l)):(this._setOrigin(i),&quot;function&quot;==typeof s.focus&amp;&amp;s.focus(r))}ngOnDestroy(){this._elementInfo.forEach((e,i)=&gt;this.stopMonitoring(i))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(e,i,r){r?e.classList.add(i):e.classList.remove(i)}_getFocusOrigin(e){return this._origin?this._originFromTouchInteraction?this._shouldBeAttributedToTouch(e)?&quot;touch&quot;:&quot;program&quot;:this._origin:this._windowFocused&amp;&amp;this._lastFocusOrigin?this._lastFocusOrigin:&quot;program&quot;}_shouldBeAttributedToTouch(e){return 1===this._detectionMode||!!(null==e?void 0:e.contains(this._inputModalityDetector._mostRecentTarget))}_setClasses(e,i){this._toggleClass(e,&quot;cdk-focused&quot;,!!i),this._toggleClass(e,&quot;cdk-touch-focused&quot;,&quot;touch&quot;===i),this._toggleClass(e,&quot;cdk-keyboard-focused&quot;,&quot;keyboard&quot;===i),this._toggleClass(e,&quot;cdk-mouse-focused&quot;,&quot;mouse&quot;===i),this._toggleClass(e,&quot;cdk-program-focused&quot;,&quot;program&quot;===i)}_setOrigin(e,i=!1){this._ngZone.runOutsideAngular(()=&gt;{this._origin=e,this._originFromTouchInteraction=&quot;touch&quot;===e&amp;&amp;i,0===this._detectionMode&amp;&amp;(clearTimeout(this._originTimeoutId),this._originTimeoutId=setTimeout(()=&gt;this._origin=null,this._originFromTouchInteraction?650:1))})}_onFocus(e,i){const r=this._elementInfo.get(i),s=xs(e);!r||!r.checkChildren&amp;&amp;i!==s||this._originChanged(i,this._getFocusOrigin(s),r)}_onBlur(e,i){const r=this._elementInfo.get(i);!r||r.checkChildren&amp;&amp;e.relatedTarget instanceof Node&amp;&amp;i.contains(e.relatedTarget)||(this._setClasses(i),this._emitOrigin(r.subject,null))}_emitOrigin(e,i){this._ngZone.run(()=&gt;e.next(i))}_registerGlobalListeners(e){if(!this._platform.isBrowser)return;const i=e.rootNode,r=this._rootNodeFocusListenerCount.get(i)||0;r||this._ngZone.runOutsideAngular(()=&gt;{i.addEventListener(&quot;focus&quot;,this._rootNodeFocusAndBlurListener,Hd),i.addEventListener(&quot;blur&quot;,this._rootNodeFocusAndBlurListener,Hd)}),this._rootNodeFocusListenerCount.set(i,r+1),1==++this._monitoredElementCount&amp;&amp;(this._ngZone.runOutsideAngular(()=&gt;{this._getWindow().addEventListener(&quot;focus&quot;,this._windowFocusListener)}),this._inputModalityDetector.modalityDetected.pipe(fr(this._stopInputModalityDetector)).subscribe(s=&gt;{this._setOrigin(s,!0)}))}_removeGlobalListeners(e){const i=e.rootNode;if(this._rootNodeFocusListenerCount.has(i)){const r=this._rootNodeFocusListenerCount.get(i);r&gt;1?this._rootNodeFocusListenerCount.set(i,r-1):(i.removeEventListener(&quot;focus&quot;,this._rootNodeFocusAndBlurListener,Hd),i.removeEventListener(&quot;blur&quot;,this._rootNodeFocusAndBlurListener,Hd),this._rootNodeFocusListenerCount.delete(i))}--this._monitoredElementCount||(this._getWindow().removeEventListener(&quot;focus&quot;,this._windowFocusListener),this._stopInputModalityDetector.next(),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._originTimeoutId))}_originChanged(e,i,r){this._setClasses(e,i),this._emitOrigin(r.subject,i),this._lastFocusOrigin=i}_getClosestElementsInfo(e){const i=[];return this._elementInfo.forEach((r,s)=&gt;{(s===e||r.checkChildren&amp;&amp;s.contains(e))&amp;&amp;i.push([s,r])}),i}}return n.\u0275fac=function(e){return new(e||n)(D(Y),D(Ke),D(h1),D(W,8),D(g1,8))},n.\u0275prov=P({factory:function(){return new n(D(Y),D(Ke),D(h1),D(W,8),D(g1,8))},token:n,providedIn:&quot;root&quot;}),n})(),m1=(()=&gt;{class n{constructor(e,i){this._elementRef=e,this._focusMonitor=i,this.cdkFocusChange=new U}ngAfterViewInit(){const e=this._elementRef.nativeElement;this._monitorSubscription=this._focusMonitor.monitor(e,1===e.nodeType&amp;&amp;e.hasAttribute(&quot;cdkMonitorSubtreeFocus&quot;)).subscribe(i=&gt;this.cdkFocusChange.emit(i))}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef),this._monitorSubscription&amp;&amp;this._monitorSubscription.unsubscribe()}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(t_))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;cdkMonitorElementFocus&quot;,&quot;&quot;],[&quot;&quot;,&quot;cdkMonitorSubtreeFocus&quot;,&quot;&quot;]],outputs:{cdkFocusChange:&quot;cdkFocusChange&quot;}}),n})();const _1=&quot;cdk-high-contrast-black-on-white&quot;,y1=&quot;cdk-high-contrast-white-on-black&quot;,n_=&quot;cdk-high-contrast-active&quot;;let v1=(()=&gt;{class n{constructor(e,i){this._platform=e,this._document=i}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const e=this._document.createElement(&quot;div&quot;);e.style.backgroundColor=&quot;rgb(1,2,3)&quot;,e.style.position=&quot;absolute&quot;,this._document.body.appendChild(e);const i=this._document.defaultView||window,r=i&amp;&amp;i.getComputedStyle?i.getComputedStyle(e):null,s=(r&amp;&amp;r.backgroundColor||&quot;&quot;).replace(/ /g,&quot;&quot;);switch(this._document.body.removeChild(e),s){case&quot;rgb(0,0,0)&quot;:return 2;case&quot;rgb(255,255,255)&quot;:return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(!this._hasCheckedHighContrastMode&amp;&amp;this._platform.isBrowser&amp;&amp;this._document.body){const e=this._document.body.classList;e.remove(n_),e.remove(_1),e.remove(y1),this._hasCheckedHighContrastMode=!0;const i=this.getHighContrastMode();1===i?(e.add(n_),e.add(_1)):2===i&amp;&amp;(e.add(n_),e.add(y1))}}}return n.\u0275fac=function(e){return new(e||n)(D(Ke),D(W))},n.\u0275prov=P({factory:function(){return new n(D(Ke),D(W))},token:n,providedIn:&quot;root&quot;}),n})(),e$=(()=&gt;{class n{constructor(e){e._applyBodyHighContrastModeCssClasses()}}return n.\u0275fac=function(e){return new(e||n)(D(v1))},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[Wl,Zk]]}),n})();const b1=new j(&quot;cdk-dir-doc&quot;,{providedIn:&quot;root&quot;,factory:function(){return _v(W)}});let Bi=(()=&gt;{class n{constructor(e){if(this.value=&quot;ltr&quot;,this.change=new U,e){const r=e.documentElement?e.documentElement.dir:null,s=(e.body?e.body.dir:null)||r;this.value=&quot;ltr&quot;===s||&quot;rtl&quot;===s?s:&quot;ltr&quot;}}ngOnDestroy(){this.change.complete()}}return n.\u0275fac=function(e){return new(e||n)(D(b1,8))},n.\u0275prov=P({factory:function(){return new n(D(b1,8))},token:n,providedIn:&quot;root&quot;}),n})(),Kl=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({}),n})();const C1=new Tr(&quot;12.2.13&quot;);class D1{}const pr=&quot;*&quot;;function i_(n,t){return{type:7,name:n,definitions:t,options:{}}}function Ql(n,t=null){return{type:4,styles:t,timings:n}}function w1(n,t=null){return{type:2,steps:n,options:t}}function yi(n){return{type:6,styles:n,offset:null}}function r_(n,t,e){return{type:0,name:n,styles:t,options:e}}function E1(n){return{type:5,steps:n}}function Zl(n,t,e=null){return{type:1,expr:n,animation:t,options:e}}function S1(n){Promise.resolve(null).then(n)}class ua{constructor(t=0,e=0){this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._started=!1,this._destroyed=!1,this._finished=!1,this._position=0,this.parentPlayer=null,this.totalTime=t+e}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=&gt;t()),this._onDoneFns=[])}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}init(){}play(){this.hasStarted()||(this._onStart(),this.triggerMicrotask()),this._started=!0}triggerMicrotask(){S1(()=&gt;this._onFinish())}_onStart(){this._onStartFns.forEach(t=&gt;t()),this._onStartFns=[]}pause(){}restart(){}finish(){this._onFinish()}destroy(){this._destroyed||(this._destroyed=!0,this.hasStarted()||this._onStart(),this.finish(),this._onDestroyFns.forEach(t=&gt;t()),this._onDestroyFns=[])}reset(){this._started=!1}setPosition(t){this._position=this.totalTime?t*this.totalTime:1}getPosition(){return this.totalTime?this._position/this.totalTime:1}triggerCallback(t){const e=&quot;start&quot;==t?this._onStartFns:this._onDoneFns;e.forEach(i=&gt;i()),e.length=0}}class k1{constructor(t){this._onDoneFns=[],this._onStartFns=[],this._finished=!1,this._started=!1,this._destroyed=!1,this._onDestroyFns=[],this.parentPlayer=null,this.totalTime=0,this.players=t;let e=0,i=0,r=0;const s=this.players.length;0==s?S1(()=&gt;this._onFinish()):this.players.forEach(o=&gt;{o.onDone(()=&gt;{++e==s&amp;&amp;this._onFinish()}),o.onDestroy(()=&gt;{++i==s&amp;&amp;this._onDestroy()}),o.onStart(()=&gt;{++r==s&amp;&amp;this._onStart()})}),this.totalTime=this.players.reduce((o,a)=&gt;Math.max(o,a.totalTime),0)}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=&gt;t()),this._onDoneFns=[])}init(){this.players.forEach(t=&gt;t.init())}onStart(t){this._onStartFns.push(t)}_onStart(){this.hasStarted()||(this._started=!0,this._onStartFns.forEach(t=&gt;t()),this._onStartFns=[])}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}hasStarted(){return this._started}play(){this.parentPlayer||this.init(),this._onStart(),this.players.forEach(t=&gt;t.play())}pause(){this.players.forEach(t=&gt;t.pause())}restart(){this.players.forEach(t=&gt;t.restart())}finish(){this._onFinish(),this.players.forEach(t=&gt;t.finish())}destroy(){this._onDestroy()}_onDestroy(){this._destroyed||(this._destroyed=!0,this._onFinish(),this.players.forEach(t=&gt;t.destroy()),this._onDestroyFns.forEach(t=&gt;t()),this._onDestroyFns=[])}reset(){this.players.forEach(t=&gt;t.reset()),this._destroyed=!1,this._finished=!1,this._started=!1}setPosition(t){const e=t*this.totalTime;this.players.forEach(i=&gt;{const r=i.totalTime?Math.min(1,e/i.totalTime):1;i.setPosition(r)})}getPosition(){const t=this.players.reduce((e,i)=&gt;null===e||i.totalTime&gt;e.totalTime?i:e,null);return null!=t?t.getPosition():0}beforeDestroy(){this.players.forEach(t=&gt;{t.beforeDestroy&amp;&amp;t.beforeDestroy()})}triggerCallback(t){const e=&quot;start&quot;==t?this._onStartFns:this._onDoneFns;e.forEach(i=&gt;i()),e.length=0}}function M1(){return&quot;undefined&quot;!=typeof window&amp;&amp;void 0!==window.document}function o_(){return&quot;undefined&quot;!=typeof process&amp;&amp;&quot;[object process]&quot;==={}.toString.call(process)}function Gr(n){switch(n.length){case 0:return new ua;case 1:return n[0];default:return new k1(n)}}function A1(n,t,e,i,r={},s={}){const o=[],a=[];let l=-1,c=null;if(i.forEach(u=&gt;{const f=u.offset,p=f==l,g=p&amp;&amp;c||{};Object.keys(u).forEach(m=&gt;{let C=m,v=u[m];if(&quot;offset&quot;!==m)switch(C=t.normalizePropertyName(C,o),v){case&quot;!&quot;:v=r[m];break;case pr:v=s[m];break;default:v=t.normalizeStyleValue(m,C,v,o)}g[C]=v}),p||a.push(g),c=g,l=f}),o.length){const u=&quot;\n - &quot;;throw new Error(`Unable to animate due to the following errors:${u}${o.join(u)}`)}return a}function a_(n,t,e,i){switch(t){case&quot;start&quot;:n.onStart(()=&gt;i(e&amp;&amp;l_(e,&quot;start&quot;,n)));break;case&quot;done&quot;:n.onDone(()=&gt;i(e&amp;&amp;l_(e,&quot;done&quot;,n)));break;case&quot;destroy&quot;:n.onDestroy(()=&gt;i(e&amp;&amp;l_(e,&quot;destroy&quot;,n)))}}function l_(n,t,e){const i=e.totalTime,s=c_(n.element,n.triggerName,n.fromState,n.toState,t||n.phaseName,null==i?n.totalTime:i,!!e.disabled),o=n._data;return null!=o&amp;&amp;(s._data=o),s}function c_(n,t,e,i,r=&quot;&quot;,s=0,o){return{element:n,triggerName:t,fromState:e,toState:i,phaseName:r,totalTime:s,disabled:!!o}}function Dn(n,t,e){let i;return n instanceof Map?(i=n.get(t),i||n.set(t,i=e)):(i=n[t],i||(i=n[t]=e)),i}function T1(n){const t=n.indexOf(&quot;:&quot;);return[n.substring(1,t),n.substr(t+1)]}let u_=(n,t)=&gt;!1,d_=(n,t)=&gt;!1,I1=(n,t,e)=&gt;[];const x1=o_();(x1||&quot;undefined&quot;!=typeof Element)&amp;&amp;(u_=M1()?(n,t)=&gt;{for(;t&amp;&amp;t!==document.documentElement;){if(t===n)return!0;t=t.parentNode||t.host}return!1}:(n,t)=&gt;n.contains(t),d_=(()=&gt;{if(x1||Element.prototype.matches)return(n,t)=&gt;n.matches(t);{const n=Element.prototype,t=n.matchesSelector||n.mozMatchesSelector||n.msMatchesSelector||n.oMatchesSelector||n.webkitMatchesSelector;return t?(e,i)=&gt;t.apply(e,[i]):d_}})(),I1=(n,t,e)=&gt;{let i=[];if(e){const r=n.querySelectorAll(t);for(let s=0;s&lt;r.length;s++)i.push(r[s])}else{const r=n.querySelector(t);r&amp;&amp;i.push(r)}return i});let Rs=null,R1=!1;function h_(n){Rs||(Rs=(&quot;undefined&quot;!=typeof document?document.body:null)||{},R1=!!Rs.style&amp;&amp;&quot;WebkitAppearance&quot;in Rs.style);let t=!0;return Rs.style&amp;&amp;!function(n){return&quot;ebkit&quot;==n.substring(1,6)}(n)&amp;&amp;(t=n in Rs.style,!t&amp;&amp;R1&amp;&amp;(t=&quot;Webkit&quot;+n.charAt(0).toUpperCase()+n.substr(1)in Rs.style)),t}const f_=d_,p_=u_,g_=I1;function P1(n){const t={};return Object.keys(n).forEach(e=&gt;{const i=e.replace(/([a-z])([A-Z])/g,&quot;$1-$2&quot;);t[i]=n[e]}),t}let O1=(()=&gt;{class n{validateStyleProperty(e){return h_(e)}matchesElement(e,i){return f_(e,i)}containsElement(e,i){return p_(e,i)}query(e,i,r){return g_(e,i,r)}computeStyle(e,i,r){return r||&quot;&quot;}animate(e,i,r,s,o,a=[],l){return new ua(r,s)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),m_=(()=&gt;{class n{}return n.NOOP=new O1,n})();const __=&quot;ng-enter&quot;,zd=&quot;ng-leave&quot;,$d=&quot;ng-trigger&quot;,Gd=&quot;.ng-trigger&quot;,N1=&quot;ng-animating&quot;,y_=&quot;.ng-animating&quot;;function Ps(n){if(&quot;number&quot;==typeof n)return n;const t=n.match(/^(-?[\.\d]+)(m?s)/);return!t||t.length&lt;2?0:v_(parseFloat(t[1]),t[2])}function v_(n,t){switch(t){case&quot;s&quot;:return 1e3*n;default:return n}}function Wd(n,t,e){return n.hasOwnProperty(&quot;duration&quot;)?n:function(n,t,e){let r,s=0,o=&quot;&quot;;if(&quot;string&quot;==typeof n){const a=n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i);if(null===a)return t.push(`The provided timing value &quot;${n}&quot; is invalid.`),{duration:0,delay:0,easing:&quot;&quot;};r=v_(parseFloat(a[1]),a[2]);const l=a[3];null!=l&amp;&amp;(s=v_(parseFloat(l),a[4]));const c=a[5];c&amp;&amp;(o=c)}else r=n;if(!e){let a=!1,l=t.length;r&lt;0&amp;&amp;(t.push(&quot;Duration values below 0 are not allowed for this animation step.&quot;),a=!0),s&lt;0&amp;&amp;(t.push(&quot;Delay values below 0 are not allowed for this animation step.&quot;),a=!0),a&amp;&amp;t.splice(l,0,`The provided timing value &quot;${n}&quot; is invalid.`)}return{duration:r,delay:s,easing:o}}(n,t,e)}function da(n,t={}){return Object.keys(n).forEach(e=&gt;{t[e]=n[e]}),t}function Wr(n,t,e={}){if(t)for(let i in n)e[i]=n[i];else da(n,e);return e}function L1(n,t,e){return e?t+&quot;:&quot;+e+&quot;;&quot;:&quot;&quot;}function j1(n){let t=&quot;&quot;;for(let e=0;e&lt;n.style.length;e++){const i=n.style.item(e);t+=L1(0,i,n.style.getPropertyValue(i))}for(const e in n.style)n.style.hasOwnProperty(e)&amp;&amp;!e.startsWith(&quot;_&quot;)&amp;&amp;(t+=L1(0,u$(e),n.style[e]));n.setAttribute(&quot;style&quot;,t)}function Ui(n,t,e){n.style&amp;&amp;(Object.keys(t).forEach(i=&gt;{const r=C_(i);e&amp;&amp;!e.hasOwnProperty(i)&amp;&amp;(e[i]=n.style[r]),n.style[r]=t[i]}),o_()&amp;&amp;j1(n))}function Os(n,t){n.style&amp;&amp;(Object.keys(t).forEach(e=&gt;{const i=C_(e);n.style[i]=&quot;&quot;}),o_()&amp;&amp;j1(n))}function Jl(n){return Array.isArray(n)?1==n.length?n[0]:w1(n):n}const b_=new RegExp(&quot;{{\\s*(.+?)\\s*}}&quot;,&quot;g&quot;);function B1(n){let t=[];if(&quot;string&quot;==typeof n){let e;for(;e=b_.exec(n);)t.push(e[1]);b_.lastIndex=0}return t}function qd(n,t,e){const i=n.toString(),r=i.replace(b_,(s,o)=&gt;{let a=t[o];return t.hasOwnProperty(o)||(e.push(`Please provide a value for the animation param ${o}`),a=&quot;&quot;),a.toString()});return r==i?n:r}function Yd(n){const t=[];let e=n.next();for(;!e.done;)t.push(e.value),e=n.next();return t}const c$=/-+([a-z0-9])/g;function C_(n){return n.replace(c$,(...t)=&gt;t[1].toUpperCase())}function u$(n){return n.replace(/([a-z])([A-Z])/g,&quot;$1-$2&quot;).toLowerCase()}function U1(n,t){return 0===n||0===t}function H1(n,t,e){const i=Object.keys(e);if(i.length&amp;&amp;t.length){let s=t[0],o=[];if(i.forEach(a=&gt;{s.hasOwnProperty(a)||o.push(a),s[a]=e[a]}),o.length)for(var r=1;r&lt;t.length;r++){let a=t[r];o.forEach(function(l){a[l]=D_(n,l)})}}return t}function wn(n,t,e){switch(t.type){case 7:return n.visitTrigger(t,e);case 0:return n.visitState(t,e);case 1:return n.visitTransition(t,e);case 2:return n.visitSequence(t,e);case 3:return n.visitGroup(t,e);case 4:return n.visitAnimate(t,e);case 5:return n.visitKeyframes(t,e);case 6:return n.visitStyle(t,e);case 8:return n.visitReference(t,e);case 9:return n.visitAnimateChild(t,e);case 10:return n.visitAnimateRef(t,e);case 11:return n.visitQuery(t,e);case 12:return n.visitStagger(t,e);default:throw new Error(`Unable to resolve animation metadata node #${t.type}`)}}function D_(n,t){return window.getComputedStyle(n)[t]}function d$(n,t){const e=[];return&quot;string&quot;==typeof n?n.split(/\s*,\s*/).forEach(i=&gt;function(n,t,e){if(&quot;:&quot;==n[0]){const l=function(n,t){switch(n){case&quot;:enter&quot;:return&quot;void =&gt; *&quot;;case&quot;:leave&quot;:return&quot;* =&gt; void&quot;;case&quot;:increment&quot;:return(e,i)=&gt;parseFloat(i)&gt;parseFloat(e);case&quot;:decrement&quot;:return(e,i)=&gt;parseFloat(i)&lt;parseFloat(e);default:return t.push(`The transition alias value &quot;${n}&quot; is not supported`),&quot;* =&gt; *&quot;}}(n,e);if(&quot;function&quot;==typeof l)return void t.push(l);n=l}const i=n.match(/^(\*|[-\w]+)\s*(&lt;?[=-]&gt;)\s*(\*|[-\w]+)$/);if(null==i||i.length&lt;4)return e.push(`The provided transition expression &quot;${n}&quot; is not supported`),t;const r=i[1],s=i[2],o=i[3];t.push(z1(r,o));&quot;&lt;&quot;==s[0]&amp;&amp;!(&quot;*&quot;==r&amp;&amp;&quot;*&quot;==o)&amp;&amp;t.push(z1(o,r))}(i,e,t)):e.push(n),e}const Qd=new Set([&quot;true&quot;,&quot;1&quot;]),Zd=new Set([&quot;false&quot;,&quot;0&quot;]);function z1(n,t){const e=Qd.has(n)||Zd.has(n),i=Qd.has(t)||Zd.has(t);return(r,s)=&gt;{let o=&quot;*&quot;==n||n==r,a=&quot;*&quot;==t||t==s;return!o&amp;&amp;e&amp;&amp;&quot;boolean&quot;==typeof r&amp;&amp;(o=r?Qd.has(n):Zd.has(n)),!a&amp;&amp;i&amp;&amp;&quot;boolean&quot;==typeof s&amp;&amp;(a=s?Qd.has(t):Zd.has(t)),o&amp;&amp;a}}const p$=new RegExp(&quot;s*:selfs*,?&quot;,&quot;g&quot;);function w_(n,t,e){return new g$(n).build(t,e)}class g${constructor(t){this._driver=t}build(t,e){const i=new y$(e);return this._resetContextStyleTimingState(i),wn(this,Jl(t),i)}_resetContextStyleTimingState(t){t.currentQuerySelector=&quot;&quot;,t.collectedStyles={},t.collectedStyles[&quot;&quot;]={},t.currentTime=0}visitTrigger(t,e){let i=e.queryCount=0,r=e.depCount=0;const s=[],o=[];return&quot;@&quot;==t.name.charAt(0)&amp;&amp;e.errors.push(&quot;animation triggers cannot be prefixed with an `@` sign (e.g. trigger(&#39;@foo&#39;, [...]))&quot;),t.definitions.forEach(a=&gt;{if(this._resetContextStyleTimingState(e),0==a.type){const l=a,c=l.name;c.toString().split(/\s*,\s*/).forEach(u=&gt;{l.name=u,s.push(this.visitState(l,e))}),l.name=c}else if(1==a.type){const l=this.visitTransition(a,e);i+=l.queryCount,r+=l.depCount,o.push(l)}else e.errors.push(&quot;only state() and transition() definitions can sit inside of a trigger()&quot;)}),{type:7,name:t.name,states:s,transitions:o,queryCount:i,depCount:r,options:null}}visitState(t,e){const i=this.visitStyle(t.styles,e),r=t.options&amp;&amp;t.options.params||null;if(i.containsDynamicStyles){const s=new Set,o=r||{};if(i.styles.forEach(a=&gt;{if(Jd(a)){const l=a;Object.keys(l).forEach(c=&gt;{B1(l[c]).forEach(u=&gt;{o.hasOwnProperty(u)||s.add(u)})})}}),s.size){const a=Yd(s.values());e.errors.push(`state(&quot;${t.name}&quot;, ...) must define default values for all the following style substitutions: ${a.join(&quot;, &quot;)}`)}}return{type:0,name:t.name,style:i,options:r?{params:r}:null}}visitTransition(t,e){e.queryCount=0,e.depCount=0;const i=wn(this,Jl(t.animation),e);return{type:1,matchers:d$(t.expr,e.errors),animation:i,queryCount:e.queryCount,depCount:e.depCount,options:Fs(t.options)}}visitSequence(t,e){return{type:2,steps:t.steps.map(i=&gt;wn(this,i,e)),options:Fs(t.options)}}visitGroup(t,e){const i=e.currentTime;let r=0;const s=t.steps.map(o=&gt;{e.currentTime=i;const a=wn(this,o,e);return r=Math.max(r,e.currentTime),a});return e.currentTime=r,{type:3,steps:s,options:Fs(t.options)}}visitAnimate(t,e){const i=function(n,t){let e=null;if(n.hasOwnProperty(&quot;duration&quot;))e=n;else if(&quot;number&quot;==typeof n)return E_(Wd(n,t).duration,0,&quot;&quot;);const i=n;if(i.split(/\s+/).some(s=&gt;&quot;{&quot;==s.charAt(0)&amp;&amp;&quot;{&quot;==s.charAt(1))){const s=E_(0,0,&quot;&quot;);return s.dynamic=!0,s.strValue=i,s}return e=e||Wd(i,t),E_(e.duration,e.delay,e.easing)}(t.timings,e.errors);e.currentAnimateTimings=i;let r,s=t.styles?t.styles:yi({});if(5==s.type)r=this.visitKeyframes(s,e);else{let o=t.styles,a=!1;if(!o){a=!0;const c={};i.easing&amp;&amp;(c.easing=i.easing),o=yi(c)}e.currentTime+=i.duration+i.delay;const l=this.visitStyle(o,e);l.isEmptyStep=a,r=l}return e.currentAnimateTimings=null,{type:4,timings:i,style:r,options:null}}visitStyle(t,e){const i=this._makeStyleAst(t,e);return this._validateStyleAst(i,e),i}_makeStyleAst(t,e){const i=[];Array.isArray(t.styles)?t.styles.forEach(o=&gt;{&quot;string&quot;==typeof o?o==pr?i.push(o):e.errors.push(`The provided style string value ${o} is not allowed.`):i.push(o)}):i.push(t.styles);let r=!1,s=null;return i.forEach(o=&gt;{if(Jd(o)){const a=o,l=a.easing;if(l&amp;&amp;(s=l,delete a.easing),!r)for(let c in a)if(a[c].toString().indexOf(&quot;{{&quot;)&gt;=0){r=!0;break}}}),{type:6,styles:i,easing:s,offset:t.offset,containsDynamicStyles:r,options:null}}_validateStyleAst(t,e){const i=e.currentAnimateTimings;let r=e.currentTime,s=e.currentTime;i&amp;&amp;s&gt;0&amp;&amp;(s-=i.duration+i.delay),t.styles.forEach(o=&gt;{&quot;string&quot;!=typeof o&amp;&amp;Object.keys(o).forEach(a=&gt;{if(!this._driver.validateStyleProperty(a))return void e.errors.push(`The provided animation property &quot;${a}&quot; is not a supported CSS property for animations`);const l=e.collectedStyles[e.currentQuerySelector],c=l[a];let u=!0;c&amp;&amp;(s!=r&amp;&amp;s&gt;=c.startTime&amp;&amp;r&lt;=c.endTime&amp;&amp;(e.errors.push(`The CSS property &quot;${a}&quot; that exists between the times of &quot;${c.startTime}ms&quot; and &quot;${c.endTime}ms&quot; is also being animated in a parallel animation between the times of &quot;${s}ms&quot; and &quot;${r}ms&quot;`),u=!1),s=c.startTime),u&amp;&amp;(l[a]={startTime:s,endTime:r}),e.options&amp;&amp;function(n,t,e){const i=t.params||{},r=B1(n);r.length&amp;&amp;r.forEach(s=&gt;{i.hasOwnProperty(s)||e.push(`Unable to resolve the local animation param ${s} in the given list of values`)})}(o[a],e.options,e.errors)})})}visitKeyframes(t,e){const i={type:5,styles:[],options:null};if(!e.currentAnimateTimings)return e.errors.push(&quot;keyframes() must be placed inside of a call to animate()&quot;),i;let s=0;const o=[];let a=!1,l=!1,c=0;const u=t.steps.map(S=&gt;{const E=this._makeStyleAst(S,e);let R=null!=E.offset?E.offset:function(n){if(&quot;string&quot;==typeof n)return null;let t=null;if(Array.isArray(n))n.forEach(e=&gt;{if(Jd(e)&amp;&amp;e.hasOwnProperty(&quot;offset&quot;)){const i=e;t=parseFloat(i.offset),delete i.offset}});else if(Jd(n)&amp;&amp;n.hasOwnProperty(&quot;offset&quot;)){const e=n;t=parseFloat(e.offset),delete e.offset}return t}(E.styles),F=0;return null!=R&amp;&amp;(s++,F=E.offset=R),l=l||F&lt;0||F&gt;1,a=a||F&lt;c,c=F,o.push(F),E});l&amp;&amp;e.errors.push(&quot;Please ensure that all keyframe offsets are between 0 and 1&quot;),a&amp;&amp;e.errors.push(&quot;Please ensure that all keyframe offsets are in order&quot;);const f=t.steps.length;let p=0;s&gt;0&amp;&amp;s&lt;f?e.errors.push(&quot;Not all style() steps within the declared keyframes() contain offsets&quot;):0==s&amp;&amp;(p=1/(f-1));const g=f-1,m=e.currentTime,C=e.currentAnimateTimings,v=C.duration;return u.forEach((S,E)=&gt;{const R=p&gt;0?E==g?1:p*E:o[E],F=R*v;e.currentTime=m+C.delay+F,C.duration=F,this._validateStyleAst(S,e),S.offset=R,i.styles.push(S)}),i}visitReference(t,e){return{type:8,animation:wn(this,Jl(t.animation),e),options:Fs(t.options)}}visitAnimateChild(t,e){return e.depCount++,{type:9,options:Fs(t.options)}}visitAnimateRef(t,e){return{type:10,animation:this.visitReference(t.animation,e),options:Fs(t.options)}}visitQuery(t,e){const i=e.currentQuerySelector,r=t.options||{};e.queryCount++,e.currentQuery=t;const[s,o]=function(n){const t=!!n.split(/\s*,\s*/).find(e=&gt;&quot;:self&quot;==e);return t&amp;&amp;(n=n.replace(p$,&quot;&quot;)),[n=n.replace(/@\*/g,Gd).replace(/@\w+/g,e=&gt;Gd+&quot;-&quot;+e.substr(1)).replace(/:animating/g,y_),t]}(t.selector);e.currentQuerySelector=i.length?i+&quot; &quot;+s:s,Dn(e.collectedStyles,e.currentQuerySelector,{});const a=wn(this,Jl(t.animation),e);return e.currentQuery=null,e.currentQuerySelector=i,{type:11,selector:s,limit:r.limit||0,optional:!!r.optional,includeSelf:o,animation:a,originalSelector:t.selector,options:Fs(t.options)}}visitStagger(t,e){e.currentQuery||e.errors.push(&quot;stagger() can only be used inside of query()&quot;);const i=&quot;full&quot;===t.timings?{duration:0,delay:0,easing:&quot;full&quot;}:Wd(t.timings,e.errors,!0);return{type:12,animation:wn(this,Jl(t.animation),e),timings:i,options:null}}}class y${constructor(t){this.errors=t,this.queryCount=0,this.depCount=0,this.currentTransition=null,this.currentQuery=null,this.currentQuerySelector=null,this.currentAnimateTimings=null,this.currentTime=0,this.collectedStyles={},this.options=null}}function Jd(n){return!Array.isArray(n)&amp;&amp;&quot;object&quot;==typeof n}function Fs(n){return n?(n=da(n)).params&amp;&amp;(n.params=function(n){return n?da(n):null}(n.params)):n={},n}function E_(n,t,e){return{duration:n,delay:t,easing:e}}function S_(n,t,e,i,r,s,o=null,a=!1){return{type:1,element:n,keyframes:t,preStyleProps:e,postStyleProps:i,duration:r,delay:s,totalTime:r+s,easing:o,subTimeline:a}}class Xd{constructor(){this._map=new Map}consume(t){let e=this._map.get(t);return e?this._map.delete(t):e=[],e}append(t,e){let i=this._map.get(t);i||this._map.set(t,i=[]),i.push(...e)}has(t){return this._map.has(t)}clear(){this._map.clear()}}const w$=new RegExp(&quot;:enter&quot;,&quot;g&quot;),S$=new RegExp(&quot;:leave&quot;,&quot;g&quot;);function k_(n,t,e,i,r,s={},o={},a,l,c=[]){return(new k$).buildKeyframes(n,t,e,i,r,s,o,a,l,c)}class k${buildKeyframes(t,e,i,r,s,o,a,l,c,u=[]){c=c||new Xd;const f=new M_(t,e,c,r,s,u,[]);f.options=l,f.currentTimeline.setStyles([o],null,f.errors,l),wn(this,i,f);const p=f.timelines.filter(g=&gt;g.containsAnimation());if(p.length&amp;&amp;Object.keys(a).length){const g=p[p.length-1];g.allowOnlyTimelineStyles()||g.setStyles([a],null,f.errors,l)}return p.length?p.map(g=&gt;g.buildKeyframes()):[S_(e,[],[],[],0,0,&quot;&quot;,!1)]}visitTrigger(t,e){}visitState(t,e){}visitTransition(t,e){}visitAnimateChild(t,e){const i=e.subInstructions.consume(e.element);if(i){const r=e.createSubContext(t.options),s=e.currentTimeline.currentTime,o=this._visitSubInstructions(i,r,r.options);s!=o&amp;&amp;e.transformIntoNewTimeline(o)}e.previousNode=t}visitAnimateRef(t,e){const i=e.createSubContext(t.options);i.transformIntoNewTimeline(),this.visitReference(t.animation,i),e.transformIntoNewTimeline(i.currentTimeline.currentTime),e.previousNode=t}_visitSubInstructions(t,e,i){let s=e.currentTimeline.currentTime;const o=null!=i.duration?Ps(i.duration):null,a=null!=i.delay?Ps(i.delay):null;return 0!==o&amp;&amp;t.forEach(l=&gt;{const c=e.appendInstructionToTimeline(l,o,a);s=Math.max(s,c.duration+c.delay)}),s}visitReference(t,e){e.updateOptions(t.options,!0),wn(this,t.animation,e),e.previousNode=t}visitSequence(t,e){const i=e.subContextCount;let r=e;const s=t.options;if(s&amp;&amp;(s.params||s.delay)&amp;&amp;(r=e.createSubContext(s),r.transformIntoNewTimeline(),null!=s.delay)){6==r.previousNode.type&amp;&amp;(r.currentTimeline.snapshotCurrentStyles(),r.previousNode=eh);const o=Ps(s.delay);r.delayNextStep(o)}t.steps.length&amp;&amp;(t.steps.forEach(o=&gt;wn(this,o,r)),r.currentTimeline.applyStylesToKeyframe(),r.subContextCount&gt;i&amp;&amp;r.transformIntoNewTimeline()),e.previousNode=t}visitGroup(t,e){const i=[];let r=e.currentTimeline.currentTime;const s=t.options&amp;&amp;t.options.delay?Ps(t.options.delay):0;t.steps.forEach(o=&gt;{const a=e.createSubContext(t.options);s&amp;&amp;a.delayNextStep(s),wn(this,o,a),r=Math.max(r,a.currentTimeline.currentTime),i.push(a.currentTimeline)}),i.forEach(o=&gt;e.currentTimeline.mergeTimelineCollectedStyles(o)),e.transformIntoNewTimeline(r),e.previousNode=t}_visitTiming(t,e){if(t.dynamic){const i=t.strValue;return Wd(e.params?qd(i,e.params,e.errors):i,e.errors)}return{duration:t.duration,delay:t.delay,easing:t.easing}}visitAnimate(t,e){const i=e.currentAnimateTimings=this._visitTiming(t.timings,e),r=e.currentTimeline;i.delay&amp;&amp;(e.incrementTime(i.delay),r.snapshotCurrentStyles());const s=t.style;5==s.type?this.visitKeyframes(s,e):(e.incrementTime(i.duration),this.visitStyle(s,e),r.applyStylesToKeyframe()),e.currentAnimateTimings=null,e.previousNode=t}visitStyle(t,e){const i=e.currentTimeline,r=e.currentAnimateTimings;!r&amp;&amp;i.getCurrentStyleProperties().length&amp;&amp;i.forwardFrame();const s=r&amp;&amp;r.easing||t.easing;t.isEmptyStep?i.applyEmptyStep(s):i.setStyles(t.styles,s,e.errors,e.options),e.previousNode=t}visitKeyframes(t,e){const i=e.currentAnimateTimings,r=e.currentTimeline.duration,s=i.duration,a=e.createSubContext().currentTimeline;a.easing=i.easing,t.styles.forEach(l=&gt;{a.forwardTime((l.offset||0)*s),a.setStyles(l.styles,l.easing,e.errors,e.options),a.applyStylesToKeyframe()}),e.currentTimeline.mergeTimelineCollectedStyles(a),e.transformIntoNewTimeline(r+s),e.previousNode=t}visitQuery(t,e){const i=e.currentTimeline.currentTime,r=t.options||{},s=r.delay?Ps(r.delay):0;s&amp;&amp;(6===e.previousNode.type||0==i&amp;&amp;e.currentTimeline.getCurrentStyleProperties().length)&amp;&amp;(e.currentTimeline.snapshotCurrentStyles(),e.previousNode=eh);let o=i;const a=e.invokeQuery(t.selector,t.originalSelector,t.limit,t.includeSelf,!!r.optional,e.errors);e.currentQueryTotal=a.length;let l=null;a.forEach((c,u)=&gt;{e.currentQueryIndex=u;const f=e.createSubContext(t.options,c);s&amp;&amp;f.delayNextStep(s),c===e.element&amp;&amp;(l=f.currentTimeline),wn(this,t.animation,f),f.currentTimeline.applyStylesToKeyframe(),o=Math.max(o,f.currentTimeline.currentTime)}),e.currentQueryIndex=0,e.currentQueryTotal=0,e.transformIntoNewTimeline(o),l&amp;&amp;(e.currentTimeline.mergeTimelineCollectedStyles(l),e.currentTimeline.snapshotCurrentStyles()),e.previousNode=t}visitStagger(t,e){const i=e.parentContext,r=e.currentTimeline,s=t.timings,o=Math.abs(s.duration),a=o*(e.currentQueryTotal-1);let l=o*e.currentQueryIndex;switch(s.duration&lt;0?&quot;reverse&quot;:s.easing){case&quot;reverse&quot;:l=a-l;break;case&quot;full&quot;:l=i.currentStaggerTime}const u=e.currentTimeline;l&amp;&amp;u.delayNextStep(l);const f=u.currentTime;wn(this,t.animation,e),e.previousNode=t,i.currentStaggerTime=r.currentTime-f+(r.startTime-i.currentTimeline.startTime)}}const eh={};class M_{constructor(t,e,i,r,s,o,a,l){this._driver=t,this.element=e,this.subInstructions=i,this._enterClassName=r,this._leaveClassName=s,this.errors=o,this.timelines=a,this.parentContext=null,this.currentAnimateTimings=null,this.previousNode=eh,this.subContextCount=0,this.options={},this.currentQueryIndex=0,this.currentQueryTotal=0,this.currentStaggerTime=0,this.currentTimeline=l||new th(this._driver,e,0),a.push(this.currentTimeline)}get params(){return this.options.params}updateOptions(t,e){if(!t)return;const i=t;let r=this.options;null!=i.duration&amp;&amp;(r.duration=Ps(i.duration)),null!=i.delay&amp;&amp;(r.delay=Ps(i.delay));const s=i.params;if(s){let o=r.params;o||(o=this.options.params={}),Object.keys(s).forEach(a=&gt;{(!e||!o.hasOwnProperty(a))&amp;&amp;(o[a]=qd(s[a],o,this.errors))})}}_copyOptions(){const t={};if(this.options){const e=this.options.params;if(e){const i=t.params={};Object.keys(e).forEach(r=&gt;{i[r]=e[r]})}}return t}createSubContext(t=null,e,i){const r=e||this.element,s=new M_(this._driver,r,this.subInstructions,this._enterClassName,this._leaveClassName,this.errors,this.timelines,this.currentTimeline.fork(r,i||0));return s.previousNode=this.previousNode,s.currentAnimateTimings=this.currentAnimateTimings,s.options=this._copyOptions(),s.updateOptions(t),s.currentQueryIndex=this.currentQueryIndex,s.currentQueryTotal=this.currentQueryTotal,s.parentContext=this,this.subContextCount++,s}transformIntoNewTimeline(t){return this.previousNode=eh,this.currentTimeline=this.currentTimeline.fork(this.element,t),this.timelines.push(this.currentTimeline),this.currentTimeline}appendInstructionToTimeline(t,e,i){const r={duration:null!=e?e:t.duration,delay:this.currentTimeline.currentTime+(null!=i?i:0)+t.delay,easing:&quot;&quot;},s=new M$(this._driver,t.element,t.keyframes,t.preStyleProps,t.postStyleProps,r,t.stretchStartingKeyframe);return this.timelines.push(s),r}incrementTime(t){this.currentTimeline.forwardTime(this.currentTimeline.duration+t)}delayNextStep(t){t&gt;0&amp;&amp;this.currentTimeline.delayNextStep(t)}invokeQuery(t,e,i,r,s,o){let a=[];if(r&amp;&amp;a.push(this.element),t.length&gt;0){t=(t=t.replace(w$,&quot;.&quot;+this._enterClassName)).replace(S$,&quot;.&quot;+this._leaveClassName);let c=this._driver.query(this.element,t,1!=i);0!==i&amp;&amp;(c=i&lt;0?c.slice(c.length+i,c.length):c.slice(0,i)),a.push(...c)}return!s&amp;&amp;0==a.length&amp;&amp;o.push(`\`query(&quot;${e}&quot;)\` returned zero elements. (Use \`query(&quot;${e}&quot;, { optional: true })\` if you wish to allow this.)`),a}}class th{constructor(t,e,i,r){this._driver=t,this.element=e,this.startTime=i,this._elementTimelineStylesLookup=r,this.duration=0,this._previousKeyframe={},this._currentKeyframe={},this._keyframes=new Map,this._styleSummary={},this._pendingStyles={},this._backFill={},this._currentEmptyStepKeyframe=null,this._elementTimelineStylesLookup||(this._elementTimelineStylesLookup=new Map),this._localTimelineStyles=Object.create(this._backFill,{}),this._globalTimelineStyles=this._elementTimelineStylesLookup.get(e),this._globalTimelineStyles||(this._globalTimelineStyles=this._localTimelineStyles,this._elementTimelineStylesLookup.set(e,this._localTimelineStyles)),this._loadKeyframe()}containsAnimation(){switch(this._keyframes.size){case 0:return!1;case 1:return this.getCurrentStyleProperties().length&gt;0;default:return!0}}getCurrentStyleProperties(){return Object.keys(this._currentKeyframe)}get currentTime(){return this.startTime+this.duration}delayNextStep(t){const e=1==this._keyframes.size&amp;&amp;Object.keys(this._pendingStyles).length;this.duration||e?(this.forwardTime(this.currentTime+t),e&amp;&amp;this.snapshotCurrentStyles()):this.startTime+=t}fork(t,e){return this.applyStylesToKeyframe(),new th(this._driver,t,e||this.currentTime,this._elementTimelineStylesLookup)}_loadKeyframe(){this._currentKeyframe&amp;&amp;(this._previousKeyframe=this._currentKeyframe),this._currentKeyframe=this._keyframes.get(this.duration),this._currentKeyframe||(this._currentKeyframe=Object.create(this._backFill,{}),this._keyframes.set(this.duration,this._currentKeyframe))}forwardFrame(){this.duration+=1,this._loadKeyframe()}forwardTime(t){this.applyStylesToKeyframe(),this.duration=t,this._loadKeyframe()}_updateStyle(t,e){this._localTimelineStyles[t]=e,this._globalTimelineStyles[t]=e,this._styleSummary[t]={time:this.currentTime,value:e}}allowOnlyTimelineStyles(){return this._currentEmptyStepKeyframe!==this._currentKeyframe}applyEmptyStep(t){t&amp;&amp;(this._previousKeyframe.easing=t),Object.keys(this._globalTimelineStyles).forEach(e=&gt;{this._backFill[e]=this._globalTimelineStyles[e]||pr,this._currentKeyframe[e]=pr}),this._currentEmptyStepKeyframe=this._currentKeyframe}setStyles(t,e,i,r){e&amp;&amp;(this._previousKeyframe.easing=e);const s=r&amp;&amp;r.params||{},o=function(n,t){const e={};let i;return n.forEach(r=&gt;{&quot;*&quot;===r?(i=i||Object.keys(t),i.forEach(s=&gt;{e[s]=pr})):Wr(r,!1,e)}),e}(t,this._globalTimelineStyles);Object.keys(o).forEach(a=&gt;{const l=qd(o[a],s,i);this._pendingStyles[a]=l,this._localTimelineStyles.hasOwnProperty(a)||(this._backFill[a]=this._globalTimelineStyles.hasOwnProperty(a)?this._globalTimelineStyles[a]:pr),this._updateStyle(a,l)})}applyStylesToKeyframe(){const t=this._pendingStyles,e=Object.keys(t);0!=e.length&amp;&amp;(this._pendingStyles={},e.forEach(i=&gt;{this._currentKeyframe[i]=t[i]}),Object.keys(this._localTimelineStyles).forEach(i=&gt;{this._currentKeyframe.hasOwnProperty(i)||(this._currentKeyframe[i]=this._localTimelineStyles[i])}))}snapshotCurrentStyles(){Object.keys(this._localTimelineStyles).forEach(t=&gt;{const e=this._localTimelineStyles[t];this._pendingStyles[t]=e,this._updateStyle(t,e)})}getFinalKeyframe(){return this._keyframes.get(this.duration)}get properties(){const t=[];for(let e in this._currentKeyframe)t.push(e);return t}mergeTimelineCollectedStyles(t){Object.keys(t._styleSummary).forEach(e=&gt;{const i=this._styleSummary[e],r=t._styleSummary[e];(!i||r.time&gt;i.time)&amp;&amp;this._updateStyle(e,r.value)})}buildKeyframes(){this.applyStylesToKeyframe();const t=new Set,e=new Set,i=1===this._keyframes.size&amp;&amp;0===this.duration;let r=[];this._keyframes.forEach((a,l)=&gt;{const c=Wr(a,!0);Object.keys(c).forEach(u=&gt;{const f=c[u];&quot;!&quot;==f?t.add(u):f==pr&amp;&amp;e.add(u)}),i||(c.offset=l/this.duration),r.push(c)});const s=t.size?Yd(t.values()):[],o=e.size?Yd(e.values()):[];if(i){const a=r[0],l=da(a);a.offset=0,l.offset=1,r=[a,l]}return S_(this.element,r,s,o,this.duration,this.startTime,this.easing,!1)}}class M$ extends th{constructor(t,e,i,r,s,o,a=!1){super(t,e,o.delay),this.keyframes=i,this.preStyleProps=r,this.postStyleProps=s,this._stretchStartingKeyframe=a,this.timings={duration:o.duration,delay:o.delay,easing:o.easing}}containsAnimation(){return this.keyframes.length&gt;1}buildKeyframes(){let t=this.keyframes,{delay:e,duration:i,easing:r}=this.timings;if(this._stretchStartingKeyframe&amp;&amp;e){const s=[],o=i+e,a=e/o,l=Wr(t[0],!1);l.offset=0,s.push(l);const c=Wr(t[0],!1);c.offset=W1(a),s.push(c);const u=t.length-1;for(let f=1;f&lt;=u;f++){let p=Wr(t[f],!1);p.offset=W1((e+p.offset*i)/o),s.push(p)}i=o,e=0,r=&quot;&quot;,t=s}return S_(this.element,t,this.preStyleProps,this.postStyleProps,i,e,r,!0)}}function W1(n,t=3){const e=Math.pow(10,t-1);return Math.round(n*e)/e}class A_{}class T$ extends A_{normalizePropertyName(t,e){return C_(t)}normalizeStyleValue(t,e,i,r){let s=&quot;&quot;;const o=i.toString().trim();if(I$[e]&amp;&amp;0!==i&amp;&amp;&quot;0&quot;!==i)if(&quot;number&quot;==typeof i)s=&quot;px&quot;;else{const a=i.match(/^[+-]?[\d\.]+([a-z]*)$/);a&amp;&amp;0==a[1].length&amp;&amp;r.push(`Please provide a CSS unit value for ${t}:${i}`)}return o+s}}const I$=(()=&gt;function(n){const t={};return n.forEach(e=&gt;t[e]=!0),t}(&quot;width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective&quot;.split(&quot;,&quot;)))();function q1(n,t,e,i,r,s,o,a,l,c,u,f,p){return{type:0,element:n,triggerName:t,isRemovalTransition:r,fromState:e,fromStyles:s,toState:i,toStyles:o,timelines:a,queriedElements:l,preStyleProps:c,postStyleProps:u,totalTime:f,errors:p}}const T_={};class Y1{constructor(t,e,i){this._triggerName=t,this.ast=e,this._stateStyles=i}match(t,e,i,r){return function(n,t,e,i,r){return n.some(s=&gt;s(t,e,i,r))}(this.ast.matchers,t,e,i,r)}buildStyles(t,e,i){const r=this._stateStyles[&quot;*&quot;],s=this._stateStyles[t],o=r?r.buildStyles(e,i):{};return s?s.buildStyles(e,i):o}build(t,e,i,r,s,o,a,l,c,u){const f=[],p=this.ast.options&amp;&amp;this.ast.options.params||T_,m=this.buildStyles(i,a&amp;&amp;a.params||T_,f),C=l&amp;&amp;l.params||T_,v=this.buildStyles(r,C,f),S=new Set,E=new Map,R=new Map,F=&quot;void&quot;===r,Q={params:Object.assign(Object.assign({},p),C)},Le=u?[]:k_(t,e,this.ast.animation,s,o,m,v,Q,c,f);let He=0;if(Le.forEach(Gt=&gt;{He=Math.max(Gt.duration+Gt.delay,He)}),f.length)return q1(e,this._triggerName,i,r,F,m,v,[],[],E,R,He,f);Le.forEach(Gt=&gt;{const Wt=Gt.element,mr=Dn(E,Wt,{});Gt.preStyleProps.forEach(vi=&gt;mr[vi]=!0);const _r=Dn(R,Wt,{});Gt.postStyleProps.forEach(vi=&gt;_r[vi]=!0),Wt!==e&amp;&amp;S.add(Wt)});const on=Yd(S.values());return q1(e,this._triggerName,i,r,F,m,v,Le,on,E,R,He)}}class P${constructor(t,e,i){this.styles=t,this.defaultParams=e,this.normalizer=i}buildStyles(t,e){const i={},r=da(this.defaultParams);return Object.keys(t).forEach(s=&gt;{const o=t[s];null!=o&amp;&amp;(r[s]=o)}),this.styles.styles.forEach(s=&gt;{if(&quot;string&quot;!=typeof s){const o=s;Object.keys(o).forEach(a=&gt;{let l=o[a];l.length&gt;1&amp;&amp;(l=qd(l,r,e));const c=this.normalizer.normalizePropertyName(a,e);l=this.normalizer.normalizeStyleValue(a,c,l,e),i[c]=l})}}),i}}class F${constructor(t,e,i){this.name=t,this.ast=e,this._normalizer=i,this.transitionFactories=[],this.states={},e.states.forEach(r=&gt;{this.states[r.name]=new P$(r.style,r.options&amp;&amp;r.options.params||{},i)}),K1(this.states,&quot;true&quot;,&quot;1&quot;),K1(this.states,&quot;false&quot;,&quot;0&quot;),e.transitions.forEach(r=&gt;{this.transitionFactories.push(new Y1(t,r,this.states))}),this.fallbackTransition=function(n,t,e){return new Y1(n,{type:1,animation:{type:2,steps:[],options:null},matchers:[(o,a)=&gt;!0],options:null,queryCount:0,depCount:0},t)}(t,this.states)}get containsQueries(){return this.ast.queryCount&gt;0}matchTransition(t,e,i,r){return this.transitionFactories.find(o=&gt;o.match(t,e,i,r))||null}matchStyles(t,e,i){return this.fallbackTransition.buildStyles(t,e,i)}}function K1(n,t,e){n.hasOwnProperty(t)?n.hasOwnProperty(e)||(n[e]=n[t]):n.hasOwnProperty(e)&amp;&amp;(n[t]=n[e])}const V$=new Xd;class L${constructor(t,e,i){this.bodyNode=t,this._driver=e,this._normalizer=i,this._animations={},this._playersById={},this.players=[]}register(t,e){const i=[],r=w_(this._driver,e,i);if(i.length)throw new Error(`Unable to build the animation due to the following errors: ${i.join(&quot;\n&quot;)}`);this._animations[t]=r}_buildPlayer(t,e,i){const r=t.element,s=A1(0,this._normalizer,0,t.keyframes,e,i);return this._driver.animate(r,s,t.duration,t.delay,t.easing,[],!0)}create(t,e,i={}){const r=[],s=this._animations[t];let o;const a=new Map;if(s?(o=k_(this._driver,e,s,__,zd,{},{},i,V$,r),o.forEach(u=&gt;{const f=Dn(a,u.element,{});u.postStyleProps.forEach(p=&gt;f[p]=null)})):(r.push(&quot;The requested animation doesn&#39;t exist or has already been destroyed&quot;),o=[]),r.length)throw new Error(`Unable to create the animation due to the following errors: ${r.join(&quot;\n&quot;)}`);a.forEach((u,f)=&gt;{Object.keys(u).forEach(p=&gt;{u[p]=this._driver.computeStyle(f,p,pr)})});const c=Gr(o.map(u=&gt;{const f=a.get(u.element);return this._buildPlayer(u,{},f)}));return this._playersById[t]=c,c.onDestroy(()=&gt;this.destroy(t)),this.players.push(c),c}destroy(t){const e=this._getPlayer(t);e.destroy(),delete this._playersById[t];const i=this.players.indexOf(e);i&gt;=0&amp;&amp;this.players.splice(i,1)}_getPlayer(t){const e=this._playersById[t];if(!e)throw new Error(`Unable to find the timeline player referenced by ${t}`);return e}listen(t,e,i,r){const s=c_(e,&quot;&quot;,&quot;&quot;,&quot;&quot;);return a_(this._getPlayer(t),i,s,r),()=&gt;{}}command(t,e,i,r){if(&quot;register&quot;==i)return void this.register(t,r[0]);if(&quot;create&quot;==i)return void this.create(t,e,r[0]||{});const s=this._getPlayer(t);switch(i){case&quot;play&quot;:s.play();break;case&quot;pause&quot;:s.pause();break;case&quot;reset&quot;:s.reset();break;case&quot;restart&quot;:s.restart();break;case&quot;finish&quot;:s.finish();break;case&quot;init&quot;:s.init();break;case&quot;setPosition&quot;:s.setPosition(parseFloat(r[0]));break;case&quot;destroy&quot;:this.destroy(t)}}}const Q1=&quot;ng-animate-queued&quot;,Z1=&quot;ng-animate-disabled&quot;,J1=&quot;.ng-animate-disabled&quot;,H$=[],X1={namespaceId:&quot;&quot;,setForRemoval:!1,setForMove:!1,hasAnimation:!1,removedBeforeQueried:!1},z$={namespaceId:&quot;&quot;,setForMove:!1,setForRemoval:!1,hasAnimation:!1,removedBeforeQueried:!0},Gn=&quot;__ng_removed&quot;;class I_{constructor(t,e=&quot;&quot;){this.namespaceId=e;const i=t&amp;&amp;t.hasOwnProperty(&quot;value&quot;);if(this.value=function(n){return null!=n?n:null}(i?t.value:t),i){const s=da(t);delete s.value,this.options=s}else this.options={};this.options.params||(this.options.params={})}get params(){return this.options.params}absorbOptions(t){const e=t.params;if(e){const i=this.options.params;Object.keys(e).forEach(r=&gt;{null==i[r]&amp;&amp;(i[r]=e[r])})}}}const Xl=&quot;void&quot;,x_=new I_(Xl);class $${constructor(t,e,i){this.id=t,this.hostElement=e,this._engine=i,this.players=[],this._triggers={},this._queue=[],this._elementListeners=new Map,this._hostClassName=&quot;ng-tns-&quot;+t,Wn(e,this._hostClassName)}listen(t,e,i,r){if(!this._triggers.hasOwnProperty(e))throw new Error(`Unable to listen on the animation trigger event &quot;${i}&quot; because the animation trigger &quot;${e}&quot; doesn&#39;t exist!`);if(null==i||0==i.length)throw new Error(`Unable to listen on the animation trigger &quot;${e}&quot; because the provided event is undefined!`);if(!function(n){return&quot;start&quot;==n||&quot;done&quot;==n}(i))throw new Error(`The provided animation trigger event &quot;${i}&quot; for the animation trigger &quot;${e}&quot; is not supported!`);const s=Dn(this._elementListeners,t,[]),o={name:e,phase:i,callback:r};s.push(o);const a=Dn(this._engine.statesByElement,t,{});return a.hasOwnProperty(e)||(Wn(t,$d),Wn(t,$d+&quot;-&quot;+e),a[e]=x_),()=&gt;{this._engine.afterFlush(()=&gt;{const l=s.indexOf(o);l&gt;=0&amp;&amp;s.splice(l,1),this._triggers[e]||delete a[e]})}}register(t,e){return!this._triggers[t]&amp;&amp;(this._triggers[t]=e,!0)}_getTrigger(t){const e=this._triggers[t];if(!e)throw new Error(`The provided animation trigger &quot;${t}&quot; has not been registered!`);return e}trigger(t,e,i,r=!0){const s=this._getTrigger(e),o=new R_(this.id,e,t);let a=this._engine.statesByElement.get(t);a||(Wn(t,$d),Wn(t,$d+&quot;-&quot;+e),this._engine.statesByElement.set(t,a={}));let l=a[e];const c=new I_(i,this.id);if(!(i&amp;&amp;i.hasOwnProperty(&quot;value&quot;))&amp;&amp;l&amp;&amp;c.absorbOptions(l.options),a[e]=c,l||(l=x_),c.value!==Xl&amp;&amp;l.value===c.value){if(!function(n,t){const e=Object.keys(n),i=Object.keys(t);if(e.length!=i.length)return!1;for(let r=0;r&lt;e.length;r++){const s=e[r];if(!t.hasOwnProperty(s)||n[s]!==t[s])return!1}return!0}(l.params,c.params)){const C=[],v=s.matchStyles(l.value,l.params,C),S=s.matchStyles(c.value,c.params,C);C.length?this._engine.reportError(C):this._engine.afterFlush(()=&gt;{Os(t,v),Ui(t,S)})}return}const p=Dn(this._engine.playersByElement,t,[]);p.forEach(C=&gt;{C.namespaceId==this.id&amp;&amp;C.triggerName==e&amp;&amp;C.queued&amp;&amp;C.destroy()});let g=s.matchTransition(l.value,c.value,t,c.params),m=!1;if(!g){if(!r)return;g=s.fallbackTransition,m=!0}return this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:e,transition:g,fromState:l,toState:c,player:o,isFallbackTransition:m}),m||(Wn(t,Q1),o.onStart(()=&gt;{ha(t,Q1)})),o.onDone(()=&gt;{let C=this.players.indexOf(o);C&gt;=0&amp;&amp;this.players.splice(C,1);const v=this._engine.playersByElement.get(t);if(v){let S=v.indexOf(o);S&gt;=0&amp;&amp;v.splice(S,1)}}),this.players.push(o),p.push(o),o}deregister(t){delete this._triggers[t],this._engine.statesByElement.forEach((e,i)=&gt;{delete e[t]}),this._elementListeners.forEach((e,i)=&gt;{this._elementListeners.set(i,e.filter(r=&gt;r.name!=t))})}clearElementCache(t){this._engine.statesByElement.delete(t),this._elementListeners.delete(t);const e=this._engine.playersByElement.get(t);e&amp;&amp;(e.forEach(i=&gt;i.destroy()),this._engine.playersByElement.delete(t))}_signalRemovalForInnerTriggers(t,e){const i=this._engine.driver.query(t,Gd,!0);i.forEach(r=&gt;{if(r[Gn])return;const s=this._engine.fetchNamespacesByElement(r);s.size?s.forEach(o=&gt;o.triggerLeaveAnimation(r,e,!1,!0)):this.clearElementCache(r)}),this._engine.afterFlushAnimationsDone(()=&gt;i.forEach(r=&gt;this.clearElementCache(r)))}triggerLeaveAnimation(t,e,i,r){const s=this._engine.statesByElement.get(t);if(s){const o=[];if(Object.keys(s).forEach(a=&gt;{if(this._triggers[a]){const l=this.trigger(t,a,Xl,r);l&amp;&amp;o.push(l)}}),o.length)return this._engine.markElementAsRemoved(this.id,t,!0,e),i&amp;&amp;Gr(o).onDone(()=&gt;this._engine.processLeaveNode(t)),!0}return!1}prepareLeaveAnimationListeners(t){const e=this._elementListeners.get(t),i=this._engine.statesByElement.get(t);if(e&amp;&amp;i){const r=new Set;e.forEach(s=&gt;{const o=s.name;if(r.has(o))return;r.add(o);const l=this._triggers[o].fallbackTransition,c=i[o]||x_,u=new I_(Xl),f=new R_(this.id,o,t);this._engine.totalQueuedPlayers++,this._queue.push({element:t,triggerName:o,transition:l,fromState:c,toState:u,player:f,isFallbackTransition:!0})})}}removeNode(t,e){const i=this._engine;if(t.childElementCount&amp;&amp;this._signalRemovalForInnerTriggers(t,e),this.triggerLeaveAnimation(t,e,!0))return;let r=!1;if(i.totalAnimations){const s=i.players.length?i.playersByQueriedElement.get(t):[];if(s&amp;&amp;s.length)r=!0;else{let o=t;for(;o=o.parentNode;)if(i.statesByElement.get(o)){r=!0;break}}}if(this.prepareLeaveAnimationListeners(t),r)i.markElementAsRemoved(this.id,t,!1,e);else{const s=t[Gn];(!s||s===X1)&amp;&amp;(i.afterFlush(()=&gt;this.clearElementCache(t)),i.destroyInnerAnimations(t),i._onRemovalComplete(t,e))}}insertNode(t,e){Wn(t,this._hostClassName)}drainQueuedTransitions(t){const e=[];return this._queue.forEach(i=&gt;{const r=i.player;if(r.destroyed)return;const s=i.element,o=this._elementListeners.get(s);o&amp;&amp;o.forEach(a=&gt;{if(a.name==i.triggerName){const l=c_(s,i.triggerName,i.fromState.value,i.toState.value);l._data=t,a_(i.player,a.phase,l,a.callback)}}),r.markedForDestroy?this._engine.afterFlush(()=&gt;{r.destroy()}):e.push(i)}),this._queue=[],e.sort((i,r)=&gt;{const s=i.transition.ast.depCount,o=r.transition.ast.depCount;return 0==s||0==o?s-o:this._engine.driver.containsElement(i.element,r.element)?1:-1})}destroy(t){this.players.forEach(e=&gt;e.destroy()),this._signalRemovalForInnerTriggers(this.hostElement,t)}elementContainsData(t){let e=!1;return this._elementListeners.has(t)&amp;&amp;(e=!0),e=!!this._queue.find(i=&gt;i.element===t)||e,e}}class G${constructor(t,e,i){this.bodyNode=t,this.driver=e,this._normalizer=i,this.players=[],this.newHostElements=new Map,this.playersByElement=new Map,this.playersByQueriedElement=new Map,this.statesByElement=new Map,this.disabledNodes=new Set,this.totalAnimations=0,this.totalQueuedPlayers=0,this._namespaceLookup={},this._namespaceList=[],this._flushFns=[],this._whenQuietFns=[],this.namespacesByHostElement=new Map,this.collectedEnterElements=[],this.collectedLeaveElements=[],this.onRemovalComplete=(r,s)=&gt;{}}_onRemovalComplete(t,e){this.onRemovalComplete(t,e)}get queuedPlayers(){const t=[];return this._namespaceList.forEach(e=&gt;{e.players.forEach(i=&gt;{i.queued&amp;&amp;t.push(i)})}),t}createNamespace(t,e){const i=new $$(t,e,this);return this.bodyNode&amp;&amp;this.driver.containsElement(this.bodyNode,e)?this._balanceNamespaceList(i,e):(this.newHostElements.set(e,i),this.collectEnterElement(e)),this._namespaceLookup[t]=i}_balanceNamespaceList(t,e){const i=this._namespaceList.length-1;if(i&gt;=0){let r=!1;for(let s=i;s&gt;=0;s--)if(this.driver.containsElement(this._namespaceList[s].hostElement,e)){this._namespaceList.splice(s+1,0,t),r=!0;break}r||this._namespaceList.splice(0,0,t)}else this._namespaceList.push(t);return this.namespacesByHostElement.set(e,t),t}register(t,e){let i=this._namespaceLookup[t];return i||(i=this.createNamespace(t,e)),i}registerTrigger(t,e,i){let r=this._namespaceLookup[t];r&amp;&amp;r.register(e,i)&amp;&amp;this.totalAnimations++}destroy(t,e){if(!t)return;const i=this._fetchNamespace(t);this.afterFlush(()=&gt;{this.namespacesByHostElement.delete(i.hostElement),delete this._namespaceLookup[t];const r=this._namespaceList.indexOf(i);r&gt;=0&amp;&amp;this._namespaceList.splice(r,1)}),this.afterFlushAnimationsDone(()=&gt;i.destroy(e))}_fetchNamespace(t){return this._namespaceLookup[t]}fetchNamespacesByElement(t){const e=new Set,i=this.statesByElement.get(t);if(i){const r=Object.keys(i);for(let s=0;s&lt;r.length;s++){const o=i[r[s]].namespaceId;if(o){const a=this._fetchNamespace(o);a&amp;&amp;e.add(a)}}}return e}trigger(t,e,i,r){if(nh(e)){const s=this._fetchNamespace(t);if(s)return s.trigger(e,i,r),!0}return!1}insertNode(t,e,i,r){if(!nh(e))return;const s=e[Gn];if(s&amp;&amp;s.setForRemoval){s.setForRemoval=!1,s.setForMove=!0;const o=this.collectedLeaveElements.indexOf(e);o&gt;=0&amp;&amp;this.collectedLeaveElements.splice(o,1)}if(t){const o=this._fetchNamespace(t);o&amp;&amp;o.insertNode(e,i)}r&amp;&amp;this.collectEnterElement(e)}collectEnterElement(t){this.collectedEnterElements.push(t)}markElementAsDisabled(t,e){e?this.disabledNodes.has(t)||(this.disabledNodes.add(t),Wn(t,Z1)):this.disabledNodes.has(t)&amp;&amp;(this.disabledNodes.delete(t),ha(t,Z1))}removeNode(t,e,i,r){if(nh(e)){const s=t?this._fetchNamespace(t):null;if(s?s.removeNode(e,r):this.markElementAsRemoved(t,e,!1,r),i){const o=this.namespacesByHostElement.get(e);o&amp;&amp;o.id!==t&amp;&amp;o.removeNode(e,r)}}else this._onRemovalComplete(e,r)}markElementAsRemoved(t,e,i,r){this.collectedLeaveElements.push(e),e[Gn]={namespaceId:t,setForRemoval:r,hasAnimation:i,removedBeforeQueried:!1}}listen(t,e,i,r,s){return nh(e)?this._fetchNamespace(t).listen(e,i,r,s):()=&gt;{}}_buildInstruction(t,e,i,r,s){return t.transition.build(this.driver,t.element,t.fromState.value,t.toState.value,i,r,t.fromState.options,t.toState.options,e,s)}destroyInnerAnimations(t){let e=this.driver.query(t,Gd,!0);e.forEach(i=&gt;this.destroyActiveAnimationsForElement(i)),0!=this.playersByQueriedElement.size&amp;&amp;(e=this.driver.query(t,y_,!0),e.forEach(i=&gt;this.finishActiveQueriedAnimationOnElement(i)))}destroyActiveAnimationsForElement(t){const e=this.playersByElement.get(t);e&amp;&amp;e.forEach(i=&gt;{i.queued?i.markedForDestroy=!0:i.destroy()})}finishActiveQueriedAnimationOnElement(t){const e=this.playersByQueriedElement.get(t);e&amp;&amp;e.forEach(i=&gt;i.finish())}whenRenderingDone(){return new Promise(t=&gt;{if(this.players.length)return Gr(this.players).onDone(()=&gt;t());t()})}processLeaveNode(t){const e=t[Gn];if(e&amp;&amp;e.setForRemoval){if(t[Gn]=X1,e.namespaceId){this.destroyInnerAnimations(t);const i=this._fetchNamespace(e.namespaceId);i&amp;&amp;i.clearElementCache(t)}this._onRemovalComplete(t,e.setForRemoval)}this.driver.matchesElement(t,J1)&amp;&amp;this.markElementAsDisabled(t,!1),this.driver.query(t,J1,!0).forEach(i=&gt;{this.markElementAsDisabled(i,!1)})}flush(t=-1){let e=[];if(this.newHostElements.size&amp;&amp;(this.newHostElements.forEach((i,r)=&gt;this._balanceNamespaceList(i,r)),this.newHostElements.clear()),this.totalAnimations&amp;&amp;this.collectedEnterElements.length)for(let i=0;i&lt;this.collectedEnterElements.length;i++)Wn(this.collectedEnterElements[i],&quot;ng-star-inserted&quot;);if(this._namespaceList.length&amp;&amp;(this.totalQueuedPlayers||this.collectedLeaveElements.length)){const i=[];try{e=this._flushAnimations(i,t)}finally{for(let r=0;r&lt;i.length;r++)i[r]()}}else for(let i=0;i&lt;this.collectedLeaveElements.length;i++)this.processLeaveNode(this.collectedLeaveElements[i]);if(this.totalQueuedPlayers=0,this.collectedEnterElements.length=0,this.collectedLeaveElements.length=0,this._flushFns.forEach(i=&gt;i()),this._flushFns=[],this._whenQuietFns.length){const i=this._whenQuietFns;this._whenQuietFns=[],e.length?Gr(e).onDone(()=&gt;{i.forEach(r=&gt;r())}):i.forEach(r=&gt;r())}}reportError(t){throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join(&quot;\n&quot;)}`)}_flushAnimations(t,e){const i=new Xd,r=[],s=new Map,o=[],a=new Map,l=new Map,c=new Map,u=new Set;this.disabledNodes.forEach(B=&gt;{u.add(B);const q=this.driver.query(B,&quot;.ng-animate-queued&quot;,!0);for(let ae=0;ae&lt;q.length;ae++)u.add(q[ae])});const f=this.bodyNode,p=Array.from(this.statesByElement.keys()),g=nM(p,this.collectedEnterElements),m=new Map;let C=0;g.forEach((B,q)=&gt;{const ae=__+C++;m.set(q,ae),B.forEach(Te=&gt;Wn(Te,ae))});const v=[],S=new Set,E=new Set;for(let B=0;B&lt;this.collectedLeaveElements.length;B++){const q=this.collectedLeaveElements[B],ae=q[Gn];ae&amp;&amp;ae.setForRemoval&amp;&amp;(v.push(q),S.add(q),ae.hasAnimation?this.driver.query(q,&quot;.ng-star-inserted&quot;,!0).forEach(Te=&gt;S.add(Te)):E.add(q))}const R=new Map,F=nM(p,Array.from(S));F.forEach((B,q)=&gt;{const ae=zd+C++;R.set(q,ae),B.forEach(Te=&gt;Wn(Te,ae))}),t.push(()=&gt;{g.forEach((B,q)=&gt;{const ae=m.get(q);B.forEach(Te=&gt;ha(Te,ae))}),F.forEach((B,q)=&gt;{const ae=R.get(q);B.forEach(Te=&gt;ha(Te,ae))}),v.forEach(B=&gt;{this.processLeaveNode(B)})});const Q=[],Le=[];for(let B=this._namespaceList.length-1;B&gt;=0;B--)this._namespaceList[B].drainQueuedTransitions(e).forEach(ae=&gt;{const Te=ae.player,Mt=ae.element;if(Q.push(Te),this.collectedEnterElements.length){const Gi=Mt[Gn];if(Gi&amp;&amp;Gi.setForMove)return void Te.destroy()}const $i=!f||!this.driver.containsElement(f,Mt),Sn=R.get(Mt),Kr=m.get(Mt),ot=this._buildInstruction(ae,i,Kr,Sn,$i);if(ot.errors&amp;&amp;ot.errors.length)Le.push(ot);else{if($i)return Te.onStart(()=&gt;Os(Mt,ot.fromStyles)),Te.onDestroy(()=&gt;Ui(Mt,ot.toStyles)),void r.push(Te);if(ae.isFallbackTransition)return Te.onStart(()=&gt;Os(Mt,ot.fromStyles)),Te.onDestroy(()=&gt;Ui(Mt,ot.toStyles)),void r.push(Te);ot.timelines.forEach(Gi=&gt;Gi.stretchStartingKeyframe=!0),i.append(Mt,ot.timelines),o.push({instruction:ot,player:Te,element:Mt}),ot.queriedElements.forEach(Gi=&gt;Dn(a,Gi,[]).push(Te)),ot.preStyleProps.forEach((Gi,pc)=&gt;{const Dh=Object.keys(Gi);if(Dh.length){let Us=l.get(pc);Us||l.set(pc,Us=new Set),Dh.forEach(uy=&gt;Us.add(uy))}}),ot.postStyleProps.forEach((Gi,pc)=&gt;{const Dh=Object.keys(Gi);let Us=c.get(pc);Us||c.set(pc,Us=new Set),Dh.forEach(uy=&gt;Us.add(uy))})}});if(Le.length){const B=[];Le.forEach(q=&gt;{B.push(`@${q.triggerName} has failed due to:\n`),q.errors.forEach(ae=&gt;B.push(`- ${ae}\n`))}),Q.forEach(q=&gt;q.destroy()),this.reportError(B)}const He=new Map,on=new Map;o.forEach(B=&gt;{const q=B.element;i.has(q)&amp;&amp;(on.set(q,q),this._beforeAnimationBuild(B.player.namespaceId,B.instruction,He))}),r.forEach(B=&gt;{const q=B.element;this._getPreviousPlayers(q,!1,B.namespaceId,B.triggerName,null).forEach(Te=&gt;{Dn(He,q,[]).push(Te),Te.destroy()})});const Gt=v.filter(B=&gt;rM(B,l,c)),Wt=new Map;tM(Wt,this.driver,E,c,pr).forEach(B=&gt;{rM(B,l,c)&amp;&amp;Gt.push(B)});const _r=new Map;g.forEach((B,q)=&gt;{tM(_r,this.driver,new Set(B),l,&quot;!&quot;)}),Gt.forEach(B=&gt;{const q=Wt.get(B),ae=_r.get(B);Wt.set(B,Object.assign(Object.assign({},q),ae))});const vi=[],ga=[],ma={};o.forEach(B=&gt;{const{element:q,player:ae,instruction:Te}=B;if(i.has(q)){if(u.has(q))return ae.onDestroy(()=&gt;Ui(q,Te.toStyles)),ae.disabled=!0,ae.overrideTotalTime(Te.totalTime),void r.push(ae);let Mt=ma;if(on.size&gt;1){let Sn=q;const Kr=[];for(;Sn=Sn.parentNode;){const ot=on.get(Sn);if(ot){Mt=ot;break}Kr.push(Sn)}Kr.forEach(ot=&gt;on.set(ot,Mt))}const $i=this._buildAnimation(ae.namespaceId,Te,He,s,_r,Wt);if(ae.setRealPlayer($i),Mt===ma)vi.push(ae);else{const Sn=this.playersByElement.get(Mt);Sn&amp;&amp;Sn.length&amp;&amp;(ae.parentPlayer=Gr(Sn)),r.push(ae)}}else Os(q,Te.fromStyles),ae.onDestroy(()=&gt;Ui(q,Te.toStyles)),ga.push(ae),u.has(q)&amp;&amp;r.push(ae)}),ga.forEach(B=&gt;{const q=s.get(B.element);if(q&amp;&amp;q.length){const ae=Gr(q);B.setRealPlayer(ae)}}),r.forEach(B=&gt;{B.parentPlayer?B.syncPlayerEvents(B.parentPlayer):B.destroy()});for(let B=0;B&lt;v.length;B++){const q=v[B],ae=q[Gn];if(ha(q,zd),ae&amp;&amp;ae.hasAnimation)continue;let Te=[];if(a.size){let $i=a.get(q);$i&amp;&amp;$i.length&amp;&amp;Te.push(...$i);let Sn=this.driver.query(q,y_,!0);for(let Kr=0;Kr&lt;Sn.length;Kr++){let ot=a.get(Sn[Kr]);ot&amp;&amp;ot.length&amp;&amp;Te.push(...ot)}}const Mt=Te.filter($i=&gt;!$i.destroyed);Mt.length?K$(this,q,Mt):this.processLeaveNode(q)}return v.length=0,vi.forEach(B=&gt;{this.players.push(B),B.onDone(()=&gt;{B.destroy();const q=this.players.indexOf(B);this.players.splice(q,1)}),B.play()}),vi}elementContainsData(t,e){let i=!1;const r=e[Gn];return r&amp;&amp;r.setForRemoval&amp;&amp;(i=!0),this.playersByElement.has(e)&amp;&amp;(i=!0),this.playersByQueriedElement.has(e)&amp;&amp;(i=!0),this.statesByElement.has(e)&amp;&amp;(i=!0),this._fetchNamespace(t).elementContainsData(e)||i}afterFlush(t){this._flushFns.push(t)}afterFlushAnimationsDone(t){this._whenQuietFns.push(t)}_getPreviousPlayers(t,e,i,r,s){let o=[];if(e){const a=this.playersByQueriedElement.get(t);a&amp;&amp;(o=a)}else{const a=this.playersByElement.get(t);if(a){const l=!s||s==Xl;a.forEach(c=&gt;{c.queued||!l&amp;&amp;c.triggerName!=r||o.push(c)})}}return(i||r)&amp;&amp;(o=o.filter(a=&gt;!(i&amp;&amp;i!=a.namespaceId||r&amp;&amp;r!=a.triggerName))),o}_beforeAnimationBuild(t,e,i){const s=e.element,o=e.isRemovalTransition?void 0:t,a=e.isRemovalTransition?void 0:e.triggerName;for(const l of e.timelines){const c=l.element,u=c!==s,f=Dn(i,c,[]);this._getPreviousPlayers(c,u,o,a,e.toState).forEach(g=&gt;{const m=g.getRealPlayer();m.beforeDestroy&amp;&amp;m.beforeDestroy(),g.destroy(),f.push(g)})}Os(s,e.fromStyles)}_buildAnimation(t,e,i,r,s,o){const a=e.triggerName,l=e.element,c=[],u=new Set,f=new Set,p=e.timelines.map(m=&gt;{const C=m.element;u.add(C);const v=C[Gn];if(v&amp;&amp;v.removedBeforeQueried)return new ua(m.duration,m.delay);const S=C!==l,E=function(n){const t=[];return iM(n,t),t}((i.get(C)||H$).map(He=&gt;He.getRealPlayer())).filter(He=&gt;!!He.element&amp;&amp;He.element===C),R=s.get(C),F=o.get(C),Q=A1(0,this._normalizer,0,m.keyframes,R,F),Le=this._buildPlayer(m,Q,E);if(m.subTimeline&amp;&amp;r&amp;&amp;f.add(C),S){const He=new R_(t,a,C);He.setRealPlayer(Le),c.push(He)}return Le});c.forEach(m=&gt;{Dn(this.playersByQueriedElement,m.element,[]).push(m),m.onDone(()=&gt;function(n,t,e){let i;if(n instanceof Map){if(i=n.get(t),i){if(i.length){const r=i.indexOf(e);i.splice(r,1)}0==i.length&amp;&amp;n.delete(t)}}else if(i=n[t],i){if(i.length){const r=i.indexOf(e);i.splice(r,1)}0==i.length&amp;&amp;delete n[t]}return i}(this.playersByQueriedElement,m.element,m))}),u.forEach(m=&gt;Wn(m,N1));const g=Gr(p);return g.onDestroy(()=&gt;{u.forEach(m=&gt;ha(m,N1)),Ui(l,e.toStyles)}),f.forEach(m=&gt;{Dn(r,m,[]).push(g)}),g}_buildPlayer(t,e,i){return e.length&gt;0?this.driver.animate(t.element,e,t.duration,t.delay,t.easing,i):new ua(t.duration,t.delay)}}class R_{constructor(t,e,i){this.namespaceId=t,this.triggerName=e,this.element=i,this._player=new ua,this._containsRealPlayer=!1,this._queuedCallbacks={},this.destroyed=!1,this.markedForDestroy=!1,this.disabled=!1,this.queued=!0,this.totalTime=0}setRealPlayer(t){this._containsRealPlayer||(this._player=t,Object.keys(this._queuedCallbacks).forEach(e=&gt;{this._queuedCallbacks[e].forEach(i=&gt;a_(t,e,void 0,i))}),this._queuedCallbacks={},this._containsRealPlayer=!0,this.overrideTotalTime(t.totalTime),this.queued=!1)}getRealPlayer(){return this._player}overrideTotalTime(t){this.totalTime=t}syncPlayerEvents(t){const e=this._player;e.triggerCallback&amp;&amp;t.onStart(()=&gt;e.triggerCallback(&quot;start&quot;)),t.onDone(()=&gt;this.finish()),t.onDestroy(()=&gt;this.destroy())}_queueEvent(t,e){Dn(this._queuedCallbacks,t,[]).push(e)}onDone(t){this.queued&amp;&amp;this._queueEvent(&quot;done&quot;,t),this._player.onDone(t)}onStart(t){this.queued&amp;&amp;this._queueEvent(&quot;start&quot;,t),this._player.onStart(t)}onDestroy(t){this.queued&amp;&amp;this._queueEvent(&quot;destroy&quot;,t),this._player.onDestroy(t)}init(){this._player.init()}hasStarted(){return!this.queued&amp;&amp;this._player.hasStarted()}play(){!this.queued&amp;&amp;this._player.play()}pause(){!this.queued&amp;&amp;this._player.pause()}restart(){!this.queued&amp;&amp;this._player.restart()}finish(){this._player.finish()}destroy(){this.destroyed=!0,this._player.destroy()}reset(){!this.queued&amp;&amp;this._player.reset()}setPosition(t){this.queued||this._player.setPosition(t)}getPosition(){return this.queued?0:this._player.getPosition()}triggerCallback(t){const e=this._player;e.triggerCallback&amp;&amp;e.triggerCallback(t)}}function nh(n){return n&amp;&amp;1===n.nodeType}function eM(n,t){const e=n.style.display;return n.style.display=null!=t?t:&quot;none&quot;,e}function tM(n,t,e,i,r){const s=[];e.forEach(l=&gt;s.push(eM(l)));const o=[];i.forEach((l,c)=&gt;{const u={};l.forEach(f=&gt;{const p=u[f]=t.computeStyle(c,f,r);(!p||0==p.length)&amp;&amp;(c[Gn]=z$,o.push(c))}),n.set(c,u)});let a=0;return e.forEach(l=&gt;eM(l,s[a++])),o}function nM(n,t){const e=new Map;if(n.forEach(a=&gt;e.set(a,[])),0==t.length)return e;const r=new Set(t),s=new Map;function o(a){if(!a)return 1;let l=s.get(a);if(l)return l;const c=a.parentNode;return l=e.has(c)?c:r.has(c)?1:o(c),s.set(a,l),l}return t.forEach(a=&gt;{const l=o(a);1!==l&amp;&amp;e.get(l).push(a)}),e}const ih=&quot;$$classes&quot;;function Wn(n,t){if(n.classList)n.classList.add(t);else{let e=n[ih];e||(e=n[ih]={}),e[t]=!0}}function ha(n,t){if(n.classList)n.classList.remove(t);else{let e=n[ih];e&amp;&amp;delete e[t]}}function K$(n,t,e){Gr(e).onDone(()=&gt;n.processLeaveNode(t))}function iM(n,t){for(let e=0;e&lt;n.length;e++){const i=n[e];i instanceof k1?iM(i.players,t):t.push(i)}}function rM(n,t,e){const i=e.get(n);if(!i)return!1;let r=t.get(n);return r?i.forEach(s=&gt;r.add(s)):t.set(n,i),e.delete(n),!0}class rh{constructor(t,e,i){this.bodyNode=t,this._driver=e,this._normalizer=i,this._triggerCache={},this.onRemovalComplete=(r,s)=&gt;{},this._transitionEngine=new G$(t,e,i),this._timelineEngine=new L$(t,e,i),this._transitionEngine.onRemovalComplete=(r,s)=&gt;this.onRemovalComplete(r,s)}registerTrigger(t,e,i,r,s){const o=t+&quot;-&quot;+r;let a=this._triggerCache[o];if(!a){const l=[],c=w_(this._driver,s,l);if(l.length)throw new Error(`The animation trigger &quot;${r}&quot; has failed to build due to the following errors:\n - ${l.join(&quot;\n - &quot;)}`);a=function(n,t,e){return new F$(n,t,e)}(r,c,this._normalizer),this._triggerCache[o]=a}this._transitionEngine.registerTrigger(e,r,a)}register(t,e){this._transitionEngine.register(t,e)}destroy(t,e){this._transitionEngine.destroy(t,e)}onInsert(t,e,i,r){this._transitionEngine.insertNode(t,e,i,r)}onRemove(t,e,i,r){this._transitionEngine.removeNode(t,e,r||!1,i)}disableAnimations(t,e){this._transitionEngine.markElementAsDisabled(t,e)}process(t,e,i,r){if(&quot;@&quot;==i.charAt(0)){const[s,o]=T1(i);this._timelineEngine.command(s,e,o,r)}else this._transitionEngine.trigger(t,e,i,r)}listen(t,e,i,r,s){if(&quot;@&quot;==i.charAt(0)){const[o,a]=T1(i);return this._timelineEngine.listen(o,e,a,s)}return this._transitionEngine.listen(t,e,i,r,s)}flush(t=-1){this._transitionEngine.flush(t)}get players(){return this._transitionEngine.players.concat(this._timelineEngine.players)}whenRenderingDone(){return this._transitionEngine.whenRenderingDone()}}function sM(n,t){let e=null,i=null;return Array.isArray(t)&amp;&amp;t.length?(e=P_(t[0]),t.length&gt;1&amp;&amp;(i=P_(t[t.length-1]))):t&amp;&amp;(e=P_(t)),e||i?new J$(n,e,i):null}let J$=(()=&gt;{class n{constructor(e,i,r){this._element=e,this._startStyles=i,this._endStyles=r,this._state=0;let s=n.initialStylesByElement.get(e);s||n.initialStylesByElement.set(e,s={}),this._initialStyles=s}start(){this._state&lt;1&amp;&amp;(this._startStyles&amp;&amp;Ui(this._element,this._startStyles,this._initialStyles),this._state=1)}finish(){this.start(),this._state&lt;2&amp;&amp;(Ui(this._element,this._initialStyles),this._endStyles&amp;&amp;(Ui(this._element,this._endStyles),this._endStyles=null),this._state=1)}destroy(){this.finish(),this._state&lt;3&amp;&amp;(n.initialStylesByElement.delete(this._element),this._startStyles&amp;&amp;(Os(this._element,this._startStyles),this._endStyles=null),this._endStyles&amp;&amp;(Os(this._element,this._endStyles),this._endStyles=null),Ui(this._element,this._initialStyles),this._state=3)}}return n.initialStylesByElement=new WeakMap,n})();function P_(n){let t=null;const e=Object.keys(n);for(let i=0;i&lt;e.length;i++){const r=e[i];X$(r)&amp;&amp;(t=t||{},t[r]=n[r])}return t}function X$(n){return&quot;display&quot;===n||&quot;position&quot;===n}const oM=&quot;animation&quot;,aM=&quot;animationend&quot;;class n8{constructor(t,e,i,r,s,o,a){this._element=t,this._name=e,this._duration=i,this._delay=r,this._easing=s,this._fillMode=o,this._onDoneFn=a,this._finished=!1,this._destroyed=!1,this._startTime=0,this._position=0,this._eventFn=l=&gt;this._handleCallback(l)}apply(){(function(n,t){const e=F_(n,&quot;&quot;).trim();let i=0;e.length&amp;&amp;(function(n,t){let e=0;for(let i=0;i&lt;n.length;i++)&quot;,&quot;===n.charAt(i)&amp;&amp;e++;return e}(e)+1,t=`${e}, ${t}`),sh(n,&quot;&quot;,t)})(this._element,`${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`),uM(this._element,this._eventFn,!1),this._startTime=Date.now()}pause(){lM(this._element,this._name,&quot;paused&quot;)}resume(){lM(this._element,this._name,&quot;running&quot;)}setPosition(t){const e=cM(this._element,this._name);this._position=t*this._duration,sh(this._element,&quot;Delay&quot;,`-${this._position}ms`,e)}getPosition(){return this._position}_handleCallback(t){const e=t._ngTestManualTimestamp||Date.now(),i=1e3*parseFloat(t.elapsedTime.toFixed(3));t.animationName==this._name&amp;&amp;Math.max(e-this._startTime,0)&gt;=this._delay&amp;&amp;i&gt;=this._duration&amp;&amp;this.finish()}finish(){this._finished||(this._finished=!0,this._onDoneFn(),uM(this._element,this._eventFn,!0))}destroy(){this._destroyed||(this._destroyed=!0,this.finish(),function(n,t){const i=F_(n,&quot;&quot;).split(&quot;,&quot;),r=O_(i,t);r&gt;=0&amp;&amp;(i.splice(r,1),sh(n,&quot;&quot;,i.join(&quot;,&quot;)))}(this._element,this._name))}}function lM(n,t,e){sh(n,&quot;PlayState&quot;,e,cM(n,t))}function cM(n,t){const e=F_(n,&quot;&quot;);return e.indexOf(&quot;,&quot;)&gt;0?O_(e.split(&quot;,&quot;),t):O_([e],t)}function O_(n,t){for(let e=0;e&lt;n.length;e++)if(n[e].indexOf(t)&gt;=0)return e;return-1}function uM(n,t,e){e?n.removeEventListener(aM,t):n.addEventListener(aM,t)}function sh(n,t,e,i){const r=oM+t;if(null!=i){const s=n.style[r];if(s.length){const o=s.split(&quot;,&quot;);o[i]=e,e=o.join(&quot;,&quot;)}}n.style[r]=e}function F_(n,t){return n.style[oM+t]||&quot;&quot;}class dM{constructor(t,e,i,r,s,o,a,l){this.element=t,this.keyframes=e,this.animationName=i,this._duration=r,this._delay=s,this._finalStyles=a,this._specialStyles=l,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this.currentSnapshot={},this._state=0,this.easing=o||&quot;linear&quot;,this.totalTime=r+s,this._buildStyler()}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}destroy(){this.init(),!(this._state&gt;=4)&amp;&amp;(this._state=4,this._styler.destroy(),this._flushStartFns(),this._flushDoneFns(),this._specialStyles&amp;&amp;this._specialStyles.destroy(),this._onDestroyFns.forEach(t=&gt;t()),this._onDestroyFns=[])}_flushDoneFns(){this._onDoneFns.forEach(t=&gt;t()),this._onDoneFns=[]}_flushStartFns(){this._onStartFns.forEach(t=&gt;t()),this._onStartFns=[]}finish(){this.init(),!(this._state&gt;=3)&amp;&amp;(this._state=3,this._styler.finish(),this._flushStartFns(),this._specialStyles&amp;&amp;this._specialStyles.finish(),this._flushDoneFns())}setPosition(t){this._styler.setPosition(t)}getPosition(){return this._styler.getPosition()}hasStarted(){return this._state&gt;=2}init(){this._state&gt;=1||(this._state=1,this._styler.apply(),this._delay&amp;&amp;this._styler.pause())}play(){this.init(),this.hasStarted()||(this._flushStartFns(),this._state=2,this._specialStyles&amp;&amp;this._specialStyles.start()),this._styler.resume()}pause(){this.init(),this._styler.pause()}restart(){this.reset(),this.play()}reset(){this._state=0,this._styler.destroy(),this._buildStyler(),this._styler.apply()}_buildStyler(){this._styler=new n8(this.element,this.animationName,this._duration,this._delay,this.easing,&quot;forwards&quot;,()=&gt;this.finish())}triggerCallback(t){const e=&quot;start&quot;==t?this._onStartFns:this._onDoneFns;e.forEach(i=&gt;i()),e.length=0}beforeDestroy(){this.init();const t={};if(this.hasStarted()){const e=this._state&gt;=3;Object.keys(this._finalStyles).forEach(i=&gt;{&quot;offset&quot;!=i&amp;&amp;(t[i]=e?this._finalStyles[i]:D_(this.element,i))})}this.currentSnapshot=t}}class l8 extends ua{constructor(t,e){super(),this.element=t,this._startingStyles={},this.__initialized=!1,this._styles=P1(e)}init(){this.__initialized||!this._startingStyles||(this.__initialized=!0,Object.keys(this._styles).forEach(t=&gt;{this._startingStyles[t]=this.element.style[t]}),super.init())}play(){!this._startingStyles||(this.init(),Object.keys(this._styles).forEach(t=&gt;this.element.style.setProperty(t,this._styles[t])),super.play())}destroy(){!this._startingStyles||(Object.keys(this._startingStyles).forEach(t=&gt;{const e=this._startingStyles[t];e?this.element.style.setProperty(t,e):this.element.style.removeProperty(t)}),this._startingStyles=null,super.destroy())}}class fM{constructor(){this._count=0}validateStyleProperty(t){return h_(t)}matchesElement(t,e){return f_(t,e)}containsElement(t,e){return p_(t,e)}query(t,e,i){return g_(t,e,i)}computeStyle(t,e,i){return window.getComputedStyle(t)[e]}buildKeyframeElement(t,e,i){i=i.map(a=&gt;P1(a));let r=`@keyframes ${e} {\n`,s=&quot;&quot;;i.forEach(a=&gt;{s=&quot; &quot;;const l=parseFloat(a.offset);r+=`${s}${100*l}% {\n`,s+=&quot; &quot;,Object.keys(a).forEach(c=&gt;{const u=a[c];switch(c){case&quot;offset&quot;:return;case&quot;easing&quot;:return void(u&amp;&amp;(r+=`${s}animation-timing-function: ${u};\n`));default:return void(r+=`${s}${c}: ${u};\n`)}}),r+=`${s}}\n`}),r+=&quot;}\n&quot;;const o=document.createElement(&quot;style&quot;);return o.textContent=r,o}animate(t,e,i,r,s,o=[],a){const l=o.filter(v=&gt;v instanceof dM),c={};U1(i,r)&amp;&amp;l.forEach(v=&gt;{let S=v.currentSnapshot;Object.keys(S).forEach(E=&gt;c[E]=S[E])});const u=function(n){let t={};return n&amp;&amp;(Array.isArray(n)?n:[n]).forEach(i=&gt;{Object.keys(i).forEach(r=&gt;{&quot;offset&quot;==r||&quot;easing&quot;==r||(t[r]=i[r])})}),t}(e=H1(t,e,c));if(0==i)return new l8(t,u);const f=&quot;gen_css_kf_&quot;+this._count++,p=this.buildKeyframeElement(t,f,e);(function(n){var t;const e=null===(t=n.getRootNode)||void 0===t?void 0:t.call(n);return&quot;undefined&quot;!=typeof ShadowRoot&amp;&amp;e instanceof ShadowRoot?e:document.head})(t).appendChild(p);const m=sM(t,e),C=new dM(t,e,f,i,r,s,u,m);return C.onDestroy(()=&gt;function(n){n.parentNode.removeChild(n)}(p)),C}}class gM{constructor(t,e,i,r){this.element=t,this.keyframes=e,this.options=i,this._specialStyles=r,this._onDoneFns=[],this._onStartFns=[],this._onDestroyFns=[],this._initialized=!1,this._finished=!1,this._started=!1,this._destroyed=!1,this.time=0,this.parentPlayer=null,this.currentSnapshot={},this._duration=i.duration,this._delay=i.delay||0,this.time=this._duration+this._delay}_onFinish(){this._finished||(this._finished=!0,this._onDoneFns.forEach(t=&gt;t()),this._onDoneFns=[])}init(){this._buildPlayer(),this._preparePlayerBeforeStart()}_buildPlayer(){if(this._initialized)return;this._initialized=!0;const t=this.keyframes;this.domPlayer=this._triggerWebAnimation(this.element,t,this.options),this._finalKeyframe=t.length?t[t.length-1]:{},this.domPlayer.addEventListener(&quot;finish&quot;,()=&gt;this._onFinish())}_preparePlayerBeforeStart(){this._delay?this._resetDomPlayerState():this.domPlayer.pause()}_triggerWebAnimation(t,e,i){return t.animate(e,i)}onStart(t){this._onStartFns.push(t)}onDone(t){this._onDoneFns.push(t)}onDestroy(t){this._onDestroyFns.push(t)}play(){this._buildPlayer(),this.hasStarted()||(this._onStartFns.forEach(t=&gt;t()),this._onStartFns=[],this._started=!0,this._specialStyles&amp;&amp;this._specialStyles.start()),this.domPlayer.play()}pause(){this.init(),this.domPlayer.pause()}finish(){this.init(),this._specialStyles&amp;&amp;this._specialStyles.finish(),this._onFinish(),this.domPlayer.finish()}reset(){this._resetDomPlayerState(),this._destroyed=!1,this._finished=!1,this._started=!1}_resetDomPlayerState(){this.domPlayer&amp;&amp;this.domPlayer.cancel()}restart(){this.reset(),this.play()}hasStarted(){return this._started}destroy(){this._destroyed||(this._destroyed=!0,this._resetDomPlayerState(),this._onFinish(),this._specialStyles&amp;&amp;this._specialStyles.destroy(),this._onDestroyFns.forEach(t=&gt;t()),this._onDestroyFns=[])}setPosition(t){void 0===this.domPlayer&amp;&amp;this.init(),this.domPlayer.currentTime=t*this.time}getPosition(){return this.domPlayer.currentTime/this.time}get totalTime(){return this._delay+this._duration}beforeDestroy(){const t={};this.hasStarted()&amp;&amp;Object.keys(this._finalKeyframe).forEach(e=&gt;{&quot;offset&quot;!=e&amp;&amp;(t[e]=this._finished?this._finalKeyframe[e]:D_(this.element,e))}),this.currentSnapshot=t}triggerCallback(t){const e=&quot;start&quot;==t?this._onStartFns:this._onDoneFns;e.forEach(i=&gt;i()),e.length=0}}class f8{constructor(){this._isNativeImpl=/\{\s*\[native\s+code\]\s*\}/.test(mM().toString()),this._cssKeyframesDriver=new fM}validateStyleProperty(t){return h_(t)}matchesElement(t,e){return f_(t,e)}containsElement(t,e){return p_(t,e)}query(t,e,i){return g_(t,e,i)}computeStyle(t,e,i){return window.getComputedStyle(t)[e]}overrideWebAnimationsSupport(t){this._isNativeImpl=t}animate(t,e,i,r,s,o=[],a){if(!a&amp;&amp;!this._isNativeImpl)return this._cssKeyframesDriver.animate(t,e,i,r,s,o);const u={duration:i,delay:r,fill:0==r?&quot;both&quot;:&quot;forwards&quot;};s&amp;&amp;(u.easing=s);const f={},p=o.filter(m=&gt;m instanceof gM);U1(i,r)&amp;&amp;p.forEach(m=&gt;{let C=m.currentSnapshot;Object.keys(C).forEach(v=&gt;f[v]=C[v])});const g=sM(t,e=H1(t,e=e.map(m=&gt;Wr(m,!1)),f));return new gM(t,e,u,g)}}function mM(){return M1()&amp;&amp;Element.prototype.animate||{}}let g8=(()=&gt;{class n extends D1{constructor(e,i){super(),this._nextAnimationId=0,this._renderer=e.createRenderer(i.body,{id:&quot;0&quot;,encapsulation:ut.None,styles:[],data:{animation:[]}})}build(e){const i=this._nextAnimationId.toString();this._nextAnimationId++;const r=Array.isArray(e)?w1(e):e;return _M(this._renderer,null,i,&quot;register&quot;,[r]),new m8(i,this._renderer)}}return n.\u0275fac=function(e){return new(e||n)(D(hs),D(W))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();class m8 extends class{}{constructor(t,e){super(),this._id=t,this._renderer=e}create(t,e){return new _8(this._id,t,e||{},this._renderer)}}class _8{constructor(t,e,i,r){this.id=t,this.element=e,this._renderer=r,this.parentPlayer=null,this._started=!1,this.totalTime=0,this._command(&quot;create&quot;,i)}_listen(t,e){return this._renderer.listen(this.element,`@@${this.id}:${t}`,e)}_command(t,...e){return _M(this._renderer,this.element,this.id,t,e)}onDone(t){this._listen(&quot;done&quot;,t)}onStart(t){this._listen(&quot;start&quot;,t)}onDestroy(t){this._listen(&quot;destroy&quot;,t)}init(){this._command(&quot;init&quot;)}hasStarted(){return this._started}play(){this._command(&quot;play&quot;),this._started=!0}pause(){this._command(&quot;pause&quot;)}restart(){this._command(&quot;restart&quot;)}finish(){this._command(&quot;finish&quot;)}destroy(){this._command(&quot;destroy&quot;)}reset(){this._command(&quot;reset&quot;),this._started=!1}setPosition(t){this._command(&quot;setPosition&quot;,t)}getPosition(){var t,e;return null!==(e=null===(t=this._renderer.engine.players[+this.id])||void 0===t?void 0:t.getPosition())&amp;&amp;void 0!==e?e:0}}function _M(n,t,e,i,r){return n.setProperty(t,`@@${e}:${i}`,r)}const yM=&quot;@.disabled&quot;;let y8=(()=&gt;{class n{constructor(e,i,r){this.delegate=e,this.engine=i,this._zone=r,this._currentId=0,this._microtaskId=1,this._animationCallbacksBuffer=[],this._rendererCache=new Map,this._cdRecurDepth=0,this.promise=Promise.resolve(0),i.onRemovalComplete=(s,o)=&gt;{o&amp;&amp;o.parentNode(s)&amp;&amp;o.removeChild(s.parentNode,s)}}createRenderer(e,i){const s=this.delegate.createRenderer(e,i);if(!(e&amp;&amp;i&amp;&amp;i.data&amp;&amp;i.data.animation)){let u=this._rendererCache.get(s);return u||(u=new vM(&quot;&quot;,s,this.engine),this._rendererCache.set(s,u)),u}const o=i.id,a=i.id+&quot;-&quot;+this._currentId;this._currentId++,this.engine.register(a,e);const l=u=&gt;{Array.isArray(u)?u.forEach(l):this.engine.registerTrigger(o,a,e,u.name,u)};return i.data.animation.forEach(l),new v8(this,a,s,this.engine)}begin(){this._cdRecurDepth++,this.delegate.begin&amp;&amp;this.delegate.begin()}_scheduleCountTask(){this.promise.then(()=&gt;{this._microtaskId++})}scheduleListenerCallback(e,i,r){e&gt;=0&amp;&amp;e&lt;this._microtaskId?this._zone.run(()=&gt;i(r)):(0==this._animationCallbacksBuffer.length&amp;&amp;Promise.resolve(null).then(()=&gt;{this._zone.run(()=&gt;{this._animationCallbacksBuffer.forEach(s=&gt;{const[o,a]=s;o(a)}),this._animationCallbacksBuffer=[]})}),this._animationCallbacksBuffer.push([i,r]))}end(){this._cdRecurDepth--,0==this._cdRecurDepth&amp;&amp;this._zone.runOutsideAngular(()=&gt;{this._scheduleCountTask(),this.engine.flush(this._microtaskId)}),this.delegate.end&amp;&amp;this.delegate.end()}whenRenderingDone(){return this.engine.whenRenderingDone()}}return n.\u0275fac=function(e){return new(e||n)(D(hs),D(rh),D(Y))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();class vM{constructor(t,e,i){this.namespaceId=t,this.delegate=e,this.engine=i,this.destroyNode=this.delegate.destroyNode?r=&gt;e.destroyNode(r):null}get data(){return this.delegate.data}destroy(){this.engine.destroy(this.namespaceId,this.delegate),this.delegate.destroy()}createElement(t,e){return this.delegate.createElement(t,e)}createComment(t){return this.delegate.createComment(t)}createText(t){return this.delegate.createText(t)}appendChild(t,e){this.delegate.appendChild(t,e),this.engine.onInsert(this.namespaceId,e,t,!1)}insertBefore(t,e,i,r=!0){this.delegate.insertBefore(t,e,i),this.engine.onInsert(this.namespaceId,e,t,r)}removeChild(t,e,i){this.engine.onRemove(this.namespaceId,e,this.delegate,i)}selectRootElement(t,e){return this.delegate.selectRootElement(t,e)}parentNode(t){return this.delegate.parentNode(t)}nextSibling(t){return this.delegate.nextSibling(t)}setAttribute(t,e,i,r){this.delegate.setAttribute(t,e,i,r)}removeAttribute(t,e,i){this.delegate.removeAttribute(t,e,i)}addClass(t,e){this.delegate.addClass(t,e)}removeClass(t,e){this.delegate.removeClass(t,e)}setStyle(t,e,i,r){this.delegate.setStyle(t,e,i,r)}removeStyle(t,e,i){this.delegate.removeStyle(t,e,i)}setProperty(t,e,i){&quot;@&quot;==e.charAt(0)&amp;&amp;e==yM?this.disableAnimations(t,!!i):this.delegate.setProperty(t,e,i)}setValue(t,e){this.delegate.setValue(t,e)}listen(t,e,i){return this.delegate.listen(t,e,i)}disableAnimations(t,e){this.engine.disableAnimations(t,e)}}class v8 extends vM{constructor(t,e,i,r){super(e,i,r),this.factory=t,this.namespaceId=e}setProperty(t,e,i){&quot;@&quot;==e.charAt(0)?&quot;.&quot;==e.charAt(1)&amp;&amp;e==yM?this.disableAnimations(t,i=void 0===i||!!i):this.engine.process(this.namespaceId,t,e.substr(1),i):this.delegate.setProperty(t,e,i)}listen(t,e,i){if(&quot;@&quot;==e.charAt(0)){const r=function(n){switch(n){case&quot;body&quot;:return document.body;case&quot;document&quot;:return document;case&quot;window&quot;:return window;default:return n}}(t);let s=e.substr(1),o=&quot;&quot;;return&quot;@&quot;!=s.charAt(0)&amp;&amp;([s,o]=function(n){const t=n.indexOf(&quot;.&quot;);return[n.substring(0,t),n.substr(t+1)]}(s)),this.engine.listen(this.namespaceId,r,s,o,a=&gt;{this.factory.scheduleListenerCallback(a._data||-1,i,a)})}return this.delegate.listen(t,e,i)}}let D8=(()=&gt;{class n extends rh{constructor(e,i,r){super(e.body,i,r)}ngOnDestroy(){this.flush()}}return n.\u0275fac=function(e){return new(e||n)(D(W),D(m_),D(A_))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const Ns=new j(&quot;AnimationModuleType&quot;),bM=[{provide:D1,useClass:g8},{provide:A_,useFactory:function(){return new T$}},{provide:rh,useClass:D8},{provide:hs,useFactory:function(n,t,e){return new y8(n,t,e)},deps:[id,rh,Y]}],CM=[{provide:m_,useFactory:function(){return&quot;function&quot;==typeof mM()?new f8:new fM}},{provide:Ns,useValue:&quot;BrowserAnimations&quot;},...bM],DM=[{provide:m_,useClass:O1},{provide:Ns,useValue:&quot;NoopAnimations&quot;},...bM];let k8=(()=&gt;{class n{static withConfig(e){return{ngModule:n,providers:e.disableAnimations?DM:CM}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:CM,imports:[Wg]}),n})();const wM=new Tr(&quot;12.2.13&quot;),P8=new j(&quot;mat-sanity-checks&quot;,{providedIn:&quot;root&quot;,factory:function(){return!0}});let qn=(()=&gt;{class n{constructor(e,i,r){this._hasDoneGlobalChecks=!1,this._document=r,e._applyBodyHighContrastModeCssClasses(),this._sanityChecks=i,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_checkIsEnabled(e){return!(!rg()||e_())&amp;&amp;(&quot;boolean&quot;==typeof this._sanityChecks?this._sanityChecks:!!this._sanityChecks[e])}_checkDoctypeIsDefined(){this._checkIsEnabled(&quot;doctype&quot;)&amp;&amp;!this._document.doctype&amp;&amp;console.warn(&quot;Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.&quot;)}_checkThemeIsPresent(){if(!this._checkIsEnabled(&quot;theme&quot;)||!this._document.body||&quot;function&quot;!=typeof getComputedStyle)return;const e=this._document.createElement(&quot;div&quot;);e.classList.add(&quot;mat-theme-loaded-marker&quot;),this._document.body.appendChild(e);const i=getComputedStyle(e);i&amp;&amp;&quot;none&quot;!==i.display&amp;&amp;console.warn(&quot;Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming&quot;),this._document.body.removeChild(e)}_checkCdkVersionMatch(){this._checkIsEnabled(&quot;version&quot;)&amp;&amp;wM.full!==C1.full&amp;&amp;console.warn(&quot;The Angular Material version (&quot;+wM.full+&quot;) does not match the Angular CDK version (&quot;+C1.full+&quot;).\nPlease ensure the versions of these two packages exactly match.&quot;)}}return n.\u0275fac=function(e){return new(e||n)(D(v1),D(P8,8),D(W))},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[Kl],Kl]}),n})();function EM(n){return class extends n{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=Ye(t)}}}function N_(n,t){return class extends n{constructor(...e){super(...e),this.defaultColor=t,this.color=t}get color(){return this._color}set color(e){const i=e||this.defaultColor;i!==this._color&amp;&amp;(this._color&amp;&amp;this._elementRef.nativeElement.classList.remove(`mat-${this._color}`),i&amp;&amp;this._elementRef.nativeElement.classList.add(`mat-${i}`),this._color=i)}}}function O8(n){return class extends n{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=Ye(t)}}}function SM(n){return class extends n{constructor(...t){super(...t),this.stateChanges=new ie,this.errorState=!1}updateErrorState(){const t=this.errorState,s=(this.errorStateMatcher||this._defaultErrorStateMatcher).isErrorState(this.ngControl?this.ngControl.control:null,this._parentFormGroup||this._parentForm);s!==t&amp;&amp;(this.errorState=s,this.stateChanges.next())}}}const kM=new j(&quot;MAT_DATE_LOCALE&quot;,{providedIn:&quot;root&quot;,factory:function(){return _v(rr)}});class st{constructor(){this._localeChanges=new ie,this.localeChanges=this._localeChanges}getValidDateOrNull(t){return this.isDateInstance(t)&amp;&amp;this.isValid(t)?t:null}deserialize(t){return null==t||this.isDateInstance(t)&amp;&amp;this.isValid(t)?t:this.invalid()}setLocale(t){this.locale=t,this._localeChanges.next()}compareDate(t,e){return this.getYear(t)-this.getYear(e)||this.getMonth(t)-this.getMonth(e)||this.getDate(t)-this.getDate(e)}sameDate(t,e){if(t&amp;&amp;e){let i=this.isValid(t),r=this.isValid(e);return i&amp;&amp;r?!this.compareDate(t,e):i==r}return t==e}clampDate(t,e,i){return e&amp;&amp;this.compareDate(t,e)&lt;0?e:i&amp;&amp;this.compareDate(t,i)&gt;0?i:t}}const Hi=new j(&quot;mat-date-formats&quot;);let Vs;try{Vs=&quot;undefined&quot;!=typeof Intl}catch(n){Vs=!1}const N8={long:[&quot;January&quot;,&quot;February&quot;,&quot;March&quot;,&quot;April&quot;,&quot;May&quot;,&quot;June&quot;,&quot;July&quot;,&quot;August&quot;,&quot;September&quot;,&quot;October&quot;,&quot;November&quot;,&quot;December&quot;],short:[&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;],narrow:[&quot;J&quot;,&quot;F&quot;,&quot;M&quot;,&quot;A&quot;,&quot;M&quot;,&quot;J&quot;,&quot;J&quot;,&quot;A&quot;,&quot;S&quot;,&quot;O&quot;,&quot;N&quot;,&quot;D&quot;]},V8=ah(31,n=&gt;String(n+1)),L8={long:[&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;],short:[&quot;Sun&quot;,&quot;Mon&quot;,&quot;Tue&quot;,&quot;Wed&quot;,&quot;Thu&quot;,&quot;Fri&quot;,&quot;Sat&quot;],narrow:[&quot;S&quot;,&quot;M&quot;,&quot;T&quot;,&quot;W&quot;,&quot;T&quot;,&quot;F&quot;,&quot;S&quot;]},j8=/^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/;function ah(n,t){const e=Array(n);for(let i=0;i&lt;n;i++)e[i]=t(i);return e}let B8=(()=&gt;{class n extends st{constructor(e,i){super(),this.useUtcForDisplay=!0,super.setLocale(e),this.useUtcForDisplay=!i.TRIDENT,this._clampDate=i.TRIDENT||i.EDGE}getYear(e){return e.getFullYear()}getMonth(e){return e.getMonth()}getDate(e){return e.getDate()}getDayOfWeek(e){return e.getDay()}getMonthNames(e){if(Vs){const i=new Intl.DateTimeFormat(this.locale,{month:e,timeZone:&quot;utc&quot;});return ah(12,r=&gt;this._stripDirectionalityCharacters(this._format(i,new Date(2017,r,1))))}return N8[e]}getDateNames(){if(Vs){const e=new Intl.DateTimeFormat(this.locale,{day:&quot;numeric&quot;,timeZone:&quot;utc&quot;});return ah(31,i=&gt;this._stripDirectionalityCharacters(this._format(e,new Date(2017,0,i+1))))}return V8}getDayOfWeekNames(e){if(Vs){const i=new Intl.DateTimeFormat(this.locale,{weekday:e,timeZone:&quot;utc&quot;});return ah(7,r=&gt;this._stripDirectionalityCharacters(this._format(i,new Date(2017,0,r+1))))}return L8[e]}getYearName(e){if(Vs){const i=new Intl.DateTimeFormat(this.locale,{year:&quot;numeric&quot;,timeZone:&quot;utc&quot;});return this._stripDirectionalityCharacters(this._format(i,e))}return String(this.getYear(e))}getFirstDayOfWeek(){return 0}getNumDaysInMonth(e){return this.getDate(this._createDateWithOverflow(this.getYear(e),this.getMonth(e)+1,0))}clone(e){return new Date(e.getTime())}createDate(e,i,r){let s=this._createDateWithOverflow(e,i,r);return s.getMonth(),s}today(){return new Date}parse(e){return&quot;number&quot;==typeof e?new Date(e):e?new Date(Date.parse(e)):null}format(e,i){if(!this.isValid(e))throw Error(&quot;NativeDateAdapter: Cannot format invalid date.&quot;);if(Vs){this._clampDate&amp;&amp;(e.getFullYear()&lt;1||e.getFullYear()&gt;9999)&amp;&amp;(e=this.clone(e)).setFullYear(Math.max(1,Math.min(9999,e.getFullYear()))),i=Object.assign(Object.assign({},i),{timeZone:&quot;utc&quot;});const r=new Intl.DateTimeFormat(this.locale,i);return this._stripDirectionalityCharacters(this._format(r,e))}return this._stripDirectionalityCharacters(e.toDateString())}addCalendarYears(e,i){return this.addCalendarMonths(e,12*i)}addCalendarMonths(e,i){let r=this._createDateWithOverflow(this.getYear(e),this.getMonth(e)+i,this.getDate(e));return this.getMonth(r)!=((this.getMonth(e)+i)%12+12)%12&amp;&amp;(r=this._createDateWithOverflow(this.getYear(r),this.getMonth(r),0)),r}addCalendarDays(e,i){return this._createDateWithOverflow(this.getYear(e),this.getMonth(e),this.getDate(e)+i)}toIso8601(e){return[e.getUTCFullYear(),this._2digit(e.getUTCMonth()+1),this._2digit(e.getUTCDate())].join(&quot;-&quot;)}deserialize(e){if(&quot;string&quot;==typeof e){if(!e)return null;if(j8.test(e)){let i=new Date(e);if(this.isValid(i))return i}}return super.deserialize(e)}isDateInstance(e){return e instanceof Date}isValid(e){return!isNaN(e.getTime())}invalid(){return new Date(NaN)}_createDateWithOverflow(e,i,r){const s=new Date;return s.setFullYear(e,i,r),s.setHours(0,0,0,0),s}_2digit(e){return(&quot;00&quot;+e).slice(-2)}_stripDirectionalityCharacters(e){return e.replace(/[\u200e\u200f]/g,&quot;&quot;)}_format(e,i){const r=new Date;return r.setUTCFullYear(i.getFullYear(),i.getMonth(),i.getDate()),r.setUTCHours(i.getHours(),i.getMinutes(),i.getSeconds(),i.getMilliseconds()),e.format(r)}}return n.\u0275fac=function(e){return new(e||n)(D(kM,8),D(Ke))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),H8=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[{provide:st,useClass:B8}],imports:[[Wl]]}),n})();const z8={parse:{dateInput:null},display:{dateInput:{year:&quot;numeric&quot;,month:&quot;numeric&quot;,day:&quot;numeric&quot;},monthYearLabel:{year:&quot;numeric&quot;,month:&quot;short&quot;},dateA11yLabel:{year:&quot;numeric&quot;,month:&quot;long&quot;,day:&quot;numeric&quot;},monthYearA11yLabel:{year:&quot;numeric&quot;,month:&quot;long&quot;}}};let $8=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[{provide:Hi,useValue:z8}],imports:[[H8]]}),n})(),ec=(()=&gt;{class n{isErrorState(e,i){return!!(e&amp;&amp;e.invalid&amp;&amp;(e.touched||i&amp;&amp;i.submitted))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({factory:function(){return new n},token:n,providedIn:&quot;root&quot;}),n})();class G8{constructor(t,e,i){this._renderer=t,this.element=e,this.config=i,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const MM={enterDuration:225,exitDuration:150},V_=Bd({passive:!0}),AM=[&quot;mousedown&quot;,&quot;touchstart&quot;],TM=[&quot;mouseup&quot;,&quot;mouseleave&quot;,&quot;touchend&quot;,&quot;touchcancel&quot;];class q8{constructor(t,e,i,r){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,r.isBrowser&amp;&amp;(this._containerElement=hr(i))}fadeInRipple(t,e,i={}){const r=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),s=Object.assign(Object.assign({},MM),i.animation);i.centered&amp;&amp;(t=r.left+r.width/2,e=r.top+r.height/2);const o=i.radius||function(n,t,e){const i=Math.max(Math.abs(n-e.left),Math.abs(n-e.right)),r=Math.max(Math.abs(t-e.top),Math.abs(t-e.bottom));return Math.sqrt(i*i+r*r)}(t,e,r),a=t-r.left,l=e-r.top,c=s.enterDuration,u=document.createElement(&quot;div&quot;);u.classList.add(&quot;mat-ripple-element&quot;),u.style.left=a-o+&quot;px&quot;,u.style.top=l-o+&quot;px&quot;,u.style.height=2*o+&quot;px&quot;,u.style.width=2*o+&quot;px&quot;,null!=i.color&amp;&amp;(u.style.backgroundColor=i.color),u.style.transitionDuration=`${c}ms`,this._containerElement.appendChild(u),function(n){window.getComputedStyle(n).getPropertyValue(&quot;opacity&quot;)}(u),u.style.transform=&quot;scale(1)&quot;;const f=new G8(this,u,i);return f.state=0,this._activeRipples.add(f),i.persistent||(this._mostRecentTransientRipple=f),this._runTimeoutOutsideZone(()=&gt;{const p=f===this._mostRecentTransientRipple;f.state=1,!i.persistent&amp;&amp;(!p||!this._isPointerDown)&amp;&amp;f.fadeOut()},c),f}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&amp;&amp;(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const i=t.element,r=Object.assign(Object.assign({},MM),t.config.animation);i.style.transitionDuration=`${r.exitDuration}ms`,i.style.opacity=&quot;0&quot;,t.state=2,this._runTimeoutOutsideZone(()=&gt;{t.state=3,i.parentNode.removeChild(i)},r.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=&gt;t.fadeOut())}fadeOutAllNonPersistent(){this._activeRipples.forEach(t=&gt;{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=hr(t);!e||e===this._triggerElement||(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(AM))}handleEvent(t){&quot;mousedown&quot;===t.type?this._onMousedown(t):&quot;touchstart&quot;===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(TM),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=l1(t),i=this._lastTouchStartEvent&amp;&amp;Date.now()&lt;this._lastTouchStartEvent+800;!this._target.rippleDisabled&amp;&amp;!e&amp;&amp;!i&amp;&amp;(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&amp;&amp;!c1(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let i=0;i&lt;e.length;i++)this.fadeInRipple(e[i].clientX,e[i].clientY,this._target.rippleConfig)}}_onPointerUp(){!this._isPointerDown||(this._isPointerDown=!1,this._activeRipples.forEach(t=&gt;{!t.config.persistent&amp;&amp;(1===t.state||t.config.terminateOnPointerUp&amp;&amp;0===t.state)&amp;&amp;t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=&gt;setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=&gt;{t.forEach(e=&gt;{this._triggerElement.addEventListener(e,this,V_)})})}_removeTriggerEvents(){this._triggerElement&amp;&amp;(AM.forEach(t=&gt;{this._triggerElement.removeEventListener(t,this,V_)}),this._pointerUpEventsRegistered&amp;&amp;TM.forEach(t=&gt;{this._triggerElement.removeEventListener(t,this,V_)}))}}const Q8=new j(&quot;mat-ripple-global-options&quot;);let lh=(()=&gt;{class n{constructor(e,i,r,s,o){this._elementRef=e,this._animationMode=o,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=s||{},this._rippleRenderer=new q8(this,i,e,r)}get disabled(){return this._disabled}set disabled(e){e&amp;&amp;this.fadeOutAllNonPersistent(),this._disabled=e,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(e){this._trigger=e,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),&quot;NoopAnimations&quot;===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&amp;&amp;this._isInitialized&amp;&amp;this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(e,i=0,r){return&quot;number&quot;==typeof e?this._rippleRenderer.fadeInRipple(e,i,Object.assign(Object.assign({},this.rippleConfig),r)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),e))}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(Y),_(Ke),_(Q8,8),_(Ns,8))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;mat-ripple&quot;,&quot;&quot;],[&quot;&quot;,&quot;matRipple&quot;,&quot;&quot;]],hostAttrs:[1,&quot;mat-ripple&quot;],hostVars:2,hostBindings:function(e,i){2&amp;e&amp;&amp;Me(&quot;mat-ripple-unbounded&quot;,i.unbounded)},inputs:{radius:[&quot;matRippleRadius&quot;,&quot;radius&quot;],disabled:[&quot;matRippleDisabled&quot;,&quot;disabled&quot;],trigger:[&quot;matRippleTrigger&quot;,&quot;trigger&quot;],color:[&quot;matRippleColor&quot;,&quot;color&quot;],unbounded:[&quot;matRippleUnbounded&quot;,&quot;unbounded&quot;],centered:[&quot;matRippleCentered&quot;,&quot;centered&quot;],animation:[&quot;matRippleAnimation&quot;,&quot;animation&quot;]},exportAs:[&quot;matRipple&quot;]}),n})(),IM=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[qn,Wl],qn]}),n})();function gr(n,t,e,i){return bi(e)&amp;&amp;(i=e,e=void 0),i?gr(n,t,e).pipe(pe(r=&gt;zs(r)?i(...r):i(r))):new ye(r=&gt;{OM(n,t,function(o){r.next(arguments.length&gt;1?Array.prototype.slice.call(arguments):o)},r,e)})}function OM(n,t,e,i,r){let s;if(function(n){return n&amp;&amp;&quot;function&quot;==typeof n.addEventListener&amp;&amp;&quot;function&quot;==typeof n.removeEventListener}(n)){const o=n;n.addEventListener(t,e,r),s=()=&gt;o.removeEventListener(t,e,r)}else if(function(n){return n&amp;&amp;&quot;function&quot;==typeof n.on&amp;&amp;&quot;function&quot;==typeof n.off}(n)){const o=n;n.on(t,e),s=()=&gt;o.off(t,e)}else if(function(n){return n&amp;&amp;&quot;function&quot;==typeof n.addListener&amp;&amp;&quot;function&quot;==typeof n.removeListener}(n)){const o=n;n.addListener(t,e),s=()=&gt;o.removeListener(t,e)}else{if(!n||!n.length)throw new TypeError(&quot;Invalid event target&quot;);for(let o=0,a=n.length;o&lt;a;o++)OM(n[o],t,e,i,r)}i.add(s)}const a5=[&quot;underline&quot;],l5=[&quot;connectionContainer&quot;],c5=[&quot;inputContainer&quot;],u5=[&quot;label&quot;];function d5(n,t){1&amp;n&amp;&amp;(Xa(0),d(1,&quot;div&quot;,14),k(2,&quot;div&quot;,15),k(3,&quot;div&quot;,16),k(4,&quot;div&quot;,17),h(),d(5,&quot;div&quot;,18),k(6,&quot;div&quot;,15),k(7,&quot;div&quot;,16),k(8,&quot;div&quot;,17),h(),el())}function h5(n,t){1&amp;n&amp;&amp;(d(0,&quot;div&quot;,19),ht(1,1),h())}function f5(n,t){if(1&amp;n&amp;&amp;(Xa(0),ht(1,2),d(2,&quot;span&quot;),b(3),h(),el()),2&amp;n){const e=T(2);y(3),nt(e._control.placeholder)}}function p5(n,t){1&amp;n&amp;&amp;ht(0,3,[&quot;*ngSwitchCase&quot;,&quot;true&quot;])}function g5(n,t){1&amp;n&amp;&amp;(d(0,&quot;span&quot;,23),b(1,&quot; *&quot;),h())}function m5(n,t){if(1&amp;n){const e=Ue();d(0,&quot;label&quot;,20,21),M(&quot;cdkObserveContent&quot;,function(){return _e(e),T().updateOutlineGap()}),I(2,f5,4,1,&quot;ng-container&quot;,12),I(3,p5,1,0,&quot;ng-content&quot;,12),I(4,g5,2,0,&quot;span&quot;,22),h()}if(2&amp;n){const e=T();Me(&quot;mat-empty&quot;,e._control.empty&amp;&amp;!e._shouldAlwaysFloat())(&quot;mat-form-field-empty&quot;,e._control.empty&amp;&amp;!e._shouldAlwaysFloat())(&quot;mat-accent&quot;,&quot;accent&quot;==e.color)(&quot;mat-warn&quot;,&quot;warn&quot;==e.color),w(&quot;cdkObserveContentDisabled&quot;,&quot;outline&quot;!=e.appearance)(&quot;id&quot;,e._labelId)(&quot;ngSwitch&quot;,e._hasLabel()),Ce(&quot;for&quot;,e._control.id)(&quot;aria-owns&quot;,e._control.id),y(2),w(&quot;ngSwitchCase&quot;,!1),y(1),w(&quot;ngSwitchCase&quot;,!0),y(1),w(&quot;ngIf&quot;,!e.hideRequiredMarker&amp;&amp;e._control.required&amp;&amp;!e._control.disabled)}}function _5(n,t){1&amp;n&amp;&amp;(d(0,&quot;div&quot;,24),ht(1,4),h())}function y5(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,25,26),k(2,&quot;span&quot;,27),h()),2&amp;n){const e=T();y(2),Me(&quot;mat-accent&quot;,&quot;accent&quot;==e.color)(&quot;mat-warn&quot;,&quot;warn&quot;==e.color)}}function v5(n,t){1&amp;n&amp;&amp;(d(0,&quot;div&quot;),ht(1,5),h()),2&amp;n&amp;&amp;w(&quot;@transitionMessages&quot;,T()._subscriptAnimationState)}function b5(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,31),b(1),h()),2&amp;n){const e=T(2);w(&quot;id&quot;,e._hintLabelId),y(1),nt(e.hintLabel)}}function C5(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,28),I(1,b5,2,2,&quot;div&quot;,29),ht(2,6),k(3,&quot;div&quot;,30),ht(4,7),h()),2&amp;n){const e=T();w(&quot;@transitionMessages&quot;,e._subscriptAnimationState),y(1),w(&quot;ngIf&quot;,e.hintLabel)}}const D5=[&quot;*&quot;,[[&quot;&quot;,&quot;matPrefix&quot;,&quot;&quot;]],[[&quot;mat-placeholder&quot;]],[[&quot;mat-label&quot;]],[[&quot;&quot;,&quot;matSuffix&quot;,&quot;&quot;]],[[&quot;mat-error&quot;]],[[&quot;mat-hint&quot;,3,&quot;align&quot;,&quot;end&quot;]],[[&quot;mat-hint&quot;,&quot;align&quot;,&quot;end&quot;]]],w5=[&quot;*&quot;,&quot;[matPrefix]&quot;,&quot;mat-placeholder&quot;,&quot;mat-label&quot;,&quot;[matSuffix]&quot;,&quot;mat-error&quot;,&quot;mat-hint:not([align=&#39;end&#39;])&quot;,&quot;mat-hint[align=&#39;end&#39;]&quot;];let E5=0;const FM=new j(&quot;MatError&quot;);let S5=(()=&gt;{class n{constructor(e,i){this.id=&quot;mat-error-&quot;+E5++,e||i.nativeElement.setAttribute(&quot;aria-live&quot;,&quot;polite&quot;)}}return n.\u0275fac=function(e){return new(e||n)(is(&quot;aria-live&quot;),_(X))},n.\u0275dir=O({type:n,selectors:[[&quot;mat-error&quot;]],hostAttrs:[&quot;aria-atomic&quot;,&quot;true&quot;,1,&quot;mat-error&quot;],hostVars:1,hostBindings:function(e,i){2&amp;e&amp;&amp;Ce(&quot;id&quot;,i.id)},inputs:{id:&quot;id&quot;},features:[ce([{provide:FM,useExisting:n}])]}),n})();const k5={transitionMessages:i_(&quot;transitionMessages&quot;,[r_(&quot;enter&quot;,yi({opacity:1,transform:&quot;translateY(0%)&quot;})),Zl(&quot;void =&gt; enter&quot;,[yi({opacity:0,transform:&quot;translateY(-5px)&quot;}),Ql(&quot;300ms cubic-bezier(0.55, 0, 0.55, 0.2)&quot;)])])};let ch=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n}),n})();const NM=new j(&quot;MatHint&quot;);let nc=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n,selectors:[[&quot;mat-label&quot;]]}),n})(),A5=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n,selectors:[[&quot;mat-placeholder&quot;]]}),n})();const VM=new j(&quot;MatPrefix&quot;),LM=new j(&quot;MatSuffix&quot;);let L_=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;matSuffix&quot;,&quot;&quot;]],features:[ce([{provide:LM,useExisting:n}])]}),n})(),jM=0;const I5=N_(class{constructor(n){this._elementRef=n}},&quot;primary&quot;),x5=new j(&quot;MAT_FORM_FIELD_DEFAULT_OPTIONS&quot;),uh=new j(&quot;MatFormField&quot;);let j_=(()=&gt;{class n extends I5{constructor(e,i,r,s,o,a,l,c){super(e),this._changeDetectorRef=i,this._dir=s,this._defaults=o,this._platform=a,this._ngZone=l,this._outlineGapCalculationNeededImmediately=!1,this._outlineGapCalculationNeededOnStable=!1,this._destroyed=new ie,this._showAlwaysAnimate=!1,this._subscriptAnimationState=&quot;&quot;,this._hintLabel=&quot;&quot;,this._hintLabelId=&quot;mat-hint-&quot;+jM++,this._labelId=&quot;mat-form-field-label-&quot;+jM++,this.floatLabel=this._getDefaultFloatLabelState(),this._animationsEnabled=&quot;NoopAnimations&quot;!==c,this.appearance=o&amp;&amp;o.appearance?o.appearance:&quot;legacy&quot;,this._hideRequiredMarker=!(!o||null==o.hideRequiredMarker)&amp;&amp;o.hideRequiredMarker}get appearance(){return this._appearance}set appearance(e){const i=this._appearance;this._appearance=e||this._defaults&amp;&amp;this._defaults.appearance||&quot;legacy&quot;,&quot;outline&quot;===this._appearance&amp;&amp;i!==e&amp;&amp;(this._outlineGapCalculationNeededOnStable=!0)}get hideRequiredMarker(){return this._hideRequiredMarker}set hideRequiredMarker(e){this._hideRequiredMarker=Ye(e)}_shouldAlwaysFloat(){return&quot;always&quot;===this.floatLabel&amp;&amp;!this._showAlwaysAnimate}_canLabelFloat(){return&quot;never&quot;!==this.floatLabel}get hintLabel(){return this._hintLabel}set hintLabel(e){this._hintLabel=e,this._processHints()}get floatLabel(){return&quot;legacy&quot;!==this.appearance&amp;&amp;&quot;never&quot;===this._floatLabel?&quot;auto&quot;:this._floatLabel}set floatLabel(e){e!==this._floatLabel&amp;&amp;(this._floatLabel=e||this._getDefaultFloatLabelState(),this._changeDetectorRef.markForCheck())}get _control(){return this._explicitFormFieldControl||this._controlNonStatic||this._controlStatic}set _control(e){this._explicitFormFieldControl=e}getLabelId(){return this._hasFloatingLabel()?this._labelId:null}getConnectedOverlayOrigin(){return this._connectionContainerRef||this._elementRef}ngAfterContentInit(){this._validateControlChild();const e=this._control;e.controlType&amp;&amp;this._elementRef.nativeElement.classList.add(`mat-form-field-type-${e.controlType}`),e.stateChanges.pipe(lr(null)).subscribe(()=&gt;{this._validatePlaceholders(),this._syncDescribedByIds(),this._changeDetectorRef.markForCheck()}),e.ngControl&amp;&amp;e.ngControl.valueChanges&amp;&amp;e.ngControl.valueChanges.pipe(fr(this._destroyed)).subscribe(()=&gt;this._changeDetectorRef.markForCheck()),this._ngZone.runOutsideAngular(()=&gt;{this._ngZone.onStable.pipe(fr(this._destroyed)).subscribe(()=&gt;{this._outlineGapCalculationNeededOnStable&amp;&amp;this.updateOutlineGap()})}),Ci(this._prefixChildren.changes,this._suffixChildren.changes).subscribe(()=&gt;{this._outlineGapCalculationNeededOnStable=!0,this._changeDetectorRef.markForCheck()}),this._hintChildren.changes.pipe(lr(null)).subscribe(()=&gt;{this._processHints(),this._changeDetectorRef.markForCheck()}),this._errorChildren.changes.pipe(lr(null)).subscribe(()=&gt;{this._syncDescribedByIds(),this._changeDetectorRef.markForCheck()}),this._dir&amp;&amp;this._dir.change.pipe(fr(this._destroyed)).subscribe(()=&gt;{&quot;function&quot;==typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=&gt;{requestAnimationFrame(()=&gt;this.updateOutlineGap())}):this.updateOutlineGap()})}ngAfterContentChecked(){this._validateControlChild(),this._outlineGapCalculationNeededImmediately&amp;&amp;this.updateOutlineGap()}ngAfterViewInit(){this._subscriptAnimationState=&quot;enter&quot;,this._changeDetectorRef.detectChanges()}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete()}_shouldForward(e){const i=this._control?this._control.ngControl:null;return i&amp;&amp;i[e]}_hasPlaceholder(){return!!(this._control&amp;&amp;this._control.placeholder||this._placeholderChild)}_hasLabel(){return!(!this._labelChildNonStatic&amp;&amp;!this._labelChildStatic)}_shouldLabelFloat(){return this._canLabelFloat()&amp;&amp;(this._control&amp;&amp;this._control.shouldLabelFloat||this._shouldAlwaysFloat())}_hideControlPlaceholder(){return&quot;legacy&quot;===this.appearance&amp;&amp;!this._hasLabel()||this._hasLabel()&amp;&amp;!this._shouldLabelFloat()}_hasFloatingLabel(){return this._hasLabel()||&quot;legacy&quot;===this.appearance&amp;&amp;this._hasPlaceholder()}_getDisplayedMessages(){return this._errorChildren&amp;&amp;this._errorChildren.length&gt;0&amp;&amp;this._control.errorState?&quot;error&quot;:&quot;hint&quot;}_animateAndLockLabel(){this._hasFloatingLabel()&amp;&amp;this._canLabelFloat()&amp;&amp;(this._animationsEnabled&amp;&amp;this._label&amp;&amp;(this._showAlwaysAnimate=!0,gr(this._label.nativeElement,&quot;transitionend&quot;).pipe(rn(1)).subscribe(()=&gt;{this._showAlwaysAnimate=!1})),this.floatLabel=&quot;always&quot;,this._changeDetectorRef.markForCheck())}_validatePlaceholders(){}_processHints(){this._validateHints(),this._syncDescribedByIds()}_validateHints(){}_getDefaultFloatLabelState(){return this._defaults&amp;&amp;this._defaults.floatLabel||&quot;auto&quot;}_syncDescribedByIds(){if(this._control){let e=[];if(this._control.userAriaDescribedBy&amp;&amp;&quot;string&quot;==typeof this._control.userAriaDescribedBy&amp;&amp;e.push(...this._control.userAriaDescribedBy.split(&quot; &quot;)),&quot;hint&quot;===this._getDisplayedMessages()){const i=this._hintChildren?this._hintChildren.find(s=&gt;&quot;start&quot;===s.align):null,r=this._hintChildren?this._hintChildren.find(s=&gt;&quot;end&quot;===s.align):null;i?e.push(i.id):this._hintLabel&amp;&amp;e.push(this._hintLabelId),r&amp;&amp;e.push(r.id)}else this._errorChildren&amp;&amp;e.push(...this._errorChildren.map(i=&gt;i.id));this._control.setDescribedByIds(e)}}_validateControlChild(){}updateOutlineGap(){const e=this._label?this._label.nativeElement:null;if(!(&quot;outline&quot;===this.appearance&amp;&amp;e&amp;&amp;e.children.length&amp;&amp;e.textContent.trim()&amp;&amp;this._platform.isBrowser))return;if(!this._isAttachedToDOM())return void(this._outlineGapCalculationNeededImmediately=!0);let i=0,r=0;const s=this._connectionContainerRef.nativeElement,o=s.querySelectorAll(&quot;.mat-form-field-outline-start&quot;),a=s.querySelectorAll(&quot;.mat-form-field-outline-gap&quot;);if(this._label&amp;&amp;this._label.nativeElement.children.length){const l=s.getBoundingClientRect();if(0===l.width&amp;&amp;0===l.height)return this._outlineGapCalculationNeededOnStable=!0,void(this._outlineGapCalculationNeededImmediately=!1);const c=this._getStartEnd(l),u=e.children,f=this._getStartEnd(u[0].getBoundingClientRect());let p=0;for(let g=0;g&lt;u.length;g++)p+=u[g].offsetWidth;i=Math.abs(f-c)-5,r=p&gt;0?.75*p+10:0}for(let l=0;l&lt;o.length;l++)o[l].style.width=`${i}px`;for(let l=0;l&lt;a.length;l++)a[l].style.width=`${r}px`;this._outlineGapCalculationNeededOnStable=this._outlineGapCalculationNeededImmediately=!1}_getStartEnd(e){return this._dir&amp;&amp;&quot;rtl&quot;===this._dir.value?e.right:e.left}_isAttachedToDOM(){const e=this._elementRef.nativeElement;if(e.getRootNode){const i=e.getRootNode();return i&amp;&amp;i!==e}return document.documentElement.contains(e)}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(xt),_(X),_(Bi,8),_(x5,8),_(Ke),_(Y),_(Ns,8))},n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-form-field&quot;]],contentQueries:function(e,i,r){if(1&amp;e&amp;&amp;(Xt(r,ch,5),Xt(r,ch,7),Xt(r,nc,5),Xt(r,nc,7),Xt(r,A5,5),Xt(r,FM,5),Xt(r,NM,5),Xt(r,VM,5),Xt(r,LM,5)),2&amp;e){let s;Pe(s=Oe())&amp;&amp;(i._controlNonStatic=s.first),Pe(s=Oe())&amp;&amp;(i._controlStatic=s.first),Pe(s=Oe())&amp;&amp;(i._labelChildNonStatic=s.first),Pe(s=Oe())&amp;&amp;(i._labelChildStatic=s.first),Pe(s=Oe())&amp;&amp;(i._placeholderChild=s.first),Pe(s=Oe())&amp;&amp;(i._errorChildren=s),Pe(s=Oe())&amp;&amp;(i._hintChildren=s),Pe(s=Oe())&amp;&amp;(i._prefixChildren=s),Pe(s=Oe())&amp;&amp;(i._suffixChildren=s)}},viewQuery:function(e,i){if(1&amp;e&amp;&amp;(Pt(a5,5),Pt(l5,7),Pt(c5,5),Pt(u5,5)),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i.underlineRef=r.first),Pe(r=Oe())&amp;&amp;(i._connectionContainerRef=r.first),Pe(r=Oe())&amp;&amp;(i._inputContainerRef=r.first),Pe(r=Oe())&amp;&amp;(i._label=r.first)}},hostAttrs:[1,&quot;mat-form-field&quot;],hostVars:40,hostBindings:function(e,i){2&amp;e&amp;&amp;Me(&quot;mat-form-field-appearance-standard&quot;,&quot;standard&quot;==i.appearance)(&quot;mat-form-field-appearance-fill&quot;,&quot;fill&quot;==i.appearance)(&quot;mat-form-field-appearance-outline&quot;,&quot;outline&quot;==i.appearance)(&quot;mat-form-field-appearance-legacy&quot;,&quot;legacy&quot;==i.appearance)(&quot;mat-form-field-invalid&quot;,i._control.errorState)(&quot;mat-form-field-can-float&quot;,i._canLabelFloat())(&quot;mat-form-field-should-float&quot;,i._shouldLabelFloat())(&quot;mat-form-field-has-label&quot;,i._hasFloatingLabel())(&quot;mat-form-field-hide-placeholder&quot;,i._hideControlPlaceholder())(&quot;mat-form-field-disabled&quot;,i._control.disabled)(&quot;mat-form-field-autofilled&quot;,i._control.autofilled)(&quot;mat-focused&quot;,i._control.focused)(&quot;ng-untouched&quot;,i._shouldForward(&quot;untouched&quot;))(&quot;ng-touched&quot;,i._shouldForward(&quot;touched&quot;))(&quot;ng-pristine&quot;,i._shouldForward(&quot;pristine&quot;))(&quot;ng-dirty&quot;,i._shouldForward(&quot;dirty&quot;))(&quot;ng-valid&quot;,i._shouldForward(&quot;valid&quot;))(&quot;ng-invalid&quot;,i._shouldForward(&quot;invalid&quot;))(&quot;ng-pending&quot;,i._shouldForward(&quot;pending&quot;))(&quot;_mat-animation-noopable&quot;,!i._animationsEnabled)},inputs:{color:&quot;color&quot;,floatLabel:&quot;floatLabel&quot;,appearance:&quot;appearance&quot;,hideRequiredMarker:&quot;hideRequiredMarker&quot;,hintLabel:&quot;hintLabel&quot;},exportAs:[&quot;matFormField&quot;],features:[ce([{provide:uh,useExisting:n}]),se],ngContentSelectors:w5,decls:15,vars:8,consts:[[1,&quot;mat-form-field-wrapper&quot;],[1,&quot;mat-form-field-flex&quot;,3,&quot;click&quot;],[&quot;connectionContainer&quot;,&quot;&quot;],[4,&quot;ngIf&quot;],[&quot;class&quot;,&quot;mat-form-field-prefix&quot;,4,&quot;ngIf&quot;],[1,&quot;mat-form-field-infix&quot;],[&quot;inputContainer&quot;,&quot;&quot;],[1,&quot;mat-form-field-label-wrapper&quot;],[&quot;class&quot;,&quot;mat-form-field-label&quot;,3,&quot;cdkObserveContentDisabled&quot;,&quot;id&quot;,&quot;mat-empty&quot;,&quot;mat-form-field-empty&quot;,&quot;mat-accent&quot;,&quot;mat-warn&quot;,&quot;ngSwitch&quot;,&quot;cdkObserveContent&quot;,4,&quot;ngIf&quot;],[&quot;class&quot;,&quot;mat-form-field-suffix&quot;,4,&quot;ngIf&quot;],[&quot;class&quot;,&quot;mat-form-field-underline&quot;,4,&quot;ngIf&quot;],[1,&quot;mat-form-field-subscript-wrapper&quot;,3,&quot;ngSwitch&quot;],[4,&quot;ngSwitchCase&quot;],[&quot;class&quot;,&quot;mat-form-field-hint-wrapper&quot;,4,&quot;ngSwitchCase&quot;],[1,&quot;mat-form-field-outline&quot;],[1,&quot;mat-form-field-outline-start&quot;],[1,&quot;mat-form-field-outline-gap&quot;],[1,&quot;mat-form-field-outline-end&quot;],[1,&quot;mat-form-field-outline&quot;,&quot;mat-form-field-outline-thick&quot;],[1,&quot;mat-form-field-prefix&quot;],[1,&quot;mat-form-field-label&quot;,3,&quot;cdkObserveContentDisabled&quot;,&quot;id&quot;,&quot;ngSwitch&quot;,&quot;cdkObserveContent&quot;],[&quot;label&quot;,&quot;&quot;],[&quot;class&quot;,&quot;mat-placeholder-required mat-form-field-required-marker&quot;,&quot;aria-hidden&quot;,&quot;true&quot;,4,&quot;ngIf&quot;],[&quot;aria-hidden&quot;,&quot;true&quot;,1,&quot;mat-placeholder-required&quot;,&quot;mat-form-field-required-marker&quot;],[1,&quot;mat-form-field-suffix&quot;],[1,&quot;mat-form-field-underline&quot;],[&quot;underline&quot;,&quot;&quot;],[1,&quot;mat-form-field-ripple&quot;],[1,&quot;mat-form-field-hint-wrapper&quot;],[&quot;class&quot;,&quot;mat-hint&quot;,3,&quot;id&quot;,4,&quot;ngIf&quot;],[1,&quot;mat-form-field-hint-spacer&quot;],[1,&quot;mat-hint&quot;,3,&quot;id&quot;]],template:function(e,i){1&amp;e&amp;&amp;(ri(D5),d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1,2),M(&quot;click&quot;,function(s){return i._control.onContainerClick&amp;&amp;i._control.onContainerClick(s)}),I(3,d5,9,0,&quot;ng-container&quot;,3),I(4,h5,2,0,&quot;div&quot;,4),d(5,&quot;div&quot;,5,6),ht(7),d(8,&quot;span&quot;,7),I(9,m5,5,16,&quot;label&quot;,8),h(),h(),I(10,_5,2,0,&quot;div&quot;,9),h(),I(11,y5,3,4,&quot;div&quot;,10),d(12,&quot;div&quot;,11),I(13,v5,2,1,&quot;div&quot;,12),I(14,C5,5,2,&quot;div&quot;,13),h(),h()),2&amp;e&amp;&amp;(y(3),w(&quot;ngIf&quot;,&quot;outline&quot;==i.appearance),y(1),w(&quot;ngIf&quot;,i._prefixChildren.length),y(5),w(&quot;ngIf&quot;,i._hasFloatingLabel()),y(1),w(&quot;ngIf&quot;,i._suffixChildren.length),y(1),w(&quot;ngIf&quot;,&quot;outline&quot;!=i.appearance),y(1),w(&quot;ngSwitch&quot;,i._getDisplayedMessages()),y(1),w(&quot;ngSwitchCase&quot;,&quot;error&quot;),y(1),w(&quot;ngSwitchCase&quot;,&quot;hint&quot;))},directives:[rt,Yo,Ju,p4],styles:[&quot;.mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n&quot;,&#39;.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-form-field-flex{outline:dashed 3px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:&quot;&quot;;display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n&#39;,&#39;.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element:not([type=password])::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:&quot; &quot;;white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{opacity:0}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.cdk-high-contrast-active .mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{opacity:0}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:&quot;&quot;;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n&#39;,&quot;.mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n&quot;,&quot;.mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.cdk-high-contrast-active .mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick{border:3px dashed}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n&quot;,&quot;.mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n&quot;],encapsulation:2,data:{animation:[k5.transitionMessages]},changeDetection:0}),n})(),UM=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[Ko,qn,Zk],qn]}),n})();class P5{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new O5(t,this.durationSelector))}}class O5 extends Ca{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let e;try{const{durationSelector:r}=this;e=r(t)}catch(r){return this.destination.error(r)}const i=Da(e,new ba(this));!i||i.closed?this.clearThrottle():this.add(this.throttled=i)}}clearThrottle(){const{value:t,hasValue:e,throttled:i}=this;i&amp;&amp;(this.remove(i),this.throttled=void 0,i.unsubscribe()),e&amp;&amp;(this.value=void 0,this.hasValue=!1,this.destination.next(t))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function B_(n){return!zs(n)&amp;&amp;n-parseFloat(n)+1&gt;=0}function N5(n){const{index:t,period:e,subscriber:i}=n;if(i.next(t),!i.closed){if(-1===e)return i.complete();n.index=t+1,this.schedule(n,e)}}function dh(n,t=aa){return function(n){return function(e){return e.lift(new P5(n))}}(()=&gt;function(n=0,t,e){let i=-1;return B_(t)?i=Number(t)&lt;1?1:Number(t):$s(t)&amp;&amp;(e=t),$s(e)||(e=aa),new ye(r=&gt;{const s=B_(n)?n:+n-e.now();return e.schedule(N5,s,{index:0,period:i,subscriber:r})})}(n,t))}const HM=Bd({passive:!0});let zM=(()=&gt;{class n{constructor(e,i){this._platform=e,this._ngZone=i,this._monitoredElements=new Map}monitor(e){if(!this._platform.isBrowser)return Cs;const i=hr(e),r=this._monitoredElements.get(i);if(r)return r.subject;const s=new ie,o=&quot;cdk-text-field-autofilled&quot;,a=l=&gt;{&quot;cdk-text-field-autofill-start&quot;!==l.animationName||i.classList.contains(o)?&quot;cdk-text-field-autofill-end&quot;===l.animationName&amp;&amp;i.classList.contains(o)&amp;&amp;(i.classList.remove(o),this._ngZone.run(()=&gt;s.next({target:l.target,isAutofilled:!1}))):(i.classList.add(o),this._ngZone.run(()=&gt;s.next({target:l.target,isAutofilled:!0})))};return this._ngZone.runOutsideAngular(()=&gt;{i.addEventListener(&quot;animationstart&quot;,a,HM),i.classList.add(&quot;cdk-text-field-autofill-monitored&quot;)}),this._monitoredElements.set(i,{subject:s,unlisten:()=&gt;{i.removeEventListener(&quot;animationstart&quot;,a,HM)}}),s}stopMonitoring(e){const i=hr(e),r=this._monitoredElements.get(i);r&amp;&amp;(r.unlisten(),r.subject.complete(),i.classList.remove(&quot;cdk-text-field-autofill-monitored&quot;),i.classList.remove(&quot;cdk-text-field-autofilled&quot;),this._monitoredElements.delete(i))}ngOnDestroy(){this._monitoredElements.forEach((e,i)=&gt;this.stopMonitoring(i))}}return n.\u0275fac=function(e){return new(e||n)(D(Ke),D(Y))},n.\u0275prov=P({factory:function(){return new n(D(Ke),D(Y))},token:n,providedIn:&quot;root&quot;}),n})(),$M=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[Wl]]}),n})();const GM=new j(&quot;MAT_INPUT_VALUE_ACCESSOR&quot;),L5=[&quot;button&quot;,&quot;checkbox&quot;,&quot;file&quot;,&quot;hidden&quot;,&quot;image&quot;,&quot;radio&quot;,&quot;range&quot;,&quot;reset&quot;,&quot;submit&quot;];let j5=0;const B5=SM(class{constructor(n,t,e,i){this._defaultErrorStateMatcher=n,this._parentForm=t,this._parentFormGroup=e,this.ngControl=i}});let U_=(()=&gt;{class n extends B5{constructor(e,i,r,s,o,a,l,c,u,f){super(a,s,o,r),this._elementRef=e,this._platform=i,this._autofillMonitor=c,this._formField=f,this._uid=&quot;mat-input-&quot;+j5++,this.focused=!1,this.stateChanges=new ie,this.controlType=&quot;mat-input&quot;,this.autofilled=!1,this._disabled=!1,this._required=!1,this._type=&quot;text&quot;,this._readonly=!1,this._neverEmptyInputTypes=[&quot;date&quot;,&quot;datetime&quot;,&quot;datetime-local&quot;,&quot;month&quot;,&quot;time&quot;,&quot;week&quot;].filter(m=&gt;e1().has(m));const p=this._elementRef.nativeElement,g=p.nodeName.toLowerCase();this._inputValueAccessor=l||p,this._previousNativeValue=this.value,this.id=this.id,i.IOS&amp;&amp;u.runOutsideAngular(()=&gt;{e.nativeElement.addEventListener(&quot;keyup&quot;,m=&gt;{const C=m.target;!C.value&amp;&amp;0===C.selectionStart&amp;&amp;0===C.selectionEnd&amp;&amp;(C.setSelectionRange(1,1),C.setSelectionRange(0,0))})}),this._isServer=!this._platform.isBrowser,this._isNativeSelect=&quot;select&quot;===g,this._isTextarea=&quot;textarea&quot;===g,this._isInFormField=!!f,this._isNativeSelect&amp;&amp;(this.controlType=p.multiple?&quot;mat-native-select-multiple&quot;:&quot;mat-native-select&quot;)}get disabled(){return this.ngControl&amp;&amp;null!==this.ngControl.disabled?this.ngControl.disabled:this._disabled}set disabled(e){this._disabled=Ye(e),this.focused&amp;&amp;(this.focused=!1,this.stateChanges.next())}get id(){return this._id}set id(e){this._id=e||this._uid}get required(){return this._required}set required(e){this._required=Ye(e)}get type(){return this._type}set type(e){this._type=e||&quot;text&quot;,this._validateType(),!this._isTextarea&amp;&amp;e1().has(this._type)&amp;&amp;(this._elementRef.nativeElement.type=this._type)}get value(){return this._inputValueAccessor.value}set value(e){e!==this.value&amp;&amp;(this._inputValueAccessor.value=e,this.stateChanges.next())}get readonly(){return this._readonly}set readonly(e){this._readonly=Ye(e)}ngAfterViewInit(){this._platform.isBrowser&amp;&amp;this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(e=&gt;{this.autofilled=e.isAutofilled,this.stateChanges.next()})}ngOnChanges(){this.stateChanges.next()}ngOnDestroy(){this.stateChanges.complete(),this._platform.isBrowser&amp;&amp;this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement)}ngDoCheck(){this.ngControl&amp;&amp;this.updateErrorState(),this._dirtyCheckNativeValue(),this._dirtyCheckPlaceholder()}focus(e){this._elementRef.nativeElement.focus(e)}_focusChanged(e){e!==this.focused&amp;&amp;(this.focused=e,this.stateChanges.next())}_onInput(){}_dirtyCheckPlaceholder(){var e,i;const r=(null===(i=null===(e=this._formField)||void 0===e?void 0:e._hideControlPlaceholder)||void 0===i?void 0:i.call(e))?null:this.placeholder;if(r!==this._previousPlaceholder){const s=this._elementRef.nativeElement;this._previousPlaceholder=r,r?s.setAttribute(&quot;placeholder&quot;,r):s.removeAttribute(&quot;placeholder&quot;)}}_dirtyCheckNativeValue(){const e=this._elementRef.nativeElement.value;this._previousNativeValue!==e&amp;&amp;(this._previousNativeValue=e,this.stateChanges.next())}_validateType(){L5.indexOf(this._type)}_isNeverEmpty(){return this._neverEmptyInputTypes.indexOf(this._type)&gt;-1}_isBadInput(){let e=this._elementRef.nativeElement.validity;return e&amp;&amp;e.badInput}get empty(){return!(this._isNeverEmpty()||this._elementRef.nativeElement.value||this._isBadInput()||this.autofilled)}get shouldLabelFloat(){if(this._isNativeSelect){const e=this._elementRef.nativeElement,i=e.options[0];return this.focused||e.multiple||!this.empty||!!(e.selectedIndex&gt;-1&amp;&amp;i&amp;&amp;i.label)}return this.focused||!this.empty}setDescribedByIds(e){e.length?this._elementRef.nativeElement.setAttribute(&quot;aria-describedby&quot;,e.join(&quot; &quot;)):this._elementRef.nativeElement.removeAttribute(&quot;aria-describedby&quot;)}onContainerClick(){this.focused||this.focus()}_isInlineSelect(){const e=this._elementRef.nativeElement;return this._isNativeSelect&amp;&amp;(e.multiple||e.size&gt;1)}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(Ke),_(Ni,10),_(gi,8),_(Br,8),_(ec),_(GM,10),_(zM),_(Y),_(uh,8))},n.\u0275dir=O({type:n,selectors:[[&quot;input&quot;,&quot;matInput&quot;,&quot;&quot;],[&quot;textarea&quot;,&quot;matInput&quot;,&quot;&quot;],[&quot;select&quot;,&quot;matNativeControl&quot;,&quot;&quot;],[&quot;input&quot;,&quot;matNativeControl&quot;,&quot;&quot;],[&quot;textarea&quot;,&quot;matNativeControl&quot;,&quot;&quot;]],hostAttrs:[1,&quot;mat-input-element&quot;,&quot;mat-form-field-autofill-control&quot;],hostVars:11,hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;focus&quot;,function(){return i._focusChanged(!0)})(&quot;blur&quot;,function(){return i._focusChanged(!1)})(&quot;input&quot;,function(){return i._onInput()}),2&amp;e&amp;&amp;(Ar(&quot;disabled&quot;,i.disabled)(&quot;required&quot;,i.required),Ce(&quot;id&quot;,i.id)(&quot;data-placeholder&quot;,i.placeholder)(&quot;readonly&quot;,i.readonly&amp;&amp;!i._isNativeSelect||null)(&quot;aria-invalid&quot;,i.empty&amp;&amp;i.required?null:i.errorState)(&quot;aria-required&quot;,i.required),Me(&quot;mat-input-server&quot;,i._isServer)(&quot;mat-native-select-inline&quot;,i._isInlineSelect()))},inputs:{id:&quot;id&quot;,disabled:&quot;disabled&quot;,required:&quot;required&quot;,type:&quot;type&quot;,value:&quot;value&quot;,readonly:&quot;readonly&quot;,placeholder:&quot;placeholder&quot;,errorStateMatcher:&quot;errorStateMatcher&quot;,userAriaDescribedBy:[&quot;aria-describedby&quot;,&quot;userAriaDescribedBy&quot;]},exportAs:[&quot;matInput&quot;],features:[ce([{provide:ch,useExisting:n}]),se,je]}),n})(),U5=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[ec],imports:[[$M,UM,qn],$M,UM]}),n})();new class extends _i{flush(t){this.active=!0,this.scheduled=void 0;const{actions:e}=this;let i,r=-1,s=e.length;t=t||e.shift();do{if(i=t.execute(t.state,t.delay))break}while(++r&lt;s&amp;&amp;(t=e.shift()));if(this.active=!1,i){for(;++r&lt;s&amp;&amp;(t=e.shift());)t.unsubscribe();throw i}}}(class extends Vd{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,i=0){return null!==i&amp;&amp;i&gt;0?super.requestAsyncId(t,e,i):(t.actions.push(this),t.scheduled||(t.scheduled=requestAnimationFrame(()=&gt;t.flush(null))))}recycleAsyncId(t,e,i=0){if(null!==i&amp;&amp;i&gt;0||null===i&amp;&amp;this.delay&gt;0)return super.recycleAsyncId(t,e,i);0===t.actions.length&amp;&amp;(cancelAnimationFrame(e),t.scheduled=void 0)}});let G5=1;const W5=Promise.resolve(),hh={};function WM(n){return n in hh&amp;&amp;(delete hh[n],!0)}const qM={setImmediate(n){const t=G5++;return hh[t]=!0,W5.then(()=&gt;WM(t)&amp;&amp;n()),t},clearImmediate(n){WM(n)}};new class extends _i{flush(t){this.active=!0,this.scheduled=void 0;const{actions:e}=this;let i,r=-1,s=e.length;t=t||e.shift();do{if(i=t.execute(t.state,t.delay))break}while(++r&lt;s&amp;&amp;(t=e.shift()));if(this.active=!1,i){for(;++r&lt;s&amp;&amp;(t=e.shift());)t.unsubscribe();throw i}}}(class extends Vd{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}requestAsyncId(t,e,i=0){return null!==i&amp;&amp;i&gt;0?super.requestAsyncId(t,e,i):(t.actions.push(this),t.scheduled||(t.scheduled=qM.setImmediate(t.flush.bind(t,null))))}recycleAsyncId(t,e,i=0){if(null!==i&amp;&amp;i&gt;0||null===i&amp;&amp;this.delay&gt;0)return super.recycleAsyncId(t,e,i);0===t.actions.length&amp;&amp;(qM.clearImmediate(e),t.scheduled=void 0)}});new class extends _i{}(class extends Vd{constructor(t,e){super(t,e),this.scheduler=t,this.work=e}schedule(t,e=0){return e&gt;0?super.schedule(t,e):(this.delay=e,this.state=t,this.scheduler.flush(this),this)}execute(t,e){return e&gt;0||this.closed?super.execute(t,e):this._execute(t,e)}requestAsyncId(t,e,i=0){return null!==i&amp;&amp;i&gt;0||null===i&amp;&amp;this.delay&gt;0?super.requestAsyncId(t,e,i):t.flush(this)}});class un{constructor(t,e,i){this.kind=t,this.value=e,this.error=i,this.hasValue=&quot;N&quot;===t}observe(t){switch(this.kind){case&quot;N&quot;:return t.next&amp;&amp;t.next(this.value);case&quot;E&quot;:return t.error&amp;&amp;t.error(this.error);case&quot;C&quot;:return t.complete&amp;&amp;t.complete()}}do(t,e,i){switch(this.kind){case&quot;N&quot;:return t&amp;&amp;t(this.value);case&quot;E&quot;:return e&amp;&amp;e(this.error);case&quot;C&quot;:return i&amp;&amp;i()}}accept(t,e,i){return t&amp;&amp;&quot;function&quot;==typeof t.next?this.observe(t):this.do(t,e,i)}toObservable(){switch(this.kind){case&quot;N&quot;:return G(this.value);case&quot;E&quot;:return zr(this.error);case&quot;C&quot;:return yd()}throw new Error(&quot;unexpected notification kind value&quot;)}static createNext(t){return void 0!==t?new un(&quot;N&quot;,t):un.undefinedValueNotification}static createError(t){return new un(&quot;E&quot;,void 0,t)}static createComplete(){return un.completeNotification}}un.completeNotification=new un(&quot;C&quot;),un.undefinedValueNotification=new un(&quot;N&quot;,void 0);let ph=(()=&gt;{class n{constructor(e,i,r){this._ngZone=e,this._platform=i,this._scrolled=new ie,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=r}register(e){this.scrollContainers.has(e)||this.scrollContainers.set(e,e.elementScrolled().subscribe(()=&gt;this._scrolled.next(e)))}deregister(e){const i=this.scrollContainers.get(e);i&amp;&amp;(i.unsubscribe(),this.scrollContainers.delete(e))}scrolled(e=20){return this._platform.isBrowser?new ye(i=&gt;{this._globalSubscription||this._addGlobalListener();const r=e&gt;0?this._scrolled.pipe(dh(e)).subscribe(i):this._scrolled.subscribe(i);return this._scrolledCount++,()=&gt;{r.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):G()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((e,i)=&gt;this.deregister(i)),this._scrolled.complete()}ancestorScrolled(e,i){const r=this.getAncestorScrollContainers(e);return this.scrolled(i).pipe(cn(s=&gt;!s||r.indexOf(s)&gt;-1))}getAncestorScrollContainers(e){const i=[];return this.scrollContainers.forEach((r,s)=&gt;{this._scrollableContainsElement(s,e)&amp;&amp;i.push(s)}),i}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(e,i){let r=hr(i),s=e.getElementRef().nativeElement;do{if(r==s)return!0}while(r=r.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=&gt;gr(this._getWindow().document,&quot;scroll&quot;).subscribe(()=&gt;this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&amp;&amp;(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return n.\u0275fac=function(e){return new(e||n)(D(Y),D(Ke),D(W,8))},n.\u0275prov=P({factory:function(){return new n(D(Y),D(Ke),D(W,8))},token:n,providedIn:&quot;root&quot;}),n})(),ic=(()=&gt;{class n{constructor(e,i,r){this._platform=e,this._change=new ie,this._changeListener=s=&gt;{this._change.next(s)},this._document=r,i.runOutsideAngular(()=&gt;{if(e.isBrowser){const s=this._getWindow();s.addEventListener(&quot;resize&quot;,this._changeListener),s.addEventListener(&quot;orientationchange&quot;,this._changeListener)}this.change().subscribe(()=&gt;this._viewportSize=null)})}ngOnDestroy(){if(this._platform.isBrowser){const e=this._getWindow();e.removeEventListener(&quot;resize&quot;,this._changeListener),e.removeEventListener(&quot;orientationchange&quot;,this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const e={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),e}getViewportRect(){const e=this.getViewportScrollPosition(),{width:i,height:r}=this.getViewportSize();return{top:e.top,left:e.left,bottom:e.top+r,right:e.left+i,height:r,width:i}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const e=this._document,i=this._getWindow(),r=e.documentElement,s=r.getBoundingClientRect();return{top:-s.top||e.body.scrollTop||i.scrollY||r.scrollTop||0,left:-s.left||e.body.scrollLeft||i.scrollX||r.scrollLeft||0}}change(e=20){return e&gt;0?this._change.pipe(dh(e)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const e=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:e.innerWidth,height:e.innerHeight}:{width:0,height:0}}}return n.\u0275fac=function(e){return new(e||n)(D(Ke),D(Y),D(W,8))},n.\u0275prov=P({factory:function(){return new n(D(Ke),D(Y),D(W,8))},token:n,providedIn:&quot;root&quot;}),n})(),H_=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({}),n})(),XM=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[Kl,Wl,H_],Kl,H_]}),n})();class z_{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&amp;&amp;(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class $_ extends z_{constructor(t,e,i,r){super(),this.component=t,this.viewContainerRef=e,this.injector=i,this.componentFactoryResolver=r}}class gh extends z_{constructor(t,e,i){super(),this.templateRef=t,this.viewContainerRef=e,this.context=i}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class C6 extends z_{constructor(t){super(),this.element=t instanceof X?t.nativeElement:t}}class eA{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof $_?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof gh?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&amp;&amp;t instanceof C6?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&amp;&amp;(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&amp;&amp;this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&amp;&amp;(this._disposeFn(),this._disposeFn=null)}}class D6 extends eA{constructor(t,e,i,r,s){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=i,this._defaultInjector=r,this.attachDomPortal=o=&gt;{const a=o.element,l=this._document.createComment(&quot;dom-portal&quot;);a.parentNode.insertBefore(l,a),this.outletElement.appendChild(a),this._attachedPortal=o,super.setDisposeFn(()=&gt;{l.parentNode&amp;&amp;l.parentNode.replaceChild(a,l)})},this._document=s}attachComponentPortal(t){const i=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let r;return t.viewContainerRef?(r=t.viewContainerRef.createComponent(i,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=&gt;r.destroy())):(r=i.create(t.injector||this._defaultInjector),this._appRef.attachView(r.hostView),this.setDisposeFn(()=&gt;{this._appRef.detachView(r.hostView),r.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(r)),this._attachedPortal=t,r}attachTemplatePortal(t){let e=t.viewContainerRef,i=e.createEmbeddedView(t.templateRef,t.context);return i.rootNodes.forEach(r=&gt;this.outletElement.appendChild(r)),i.detectChanges(),this.setDisposeFn(()=&gt;{let r=e.indexOf(i);-1!==r&amp;&amp;e.remove(r)}),this._attachedPortal=t,i}dispose(){super.dispose(),null!=this.outletElement.parentNode&amp;&amp;this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let mh=(()=&gt;{class n extends eA{constructor(e,i,r){super(),this._componentFactoryResolver=e,this._viewContainerRef=i,this._isInitialized=!1,this.attached=new U,this.attachDomPortal=s=&gt;{const o=s.element,a=this._document.createComment(&quot;dom-portal&quot;);s.setAttachedHost(this),o.parentNode.insertBefore(a,o),this._getRootNode().appendChild(o),this._attachedPortal=s,super.setDisposeFn(()=&gt;{a.parentNode&amp;&amp;a.parentNode.replaceChild(o,a)})},this._document=r}get portal(){return this._attachedPortal}set portal(e){this.hasAttached()&amp;&amp;!e&amp;&amp;!this._isInitialized||(this.hasAttached()&amp;&amp;super.detach(),e&amp;&amp;super.attach(e),this._attachedPortal=e)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(e){e.setAttachedHost(this);const i=null!=e.viewContainerRef?e.viewContainerRef:this._viewContainerRef,s=(e.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(e.component),o=i.createComponent(s,i.length,e.injector||i.injector);return i!==this._viewContainerRef&amp;&amp;this._getRootNode().appendChild(o.hostView.rootNodes[0]),super.setDisposeFn(()=&gt;o.destroy()),this._attachedPortal=e,this._attachedRef=o,this.attached.emit(o),o}attachTemplatePortal(e){e.setAttachedHost(this);const i=this._viewContainerRef.createEmbeddedView(e.templateRef,e.context);return super.setDisposeFn(()=&gt;this._viewContainerRef.clear()),this._attachedPortal=e,this._attachedRef=i,this.attached.emit(i),i}_getRootNode(){const e=this._viewContainerRef.element.nativeElement;return e.nodeType===e.ELEMENT_NODE?e:e.parentNode}}return n.\u0275fac=function(e){return new(e||n)(_(tr),_(Rt),_(W))},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;cdkPortalOutlet&quot;,&quot;&quot;]],inputs:{portal:[&quot;cdkPortalOutlet&quot;,&quot;portal&quot;]},outputs:{attached:&quot;attached&quot;},exportAs:[&quot;cdkPortalOutlet&quot;],features:[se]}),n})(),nA=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({}),n})();const iA=t1();class k6{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:&quot;&quot;,left:&quot;&quot;},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||&quot;&quot;,this._previousHTMLStyles.top=t.style.top||&quot;&quot;,t.style.left=mt(-this._previousScrollPosition.left),t.style.top=mt(-this._previousScrollPosition.top),t.classList.add(&quot;cdk-global-scrollblock&quot;),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,i=t.style,r=this._document.body.style,s=i.scrollBehavior||&quot;&quot;,o=r.scrollBehavior||&quot;&quot;;this._isEnabled=!1,i.left=this._previousHTMLStyles.left,i.top=this._previousHTMLStyles.top,t.classList.remove(&quot;cdk-global-scrollblock&quot;),iA&amp;&amp;(i.scrollBehavior=r.scrollBehavior=&quot;auto&quot;),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),iA&amp;&amp;(i.scrollBehavior=s,r.scrollBehavior=o)}}_canBeEnabled(){if(this._document.documentElement.classList.contains(&quot;cdk-global-scrollblock&quot;)||this._isEnabled)return!1;const e=this._document.body,i=this._viewportRuler.getViewportSize();return e.scrollHeight&gt;i.height||e.scrollWidth&gt;i.width}}class M6{constructor(t,e,i,r){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=i,this._config=r,this._scrollSubscription=null,this._detach=()=&gt;{this.disable(),this._overlayRef.hasAttached()&amp;&amp;this._ngZone.run(()=&gt;this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&amp;&amp;this._config.threshold&amp;&amp;this._config.threshold&gt;1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=&gt;{const e=this._viewportRuler.getViewportScrollPosition().top;Math.abs(e-this._initialScrollPosition)&gt;this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&amp;&amp;(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class rA{enable(){}disable(){}attach(){}}function G_(n,t){return t.some(e=&gt;n.bottom&lt;e.top||n.top&gt;e.bottom||n.right&lt;e.left||n.left&gt;e.right)}function sA(n,t){return t.some(e=&gt;n.top&lt;e.top||n.bottom&gt;e.bottom||n.left&lt;e.left||n.right&gt;e.right)}class A6{constructor(t,e,i,r){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=i,this._config=r,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=&gt;{if(this._overlayRef.updatePosition(),this._config&amp;&amp;this._config.autoClose){const e=this._overlayRef.overlayElement.getBoundingClientRect(),{width:i,height:r}=this._viewportRuler.getViewportSize();G_(e,[{width:i,height:r,bottom:r,right:i,top:0,left:0}])&amp;&amp;(this.disable(),this._ngZone.run(()=&gt;this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&amp;&amp;(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let T6=(()=&gt;{class n{constructor(e,i,r,s){this._scrollDispatcher=e,this._viewportRuler=i,this._ngZone=r,this.noop=()=&gt;new rA,this.close=o=&gt;new M6(this._scrollDispatcher,this._ngZone,this._viewportRuler,o),this.block=()=&gt;new k6(this._viewportRuler,this._document),this.reposition=o=&gt;new A6(this._scrollDispatcher,this._viewportRuler,this._ngZone,o),this._document=s}}return n.\u0275fac=function(e){return new(e||n)(D(ph),D(ic),D(Y),D(W))},n.\u0275prov=P({factory:function(){return new n(D(ph),D(ic),D(Y),D(W))},token:n,providedIn:&quot;root&quot;}),n})();class W_{constructor(t){if(this.scrollStrategy=new rA,this.panelClass=&quot;&quot;,this.hasBackdrop=!1,this.backdropClass=&quot;cdk-overlay-dark-backdrop&quot;,this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const i of e)void 0!==t[i]&amp;&amp;(this[i]=t[i])}}}class I6{constructor(t,e,i,r,s){this.offsetX=i,this.offsetY=r,this.panelClass=s,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class x6{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let oA=(()=&gt;{class n{constructor(e){this._attachedOverlays=[],this._document=e}ngOnDestroy(){this.detach()}add(e){this.remove(e),this._attachedOverlays.push(e)}remove(e){const i=this._attachedOverlays.indexOf(e);i&gt;-1&amp;&amp;this._attachedOverlays.splice(i,1),0===this._attachedOverlays.length&amp;&amp;this.detach()}}return n.\u0275fac=function(e){return new(e||n)(D(W))},n.\u0275prov=P({factory:function(){return new n(D(W))},token:n,providedIn:&quot;root&quot;}),n})(),R6=(()=&gt;{class n extends oA{constructor(e){super(e),this._keydownListener=i=&gt;{const r=this._attachedOverlays;for(let s=r.length-1;s&gt;-1;s--)if(r[s]._keydownEvents.observers.length&gt;0){r[s]._keydownEvents.next(i);break}}}add(e){super.add(e),this._isAttached||(this._document.body.addEventListener(&quot;keydown&quot;,this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&amp;&amp;(this._document.body.removeEventListener(&quot;keydown&quot;,this._keydownListener),this._isAttached=!1)}}return n.\u0275fac=function(e){return new(e||n)(D(W))},n.\u0275prov=P({factory:function(){return new n(D(W))},token:n,providedIn:&quot;root&quot;}),n})(),P6=(()=&gt;{class n extends oA{constructor(e,i){super(e),this._platform=i,this._cursorStyleIsSet=!1,this._pointerDownListener=r=&gt;{this._pointerDownEventTarget=xs(r)},this._clickListener=r=&gt;{const s=xs(r),o=&quot;click&quot;===r.type&amp;&amp;this._pointerDownEventTarget?this._pointerDownEventTarget:s;this._pointerDownEventTarget=null;const a=this._attachedOverlays.slice();for(let l=a.length-1;l&gt;-1;l--){const c=a[l];if(!(c._outsidePointerEvents.observers.length&lt;1)&amp;&amp;c.hasAttached()){if(c.overlayElement.contains(s)||c.overlayElement.contains(o))break;c._outsidePointerEvents.next(r)}}}}add(e){if(super.add(e),!this._isAttached){const i=this._document.body;i.addEventListener(&quot;pointerdown&quot;,this._pointerDownListener,!0),i.addEventListener(&quot;click&quot;,this._clickListener,!0),i.addEventListener(&quot;auxclick&quot;,this._clickListener,!0),i.addEventListener(&quot;contextmenu&quot;,this._clickListener,!0),this._platform.IOS&amp;&amp;!this._cursorStyleIsSet&amp;&amp;(this._cursorOriginalValue=i.style.cursor,i.style.cursor=&quot;pointer&quot;,this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const e=this._document.body;e.removeEventListener(&quot;pointerdown&quot;,this._pointerDownListener,!0),e.removeEventListener(&quot;click&quot;,this._clickListener,!0),e.removeEventListener(&quot;auxclick&quot;,this._clickListener,!0),e.removeEventListener(&quot;contextmenu&quot;,this._clickListener,!0),this._platform.IOS&amp;&amp;this._cursorStyleIsSet&amp;&amp;(e.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}}return n.\u0275fac=function(e){return new(e||n)(D(W),D(Ke))},n.\u0275prov=P({factory:function(){return new n(D(W),D(Ke))},token:n,providedIn:&quot;root&quot;}),n})(),q_=(()=&gt;{class n{constructor(e,i){this._platform=i,this._document=e}ngOnDestroy(){const e=this._containerElement;e&amp;&amp;e.parentNode&amp;&amp;e.parentNode.removeChild(e)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const e=&quot;cdk-overlay-container&quot;;if(this._platform.isBrowser||e_()){const r=this._document.querySelectorAll(`.${e}[platform=&quot;server&quot;], .${e}[platform=&quot;test&quot;]`);for(let s=0;s&lt;r.length;s++)r[s].parentNode.removeChild(r[s])}const i=this._document.createElement(&quot;div&quot;);i.classList.add(e),e_()?i.setAttribute(&quot;platform&quot;,&quot;test&quot;):this._platform.isBrowser||i.setAttribute(&quot;platform&quot;,&quot;server&quot;),this._document.body.appendChild(i),this._containerElement=i}}return n.\u0275fac=function(e){return new(e||n)(D(W),D(Ke))},n.\u0275prov=P({factory:function(){return new n(D(W),D(Ke))},token:n,providedIn:&quot;root&quot;}),n})();class O6{constructor(t,e,i,r,s,o,a,l,c){this._portalOutlet=t,this._host=e,this._pane=i,this._config=r,this._ngZone=s,this._keyboardDispatcher=o,this._document=a,this._location=l,this._outsideClickDispatcher=c,this._backdropElement=null,this._backdropClick=new ie,this._attachments=new ie,this._detachments=new ie,this._locationChanges=ue.EMPTY,this._backdropClickHandler=u=&gt;this._backdropClick.next(u),this._keydownEvents=new ie,this._outsidePointerEvents=new ie,r.scrollStrategy&amp;&amp;(this._scrollStrategy=r.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=r.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&amp;&amp;this._previousHostParent&amp;&amp;this._previousHostParent.appendChild(this._host),this._positionStrategy&amp;&amp;this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&amp;&amp;this._scrollStrategy.enable(),this._ngZone.onStable.pipe(rn(1)).subscribe(()=&gt;{this.hasAttached()&amp;&amp;this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&amp;&amp;this._attachBackdrop(),this._config.panelClass&amp;&amp;this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&amp;&amp;(this._locationChanges=this._location.subscribe(()=&gt;this.dispose())),this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&amp;&amp;this._positionStrategy.detach&amp;&amp;this._positionStrategy.detach(),this._scrollStrategy&amp;&amp;this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&amp;&amp;this._positionStrategy.dispose(),this._disposeScrollStrategy(),this._disposeBackdrop(this._backdropElement),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host&amp;&amp;this._host.parentNode&amp;&amp;(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&amp;&amp;this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&amp;&amp;this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&amp;&amp;(this._positionStrategy&amp;&amp;this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&amp;&amp;(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&amp;&amp;this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&amp;&amp;this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?&quot;string&quot;==typeof t?t:t.value:&quot;ltr&quot;}updateScrollStrategy(t){t!==this._scrollStrategy&amp;&amp;(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&amp;&amp;(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute(&quot;dir&quot;,this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=mt(this._config.width),t.height=mt(this._config.height),t.minWidth=mt(this._config.minWidth),t.minHeight=mt(this._config.minHeight),t.maxWidth=mt(this._config.maxWidth),t.maxHeight=mt(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?&quot;&quot;:&quot;none&quot;}_attachBackdrop(){const t=&quot;cdk-overlay-backdrop-showing&quot;;this._backdropElement=this._document.createElement(&quot;div&quot;),this._backdropElement.classList.add(&quot;cdk-overlay-backdrop&quot;),this._config.backdropClass&amp;&amp;this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener(&quot;click&quot;,this._backdropClickHandler),&quot;undefined&quot;!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=&gt;{requestAnimationFrame(()=&gt;{this._backdropElement&amp;&amp;this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&amp;&amp;this._host.parentNode.appendChild(this._host)}detachBackdrop(){const t=this._backdropElement;if(!t)return;let e;const i=()=&gt;{t&amp;&amp;(t.removeEventListener(&quot;click&quot;,this._backdropClickHandler),t.removeEventListener(&quot;transitionend&quot;,i),this._disposeBackdrop(t)),this._config.backdropClass&amp;&amp;this._toggleClasses(t,this._config.backdropClass,!1),clearTimeout(e)};t.classList.remove(&quot;cdk-overlay-backdrop-showing&quot;),this._ngZone.runOutsideAngular(()=&gt;{t.addEventListener(&quot;transitionend&quot;,i)}),t.style.pointerEvents=&quot;none&quot;,e=this._ngZone.runOutsideAngular(()=&gt;setTimeout(i,500))}_toggleClasses(t,e,i){const r=t.classList;Yk(e).forEach(s=&gt;{s&amp;&amp;(i?r.add(s):r.remove(s))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=&gt;{const t=this._ngZone.onStable.pipe(fr(Ci(this._attachments,this._detachments))).subscribe(()=&gt;{(!this._pane||!this._host||0===this._pane.children.length)&amp;&amp;(this._pane&amp;&amp;this._config.panelClass&amp;&amp;this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&amp;&amp;this._host.parentElement&amp;&amp;(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&amp;&amp;(t.disable(),t.detach&amp;&amp;t.detach())}_disposeBackdrop(t){t&amp;&amp;(t.parentNode&amp;&amp;t.parentNode.removeChild(t),this._backdropElement===t&amp;&amp;(this._backdropElement=null))}}const aA=&quot;cdk-overlay-connected-position-bounding-box&quot;,F6=/([A-Za-z%]+)$/;class Y_{constructor(t,e,i,r,s){this._viewportRuler=e,this._document=i,this._platform=r,this._overlayContainer=s,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new ie,this._resizeSubscription=ue.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(aA),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=&gt;{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&amp;&amp;this._positionLocked&amp;&amp;this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,i=this._viewportRect,r=[];let s;for(let o of this._preferredPositions){let a=this._getOriginPoint(t,o),l=this._getOverlayPoint(a,e,o),c=this._getOverlayFit(l,e,i,o);if(c.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(o,a);this._canFitWithFlexibleDimensions(c,l,i)?r.push({position:o,origin:a,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(a,o)}):(!s||s.overlayFit.visibleArea&lt;c.visibleArea)&amp;&amp;(s={overlayFit:c,overlayPoint:l,originPoint:a,position:o,overlayRect:e})}if(r.length){let o=null,a=-1;for(const l of r){const c=l.boundingBoxRect.width*l.boundingBoxRect.height*(l.position.weight||1);c&gt;a&amp;&amp;(a=c,o=l)}return this._isPushed=!1,void this._applyPosition(o.position,o.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(s.position,s.originPoint);this._applyPosition(s.position,s.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&amp;&amp;Ls(this._boundingBox.style,{top:&quot;&quot;,left:&quot;&quot;,right:&quot;&quot;,bottom:&quot;&quot;,height:&quot;&quot;,width:&quot;&quot;,alignItems:&quot;&quot;,justifyContent:&quot;&quot;}),this._pane&amp;&amp;this._resetOverlayElementStyles(),this._overlayRef&amp;&amp;this._overlayRef.hostElement.classList.remove(aA),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&amp;&amp;(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&amp;&amp;(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let i,r;if(&quot;center&quot;==e.originX)i=t.left+t.width/2;else{const s=this._isRtl()?t.right:t.left,o=this._isRtl()?t.left:t.right;i=&quot;start&quot;==e.originX?s:o}return r=&quot;center&quot;==e.originY?t.top+t.height/2:&quot;top&quot;==e.originY?t.top:t.bottom,{x:i,y:r}}_getOverlayPoint(t,e,i){let r,s;return r=&quot;center&quot;==i.overlayX?-e.width/2:&quot;start&quot;===i.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,s=&quot;center&quot;==i.overlayY?-e.height/2:&quot;top&quot;==i.overlayY?0:-e.height,{x:t.x+r,y:t.y+s}}_getOverlayFit(t,e,i,r){const s=cA(e);let{x:o,y:a}=t,l=this._getOffset(r,&quot;x&quot;),c=this._getOffset(r,&quot;y&quot;);l&amp;&amp;(o+=l),c&amp;&amp;(a+=c);let p=0-a,g=a+s.height-i.height,m=this._subtractOverflows(s.width,0-o,o+s.width-i.width),C=this._subtractOverflows(s.height,p,g),v=m*C;return{visibleArea:v,isCompletelyWithinViewport:s.width*s.height===v,fitsInViewportVertically:C===s.height,fitsInViewportHorizontally:m==s.width}}_canFitWithFlexibleDimensions(t,e,i){if(this._hasFlexibleDimensions){const r=i.bottom-e.y,s=i.right-e.x,o=lA(this._overlayRef.getConfig().minHeight),a=lA(this._overlayRef.getConfig().minWidth),c=t.fitsInViewportHorizontally||null!=a&amp;&amp;a&lt;=s;return(t.fitsInViewportVertically||null!=o&amp;&amp;o&lt;=r)&amp;&amp;c}return!1}_pushOverlayOnScreen(t,e,i){if(this._previousPushAmount&amp;&amp;this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const r=cA(e),s=this._viewportRect,o=Math.max(t.x+r.width-s.width,0),a=Math.max(t.y+r.height-s.height,0),l=Math.max(s.top-i.top-t.y,0),c=Math.max(s.left-i.left-t.x,0);let u=0,f=0;return u=r.width&lt;=s.width?c||-o:t.x&lt;this._viewportMargin?s.left-i.left-t.x:0,f=r.height&lt;=s.height?l||-a:t.y&lt;this._viewportMargin?s.top-i.top-t.y:0,this._previousPushAmount={x:u,y:f},{x:t.x+u,y:t.y+f}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&amp;&amp;this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const i=this._getScrollVisibility(),r=new x6(t,i);this._positionChanges.next(r)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let i,r=t.overlayY;i=&quot;center&quot;===t.overlayX?&quot;center&quot;:this._isRtl()?&quot;start&quot;===t.overlayX?&quot;right&quot;:&quot;left&quot;:&quot;start&quot;===t.overlayX?&quot;left&quot;:&quot;right&quot;;for(let s=0;s&lt;e.length;s++)e[s].style.transformOrigin=`${i} ${r}`}_calculateBoundingBoxRect(t,e){const i=this._viewportRect,r=this._isRtl();let s,o,a,u,f,p;if(&quot;top&quot;===e.overlayY)o=t.y,s=i.height-o+this._viewportMargin;else if(&quot;bottom&quot;===e.overlayY)a=i.height-t.y+2*this._viewportMargin,s=i.height-a+this._viewportMargin;else{const g=Math.min(i.bottom-t.y+i.top,t.y),m=this._lastBoundingBoxSize.height;s=2*g,o=t.y-g,s&gt;m&amp;&amp;!this._isInitialRender&amp;&amp;!this._growAfterOpen&amp;&amp;(o=t.y-m/2)}if(&quot;end&quot;===e.overlayX&amp;&amp;!r||&quot;start&quot;===e.overlayX&amp;&amp;r)p=i.width-t.x+this._viewportMargin,u=t.x-this._viewportMargin;else if(&quot;start&quot;===e.overlayX&amp;&amp;!r||&quot;end&quot;===e.overlayX&amp;&amp;r)f=t.x,u=i.right-t.x;else{const g=Math.min(i.right-t.x+i.left,t.x),m=this._lastBoundingBoxSize.width;u=2*g,f=t.x-g,u&gt;m&amp;&amp;!this._isInitialRender&amp;&amp;!this._growAfterOpen&amp;&amp;(f=t.x-m/2)}return{top:o,left:f,bottom:a,right:p,width:u,height:s}}_setBoundingBoxStyles(t,e){const i=this._calculateBoundingBoxRect(t,e);!this._isInitialRender&amp;&amp;!this._growAfterOpen&amp;&amp;(i.height=Math.min(i.height,this._lastBoundingBoxSize.height),i.width=Math.min(i.width,this._lastBoundingBoxSize.width));const r={};if(this._hasExactPosition())r.top=r.left=&quot;0&quot;,r.bottom=r.right=r.maxHeight=r.maxWidth=&quot;&quot;,r.width=r.height=&quot;100%&quot;;else{const s=this._overlayRef.getConfig().maxHeight,o=this._overlayRef.getConfig().maxWidth;r.height=mt(i.height),r.top=mt(i.top),r.bottom=mt(i.bottom),r.width=mt(i.width),r.left=mt(i.left),r.right=mt(i.right),r.alignItems=&quot;center&quot;===e.overlayX?&quot;center&quot;:&quot;end&quot;===e.overlayX?&quot;flex-end&quot;:&quot;flex-start&quot;,r.justifyContent=&quot;center&quot;===e.overlayY?&quot;center&quot;:&quot;bottom&quot;===e.overlayY?&quot;flex-end&quot;:&quot;flex-start&quot;,s&amp;&amp;(r.maxHeight=mt(s)),o&amp;&amp;(r.maxWidth=mt(o))}this._lastBoundingBoxSize=i,Ls(this._boundingBox.style,r)}_resetBoundingBoxStyles(){Ls(this._boundingBox.style,{top:&quot;0&quot;,left:&quot;0&quot;,right:&quot;0&quot;,bottom:&quot;0&quot;,height:&quot;&quot;,width:&quot;&quot;,alignItems:&quot;&quot;,justifyContent:&quot;&quot;})}_resetOverlayElementStyles(){Ls(this._pane.style,{top:&quot;&quot;,left:&quot;&quot;,bottom:&quot;&quot;,right:&quot;&quot;,position:&quot;&quot;,transform:&quot;&quot;})}_setOverlayElementStyles(t,e){const i={},r=this._hasExactPosition(),s=this._hasFlexibleDimensions,o=this._overlayRef.getConfig();if(r){const u=this._viewportRuler.getViewportScrollPosition();Ls(i,this._getExactOverlayY(e,t,u)),Ls(i,this._getExactOverlayX(e,t,u))}else i.position=&quot;static&quot;;let a=&quot;&quot;,l=this._getOffset(e,&quot;x&quot;),c=this._getOffset(e,&quot;y&quot;);l&amp;&amp;(a+=`translateX(${l}px) `),c&amp;&amp;(a+=`translateY(${c}px)`),i.transform=a.trim(),o.maxHeight&amp;&amp;(r?i.maxHeight=mt(o.maxHeight):s&amp;&amp;(i.maxHeight=&quot;&quot;)),o.maxWidth&amp;&amp;(r?i.maxWidth=mt(o.maxWidth):s&amp;&amp;(i.maxWidth=&quot;&quot;)),Ls(this._pane.style,i)}_getExactOverlayY(t,e,i){let r={top:&quot;&quot;,bottom:&quot;&quot;},s=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&amp;&amp;(s=this._pushOverlayOnScreen(s,this._overlayRect,i));let o=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return s.y-=o,&quot;bottom&quot;===t.overlayY?r.bottom=this._document.documentElement.clientHeight-(s.y+this._overlayRect.height)+&quot;px&quot;:r.top=mt(s.y),r}_getExactOverlayX(t,e,i){let o,r={left:&quot;&quot;,right:&quot;&quot;},s=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&amp;&amp;(s=this._pushOverlayOnScreen(s,this._overlayRect,i)),o=this._isRtl()?&quot;end&quot;===t.overlayX?&quot;left&quot;:&quot;right&quot;:&quot;end&quot;===t.overlayX?&quot;right&quot;:&quot;left&quot;,&quot;right&quot;===o?r.right=this._document.documentElement.clientWidth-(s.x+this._overlayRect.width)+&quot;px&quot;:r.left=mt(s.x),r}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),i=this._scrollables.map(r=&gt;r.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:sA(t,i),isOriginOutsideView:G_(t,i),isOverlayClipped:sA(e,i),isOverlayOutsideView:G_(e,i)}}_subtractOverflows(t,...e){return e.reduce((i,r)=&gt;i-Math.max(r,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,i=this._viewportRuler.getViewportScrollPosition();return{top:i.top+this._viewportMargin,left:i.left+this._viewportMargin,right:i.left+t-this._viewportMargin,bottom:i.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return&quot;rtl&quot;===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return&quot;x&quot;===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&amp;&amp;Yk(t).forEach(e=&gt;{&quot;&quot;!==e&amp;&amp;-1===this._appliedPanelClasses.indexOf(e)&amp;&amp;(this._appliedPanelClasses.push(e),this._pane.classList.add(e))})}_clearPanelClasses(){this._pane&amp;&amp;(this._appliedPanelClasses.forEach(t=&gt;{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof X)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,i=t.height||0;return{top:t.y,bottom:t.y+i,left:t.x,right:t.x+e,height:i,width:e}}}function Ls(n,t){for(let e in t)t.hasOwnProperty(e)&amp;&amp;(n[e]=t[e]);return n}function lA(n){if(&quot;number&quot;!=typeof n&amp;&amp;null!=n){const[t,e]=n.split(F6);return e&amp;&amp;&quot;px&quot;!==e?null:parseFloat(t)}return n||null}function cA(n){return{top:Math.floor(n.top),right:Math.floor(n.right),bottom:Math.floor(n.bottom),left:Math.floor(n.left),width:Math.floor(n.width),height:Math.floor(n.height)}}class N6{constructor(t,e,i,r,s,o,a){this._preferredPositions=[],this._positionStrategy=new Y_(i,r,s,o,a).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e),this.onPositionChange=this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&amp;&amp;(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,i,r){const s=new I6(t,e,i,r);return this._preferredPositions.push(s),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}const uA=&quot;cdk-global-overlay-wrapper&quot;;class V6{constructor(){this._cssPosition=&quot;static&quot;,this._topOffset=&quot;&quot;,this._bottomOffset=&quot;&quot;,this._leftOffset=&quot;&quot;,this._rightOffset=&quot;&quot;,this._alignItems=&quot;&quot;,this._justifyContent=&quot;&quot;,this._width=&quot;&quot;,this._height=&quot;&quot;}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&amp;&amp;!e.width&amp;&amp;t.updateSize({width:this._width}),this._height&amp;&amp;!e.height&amp;&amp;t.updateSize({height:this._height}),t.hostElement.classList.add(uA),this._isDisposed=!1}top(t=&quot;&quot;){return this._bottomOffset=&quot;&quot;,this._topOffset=t,this._alignItems=&quot;flex-start&quot;,this}left(t=&quot;&quot;){return this._rightOffset=&quot;&quot;,this._leftOffset=t,this._justifyContent=&quot;flex-start&quot;,this}bottom(t=&quot;&quot;){return this._topOffset=&quot;&quot;,this._bottomOffset=t,this._alignItems=&quot;flex-end&quot;,this}right(t=&quot;&quot;){return this._leftOffset=&quot;&quot;,this._rightOffset=t,this._justifyContent=&quot;flex-end&quot;,this}width(t=&quot;&quot;){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=&quot;&quot;){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=&quot;&quot;){return this.left(t),this._justifyContent=&quot;center&quot;,this}centerVertically(t=&quot;&quot;){return this.top(t),this._alignItems=&quot;center&quot;,this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,i=this._overlayRef.getConfig(),{width:r,height:s,maxWidth:o,maxHeight:a}=i,l=!(&quot;100%&quot;!==r&amp;&amp;&quot;100vw&quot;!==r||o&amp;&amp;&quot;100%&quot;!==o&amp;&amp;&quot;100vw&quot;!==o),c=!(&quot;100%&quot;!==s&amp;&amp;&quot;100vh&quot;!==s||a&amp;&amp;&quot;100%&quot;!==a&amp;&amp;&quot;100vh&quot;!==a);t.position=this._cssPosition,t.marginLeft=l?&quot;0&quot;:this._leftOffset,t.marginTop=c?&quot;0&quot;:this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,l?e.justifyContent=&quot;flex-start&quot;:&quot;center&quot;===this._justifyContent?e.justifyContent=&quot;center&quot;:&quot;rtl&quot;===this._overlayRef.getConfig().direction?&quot;flex-start&quot;===this._justifyContent?e.justifyContent=&quot;flex-end&quot;:&quot;flex-end&quot;===this._justifyContent&amp;&amp;(e.justifyContent=&quot;flex-start&quot;):e.justifyContent=this._justifyContent,e.alignItems=c?&quot;flex-start&quot;:this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,i=e.style;e.classList.remove(uA),i.justifyContent=i.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position=&quot;&quot;,this._overlayRef=null,this._isDisposed=!0}}let L6=(()=&gt;{class n{constructor(e,i,r,s){this._viewportRuler=e,this._document=i,this._platform=r,this._overlayContainer=s}global(){return new V6}connectedTo(e,i,r){return new N6(i,r,e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(e){return new Y_(e,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return n.\u0275fac=function(e){return new(e||n)(D(ic),D(W),D(Ke),D(q_))},n.\u0275prov=P({factory:function(){return new n(D(ic),D(W),D(Ke),D(q_))},token:n,providedIn:&quot;root&quot;}),n})(),j6=0,rc=(()=&gt;{class n{constructor(e,i,r,s,o,a,l,c,u,f,p){this.scrollStrategies=e,this._overlayContainer=i,this._componentFactoryResolver=r,this._positionBuilder=s,this._keyboardDispatcher=o,this._injector=a,this._ngZone=l,this._document=c,this._directionality=u,this._location=f,this._outsideClickDispatcher=p}create(e){const i=this._createHostElement(),r=this._createPaneElement(i),s=this._createPortalOutlet(r),o=new W_(e);return o.direction=o.direction||this._directionality.value,new O6(s,i,r,o,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(e){const i=this._document.createElement(&quot;div&quot;);return i.id=&quot;cdk-overlay-&quot;+j6++,i.classList.add(&quot;cdk-overlay-pane&quot;),e.appendChild(i),i}_createHostElement(){const e=this._document.createElement(&quot;div&quot;);return this._overlayContainer.getContainerElement().appendChild(e),e}_createPortalOutlet(e){return this._appRef||(this._appRef=this._injector.get(Pr)),new D6(e,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return n.\u0275fac=function(e){return new(e||n)(D(T6),D(q_),D(tr),D(L6),D(R6),D(ke),D(Y),D(W),D(Bi),D(vs),D(P6))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const H6={provide:new j(&quot;cdk-connected-overlay-scroll-strategy&quot;),deps:[rc],useFactory:function(n){return()=&gt;n.scrollStrategies.reposition()}};let z6=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[rc,H6],imports:[[Kl,nA,XM],XM]}),n})();const hA=[&quot;mat-button&quot;,&quot;&quot;],fA=[&quot;*&quot;],G6=[&quot;mat-button&quot;,&quot;mat-flat-button&quot;,&quot;mat-icon-button&quot;,&quot;mat-raised-button&quot;,&quot;mat-stroked-button&quot;,&quot;mat-mini-fab&quot;,&quot;mat-fab&quot;],W6=N_(EM(O8(class{constructor(n){this._elementRef=n}})));let _h=(()=&gt;{class n extends W6{constructor(e,i,r){super(e),this._focusMonitor=i,this._animationMode=r,this.isRoundButton=this._hasHostAttributes(&quot;mat-fab&quot;,&quot;mat-mini-fab&quot;),this.isIconButton=this._hasHostAttributes(&quot;mat-icon-button&quot;);for(const s of G6)this._hasHostAttributes(s)&amp;&amp;this._getHostElement().classList.add(s);e.nativeElement.classList.add(&quot;mat-button-base&quot;),this.isRoundButton&amp;&amp;(this.color=&quot;accent&quot;)}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(e,i){e?this._focusMonitor.focusVia(this._getHostElement(),e,i):this._getHostElement().focus(i)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...e){return e.some(i=&gt;this._getHostElement().hasAttribute(i))}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(t_),_(Ns,8))},n.\u0275cmp=ee({type:n,selectors:[[&quot;button&quot;,&quot;mat-button&quot;,&quot;&quot;],[&quot;button&quot;,&quot;mat-raised-button&quot;,&quot;&quot;],[&quot;button&quot;,&quot;mat-icon-button&quot;,&quot;&quot;],[&quot;button&quot;,&quot;mat-fab&quot;,&quot;&quot;],[&quot;button&quot;,&quot;mat-mini-fab&quot;,&quot;&quot;],[&quot;button&quot;,&quot;mat-stroked-button&quot;,&quot;&quot;],[&quot;button&quot;,&quot;mat-flat-button&quot;,&quot;&quot;]],viewQuery:function(e,i){if(1&amp;e&amp;&amp;Pt(lh,5),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i.ripple=r.first)}},hostAttrs:[1,&quot;mat-focus-indicator&quot;],hostVars:5,hostBindings:function(e,i){2&amp;e&amp;&amp;(Ce(&quot;disabled&quot;,i.disabled||null),Me(&quot;_mat-animation-noopable&quot;,&quot;NoopAnimations&quot;===i._animationMode)(&quot;mat-button-disabled&quot;,i.disabled))},inputs:{disabled:&quot;disabled&quot;,disableRipple:&quot;disableRipple&quot;,color:&quot;color&quot;},exportAs:[&quot;matButton&quot;],features:[se],attrs:hA,ngContentSelectors:fA,decls:4,vars:5,consts:[[1,&quot;mat-button-wrapper&quot;],[&quot;matRipple&quot;,&quot;&quot;,1,&quot;mat-button-ripple&quot;,3,&quot;matRippleDisabled&quot;,&quot;matRippleCentered&quot;,&quot;matRippleTrigger&quot;],[1,&quot;mat-button-focus-overlay&quot;]],template:function(e,i){1&amp;e&amp;&amp;(ri(),d(0,&quot;span&quot;,0),ht(1),h(),k(2,&quot;span&quot;,1),k(3,&quot;span&quot;,2)),2&amp;e&amp;&amp;(y(2),Me(&quot;mat-button-ripple-round&quot;,i.isRoundButton||i.isIconButton),w(&quot;matRippleDisabled&quot;,i._isRippleDisabled())(&quot;matRippleCentered&quot;,i.isIconButton)(&quot;matRippleTrigger&quot;,i._getHostElement()))},directives:[lh],styles:[&quot;.mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper&gt;*,.mat-flat-button .mat-button-wrapper&gt;*,.mat-stroked-button .mat-button-wrapper&gt;*,.mat-raised-button .mat-button-wrapper&gt;*,.mat-icon-button .mat-button-wrapper&gt;*,.mat-fab .mat-button-wrapper&gt;*,.mat-mini-fab .mat-button-wrapper&gt;*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n&quot;],encapsulation:2,changeDetection:0}),n})(),q6=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[IM,qn],qn]}),n})();const Y6=[&quot;mat-calendar-body&quot;,&quot;&quot;];function K6(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;tr&quot;,2),d(1,&quot;td&quot;,3),b(2),h(),h()),2&amp;n){const e=T();y(1),xo(&quot;padding-top&quot;,e._cellPadding)(&quot;padding-bottom&quot;,e._cellPadding),Ce(&quot;colspan&quot;,e.numCols),y(1),de(&quot; &quot;,e.label,&quot; &quot;)}}function Q6(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;td&quot;,3),b(1),h()),2&amp;n){const e=T(2);xo(&quot;padding-top&quot;,e._cellPadding)(&quot;padding-bottom&quot;,e._cellPadding),Ce(&quot;colspan&quot;,e._firstRowOffset),y(1),de(&quot; &quot;,e._firstRowOffset&gt;=e.labelMinRequiredCells?e.label:&quot;&quot;,&quot; &quot;)}}function Z6(n,t){if(1&amp;n){const e=Ue();d(0,&quot;td&quot;,7),M(&quot;click&quot;,function(r){const o=_e(e).$implicit;return T(2)._cellClicked(o,r)}),d(1,&quot;div&quot;,8),b(2),h(),k(3,&quot;div&quot;,9),h()}if(2&amp;n){const e=t.$implicit,i=t.index,r=T().index,s=T();xo(&quot;width&quot;,s._cellWidth)(&quot;padding-top&quot;,s._cellPadding)(&quot;padding-bottom&quot;,s._cellPadding),Me(&quot;mat-calendar-body-disabled&quot;,!e.enabled)(&quot;mat-calendar-body-active&quot;,s._isActiveCell(r,i))(&quot;mat-calendar-body-range-start&quot;,s._isRangeStart(e.compareValue))(&quot;mat-calendar-body-range-end&quot;,s._isRangeEnd(e.compareValue))(&quot;mat-calendar-body-in-range&quot;,s._isInRange(e.compareValue))(&quot;mat-calendar-body-comparison-bridge-start&quot;,s._isComparisonBridgeStart(e.compareValue,r,i))(&quot;mat-calendar-body-comparison-bridge-end&quot;,s._isComparisonBridgeEnd(e.compareValue,r,i))(&quot;mat-calendar-body-comparison-start&quot;,s._isComparisonStart(e.compareValue))(&quot;mat-calendar-body-comparison-end&quot;,s._isComparisonEnd(e.compareValue))(&quot;mat-calendar-body-in-comparison-range&quot;,s._isInComparisonRange(e.compareValue))(&quot;mat-calendar-body-preview-start&quot;,s._isPreviewStart(e.compareValue))(&quot;mat-calendar-body-preview-end&quot;,s._isPreviewEnd(e.compareValue))(&quot;mat-calendar-body-in-preview&quot;,s._isInPreview(e.compareValue)),w(&quot;ngClass&quot;,e.cssClasses)(&quot;tabindex&quot;,s._isActiveCell(r,i)?0:-1),Ce(&quot;data-mat-row&quot;,r)(&quot;data-mat-col&quot;,i)(&quot;aria-label&quot;,e.ariaLabel)(&quot;aria-disabled&quot;,!e.enabled||null)(&quot;aria-selected&quot;,s._isSelected(e.compareValue)),y(1),Me(&quot;mat-calendar-body-selected&quot;,s._isSelected(e.compareValue))(&quot;mat-calendar-body-comparison-identical&quot;,s._isComparisonIdentical(e.compareValue))(&quot;mat-calendar-body-today&quot;,s.todayValue===e.compareValue),y(1),de(&quot; &quot;,e.displayValue,&quot; &quot;)}}function J6(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;tr&quot;,4),I(1,Q6,2,6,&quot;td&quot;,5),I(2,Z6,4,46,&quot;td&quot;,6),h()),2&amp;n){const e=t.$implicit,i=t.index,r=T();y(1),w(&quot;ngIf&quot;,0===i&amp;&amp;r._firstRowOffset),y(1),w(&quot;ngForOf&quot;,e)}}function X6(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;th&quot;,5),d(1,&quot;abbr&quot;,6),b(2),h(),h()),2&amp;n){const e=t.$implicit;Ce(&quot;aria-label&quot;,e.long),y(1),Ce(&quot;title&quot;,e.long),y(1),nt(e.narrow)}}const gA=[&quot;*&quot;];function e7(n,t){}function t7(n,t){if(1&amp;n){const e=Ue();d(0,&quot;mat-month-view&quot;,5),M(&quot;activeDateChange&quot;,function(r){return _e(e),T().activeDate=r})(&quot;_userSelection&quot;,function(r){return _e(e),T()._dateSelected(r)}),h()}if(2&amp;n){const e=T();w(&quot;activeDate&quot;,e.activeDate)(&quot;selected&quot;,e.selected)(&quot;dateFilter&quot;,e.dateFilter)(&quot;maxDate&quot;,e.maxDate)(&quot;minDate&quot;,e.minDate)(&quot;dateClass&quot;,e.dateClass)(&quot;comparisonStart&quot;,e.comparisonStart)(&quot;comparisonEnd&quot;,e.comparisonEnd)}}function n7(n,t){if(1&amp;n){const e=Ue();d(0,&quot;mat-year-view&quot;,6),M(&quot;activeDateChange&quot;,function(r){return _e(e),T().activeDate=r})(&quot;monthSelected&quot;,function(r){return _e(e),T()._monthSelectedInYearView(r)})(&quot;selectedChange&quot;,function(r){return _e(e),T()._goToDateInView(r,&quot;month&quot;)}),h()}if(2&amp;n){const e=T();w(&quot;activeDate&quot;,e.activeDate)(&quot;selected&quot;,e.selected)(&quot;dateFilter&quot;,e.dateFilter)(&quot;maxDate&quot;,e.maxDate)(&quot;minDate&quot;,e.minDate)(&quot;dateClass&quot;,e.dateClass)}}function i7(n,t){if(1&amp;n){const e=Ue();d(0,&quot;mat-multi-year-view&quot;,7),M(&quot;activeDateChange&quot;,function(r){return _e(e),T().activeDate=r})(&quot;yearSelected&quot;,function(r){return _e(e),T()._yearSelectedInMultiYearView(r)})(&quot;selectedChange&quot;,function(r){return _e(e),T()._goToDateInView(r,&quot;year&quot;)}),h()}if(2&amp;n){const e=T();w(&quot;activeDate&quot;,e.activeDate)(&quot;selected&quot;,e.selected)(&quot;dateFilter&quot;,e.dateFilter)(&quot;maxDate&quot;,e.maxDate)(&quot;minDate&quot;,e.minDate)(&quot;dateClass&quot;,e.dateClass)}}function r7(n,t){}const s7=[&quot;button&quot;];function o7(n,t){1&amp;n&amp;&amp;(te.lFrame.currentNamespace=Vy,d(0,&quot;svg&quot;,3),k(1,&quot;path&quot;,4),h())}const a7=[[[&quot;&quot;,&quot;matDatepickerToggleIcon&quot;,&quot;&quot;]]],l7=[&quot;[matDatepickerToggleIcon]&quot;];let sc=(()=&gt;{class n{constructor(){this.changes=new ie,this.calendarLabel=&quot;Calendar&quot;,this.openCalendarLabel=&quot;Open calendar&quot;,this.closeCalendarLabel=&quot;Close calendar&quot;,this.prevMonthLabel=&quot;Previous month&quot;,this.nextMonthLabel=&quot;Next month&quot;,this.prevYearLabel=&quot;Previous year&quot;,this.nextYearLabel=&quot;Next year&quot;,this.prevMultiYearLabel=&quot;Previous 24 years&quot;,this.nextMultiYearLabel=&quot;Next 24 years&quot;,this.switchToMonthViewLabel=&quot;Choose date&quot;,this.switchToMultiYearViewLabel=&quot;Choose month and year&quot;}formatYearRange(e,i){return`${e} \u2013 ${i}`}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({factory:function(){return new n},token:n,providedIn:&quot;root&quot;}),n})();class K_{constructor(t,e,i,r,s={},o=t,a){this.value=t,this.displayValue=e,this.ariaLabel=i,this.enabled=r,this.cssClasses=s,this.compareValue=o,this.rawValue=a}}let fa=(()=&gt;{class n{constructor(e,i){this._elementRef=e,this._ngZone=i,this.numCols=7,this.activeCell=0,this.isRange=!1,this.cellAspectRatio=1,this.previewStart=null,this.previewEnd=null,this.selectedValueChange=new U,this.previewChange=new U,this._enterHandler=r=&gt;{if(this._skipNextFocus&amp;&amp;&quot;focus&quot;===r.type)this._skipNextFocus=!1;else if(r.target&amp;&amp;this.isRange){const s=this._getCellFromElement(r.target);s&amp;&amp;this._ngZone.run(()=&gt;this.previewChange.emit({value:s.enabled?s:null,event:r}))}},this._leaveHandler=r=&gt;{null!==this.previewEnd&amp;&amp;this.isRange&amp;&amp;r.target&amp;&amp;Q_(r.target)&amp;&amp;this._ngZone.run(()=&gt;this.previewChange.emit({value:null,event:r}))},i.runOutsideAngular(()=&gt;{const r=e.nativeElement;r.addEventListener(&quot;mouseenter&quot;,this._enterHandler,!0),r.addEventListener(&quot;focus&quot;,this._enterHandler,!0),r.addEventListener(&quot;mouseleave&quot;,this._leaveHandler,!0),r.addEventListener(&quot;blur&quot;,this._leaveHandler,!0)})}_cellClicked(e,i){e.enabled&amp;&amp;this.selectedValueChange.emit({value:e.value,event:i})}_isSelected(e){return this.startValue===e||this.endValue===e}ngOnChanges(e){const i=e.numCols,{rows:r,numCols:s}=this;(e.rows||i)&amp;&amp;(this._firstRowOffset=r&amp;&amp;r.length&amp;&amp;r[0].length?s-r[0].length:0),(e.cellAspectRatio||i||!this._cellPadding)&amp;&amp;(this._cellPadding=50*this.cellAspectRatio/s+&quot;%&quot;),(i||!this._cellWidth)&amp;&amp;(this._cellWidth=100/s+&quot;%&quot;)}ngOnDestroy(){const e=this._elementRef.nativeElement;e.removeEventListener(&quot;mouseenter&quot;,this._enterHandler,!0),e.removeEventListener(&quot;focus&quot;,this._enterHandler,!0),e.removeEventListener(&quot;mouseleave&quot;,this._leaveHandler,!0),e.removeEventListener(&quot;blur&quot;,this._leaveHandler,!0)}_isActiveCell(e,i){let r=e*this.numCols+i;return e&amp;&amp;(r-=this._firstRowOffset),r==this.activeCell}_focusActiveCell(e=!0){this._ngZone.runOutsideAngular(()=&gt;{this._ngZone.onStable.pipe(rn(1)).subscribe(()=&gt;{const i=this._elementRef.nativeElement.querySelector(&quot;.mat-calendar-body-active&quot;);i&amp;&amp;(e||(this._skipNextFocus=!0),i.focus())})})}_isRangeStart(e){return Z_(e,this.startValue,this.endValue)}_isRangeEnd(e){return J_(e,this.startValue,this.endValue)}_isInRange(e){return X_(e,this.startValue,this.endValue,this.isRange)}_isComparisonStart(e){return Z_(e,this.comparisonStart,this.comparisonEnd)}_isComparisonBridgeStart(e,i,r){if(!this._isComparisonStart(e)||this._isRangeStart(e)||!this._isInRange(e))return!1;let s=this.rows[i][r-1];if(!s){const o=this.rows[i-1];s=o&amp;&amp;o[o.length-1]}return s&amp;&amp;!this._isRangeEnd(s.compareValue)}_isComparisonBridgeEnd(e,i,r){if(!this._isComparisonEnd(e)||this._isRangeEnd(e)||!this._isInRange(e))return!1;let s=this.rows[i][r+1];if(!s){const o=this.rows[i+1];s=o&amp;&amp;o[0]}return s&amp;&amp;!this._isRangeStart(s.compareValue)}_isComparisonEnd(e){return J_(e,this.comparisonStart,this.comparisonEnd)}_isInComparisonRange(e){return X_(e,this.comparisonStart,this.comparisonEnd,this.isRange)}_isComparisonIdentical(e){return this.comparisonStart===this.comparisonEnd&amp;&amp;e===this.comparisonStart}_isPreviewStart(e){return Z_(e,this.previewStart,this.previewEnd)}_isPreviewEnd(e){return J_(e,this.previewStart,this.previewEnd)}_isInPreview(e){return X_(e,this.previewStart,this.previewEnd,this.isRange)}_getCellFromElement(e){let i;if(Q_(e)?i=e:Q_(e.parentNode)&amp;&amp;(i=e.parentNode),i){const r=i.getAttribute(&quot;data-mat-row&quot;),s=i.getAttribute(&quot;data-mat-col&quot;);if(r&amp;&amp;s)return this.rows[parseInt(r)][parseInt(s)]}return null}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(Y))},n.\u0275cmp=ee({type:n,selectors:[[&quot;&quot;,&quot;mat-calendar-body&quot;,&quot;&quot;]],hostAttrs:[1,&quot;mat-calendar-body&quot;],inputs:{numCols:&quot;numCols&quot;,activeCell:&quot;activeCell&quot;,isRange:&quot;isRange&quot;,cellAspectRatio:&quot;cellAspectRatio&quot;,previewStart:&quot;previewStart&quot;,previewEnd:&quot;previewEnd&quot;,label:&quot;label&quot;,rows:&quot;rows&quot;,todayValue:&quot;todayValue&quot;,startValue:&quot;startValue&quot;,endValue:&quot;endValue&quot;,labelMinRequiredCells:&quot;labelMinRequiredCells&quot;,comparisonStart:&quot;comparisonStart&quot;,comparisonEnd:&quot;comparisonEnd&quot;},outputs:{selectedValueChange:&quot;selectedValueChange&quot;,previewChange:&quot;previewChange&quot;},exportAs:[&quot;matCalendarBody&quot;],features:[je],attrs:Y6,decls:2,vars:2,consts:[[&quot;aria-hidden&quot;,&quot;true&quot;,4,&quot;ngIf&quot;],[&quot;role&quot;,&quot;row&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[&quot;aria-hidden&quot;,&quot;true&quot;],[1,&quot;mat-calendar-body-label&quot;],[&quot;role&quot;,&quot;row&quot;],[&quot;class&quot;,&quot;mat-calendar-body-label&quot;,3,&quot;paddingTop&quot;,&quot;paddingBottom&quot;,4,&quot;ngIf&quot;],[&quot;role&quot;,&quot;gridcell&quot;,&quot;class&quot;,&quot;mat-calendar-body-cell&quot;,3,&quot;ngClass&quot;,&quot;tabindex&quot;,&quot;mat-calendar-body-disabled&quot;,&quot;mat-calendar-body-active&quot;,&quot;mat-calendar-body-range-start&quot;,&quot;mat-calendar-body-range-end&quot;,&quot;mat-calendar-body-in-range&quot;,&quot;mat-calendar-body-comparison-bridge-start&quot;,&quot;mat-calendar-body-comparison-bridge-end&quot;,&quot;mat-calendar-body-comparison-start&quot;,&quot;mat-calendar-body-comparison-end&quot;,&quot;mat-calendar-body-in-comparison-range&quot;,&quot;mat-calendar-body-preview-start&quot;,&quot;mat-calendar-body-preview-end&quot;,&quot;mat-calendar-body-in-preview&quot;,&quot;width&quot;,&quot;paddingTop&quot;,&quot;paddingBottom&quot;,&quot;click&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[&quot;role&quot;,&quot;gridcell&quot;,1,&quot;mat-calendar-body-cell&quot;,3,&quot;ngClass&quot;,&quot;tabindex&quot;,&quot;click&quot;],[1,&quot;mat-calendar-body-cell-content&quot;,&quot;mat-focus-indicator&quot;],[1,&quot;mat-calendar-body-cell-preview&quot;]],template:function(e,i){1&amp;e&amp;&amp;(I(0,K6,3,6,&quot;tr&quot;,0),I(1,J6,3,2,&quot;tr&quot;,1)),2&amp;e&amp;&amp;(w(&quot;ngIf&quot;,i._firstRowOffset&lt;i.labelMinRequiredCells),y(1),w(&quot;ngForOf&quot;,i.rows))},directives:[rt,Fi,xg],styles:[&#39;.mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.7142857143%;padding-right:4.7142857143%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:none;cursor:pointer}.mat-calendar-body-cell::before,.mat-calendar-body-cell::after,.mat-calendar-body-cell-preview{content:&quot;&quot;;position:absolute;top:5%;left:0;z-index:0;box-sizing:border-box;height:90%;width:100%}.mat-calendar-body-range-start:not(.mat-calendar-body-in-comparison-range)::before,.mat-calendar-body-range-start::after,.mat-calendar-body-comparison-start:not(.mat-calendar-body-comparison-bridge-start)::before,.mat-calendar-body-comparison-start::after,.mat-calendar-body-preview-start .mat-calendar-body-cell-preview{left:5%;width:95%;border-top-left-radius:999px;border-bottom-left-radius:999px}[dir=rtl] .mat-calendar-body-range-start:not(.mat-calendar-body-in-comparison-range)::before,[dir=rtl] .mat-calendar-body-range-start::after,[dir=rtl] .mat-calendar-body-comparison-start:not(.mat-calendar-body-comparison-bridge-start)::before,[dir=rtl] .mat-calendar-body-comparison-start::after,[dir=rtl] .mat-calendar-body-preview-start .mat-calendar-body-cell-preview{left:0;border-radius:0;border-top-right-radius:999px;border-bottom-right-radius:999px}.mat-calendar-body-range-end:not(.mat-calendar-body-in-comparison-range)::before,.mat-calendar-body-range-end::after,.mat-calendar-body-comparison-end:not(.mat-calendar-body-comparison-bridge-end)::before,.mat-calendar-body-comparison-end::after,.mat-calendar-body-preview-end .mat-calendar-body-cell-preview{width:95%;border-top-right-radius:999px;border-bottom-right-radius:999px}[dir=rtl] .mat-calendar-body-range-end:not(.mat-calendar-body-in-comparison-range)::before,[dir=rtl] .mat-calendar-body-range-end::after,[dir=rtl] .mat-calendar-body-comparison-end:not(.mat-calendar-body-comparison-bridge-end)::before,[dir=rtl] .mat-calendar-body-comparison-end::after,[dir=rtl] .mat-calendar-body-preview-end .mat-calendar-body-cell-preview{left:5%;border-radius:0;border-top-left-radius:999px;border-bottom-left-radius:999px}[dir=rtl] .mat-calendar-body-comparison-bridge-start.mat-calendar-body-range-end::after,[dir=rtl] .mat-calendar-body-comparison-bridge-end.mat-calendar-body-range-start::after{width:95%;border-top-right-radius:999px;border-bottom-right-radius:999px}.mat-calendar-body-comparison-start.mat-calendar-body-range-end::after,[dir=rtl] .mat-calendar-body-comparison-start.mat-calendar-body-range-end::after,.mat-calendar-body-comparison-end.mat-calendar-body-range-start::after,[dir=rtl] .mat-calendar-body-comparison-end.mat-calendar-body-range-start::after{width:90%}.mat-calendar-body-in-preview .mat-calendar-body-cell-preview{border-top:dashed 1px;border-bottom:dashed 1px}.mat-calendar-body-preview-start .mat-calendar-body-cell-preview{border-left:dashed 1px}[dir=rtl] .mat-calendar-body-preview-start .mat-calendar-body-cell-preview{border-left:0;border-right:dashed 1px}.mat-calendar-body-preview-end .mat-calendar-body-cell-preview{border-right:dashed 1px}[dir=rtl] .mat-calendar-body-preview-end .mat-calendar-body-cell-preview{border-right:0;border-left:dashed 1px}.mat-calendar-body-disabled{cursor:default}.cdk-high-contrast-active .mat-calendar-body-disabled{opacity:.5}.mat-calendar-body-cell-content{top:5%;left:5%;z-index:1;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}.mat-calendar-body-cell-content.mat-focus-indicator{position:absolute}.cdk-high-contrast-active .mat-calendar-body-cell-content{border:none}.cdk-high-contrast-active .mat-datepicker-popup:not(:empty),.cdk-high-contrast-active .mat-calendar-body-cell:not(.mat-calendar-body-in-range) .mat-calendar-body-selected{outline:solid 1px}.cdk-high-contrast-active .mat-calendar-body-today{outline:dotted 1px}.cdk-high-contrast-active .cdk-keyboard-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected),.cdk-high-contrast-active .cdk-program-focused .mat-calendar-body-active&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){outline:dotted 2px}.cdk-high-contrast-active .mat-calendar-body-cell::before,.cdk-high-contrast-active .mat-calendar-body-cell::after,.cdk-high-contrast-active .mat-calendar-body-selected{background:none}.cdk-high-contrast-active .mat-calendar-body-in-range::before,.cdk-high-contrast-active .mat-calendar-body-comparison-bridge-start::before,.cdk-high-contrast-active .mat-calendar-body-comparison-bridge-end::before{border-top:solid 1px;border-bottom:solid 1px}.cdk-high-contrast-active .mat-calendar-body-range-start::before{border-left:solid 1px}[dir=rtl] .cdk-high-contrast-active .mat-calendar-body-range-start::before{border-left:0;border-right:solid 1px}.cdk-high-contrast-active .mat-calendar-body-range-end::before{border-right:solid 1px}[dir=rtl] .cdk-high-contrast-active .mat-calendar-body-range-end::before{border-right:0;border-left:solid 1px}.cdk-high-contrast-active .mat-calendar-body-in-comparison-range::before{border-top:dashed 1px;border-bottom:dashed 1px}.cdk-high-contrast-active .mat-calendar-body-comparison-start::before{border-left:dashed 1px}[dir=rtl] .cdk-high-contrast-active .mat-calendar-body-comparison-start::before{border-left:0;border-right:dashed 1px}.cdk-high-contrast-active .mat-calendar-body-comparison-end::before{border-right:dashed 1px}[dir=rtl] .cdk-high-contrast-active .mat-calendar-body-comparison-end::before{border-right:0;border-left:dashed 1px}[dir=rtl] .mat-calendar-body-label{text-align:right}@media(hover: none){.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover&gt;.mat-calendar-body-cell-content:not(.mat-calendar-body-selected){background-color:transparent}}\n&#39;],encapsulation:2,changeDetection:0}),n})();function Q_(n){return&quot;TD&quot;===n.nodeName}function Z_(n,t,e){return null!==e&amp;&amp;t!==e&amp;&amp;n&lt;e&amp;&amp;n===t}function J_(n,t,e){return null!==t&amp;&amp;t!==e&amp;&amp;n&gt;=t&amp;&amp;n===e}function X_(n,t,e,i){return i&amp;&amp;null!==t&amp;&amp;null!==e&amp;&amp;t!==e&amp;&amp;n&gt;=t&amp;&amp;n&lt;=e}class $t{constructor(t,e){this.start=t,this.end=e}}let qr=(()=&gt;{class n{constructor(e,i){this.selection=e,this._adapter=i,this._selectionChanged=new ie,this.selectionChanged=this._selectionChanged,this.selection=e}updateSelection(e,i){const r=this.selection;this.selection=e,this._selectionChanged.next({selection:e,source:i,oldValue:r})}ngOnDestroy(){this._selectionChanged.complete()}_isValidDateInstance(e){return this._adapter.isDateInstance(e)&amp;&amp;this._adapter.isValid(e)}}return n.\u0275fac=function(e){return new(e||n)(D(void 0),D(st))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),h7=(()=&gt;{class n extends qr{constructor(e){super(null,e)}add(e){super.updateSelection(e,this)}isValid(){return null!=this.selection&amp;&amp;this._isValidDateInstance(this.selection)}isComplete(){return null!=this.selection}clone(){const e=new n(this._adapter);return e.updateSelection(this.selection,this),e}}return n.\u0275fac=function(e){return new(e||n)(D(st))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();const mA={provide:qr,deps:[[new It,new Xn,qr],st],useFactory:function(n,t){return n||new h7(t)}},yh=new j(&quot;MAT_DATE_RANGE_SELECTION_STRATEGY&quot;);let _A=(()=&gt;{class n{constructor(e,i,r,s,o){this._changeDetectorRef=e,this._dateFormats=i,this._dateAdapter=r,this._dir=s,this._rangeStrategy=o,this._rerenderSubscription=ue.EMPTY,this.selectedChange=new U,this._userSelection=new U,this.activeDateChange=new U,this._activeDate=this._dateAdapter.today()}get activeDate(){return this._activeDate}set activeDate(e){const i=this._activeDate,r=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))||this._dateAdapter.today();this._activeDate=this._dateAdapter.clampDate(r,this.minDate,this.maxDate),this._hasSameMonthAndYear(i,this._activeDate)||this._init()}get selected(){return this._selected}set selected(e){this._selected=e instanceof $t?e:this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e)),this._setRanges(this._selected)}get minDate(){return this._minDate}set minDate(e){this._minDate=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}get maxDate(){return this._maxDate}set maxDate(e){this._maxDate=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}ngAfterContentInit(){this._rerenderSubscription=this._dateAdapter.localeChanges.pipe(lr(null)).subscribe(()=&gt;this._init())}ngOnChanges(e){const i=e.comparisonStart||e.comparisonEnd;i&amp;&amp;!i.firstChange&amp;&amp;this._setRanges(this.selected)}ngOnDestroy(){this._rerenderSubscription.unsubscribe()}_dateSelected(e){const i=e.value,r=this._dateAdapter.getYear(this.activeDate),s=this._dateAdapter.getMonth(this.activeDate),o=this._dateAdapter.createDate(r,s,i);let a,l;this._selected instanceof $t?(a=this._getDateInCurrentMonth(this._selected.start),l=this._getDateInCurrentMonth(this._selected.end)):a=l=this._getDateInCurrentMonth(this._selected),(a!==i||l!==i)&amp;&amp;this.selectedChange.emit(o),this._userSelection.emit({value:o,event:e.event}),this._previewStart=this._previewEnd=null,this._changeDetectorRef.markForCheck()}_handleCalendarBodyKeydown(e){const i=this._activeDate,r=this._isRtl();switch(e.keyCode){case 37:this.activeDate=this._dateAdapter.addCalendarDays(this._activeDate,r?1:-1);break;case 39:this.activeDate=this._dateAdapter.addCalendarDays(this._activeDate,r?-1:1);break;case 38:this.activeDate=this._dateAdapter.addCalendarDays(this._activeDate,-7);break;case 40:this.activeDate=this._dateAdapter.addCalendarDays(this._activeDate,7);break;case 36:this.activeDate=this._dateAdapter.addCalendarDays(this._activeDate,1-this._dateAdapter.getDate(this._activeDate));break;case 35:this.activeDate=this._dateAdapter.addCalendarDays(this._activeDate,this._dateAdapter.getNumDaysInMonth(this._activeDate)-this._dateAdapter.getDate(this._activeDate));break;case 33:this.activeDate=e.altKey?this._dateAdapter.addCalendarYears(this._activeDate,-1):this._dateAdapter.addCalendarMonths(this._activeDate,-1);break;case 34:this.activeDate=e.altKey?this._dateAdapter.addCalendarYears(this._activeDate,1):this._dateAdapter.addCalendarMonths(this._activeDate,1);break;case 13:case 32:return this._selectionKeyPressed=!0,void(this._canSelect(this._activeDate)&amp;&amp;e.preventDefault());case 27:return void(null!=this._previewEnd&amp;&amp;!Gl(e)&amp;&amp;(this._previewStart=this._previewEnd=null,this.selectedChange.emit(null),this._userSelection.emit({value:null,event:e}),e.preventDefault(),e.stopPropagation()));default:return}this._dateAdapter.compareDate(i,this.activeDate)&amp;&amp;this.activeDateChange.emit(this.activeDate),this._focusActiveCell(),e.preventDefault()}_handleCalendarBodyKeyup(e){(32===e.keyCode||13===e.keyCode)&amp;&amp;(this._selectionKeyPressed&amp;&amp;this._canSelect(this._activeDate)&amp;&amp;this._dateSelected({value:this._dateAdapter.getDate(this._activeDate),event:e}),this._selectionKeyPressed=!1)}_init(){this._setRanges(this.selected),this._todayDate=this._getCellCompareValue(this._dateAdapter.today()),this._monthLabel=this._dateFormats.display.monthLabel?this._dateAdapter.format(this.activeDate,this._dateFormats.display.monthLabel):this._dateAdapter.getMonthNames(&quot;short&quot;)[this._dateAdapter.getMonth(this.activeDate)].toLocaleUpperCase();let e=this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate),this._dateAdapter.getMonth(this.activeDate),1);this._firstWeekOffset=(7+this._dateAdapter.getDayOfWeek(e)-this._dateAdapter.getFirstDayOfWeek())%7,this._initWeekdays(),this._createWeekCells(),this._changeDetectorRef.markForCheck()}_focusActiveCell(e){this._matCalendarBody._focusActiveCell(e)}_previewChanged({event:e,value:i}){if(this._rangeStrategy){const s=this._rangeStrategy.createPreview(i?i.rawValue:null,this.selected,e);this._previewStart=this._getCellCompareValue(s.start),this._previewEnd=this._getCellCompareValue(s.end),this._changeDetectorRef.detectChanges()}}_initWeekdays(){const e=this._dateAdapter.getFirstDayOfWeek(),i=this._dateAdapter.getDayOfWeekNames(&quot;narrow&quot;);let s=this._dateAdapter.getDayOfWeekNames(&quot;long&quot;).map((o,a)=&gt;({long:o,narrow:i[a]}));this._weekdays=s.slice(e).concat(s.slice(0,e))}_createWeekCells(){const e=this._dateAdapter.getNumDaysInMonth(this.activeDate),i=this._dateAdapter.getDateNames();this._weeks=[[]];for(let r=0,s=this._firstWeekOffset;r&lt;e;r++,s++){7==s&amp;&amp;(this._weeks.push([]),s=0);const o=this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate),this._dateAdapter.getMonth(this.activeDate),r+1),a=this._shouldEnableDate(o),l=this._dateAdapter.format(o,this._dateFormats.display.dateA11yLabel),c=this.dateClass?this.dateClass(o,&quot;month&quot;):void 0;this._weeks[this._weeks.length-1].push(new K_(r+1,i[r],l,a,c,this._getCellCompareValue(o),o))}}_shouldEnableDate(e){return!!e&amp;&amp;(!this.minDate||this._dateAdapter.compareDate(e,this.minDate)&gt;=0)&amp;&amp;(!this.maxDate||this._dateAdapter.compareDate(e,this.maxDate)&lt;=0)&amp;&amp;(!this.dateFilter||this.dateFilter(e))}_getDateInCurrentMonth(e){return e&amp;&amp;this._hasSameMonthAndYear(e,this.activeDate)?this._dateAdapter.getDate(e):null}_hasSameMonthAndYear(e,i){return!(!e||!i||this._dateAdapter.getMonth(e)!=this._dateAdapter.getMonth(i)||this._dateAdapter.getYear(e)!=this._dateAdapter.getYear(i))}_getCellCompareValue(e){if(e){const i=this._dateAdapter.getYear(e),r=this._dateAdapter.getMonth(e),s=this._dateAdapter.getDate(e);return new Date(i,r,s).getTime()}return null}_isRtl(){return this._dir&amp;&amp;&quot;rtl&quot;===this._dir.value}_setRanges(e){e instanceof $t?(this._rangeStart=this._getCellCompareValue(e.start),this._rangeEnd=this._getCellCompareValue(e.end),this._isRange=!0):(this._rangeStart=this._rangeEnd=this._getCellCompareValue(e),this._isRange=!1),this._comparisonRangeStart=this._getCellCompareValue(this.comparisonStart),this._comparisonRangeEnd=this._getCellCompareValue(this.comparisonEnd)}_canSelect(e){return!this.dateFilter||this.dateFilter(e)}}return n.\u0275fac=function(e){return new(e||n)(_(xt),_(Hi,8),_(st,8),_(Bi,8),_(yh,8))},n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-month-view&quot;]],viewQuery:function(e,i){if(1&amp;e&amp;&amp;Pt(fa,5),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i._matCalendarBody=r.first)}},inputs:{activeDate:&quot;activeDate&quot;,selected:&quot;selected&quot;,minDate:&quot;minDate&quot;,maxDate:&quot;maxDate&quot;,dateFilter:&quot;dateFilter&quot;,dateClass:&quot;dateClass&quot;,comparisonStart:&quot;comparisonStart&quot;,comparisonEnd:&quot;comparisonEnd&quot;},outputs:{selectedChange:&quot;selectedChange&quot;,_userSelection:&quot;_userSelection&quot;,activeDateChange:&quot;activeDateChange&quot;},exportAs:[&quot;matMonthView&quot;],features:[je],decls:7,vars:13,consts:[[&quot;role&quot;,&quot;grid&quot;,1,&quot;mat-calendar-table&quot;],[1,&quot;mat-calendar-table-header&quot;],[&quot;scope&quot;,&quot;col&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[&quot;aria-hidden&quot;,&quot;true&quot;,&quot;colspan&quot;,&quot;7&quot;,1,&quot;mat-calendar-table-header-divider&quot;],[&quot;mat-calendar-body&quot;,&quot;&quot;,3,&quot;label&quot;,&quot;rows&quot;,&quot;todayValue&quot;,&quot;startValue&quot;,&quot;endValue&quot;,&quot;comparisonStart&quot;,&quot;comparisonEnd&quot;,&quot;previewStart&quot;,&quot;previewEnd&quot;,&quot;isRange&quot;,&quot;labelMinRequiredCells&quot;,&quot;activeCell&quot;,&quot;selectedValueChange&quot;,&quot;previewChange&quot;,&quot;keyup&quot;,&quot;keydown&quot;],[&quot;scope&quot;,&quot;col&quot;],[1,&quot;mat-calendar-abbr&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;table&quot;,0),d(1,&quot;thead&quot;,1),d(2,&quot;tr&quot;),I(3,X6,3,3,&quot;th&quot;,2),h(),d(4,&quot;tr&quot;),k(5,&quot;th&quot;,3),h(),h(),d(6,&quot;tbody&quot;,4),M(&quot;selectedValueChange&quot;,function(s){return i._dateSelected(s)})(&quot;previewChange&quot;,function(s){return i._previewChanged(s)})(&quot;keyup&quot;,function(s){return i._handleCalendarBodyKeyup(s)})(&quot;keydown&quot;,function(s){return i._handleCalendarBodyKeydown(s)}),h(),h()),2&amp;e&amp;&amp;(y(3),w(&quot;ngForOf&quot;,i._weekdays),y(3),w(&quot;label&quot;,i._monthLabel)(&quot;rows&quot;,i._weeks)(&quot;todayValue&quot;,i._todayDate)(&quot;startValue&quot;,i._rangeStart)(&quot;endValue&quot;,i._rangeEnd)(&quot;comparisonStart&quot;,i._comparisonRangeStart)(&quot;comparisonEnd&quot;,i._comparisonRangeEnd)(&quot;previewStart&quot;,i._previewStart)(&quot;previewEnd&quot;,i._previewEnd)(&quot;isRange&quot;,i._isRange)(&quot;labelMinRequiredCells&quot;,3)(&quot;activeCell&quot;,i._dateAdapter.getDate(i.activeDate)-1))},directives:[Fi,fa],encapsulation:2,changeDetection:0}),n})(),yA=(()=&gt;{class n{constructor(e,i,r){this._changeDetectorRef=e,this._dateAdapter=i,this._dir=r,this._rerenderSubscription=ue.EMPTY,this.selectedChange=new U,this.yearSelected=new U,this.activeDateChange=new U,this._activeDate=this._dateAdapter.today()}get activeDate(){return this._activeDate}set activeDate(e){let i=this._activeDate;const r=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))||this._dateAdapter.today();this._activeDate=this._dateAdapter.clampDate(r,this.minDate,this.maxDate),vA(this._dateAdapter,i,this._activeDate,this.minDate,this.maxDate)||this._init()}get selected(){return this._selected}set selected(e){this._selected=e instanceof $t?e:this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e)),this._setSelectedYear(e)}get minDate(){return this._minDate}set minDate(e){this._minDate=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}get maxDate(){return this._maxDate}set maxDate(e){this._maxDate=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}ngAfterContentInit(){this._rerenderSubscription=this._dateAdapter.localeChanges.pipe(lr(null)).subscribe(()=&gt;this._init())}ngOnDestroy(){this._rerenderSubscription.unsubscribe()}_init(){this._todayYear=this._dateAdapter.getYear(this._dateAdapter.today());const i=this._dateAdapter.getYear(this._activeDate)-oc(this._dateAdapter,this.activeDate,this.minDate,this.maxDate);this._years=[];for(let r=0,s=[];r&lt;24;r++)s.push(i+r),4==s.length&amp;&amp;(this._years.push(s.map(o=&gt;this._createCellForYear(o))),s=[]);this._changeDetectorRef.markForCheck()}_yearSelected(e){const i=e.value;this.yearSelected.emit(this._dateAdapter.createDate(i,0,1));let r=this._dateAdapter.getMonth(this.activeDate),s=this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(i,r,1));this.selectedChange.emit(this._dateAdapter.createDate(i,r,Math.min(this._dateAdapter.getDate(this.activeDate),s)))}_handleCalendarBodyKeydown(e){const i=this._activeDate,r=this._isRtl();switch(e.keyCode){case 37:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,r?1:-1);break;case 39:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,r?-1:1);break;case 38:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,-4);break;case 40:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,4);break;case 36:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,-oc(this._dateAdapter,this.activeDate,this.minDate,this.maxDate));break;case 35:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,24-oc(this._dateAdapter,this.activeDate,this.minDate,this.maxDate)-1);break;case 33:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,e.altKey?-240:-24);break;case 34:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,e.altKey?240:24);break;case 13:case 32:this._selectionKeyPressed=!0;break;default:return}this._dateAdapter.compareDate(i,this.activeDate)&amp;&amp;this.activeDateChange.emit(this.activeDate),this._focusActiveCell(),e.preventDefault()}_handleCalendarBodyKeyup(e){(32===e.keyCode||13===e.keyCode)&amp;&amp;(this._selectionKeyPressed&amp;&amp;this._yearSelected({value:this._dateAdapter.getYear(this._activeDate),event:e}),this._selectionKeyPressed=!1)}_getActiveCell(){return oc(this._dateAdapter,this.activeDate,this.minDate,this.maxDate)}_focusActiveCell(){this._matCalendarBody._focusActiveCell()}_createCellForYear(e){const i=this._dateAdapter.createDate(e,0,1),r=this._dateAdapter.getYearName(i),s=this.dateClass?this.dateClass(i,&quot;multi-year&quot;):void 0;return new K_(e,r,r,this._shouldEnableYear(e),s)}_shouldEnableYear(e){if(null==e||this.maxDate&amp;&amp;e&gt;this._dateAdapter.getYear(this.maxDate)||this.minDate&amp;&amp;e&lt;this._dateAdapter.getYear(this.minDate))return!1;if(!this.dateFilter)return!0;for(let r=this._dateAdapter.createDate(e,0,1);this._dateAdapter.getYear(r)==e;r=this._dateAdapter.addCalendarDays(r,1))if(this.dateFilter(r))return!0;return!1}_isRtl(){return this._dir&amp;&amp;&quot;rtl&quot;===this._dir.value}_setSelectedYear(e){if(this._selectedYear=null,e instanceof $t){const i=e.start||e.end;i&amp;&amp;(this._selectedYear=this._dateAdapter.getYear(i))}else e&amp;&amp;(this._selectedYear=this._dateAdapter.getYear(e))}}return n.\u0275fac=function(e){return new(e||n)(_(xt),_(st,8),_(Bi,8))},n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-multi-year-view&quot;]],viewQuery:function(e,i){if(1&amp;e&amp;&amp;Pt(fa,5),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i._matCalendarBody=r.first)}},inputs:{activeDate:&quot;activeDate&quot;,selected:&quot;selected&quot;,minDate:&quot;minDate&quot;,maxDate:&quot;maxDate&quot;,dateFilter:&quot;dateFilter&quot;,dateClass:&quot;dateClass&quot;},outputs:{selectedChange:&quot;selectedChange&quot;,yearSelected:&quot;yearSelected&quot;,activeDateChange:&quot;activeDateChange&quot;},exportAs:[&quot;matMultiYearView&quot;],decls:5,vars:7,consts:[[&quot;role&quot;,&quot;grid&quot;,1,&quot;mat-calendar-table&quot;],[&quot;aria-hidden&quot;,&quot;true&quot;,1,&quot;mat-calendar-table-header&quot;],[&quot;colspan&quot;,&quot;4&quot;,1,&quot;mat-calendar-table-header-divider&quot;],[&quot;mat-calendar-body&quot;,&quot;&quot;,3,&quot;rows&quot;,&quot;todayValue&quot;,&quot;startValue&quot;,&quot;endValue&quot;,&quot;numCols&quot;,&quot;cellAspectRatio&quot;,&quot;activeCell&quot;,&quot;selectedValueChange&quot;,&quot;keyup&quot;,&quot;keydown&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;table&quot;,0),d(1,&quot;thead&quot;,1),d(2,&quot;tr&quot;),k(3,&quot;th&quot;,2),h(),h(),d(4,&quot;tbody&quot;,3),M(&quot;selectedValueChange&quot;,function(s){return i._yearSelected(s)})(&quot;keyup&quot;,function(s){return i._handleCalendarBodyKeyup(s)})(&quot;keydown&quot;,function(s){return i._handleCalendarBodyKeydown(s)}),h(),h()),2&amp;e&amp;&amp;(y(4),w(&quot;rows&quot;,i._years)(&quot;todayValue&quot;,i._todayYear)(&quot;startValue&quot;,i._selectedYear)(&quot;endValue&quot;,i._selectedYear)(&quot;numCols&quot;,4)(&quot;cellAspectRatio&quot;,4/7)(&quot;activeCell&quot;,i._getActiveCell()))},directives:[fa],encapsulation:2,changeDetection:0}),n})();function vA(n,t,e,i,r){const s=n.getYear(t),o=n.getYear(e),a=bA(n,i,r);return Math.floor((s-a)/24)===Math.floor((o-a)/24)}function oc(n,t,e,i){return function(n,t){return(n%24+24)%24}(n.getYear(t)-bA(n,e,i))}function bA(n,t,e){let i=0;return e?i=n.getYear(e)-24+1:t&amp;&amp;(i=n.getYear(t)),i}let CA=(()=&gt;{class n{constructor(e,i,r,s){this._changeDetectorRef=e,this._dateFormats=i,this._dateAdapter=r,this._dir=s,this._rerenderSubscription=ue.EMPTY,this.selectedChange=new U,this.monthSelected=new U,this.activeDateChange=new U,this._activeDate=this._dateAdapter.today()}get activeDate(){return this._activeDate}set activeDate(e){let i=this._activeDate;const r=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))||this._dateAdapter.today();this._activeDate=this._dateAdapter.clampDate(r,this.minDate,this.maxDate),this._dateAdapter.getYear(i)!==this._dateAdapter.getYear(this._activeDate)&amp;&amp;this._init()}get selected(){return this._selected}set selected(e){this._selected=e instanceof $t?e:this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e)),this._setSelectedMonth(e)}get minDate(){return this._minDate}set minDate(e){this._minDate=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}get maxDate(){return this._maxDate}set maxDate(e){this._maxDate=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}ngAfterContentInit(){this._rerenderSubscription=this._dateAdapter.localeChanges.pipe(lr(null)).subscribe(()=&gt;this._init())}ngOnDestroy(){this._rerenderSubscription.unsubscribe()}_monthSelected(e){const i=e.value,r=this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate),i,1);this.monthSelected.emit(r);const s=this._dateAdapter.getNumDaysInMonth(r);this.selectedChange.emit(this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate),i,Math.min(this._dateAdapter.getDate(this.activeDate),s)))}_handleCalendarBodyKeydown(e){const i=this._activeDate,r=this._isRtl();switch(e.keyCode){case 37:this.activeDate=this._dateAdapter.addCalendarMonths(this._activeDate,r?1:-1);break;case 39:this.activeDate=this._dateAdapter.addCalendarMonths(this._activeDate,r?-1:1);break;case 38:this.activeDate=this._dateAdapter.addCalendarMonths(this._activeDate,-4);break;case 40:this.activeDate=this._dateAdapter.addCalendarMonths(this._activeDate,4);break;case 36:this.activeDate=this._dateAdapter.addCalendarMonths(this._activeDate,-this._dateAdapter.getMonth(this._activeDate));break;case 35:this.activeDate=this._dateAdapter.addCalendarMonths(this._activeDate,11-this._dateAdapter.getMonth(this._activeDate));break;case 33:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,e.altKey?-10:-1);break;case 34:this.activeDate=this._dateAdapter.addCalendarYears(this._activeDate,e.altKey?10:1);break;case 13:case 32:this._selectionKeyPressed=!0;break;default:return}this._dateAdapter.compareDate(i,this.activeDate)&amp;&amp;this.activeDateChange.emit(this.activeDate),this._focusActiveCell(),e.preventDefault()}_handleCalendarBodyKeyup(e){(32===e.keyCode||13===e.keyCode)&amp;&amp;(this._selectionKeyPressed&amp;&amp;this._monthSelected({value:this._dateAdapter.getMonth(this._activeDate),event:e}),this._selectionKeyPressed=!1)}_init(){this._setSelectedMonth(this.selected),this._todayMonth=this._getMonthInCurrentYear(this._dateAdapter.today()),this._yearLabel=this._dateAdapter.getYearName(this.activeDate);let e=this._dateAdapter.getMonthNames(&quot;short&quot;);this._months=[[0,1,2,3],[4,5,6,7],[8,9,10,11]].map(i=&gt;i.map(r=&gt;this._createCellForMonth(r,e[r]))),this._changeDetectorRef.markForCheck()}_focusActiveCell(){this._matCalendarBody._focusActiveCell()}_getMonthInCurrentYear(e){return e&amp;&amp;this._dateAdapter.getYear(e)==this._dateAdapter.getYear(this.activeDate)?this._dateAdapter.getMonth(e):null}_createCellForMonth(e,i){const r=this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate),e,1),s=this._dateAdapter.format(r,this._dateFormats.display.monthYearA11yLabel),o=this.dateClass?this.dateClass(r,&quot;year&quot;):void 0;return new K_(e,i.toLocaleUpperCase(),s,this._shouldEnableMonth(e),o)}_shouldEnableMonth(e){const i=this._dateAdapter.getYear(this.activeDate);if(null==e||this._isYearAndMonthAfterMaxDate(i,e)||this._isYearAndMonthBeforeMinDate(i,e))return!1;if(!this.dateFilter)return!0;for(let s=this._dateAdapter.createDate(i,e,1);this._dateAdapter.getMonth(s)==e;s=this._dateAdapter.addCalendarDays(s,1))if(this.dateFilter(s))return!0;return!1}_isYearAndMonthAfterMaxDate(e,i){if(this.maxDate){const r=this._dateAdapter.getYear(this.maxDate),s=this._dateAdapter.getMonth(this.maxDate);return e&gt;r||e===r&amp;&amp;i&gt;s}return!1}_isYearAndMonthBeforeMinDate(e,i){if(this.minDate){const r=this._dateAdapter.getYear(this.minDate),s=this._dateAdapter.getMonth(this.minDate);return e&lt;r||e===r&amp;&amp;i&lt;s}return!1}_isRtl(){return this._dir&amp;&amp;&quot;rtl&quot;===this._dir.value}_setSelectedMonth(e){this._selectedMonth=e instanceof $t?this._getMonthInCurrentYear(e.start)||this._getMonthInCurrentYear(e.end):this._getMonthInCurrentYear(e)}}return n.\u0275fac=function(e){return new(e||n)(_(xt),_(Hi,8),_(st,8),_(Bi,8))},n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-year-view&quot;]],viewQuery:function(e,i){if(1&amp;e&amp;&amp;Pt(fa,5),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i._matCalendarBody=r.first)}},inputs:{activeDate:&quot;activeDate&quot;,selected:&quot;selected&quot;,minDate:&quot;minDate&quot;,maxDate:&quot;maxDate&quot;,dateFilter:&quot;dateFilter&quot;,dateClass:&quot;dateClass&quot;},outputs:{selectedChange:&quot;selectedChange&quot;,monthSelected:&quot;monthSelected&quot;,activeDateChange:&quot;activeDateChange&quot;},exportAs:[&quot;matYearView&quot;],decls:5,vars:9,consts:[[&quot;role&quot;,&quot;grid&quot;,1,&quot;mat-calendar-table&quot;],[&quot;aria-hidden&quot;,&quot;true&quot;,1,&quot;mat-calendar-table-header&quot;],[&quot;colspan&quot;,&quot;4&quot;,1,&quot;mat-calendar-table-header-divider&quot;],[&quot;mat-calendar-body&quot;,&quot;&quot;,3,&quot;label&quot;,&quot;rows&quot;,&quot;todayValue&quot;,&quot;startValue&quot;,&quot;endValue&quot;,&quot;labelMinRequiredCells&quot;,&quot;numCols&quot;,&quot;cellAspectRatio&quot;,&quot;activeCell&quot;,&quot;selectedValueChange&quot;,&quot;keyup&quot;,&quot;keydown&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;table&quot;,0),d(1,&quot;thead&quot;,1),d(2,&quot;tr&quot;),k(3,&quot;th&quot;,2),h(),h(),d(4,&quot;tbody&quot;,3),M(&quot;selectedValueChange&quot;,function(s){return i._monthSelected(s)})(&quot;keyup&quot;,function(s){return i._handleCalendarBodyKeyup(s)})(&quot;keydown&quot;,function(s){return i._handleCalendarBodyKeydown(s)}),h(),h()),2&amp;e&amp;&amp;(y(4),w(&quot;label&quot;,i._yearLabel)(&quot;rows&quot;,i._months)(&quot;todayValue&quot;,i._todayMonth)(&quot;startValue&quot;,i._selectedMonth)(&quot;endValue&quot;,i._selectedMonth)(&quot;labelMinRequiredCells&quot;,2)(&quot;numCols&quot;,4)(&quot;cellAspectRatio&quot;,4/7)(&quot;activeCell&quot;,i._dateAdapter.getMonth(i.activeDate)))},directives:[fa],encapsulation:2,changeDetection:0}),n})(),C7=0,D7=(()=&gt;{class n{constructor(e,i,r,s,o){this._intl=e,this.calendar=i,this._dateAdapter=r,this._dateFormats=s,this._buttonDescriptionId=&quot;mat-calendar-button-&quot;+C7++,this.calendar.stateChanges.subscribe(()=&gt;o.markForCheck())}get periodButtonText(){if(&quot;month&quot;==this.calendar.currentView)return this._dateAdapter.format(this.calendar.activeDate,this._dateFormats.display.monthYearLabel).toLocaleUpperCase();if(&quot;year&quot;==this.calendar.currentView)return this._dateAdapter.getYearName(this.calendar.activeDate);const i=this._dateAdapter.getYear(this.calendar.activeDate)-oc(this._dateAdapter,this.calendar.activeDate,this.calendar.minDate,this.calendar.maxDate),r=i+24-1,s=this._dateAdapter.getYearName(this._dateAdapter.createDate(i,0,1)),o=this._dateAdapter.getYearName(this._dateAdapter.createDate(r,0,1));return this._intl.formatYearRange(s,o)}get periodButtonLabel(){return&quot;month&quot;==this.calendar.currentView?this._intl.switchToMultiYearViewLabel:this._intl.switchToMonthViewLabel}get prevButtonLabel(){return{month:this._intl.prevMonthLabel,year:this._intl.prevYearLabel,&quot;multi-year&quot;:this._intl.prevMultiYearLabel}[this.calendar.currentView]}get nextButtonLabel(){return{month:this._intl.nextMonthLabel,year:this._intl.nextYearLabel,&quot;multi-year&quot;:this._intl.nextMultiYearLabel}[this.calendar.currentView]}currentPeriodClicked(){this.calendar.currentView=&quot;month&quot;==this.calendar.currentView?&quot;multi-year&quot;:&quot;month&quot;}previousClicked(){this.calendar.activeDate=&quot;month&quot;==this.calendar.currentView?this._dateAdapter.addCalendarMonths(this.calendar.activeDate,-1):this._dateAdapter.addCalendarYears(this.calendar.activeDate,&quot;year&quot;==this.calendar.currentView?-1:-24)}nextClicked(){this.calendar.activeDate=&quot;month&quot;==this.calendar.currentView?this._dateAdapter.addCalendarMonths(this.calendar.activeDate,1):this._dateAdapter.addCalendarYears(this.calendar.activeDate,&quot;year&quot;==this.calendar.currentView?1:24)}previousEnabled(){return!this.calendar.minDate||!this.calendar.minDate||!this._isSameView(this.calendar.activeDate,this.calendar.minDate)}nextEnabled(){return!this.calendar.maxDate||!this._isSameView(this.calendar.activeDate,this.calendar.maxDate)}_isSameView(e,i){return&quot;month&quot;==this.calendar.currentView?this._dateAdapter.getYear(e)==this._dateAdapter.getYear(i)&amp;&amp;this._dateAdapter.getMonth(e)==this._dateAdapter.getMonth(i):&quot;year&quot;==this.calendar.currentView?this._dateAdapter.getYear(e)==this._dateAdapter.getYear(i):vA(this._dateAdapter,e,i,this.calendar.minDate,this.calendar.maxDate)}}return n.\u0275fac=function(e){return new(e||n)(_(sc),_(Fe(()=&gt;ny)),_(st,8),_(Hi,8),_(xt))},n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-calendar-header&quot;]],exportAs:[&quot;matCalendarHeader&quot;],ngContentSelectors:gA,decls:10,vars:10,consts:[[1,&quot;mat-calendar-header&quot;],[1,&quot;mat-calendar-controls&quot;],[&quot;mat-button&quot;,&quot;&quot;,&quot;type&quot;,&quot;button&quot;,&quot;cdkAriaLive&quot;,&quot;polite&quot;,1,&quot;mat-calendar-period-button&quot;,3,&quot;click&quot;],[1,&quot;mat-calendar-arrow&quot;],[1,&quot;mat-calendar-spacer&quot;],[&quot;mat-icon-button&quot;,&quot;&quot;,&quot;type&quot;,&quot;button&quot;,1,&quot;mat-calendar-previous-button&quot;,3,&quot;disabled&quot;,&quot;click&quot;],[&quot;mat-icon-button&quot;,&quot;&quot;,&quot;type&quot;,&quot;button&quot;,1,&quot;mat-calendar-next-button&quot;,3,&quot;disabled&quot;,&quot;click&quot;]],template:function(e,i){1&amp;e&amp;&amp;(ri(),d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;button&quot;,2),M(&quot;click&quot;,function(){return i.currentPeriodClicked()}),d(3,&quot;span&quot;),b(4),h(),k(5,&quot;div&quot;,3),h(),k(6,&quot;div&quot;,4),ht(7),d(8,&quot;button&quot;,5),M(&quot;click&quot;,function(){return i.previousClicked()}),h(),d(9,&quot;button&quot;,6),M(&quot;click&quot;,function(){return i.nextClicked()}),h(),h(),h()),2&amp;e&amp;&amp;(y(2),Ce(&quot;aria-label&quot;,i.periodButtonLabel)(&quot;aria-describedby&quot;,i._buttonDescriptionId),y(1),Ce(&quot;id&quot;,i._buttonDescriptionId),y(1),nt(i.periodButtonText),y(1),Me(&quot;mat-calendar-invert&quot;,&quot;month&quot;!==i.calendar.currentView),y(3),w(&quot;disabled&quot;,!i.previousEnabled()),Ce(&quot;aria-label&quot;,i.prevButtonLabel),y(1),w(&quot;disabled&quot;,!i.nextEnabled()),Ce(&quot;aria-label&quot;,i.nextButtonLabel))},directives:[_h,X4],encapsulation:2,changeDetection:0}),n})(),ny=(()=&gt;{class n{constructor(e,i,r,s){this._dateAdapter=i,this._dateFormats=r,this._changeDetectorRef=s,this._moveFocusOnNextTick=!1,this.startView=&quot;month&quot;,this.selectedChange=new U,this.yearSelected=new U,this.monthSelected=new U,this.viewChanged=new U(!0),this._userSelection=new U,this.stateChanges=new ie,this._intlChanges=e.changes.subscribe(()=&gt;{s.markForCheck(),this.stateChanges.next()})}get startAt(){return this._startAt}set startAt(e){this._startAt=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}get selected(){return this._selected}set selected(e){this._selected=e instanceof $t?e:this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}get minDate(){return this._minDate}set minDate(e){this._minDate=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}get maxDate(){return this._maxDate}set maxDate(e){this._maxDate=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}get activeDate(){return this._clampedActiveDate}set activeDate(e){this._clampedActiveDate=this._dateAdapter.clampDate(e,this.minDate,this.maxDate),this.stateChanges.next(),this._changeDetectorRef.markForCheck()}get currentView(){return this._currentView}set currentView(e){const i=this._currentView!==e?e:null;this._currentView=e,this._moveFocusOnNextTick=!0,this._changeDetectorRef.markForCheck(),i&amp;&amp;this.viewChanged.emit(i)}ngAfterContentInit(){this._calendarHeaderPortal=new $_(this.headerComponent||D7),this.activeDate=this.startAt||this._dateAdapter.today(),this._currentView=this.startView}ngAfterViewChecked(){this._moveFocusOnNextTick&amp;&amp;(this._moveFocusOnNextTick=!1,this.focusActiveCell())}ngOnDestroy(){this._intlChanges.unsubscribe(),this.stateChanges.complete()}ngOnChanges(e){const i=e.minDate||e.maxDate||e.dateFilter;if(i&amp;&amp;!i.firstChange){const r=this._getCurrentViewComponent();r&amp;&amp;(this._changeDetectorRef.detectChanges(),r._init())}this.stateChanges.next()}focusActiveCell(){this._getCurrentViewComponent()._focusActiveCell(!1)}updateTodaysDate(){this._getCurrentViewComponent()._init()}_dateSelected(e){const i=e.value;(this.selected instanceof $t||i&amp;&amp;!this._dateAdapter.sameDate(i,this.selected))&amp;&amp;this.selectedChange.emit(i),this._userSelection.emit(e)}_yearSelectedInMultiYearView(e){this.yearSelected.emit(e)}_monthSelectedInYearView(e){this.monthSelected.emit(e)}_goToDateInView(e,i){this.activeDate=e,this.currentView=i}_getCurrentViewComponent(){return this.monthView||this.yearView||this.multiYearView}}return n.\u0275fac=function(e){return new(e||n)(_(sc),_(st,8),_(Hi,8),_(xt))},n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-calendar&quot;]],viewQuery:function(e,i){if(1&amp;e&amp;&amp;(Pt(_A,5),Pt(CA,5),Pt(yA,5)),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i.monthView=r.first),Pe(r=Oe())&amp;&amp;(i.yearView=r.first),Pe(r=Oe())&amp;&amp;(i.multiYearView=r.first)}},hostAttrs:[1,&quot;mat-calendar&quot;],inputs:{startView:&quot;startView&quot;,startAt:&quot;startAt&quot;,selected:&quot;selected&quot;,minDate:&quot;minDate&quot;,maxDate:&quot;maxDate&quot;,headerComponent:&quot;headerComponent&quot;,dateFilter:&quot;dateFilter&quot;,dateClass:&quot;dateClass&quot;,comparisonStart:&quot;comparisonStart&quot;,comparisonEnd:&quot;comparisonEnd&quot;},outputs:{selectedChange:&quot;selectedChange&quot;,yearSelected:&quot;yearSelected&quot;,monthSelected:&quot;monthSelected&quot;,viewChanged:&quot;viewChanged&quot;,_userSelection:&quot;_userSelection&quot;},exportAs:[&quot;matCalendar&quot;],features:[ce([mA]),je],decls:5,vars:5,consts:[[3,&quot;cdkPortalOutlet&quot;],[&quot;cdkMonitorSubtreeFocus&quot;,&quot;&quot;,&quot;tabindex&quot;,&quot;-1&quot;,1,&quot;mat-calendar-content&quot;,3,&quot;ngSwitch&quot;],[3,&quot;activeDate&quot;,&quot;selected&quot;,&quot;dateFilter&quot;,&quot;maxDate&quot;,&quot;minDate&quot;,&quot;dateClass&quot;,&quot;comparisonStart&quot;,&quot;comparisonEnd&quot;,&quot;activeDateChange&quot;,&quot;_userSelection&quot;,4,&quot;ngSwitchCase&quot;],[3,&quot;activeDate&quot;,&quot;selected&quot;,&quot;dateFilter&quot;,&quot;maxDate&quot;,&quot;minDate&quot;,&quot;dateClass&quot;,&quot;activeDateChange&quot;,&quot;monthSelected&quot;,&quot;selectedChange&quot;,4,&quot;ngSwitchCase&quot;],[3,&quot;activeDate&quot;,&quot;selected&quot;,&quot;dateFilter&quot;,&quot;maxDate&quot;,&quot;minDate&quot;,&quot;dateClass&quot;,&quot;activeDateChange&quot;,&quot;yearSelected&quot;,&quot;selectedChange&quot;,4,&quot;ngSwitchCase&quot;],[3,&quot;activeDate&quot;,&quot;selected&quot;,&quot;dateFilter&quot;,&quot;maxDate&quot;,&quot;minDate&quot;,&quot;dateClass&quot;,&quot;comparisonStart&quot;,&quot;comparisonEnd&quot;,&quot;activeDateChange&quot;,&quot;_userSelection&quot;],[3,&quot;activeDate&quot;,&quot;selected&quot;,&quot;dateFilter&quot;,&quot;maxDate&quot;,&quot;minDate&quot;,&quot;dateClass&quot;,&quot;activeDateChange&quot;,&quot;monthSelected&quot;,&quot;selectedChange&quot;],[3,&quot;activeDate&quot;,&quot;selected&quot;,&quot;dateFilter&quot;,&quot;maxDate&quot;,&quot;minDate&quot;,&quot;dateClass&quot;,&quot;activeDateChange&quot;,&quot;yearSelected&quot;,&quot;selectedChange&quot;]],template:function(e,i){1&amp;e&amp;&amp;(I(0,e7,0,0,&quot;ng-template&quot;,0),d(1,&quot;div&quot;,1),I(2,t7,1,8,&quot;mat-month-view&quot;,2),I(3,n7,1,6,&quot;mat-year-view&quot;,3),I(4,i7,1,6,&quot;mat-multi-year-view&quot;,4),h()),2&amp;e&amp;&amp;(w(&quot;cdkPortalOutlet&quot;,i._calendarHeaderPortal),y(1),w(&quot;ngSwitch&quot;,i.currentView),y(1),w(&quot;ngSwitchCase&quot;,&quot;month&quot;),y(1),w(&quot;ngSwitchCase&quot;,&quot;year&quot;),y(1),w(&quot;ngSwitchCase&quot;,&quot;multi-year&quot;))},directives:[mh,m1,Yo,Ju,_A,CA,yA],styles:[&#39;.mat-calendar{display:block}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:none}.mat-calendar-controls{display:flex;margin:5% calc(33% / 7 - 16px)}.mat-calendar-controls .mat-icon-button:hover .mat-button-focus-overlay{opacity:.04}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0}.mat-calendar-arrow{display:inline-block;width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top-width:5px;border-top-style:solid;margin:0 0 0 5px;vertical-align:middle}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}.mat-calendar-previous-button,.mat-calendar-next-button{position:relative}.mat-calendar-previous-button::after,.mat-calendar-next-button::after{top:0;left:0;right:0;bottom:0;position:absolute;content:&quot;&quot;;margin:15.5px;border:0 solid currentColor;border-top-width:2px}[dir=rtl] .mat-calendar-previous-button,[dir=rtl] .mat-calendar-next-button{transform:rotate(180deg)}.mat-calendar-previous-button::after{border-left-width:2px;transform:translateX(2px) rotate(-45deg)}.mat-calendar-next-button::after{border-right-width:2px;transform:translateX(-2px) rotate(45deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:&quot;&quot;;position:absolute;top:0;left:-8px;right:-8px;height:1px}.mat-calendar-abbr{text-decoration:none}\n&#39;],encapsulation:2,changeDetection:0}),n})();const DA={transformPanel:i_(&quot;transformPanel&quot;,[Zl(&quot;void =&gt; enter-dropdown&quot;,Ql(&quot;120ms cubic-bezier(0, 0, 0.2, 1)&quot;,E1([yi({opacity:0,transform:&quot;scale(1, 0.8)&quot;}),yi({opacity:1,transform:&quot;scale(1, 1)&quot;})]))),Zl(&quot;void =&gt; enter-dialog&quot;,Ql(&quot;150ms cubic-bezier(0, 0, 0.2, 1)&quot;,E1([yi({opacity:0,transform:&quot;scale(0.7)&quot;}),yi({transform:&quot;none&quot;,opacity:1})]))),Zl(&quot;* =&gt; void&quot;,Ql(&quot;100ms linear&quot;,yi({opacity:0})))]),fadeInCalendar:i_(&quot;fadeInCalendar&quot;,[r_(&quot;void&quot;,yi({opacity:0})),r_(&quot;enter&quot;,yi({opacity:1})),Zl(&quot;void =&gt; *&quot;,Ql(&quot;120ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)&quot;))])};let w7=0;const wA=new j(&quot;mat-datepicker-scroll-strategy&quot;),S7={provide:wA,deps:[rc],useFactory:function(n){return()=&gt;n.scrollStrategies.reposition()}},k7=N_(class{constructor(n){this._elementRef=n}});let M7=(()=&gt;{class n extends k7{constructor(e,i,r,s,o,a){super(e),this._changeDetectorRef=i,this._globalModel=r,this._dateAdapter=s,this._rangeSelectionStrategy=o,this._subscriptions=new ue,this._animationDone=new ie,this._actionsPortal=null,this._closeButtonText=a.closeCalendarLabel}ngOnInit(){this._model=this._actionsPortal?this._globalModel.clone():this._globalModel,this._animationState=this.datepicker.touchUi?&quot;enter-dialog&quot;:&quot;enter-dropdown&quot;}ngAfterViewInit(){this._subscriptions.add(this.datepicker.stateChanges.subscribe(()=&gt;{this._changeDetectorRef.markForCheck()})),this._calendar.focusActiveCell()}ngOnDestroy(){this._subscriptions.unsubscribe(),this._animationDone.complete()}_handleUserSelection(e){const i=this._model.selection,r=e.value,s=i instanceof $t;if(s&amp;&amp;this._rangeSelectionStrategy){const o=this._rangeSelectionStrategy.selectionFinished(r,i,e.event);this._model.updateSelection(o,this)}else r&amp;&amp;(s||!this._dateAdapter.sameDate(r,i))&amp;&amp;this._model.add(r);(!this._model||this._model.isComplete())&amp;&amp;!this._actionsPortal&amp;&amp;this.datepicker.close()}_startExitAnimation(){this._animationState=&quot;void&quot;,this._changeDetectorRef.markForCheck()}_getSelected(){return this._model.selection}_applyPendingSelection(){this._model!==this._globalModel&amp;&amp;this._globalModel.updateSelection(this._model.selection,this)}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(xt),_(qr),_(st),_(yh,8),_(sc))},n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-datepicker-content&quot;]],viewQuery:function(e,i){if(1&amp;e&amp;&amp;Pt(ny,5),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i._calendar=r.first)}},hostAttrs:[1,&quot;mat-datepicker-content&quot;],hostVars:3,hostBindings:function(e,i){1&amp;e&amp;&amp;fp(&quot;@transformPanel.done&quot;,function(){return i._animationDone.next()}),2&amp;e&amp;&amp;(mp(&quot;@transformPanel&quot;,i._animationState),Me(&quot;mat-datepicker-content-touch&quot;,i.datepicker.touchUi))},inputs:{color:&quot;color&quot;},exportAs:[&quot;matDatepickerContent&quot;],features:[se],decls:5,vars:20,consts:[[&quot;cdkTrapFocus&quot;,&quot;&quot;,1,&quot;mat-datepicker-content-container&quot;],[3,&quot;id&quot;,&quot;ngClass&quot;,&quot;startAt&quot;,&quot;startView&quot;,&quot;minDate&quot;,&quot;maxDate&quot;,&quot;dateFilter&quot;,&quot;headerComponent&quot;,&quot;selected&quot;,&quot;dateClass&quot;,&quot;comparisonStart&quot;,&quot;comparisonEnd&quot;,&quot;yearSelected&quot;,&quot;monthSelected&quot;,&quot;viewChanged&quot;,&quot;_userSelection&quot;],[3,&quot;cdkPortalOutlet&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;mat-raised-button&quot;,&quot;&quot;,1,&quot;mat-datepicker-close-button&quot;,3,&quot;color&quot;,&quot;focus&quot;,&quot;blur&quot;,&quot;click&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;mat-calendar&quot;,1),M(&quot;yearSelected&quot;,function(s){return i.datepicker._selectYear(s)})(&quot;monthSelected&quot;,function(s){return i.datepicker._selectMonth(s)})(&quot;viewChanged&quot;,function(s){return i.datepicker._viewChanged(s)})(&quot;_userSelection&quot;,function(s){return i._handleUserSelection(s)}),h(),I(2,r7,0,0,&quot;ng-template&quot;,2),d(3,&quot;button&quot;,3),M(&quot;focus&quot;,function(){return i._closeButtonFocused=!0})(&quot;blur&quot;,function(){return i._closeButtonFocused=!1})(&quot;click&quot;,function(){return i.datepicker.close()}),b(4),h(),h()),2&amp;e&amp;&amp;(Me(&quot;mat-datepicker-content-container-with-actions&quot;,i._actionsPortal),y(1),w(&quot;id&quot;,i.datepicker.id)(&quot;ngClass&quot;,i.datepicker.panelClass)(&quot;startAt&quot;,i.datepicker.startAt)(&quot;startView&quot;,i.datepicker.startView)(&quot;minDate&quot;,i.datepicker._getMinDate())(&quot;maxDate&quot;,i.datepicker._getMaxDate())(&quot;dateFilter&quot;,i.datepicker._getDateFilter())(&quot;headerComponent&quot;,i.datepicker.calendarHeaderComponent)(&quot;selected&quot;,i._getSelected())(&quot;dateClass&quot;,i.datepicker.dateClass)(&quot;comparisonStart&quot;,i.comparisonStart)(&quot;comparisonEnd&quot;,i.comparisonEnd)(&quot;@fadeInCalendar&quot;,&quot;enter&quot;),y(1),w(&quot;cdkPortalOutlet&quot;,i._actionsPortal),y(1),Me(&quot;cdk-visually-hidden&quot;,!i._closeButtonFocused),w(&quot;color&quot;,i.color||&quot;primary&quot;),y(1),nt(i._closeButtonText))},directives:[G4,ny,xg,mh,_h],styles:[&quot;.mat-datepicker-content{display:block;border-radius:4px}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content .mat-datepicker-close-button{position:absolute;top:100%;left:0;margin-top:8px}.ng-animating .mat-datepicker-content .mat-datepicker-close-button{display:none}.mat-datepicker-content-container{display:flex;flex-direction:column;justify-content:space-between}.mat-datepicker-content-touch{display:block;max-height:80vh;position:relative;overflow:visible}.mat-datepicker-content-touch .mat-datepicker-content-container{min-height:312px;max-height:788px;min-width:250px;max-width:750px}.mat-datepicker-content-touch .mat-calendar{width:100%;height:auto}@media all and (orientation: landscape){.mat-datepicker-content-touch .mat-datepicker-content-container{width:64vh;height:80vh}}@media all and (orientation: portrait){.mat-datepicker-content-touch .mat-datepicker-content-container{width:80vw;height:100vw}.mat-datepicker-content-touch .mat-datepicker-content-container-with-actions{height:115vw}}\n&quot;],encapsulation:2,data:{animation:[DA.transformPanel,DA.fadeInCalendar]},changeDetection:0}),n})(),js=(()=&gt;{class n{constructor(e,i,r,s,o,a,l,c,u){this._overlay=i,this._ngZone=r,this._viewContainerRef=s,this._dateAdapter=a,this._dir=l,this._model=u,this._inputStateChanges=ue.EMPTY,this.startView=&quot;month&quot;,this._touchUi=!1,this.xPosition=&quot;start&quot;,this.yPosition=&quot;below&quot;,this._restoreFocus=!0,this.yearSelected=new U,this.monthSelected=new U,this.viewChanged=new U(!0),this.openedStream=new U,this.closedStream=new U,this._opened=!1,this.id=&quot;mat-datepicker-&quot;+w7++,this._focusedElementBeforeOpen=null,this._backdropHarnessClass=`${this.id}-backdrop`,this.stateChanges=new ie,this._scrollStrategy=o}get startAt(){return this._startAt||(this.datepickerInput?this.datepickerInput.getStartValue():null)}set startAt(e){this._startAt=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e))}get color(){return this._color||(this.datepickerInput?this.datepickerInput.getThemePalette():void 0)}set color(e){this._color=e}get touchUi(){return this._touchUi}set touchUi(e){this._touchUi=Ye(e)}get disabled(){return void 0===this._disabled&amp;&amp;this.datepickerInput?this.datepickerInput.disabled:!!this._disabled}set disabled(e){const i=Ye(e);i!==this._disabled&amp;&amp;(this._disabled=i,this.stateChanges.next(void 0))}get restoreFocus(){return this._restoreFocus}set restoreFocus(e){this._restoreFocus=Ye(e)}get panelClass(){return this._panelClass}set panelClass(e){this._panelClass=function(n,t=/\s+/){const e=[];if(null!=n){const i=Array.isArray(n)?n:`${n}`.split(t);for(const r of i){const s=`${r}`.trim();s&amp;&amp;e.push(s)}}return e}(e)}get opened(){return this._opened}set opened(e){Ye(e)?this.open():this.close()}_getMinDate(){return this.datepickerInput&amp;&amp;this.datepickerInput.min}_getMaxDate(){return this.datepickerInput&amp;&amp;this.datepickerInput.max}_getDateFilter(){return this.datepickerInput&amp;&amp;this.datepickerInput.dateFilter}ngOnChanges(e){const i=e.xPosition||e.yPosition;if(i&amp;&amp;!i.firstChange&amp;&amp;this._overlayRef){const r=this._overlayRef.getConfig().positionStrategy;r instanceof Y_&amp;&amp;(this._setConnectedPositions(r),this.opened&amp;&amp;this._overlayRef.updatePosition())}this.stateChanges.next(void 0)}ngOnDestroy(){this._destroyOverlay(),this.close(),this._inputStateChanges.unsubscribe(),this.stateChanges.complete()}select(e){this._model.add(e)}_selectYear(e){this.yearSelected.emit(e)}_selectMonth(e){this.monthSelected.emit(e)}_viewChanged(e){this.viewChanged.emit(e)}registerInput(e){return this._inputStateChanges.unsubscribe(),this.datepickerInput=e,this._inputStateChanges=e.stateChanges.subscribe(()=&gt;this.stateChanges.next(void 0)),this._model}registerActions(e){this._actionsPortal=e}removeActions(e){e===this._actionsPortal&amp;&amp;(this._actionsPortal=null)}open(){this._opened||this.disabled||(this._focusedElementBeforeOpen=n1(),this._openOverlay(),this._opened=!0,this.openedStream.emit())}close(){if(!this._opened)return;if(this._componentRef){const i=this._componentRef.instance;i._startExitAnimation(),i._animationDone.pipe(rn(1)).subscribe(()=&gt;this._destroyOverlay())}const e=()=&gt;{this._opened&amp;&amp;(this._opened=!1,this.closedStream.emit(),this._focusedElementBeforeOpen=null)};this._restoreFocus&amp;&amp;this._focusedElementBeforeOpen&amp;&amp;&quot;function&quot;==typeof this._focusedElementBeforeOpen.focus?(this._focusedElementBeforeOpen.focus(),setTimeout(e)):e()}_applyPendingSelection(){var e,i;null===(i=null===(e=this._componentRef)||void 0===e?void 0:e.instance)||void 0===i||i._applyPendingSelection()}_forwardContentValues(e){e.datepicker=this,e.color=this.color,e._actionsPortal=this._actionsPortal}_openOverlay(){this._destroyOverlay();const e=this.touchUi,i=this.datepickerInput.getOverlayLabelId(),r=new $_(M7,this._viewContainerRef),s=this._overlayRef=this._overlay.create(new W_({positionStrategy:e?this._getDialogStrategy():this._getDropdownStrategy(),hasBackdrop:!0,backdropClass:[e?&quot;cdk-overlay-dark-backdrop&quot;:&quot;mat-overlay-transparent-backdrop&quot;,this._backdropHarnessClass],direction:this._dir,scrollStrategy:e?this._overlay.scrollStrategies.block():this._scrollStrategy(),panelClass:&quot;mat-datepicker-&quot;+(e?&quot;dialog&quot;:&quot;popup&quot;)})),o=s.overlayElement;o.setAttribute(&quot;role&quot;,&quot;dialog&quot;),i&amp;&amp;o.setAttribute(&quot;aria-labelledby&quot;,i),e&amp;&amp;o.setAttribute(&quot;aria-modal&quot;,&quot;true&quot;),this._getCloseStream(s).subscribe(a=&gt;{a&amp;&amp;a.preventDefault(),this.close()}),this._componentRef=s.attach(r),this._forwardContentValues(this._componentRef.instance),e||this._ngZone.onStable.pipe(rn(1)).subscribe(()=&gt;s.updatePosition())}_destroyOverlay(){this._overlayRef&amp;&amp;(this._overlayRef.dispose(),this._overlayRef=this._componentRef=null)}_getDialogStrategy(){return this._overlay.position().global().centerHorizontally().centerVertically()}_getDropdownStrategy(){const e=this._overlay.position().flexibleConnectedTo(this.datepickerInput.getConnectedOverlayOrigin()).withTransformOriginOn(&quot;.mat-datepicker-content&quot;).withFlexibleDimensions(!1).withViewportMargin(8).withLockedPosition();return this._setConnectedPositions(e)}_setConnectedPositions(e){const i=&quot;end&quot;===this.xPosition?&quot;end&quot;:&quot;start&quot;,r=&quot;start&quot;===i?&quot;end&quot;:&quot;start&quot;,s=&quot;above&quot;===this.yPosition?&quot;bottom&quot;:&quot;top&quot;,o=&quot;top&quot;===s?&quot;bottom&quot;:&quot;top&quot;;return e.withPositions([{originX:i,originY:o,overlayX:i,overlayY:s},{originX:i,originY:s,overlayX:i,overlayY:o},{originX:r,originY:o,overlayX:r,overlayY:s},{originX:r,originY:s,overlayX:r,overlayY:o}])}_getCloseStream(e){return Ci(e.backdropClick(),e.detachments(),e.keydownEvents().pipe(cn(i=&gt;27===i.keyCode&amp;&amp;!Gl(i)||this.datepickerInput&amp;&amp;Gl(i,&quot;altKey&quot;)&amp;&amp;38===i.keyCode)))}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(rc),_(Y),_(Rt),_(wA),_(st,8),_(Bi,8),_(W,8),_(qr))},n.\u0275dir=O({type:n,inputs:{startView:&quot;startView&quot;,xPosition:&quot;xPosition&quot;,yPosition:&quot;yPosition&quot;,startAt:&quot;startAt&quot;,color:&quot;color&quot;,touchUi:&quot;touchUi&quot;,disabled:&quot;disabled&quot;,restoreFocus:&quot;restoreFocus&quot;,panelClass:&quot;panelClass&quot;,opened:&quot;opened&quot;,calendarHeaderComponent:&quot;calendarHeaderComponent&quot;,dateClass:&quot;dateClass&quot;},outputs:{yearSelected:&quot;yearSelected&quot;,monthSelected:&quot;monthSelected&quot;,viewChanged:&quot;viewChanged&quot;,openedStream:&quot;opened&quot;,closedStream:&quot;closed&quot;},features:[je]}),n})(),iy=(()=&gt;{class n extends js{}return n.\u0275fac=function(){let t;return function(i){return(t||(t=Et(n)))(i||n)}}(),n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-datepicker&quot;]],exportAs:[&quot;matDatepicker&quot;],features:[ce([mA,{provide:js,useExisting:n}]),se],decls:0,vars:0,template:function(e,i){},encapsulation:2,changeDetection:0}),n})();class vh{constructor(t,e){this.target=t,this.targetElement=e,this.value=this.target.value}}let EA=(()=&gt;{class n{constructor(e,i,r){this._elementRef=e,this._dateAdapter=i,this._dateFormats=r,this.dateChange=new U,this.dateInput=new U,this.stateChanges=new ie,this._onTouched=()=&gt;{},this._validatorOnChange=()=&gt;{},this._cvaOnChange=()=&gt;{},this._valueChangesSubscription=ue.EMPTY,this._localeSubscription=ue.EMPTY,this._parseValidator=()=&gt;this._lastValueValid?null:{matDatepickerParse:{text:this._elementRef.nativeElement.value}},this._filterValidator=s=&gt;{const o=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(s.value));return!o||this._matchesFilter(o)?null:{matDatepickerFilter:!0}},this._minValidator=s=&gt;{const o=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(s.value)),a=this._getMinDate();return!a||!o||this._dateAdapter.compareDate(a,o)&lt;=0?null:{matDatepickerMin:{min:a,actual:o}}},this._maxValidator=s=&gt;{const o=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(s.value)),a=this._getMaxDate();return!a||!o||this._dateAdapter.compareDate(a,o)&gt;=0?null:{matDatepickerMax:{max:a,actual:o}}},this._lastValueValid=!1,this._localeSubscription=i.localeChanges.subscribe(()=&gt;{this._assignValueProgrammatically(this.value)})}get value(){return this._model?this._getValueFromModel(this._model.selection):this._pendingValue}set value(e){this._assignValueProgrammatically(e)}get disabled(){return!!this._disabled||this._parentDisabled()}set disabled(e){const i=Ye(e),r=this._elementRef.nativeElement;this._disabled!==i&amp;&amp;(this._disabled=i,this.stateChanges.next(void 0)),i&amp;&amp;this._isInitialized&amp;&amp;r.blur&amp;&amp;r.blur()}_getValidators(){return[this._parseValidator,this._minValidator,this._maxValidator,this._filterValidator]}_registerModel(e){this._model=e,this._valueChangesSubscription.unsubscribe(),this._pendingValue&amp;&amp;this._assignValue(this._pendingValue),this._valueChangesSubscription=this._model.selectionChanged.subscribe(i=&gt;{if(this._shouldHandleChangeEvent(i)){const r=this._getValueFromModel(i.selection);this._lastValueValid=this._isValidValue(r),this._cvaOnChange(r),this._onTouched(),this._formatValue(r),this.dateInput.emit(new vh(this,this._elementRef.nativeElement)),this.dateChange.emit(new vh(this,this._elementRef.nativeElement))}})}ngAfterViewInit(){this._isInitialized=!0}ngOnChanges(e){(function(n,t){const e=Object.keys(n);for(let i of e){const{previousValue:r,currentValue:s}=n[i];if(!t.isDateInstance(r)||!t.isDateInstance(s))return!0;if(!t.sameDate(r,s))return!0}return!1})(e,this._dateAdapter)&amp;&amp;this.stateChanges.next(void 0)}ngOnDestroy(){this._valueChangesSubscription.unsubscribe(),this._localeSubscription.unsubscribe(),this.stateChanges.complete()}registerOnValidatorChange(e){this._validatorOnChange=e}validate(e){return this._validator?this._validator(e):null}writeValue(e){this._assignValueProgrammatically(e)}registerOnChange(e){this._cvaOnChange=e}registerOnTouched(e){this._onTouched=e}setDisabledState(e){this.disabled=e}_onKeydown(e){e.altKey&amp;&amp;40===e.keyCode&amp;&amp;!this._elementRef.nativeElement.readOnly&amp;&amp;(this._openPopup(),e.preventDefault())}_onInput(e){const i=this._lastValueValid;let r=this._dateAdapter.parse(e,this._dateFormats.parse.dateInput);this._lastValueValid=this._isValidValue(r),r=this._dateAdapter.getValidDateOrNull(r),this._dateAdapter.sameDate(r,this.value)?(e&amp;&amp;!this.value&amp;&amp;this._cvaOnChange(r),i!==this._lastValueValid&amp;&amp;this._validatorOnChange()):(this._assignValue(r),this._cvaOnChange(r),this.dateInput.emit(new vh(this,this._elementRef.nativeElement)))}_onChange(){this.dateChange.emit(new vh(this,this._elementRef.nativeElement))}_onBlur(){this.value&amp;&amp;this._formatValue(this.value),this._onTouched()}_formatValue(e){this._elementRef.nativeElement.value=e?this._dateAdapter.format(e,this._dateFormats.display.dateInput):&quot;&quot;}_assignValue(e){this._model?(this._assignValueToModel(e),this._pendingValue=null):this._pendingValue=e}_isValidValue(e){return!e||this._dateAdapter.isValid(e)}_parentDisabled(){return!1}_assignValueProgrammatically(e){e=this._dateAdapter.deserialize(e),this._lastValueValid=this._isValidValue(e),e=this._dateAdapter.getValidDateOrNull(e),this._assignValue(e),this._formatValue(e)}_matchesFilter(e){const i=this._getDateFilter();return!i||i(e)}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(st,8),_(Hi,8))},n.\u0275dir=O({type:n,inputs:{value:&quot;value&quot;,disabled:&quot;disabled&quot;},outputs:{dateChange:&quot;dateChange&quot;,dateInput:&quot;dateInput&quot;},features:[je]}),n})();const A7={provide:Cn,useExisting:Fe(()=&gt;ac),multi:!0},T7={provide:Dt,useExisting:Fe(()=&gt;ac),multi:!0};let ac=(()=&gt;{class n extends EA{constructor(e,i,r,s){super(e,i,r),this._formField=s,this._closedSubscription=ue.EMPTY,this._validator=od.compose(super._getValidators())}set matDatepicker(e){e&amp;&amp;(this._datepicker=e,this._closedSubscription=e.closedStream.subscribe(()=&gt;this._onTouched()),this._registerModel(e.registerInput(this)))}get min(){return this._min}set min(e){const i=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e));this._dateAdapter.sameDate(i,this._min)||(this._min=i,this._validatorOnChange())}get max(){return this._max}set max(e){const i=this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(e));this._dateAdapter.sameDate(i,this._max)||(this._max=i,this._validatorOnChange())}get dateFilter(){return this._dateFilter}set dateFilter(e){const i=this._matchesFilter(this.value);this._dateFilter=e,this._matchesFilter(this.value)!==i&amp;&amp;this._validatorOnChange()}getConnectedOverlayOrigin(){return this._formField?this._formField.getConnectedOverlayOrigin():this._elementRef}getOverlayLabelId(){return this._formField?this._formField.getLabelId():this._elementRef.nativeElement.getAttribute(&quot;aria-labelledby&quot;)}getThemePalette(){return this._formField?this._formField.color:void 0}getStartValue(){return this.value}ngOnDestroy(){super.ngOnDestroy(),this._closedSubscription.unsubscribe()}_openPopup(){this._datepicker&amp;&amp;this._datepicker.open()}_getValueFromModel(e){return e}_assignValueToModel(e){this._model&amp;&amp;this._model.updateSelection(e,this)}_getMinDate(){return this._min}_getMaxDate(){return this._max}_getDateFilter(){return this._dateFilter}_shouldHandleChangeEvent(e){return e.source!==this}}return n.\u0275fac=function(e){return new(e||n)(_(X),_(st,8),_(Hi,8),_(uh,8))},n.\u0275dir=O({type:n,selectors:[[&quot;input&quot;,&quot;matDatepicker&quot;,&quot;&quot;]],hostAttrs:[1,&quot;mat-datepicker-input&quot;],hostVars:6,hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;input&quot;,function(s){return i._onInput(s.target.value)})(&quot;change&quot;,function(){return i._onChange()})(&quot;blur&quot;,function(){return i._onBlur()})(&quot;keydown&quot;,function(s){return i._onKeydown(s)}),2&amp;e&amp;&amp;(Ar(&quot;disabled&quot;,i.disabled),Ce(&quot;aria-haspopup&quot;,i._datepicker?&quot;dialog&quot;:null)(&quot;aria-owns&quot;,(null==i._datepicker?null:i._datepicker.opened)&amp;&amp;i._datepicker.id||null)(&quot;min&quot;,i.min?i._dateAdapter.toIso8601(i.min):null)(&quot;max&quot;,i.max?i._dateAdapter.toIso8601(i.max):null)(&quot;data-mat-calendar&quot;,i._datepicker?i._datepicker.id:null))},inputs:{matDatepicker:&quot;matDatepicker&quot;,min:&quot;min&quot;,max:&quot;max&quot;,dateFilter:[&quot;matDatepickerFilter&quot;,&quot;dateFilter&quot;]},exportAs:[&quot;matDatepickerInput&quot;],features:[ce([A7,T7,{provide:GM,useExisting:n}]),se]}),n})(),I7=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=O({type:n,selectors:[[&quot;&quot;,&quot;matDatepickerToggleIcon&quot;,&quot;&quot;]]}),n})(),ry=(()=&gt;{class n{constructor(e,i,r){this._intl=e,this._changeDetectorRef=i,this._stateChanges=ue.EMPTY;const s=Number(r);this.tabIndex=s||0===s?s:null}get disabled(){return void 0===this._disabled&amp;&amp;this.datepicker?this.datepicker.disabled:!!this._disabled}set disabled(e){this._disabled=Ye(e)}ngOnChanges(e){e.datepicker&amp;&amp;this._watchStateChanges()}ngOnDestroy(){this._stateChanges.unsubscribe()}ngAfterContentInit(){this._watchStateChanges()}_open(e){this.datepicker&amp;&amp;!this.disabled&amp;&amp;(this.datepicker.open(),e.stopPropagation())}_watchStateChanges(){const e=this.datepicker?this.datepicker.stateChanges:G(),i=this.datepicker&amp;&amp;this.datepicker.datepickerInput?this.datepicker.datepickerInput.stateChanges:G(),r=this.datepicker?Ci(this.datepicker.openedStream,this.datepicker.closedStream):G();this._stateChanges.unsubscribe(),this._stateChanges=Ci(this._intl.changes,e,i,r).subscribe(()=&gt;this._changeDetectorRef.markForCheck())}}return n.\u0275fac=function(e){return new(e||n)(_(sc),_(xt),is(&quot;tabindex&quot;))},n.\u0275cmp=ee({type:n,selectors:[[&quot;mat-datepicker-toggle&quot;]],contentQueries:function(e,i,r){if(1&amp;e&amp;&amp;Xt(r,I7,5),2&amp;e){let s;Pe(s=Oe())&amp;&amp;(i._customIcon=s.first)}},viewQuery:function(e,i){if(1&amp;e&amp;&amp;Pt(s7,5),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i._button=r.first)}},hostAttrs:[1,&quot;mat-datepicker-toggle&quot;],hostVars:8,hostBindings:function(e,i){1&amp;e&amp;&amp;M(&quot;click&quot;,function(s){return i._open(s)}),2&amp;e&amp;&amp;(Ce(&quot;tabindex&quot;,null)(&quot;data-mat-calendar&quot;,i.datepicker?i.datepicker.id:null),Me(&quot;mat-datepicker-toggle-active&quot;,i.datepicker&amp;&amp;i.datepicker.opened)(&quot;mat-accent&quot;,i.datepicker&amp;&amp;&quot;accent&quot;===i.datepicker.color)(&quot;mat-warn&quot;,i.datepicker&amp;&amp;&quot;warn&quot;===i.datepicker.color))},inputs:{tabIndex:&quot;tabIndex&quot;,disabled:&quot;disabled&quot;,datepicker:[&quot;for&quot;,&quot;datepicker&quot;],ariaLabel:[&quot;aria-label&quot;,&quot;ariaLabel&quot;],disableRipple:&quot;disableRipple&quot;},exportAs:[&quot;matDatepickerToggle&quot;],features:[je],ngContentSelectors:l7,decls:4,vars:6,consts:[[&quot;mat-icon-button&quot;,&quot;&quot;,&quot;type&quot;,&quot;button&quot;,3,&quot;disabled&quot;,&quot;disableRipple&quot;],[&quot;button&quot;,&quot;&quot;],[&quot;class&quot;,&quot;mat-datepicker-toggle-default-icon&quot;,&quot;viewBox&quot;,&quot;0 0 24 24&quot;,&quot;width&quot;,&quot;24px&quot;,&quot;height&quot;,&quot;24px&quot;,&quot;fill&quot;,&quot;currentColor&quot;,&quot;focusable&quot;,&quot;false&quot;,4,&quot;ngIf&quot;],[&quot;viewBox&quot;,&quot;0 0 24 24&quot;,&quot;width&quot;,&quot;24px&quot;,&quot;height&quot;,&quot;24px&quot;,&quot;fill&quot;,&quot;currentColor&quot;,&quot;focusable&quot;,&quot;false&quot;,1,&quot;mat-datepicker-toggle-default-icon&quot;],[&quot;d&quot;,&quot;M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z&quot;]],template:function(e,i){1&amp;e&amp;&amp;(ri(a7),d(0,&quot;button&quot;,0,1),I(2,o7,2,0,&quot;svg&quot;,2),ht(3),h()),2&amp;e&amp;&amp;(w(&quot;disabled&quot;,i.disabled)(&quot;disableRipple&quot;,i.disableRipple),Ce(&quot;aria-haspopup&quot;,i.datepicker?&quot;dialog&quot;:null)(&quot;aria-label&quot;,i.ariaLabel||i._intl.openCalendarLabel)(&quot;tabindex&quot;,i.disabled?-1:i.tabIndex),y(2),w(&quot;ngIf&quot;,!i._customIcon))},directives:[_h,rt],styles:[&quot;.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-datepicker-toggle-default-icon{width:1em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-datepicker-toggle-default-icon{display:block;width:1.5em;height:1.5em}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-datepicker-toggle-default-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-datepicker-toggle-default-icon{margin:auto}.cdk-high-contrast-active .mat-datepicker-toggle-default-icon{color:CanvasText}\n&quot;],encapsulation:2,changeDetection:0}),n})(),O7=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[sc,S7],imports:[[Ko,q6,z6,e$,nA,qn],H_]}),n})(),Yr=(()=&gt;{class n{constructor(){this.jePovezava=!1,Ci(gr(window,&quot;offline&quot;).pipe(pe(()=&gt;!1)),gr(window,&quot;online&quot;).pipe(pe(()=&gt;!0)),new ye(e=&gt;{e.next(navigator.onLine),e.complete()})).subscribe(e=&gt;this.jePovezava=e)}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:n.\u0275fac,providedIn:&quot;root&quot;}),n})();function F7(n,t){if(1&amp;n){var e=Ue();d(0,&quot;a&quot;,11),M(&quot;keyup.enter&quot;,function(){return _e(e),T(3),Ee(1).previous()})(&quot;click&quot;,function(){return _e(e),T(3),Ee(1).previous()}),b(1),d(2,&quot;span&quot;,12),b(3),h(),h()}if(2&amp;n){var i=T(3);Ce(&quot;aria-label&quot;,i.previousLabel+&quot; &quot;+i.screenReaderPageLabel),y(1),de(&quot; &quot;,i.previousLabel,&quot; &quot;),y(2),nt(i.screenReaderPageLabel)}}function N7(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;span&quot;),b(1),d(2,&quot;span&quot;,12),b(3),h(),h()),2&amp;n){var e=T(3);y(1),de(&quot; &quot;,e.previousLabel,&quot; &quot;),y(2),nt(e.screenReaderPageLabel)}}function V7(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;li&quot;,8),I(1,F7,4,3,&quot;a&quot;,9),I(2,N7,4,2,&quot;span&quot;,10),h()),2&amp;n){T(2);var e=Ee(1);Me(&quot;disabled&quot;,e.isFirstPage()),y(1),w(&quot;ngIf&quot;,1&lt;e.getCurrent()),y(1),w(&quot;ngIf&quot;,e.isFirstPage())}}function L7(n,t){if(1&amp;n){var e=Ue();d(0,&quot;a&quot;,11),M(&quot;keyup.enter&quot;,function(){_e(e);var o=T().$implicit;return T(2),Ee(1).setCurrent(o.value)})(&quot;click&quot;,function(){_e(e);var o=T().$implicit;return T(2),Ee(1).setCurrent(o.value)}),d(1,&quot;span&quot;,12),b(2),h(),d(3,&quot;span&quot;),b(4),Ut(5,&quot;number&quot;),h(),h()}if(2&amp;n){var i=T().$implicit,r=T(2);y(2),de(&quot;&quot;,r.screenReaderPageLabel,&quot; &quot;),y(2),nt(&quot;...&quot;===i.label?i.label:xr(5,2,i.label,&quot;&quot;))}}function j7(n,t){if(1&amp;n&amp;&amp;(Xa(0),d(1,&quot;span&quot;,12),b(2),h(),d(3,&quot;span&quot;),b(4),Ut(5,&quot;number&quot;),h(),el()),2&amp;n){var e=T().$implicit,i=T(2);y(2),de(&quot;&quot;,i.screenReaderCurrentLabel,&quot; &quot;),y(2),nt(&quot;...&quot;===e.label?e.label:xr(5,2,e.label,&quot;&quot;))}}function B7(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;li&quot;),I(1,L7,6,5,&quot;a&quot;,9),I(2,j7,6,5,&quot;ng-container&quot;,10),h()),2&amp;n){var e=t.$implicit;T(2);var i=Ee(1);Me(&quot;current&quot;,i.getCurrent()===e.value)(&quot;ellipsis&quot;,&quot;...&quot;===e.label),y(1),w(&quot;ngIf&quot;,i.getCurrent()!==e.value),y(1),w(&quot;ngIf&quot;,i.getCurrent()===e.value)}}function U7(n,t){if(1&amp;n){var e=Ue();d(0,&quot;a&quot;,11),M(&quot;keyup.enter&quot;,function(){return _e(e),T(3),Ee(1).next()})(&quot;click&quot;,function(){return _e(e),T(3),Ee(1).next()}),b(1),d(2,&quot;span&quot;,12),b(3),h(),h()}if(2&amp;n){var i=T(3);Ce(&quot;aria-label&quot;,i.nextLabel+&quot; &quot;+i.screenReaderPageLabel),y(1),de(&quot; &quot;,i.nextLabel,&quot; &quot;),y(2),nt(i.screenReaderPageLabel)}}function H7(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;span&quot;),b(1),d(2,&quot;span&quot;,12),b(3),h(),h()),2&amp;n){var e=T(3);y(1),de(&quot; &quot;,e.nextLabel,&quot; &quot;),y(2),nt(e.screenReaderPageLabel)}}function z7(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;li&quot;,13),I(1,U7,4,3,&quot;a&quot;,9),I(2,H7,4,2,&quot;span&quot;,10),h()),2&amp;n){T(2);var e=Ee(1);Me(&quot;disabled&quot;,e.isLastPage()),y(1),w(&quot;ngIf&quot;,!e.isLastPage()),y(1),w(&quot;ngIf&quot;,e.isLastPage())}}function $7(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;ul&quot;,3),I(1,V7,3,4,&quot;li&quot;,4),d(2,&quot;li&quot;,5),b(3),h(),I(4,B7,3,6,&quot;li&quot;,6),I(5,z7,3,4,&quot;li&quot;,7),h()),2&amp;n){var e=T(),i=Ee(1);Me(&quot;responsive&quot;,e.responsive),Ce(&quot;aria-label&quot;,e.screenReaderPaginationLabel),y(1),w(&quot;ngIf&quot;,e.directionLinks),y(2),er(&quot; &quot;,i.getCurrent(),&quot; / &quot;,i.getLastPage(),&quot; &quot;),y(1),w(&quot;ngForOf&quot;,i.pages)(&quot;ngForTrackBy&quot;,e.trackByIndex),y(1),w(&quot;ngIf&quot;,e.directionLinks)}}var lc=function(){function n(){this.change=new U,this.instances={},this.DEFAULT_ID=&quot;DEFAULT_PAGINATION_ID&quot;}return n.prototype.defaultId=function(){return this.DEFAULT_ID},n.prototype.register=function(t){return null==t.id&amp;&amp;(t.id=this.DEFAULT_ID),this.instances[t.id]?this.updateInstance(t):(this.instances[t.id]=t,!0)},n.prototype.updateInstance=function(t){var e=!1;for(var i in this.instances[t.id])t[i]!==this.instances[t.id][i]&amp;&amp;(this.instances[t.id][i]=t[i],e=!0);return e},n.prototype.getCurrentPage=function(t){if(this.instances[t])return this.instances[t].currentPage},n.prototype.setCurrentPage=function(t,e){if(this.instances[t]){var i=this.instances[t];e&lt;=Math.ceil(i.totalItems/i.itemsPerPage)&amp;&amp;1&lt;=e&amp;&amp;(this.instances[t].currentPage=e,this.change.emit(t))}},n.prototype.setTotalItems=function(t,e){this.instances[t]&amp;&amp;0&lt;=e&amp;&amp;(this.instances[t].totalItems=e,this.change.emit(t))},n.prototype.setItemsPerPage=function(t,e){this.instances[t]&amp;&amp;(this.instances[t].itemsPerPage=e,this.change.emit(t))},n.prototype.getInstance=function(t){return void 0===t&amp;&amp;(t=this.DEFAULT_ID),this.instances[t]?this.clone(this.instances[t]):{}},n.prototype.clone=function(t){var e={};for(var i in t)t.hasOwnProperty(i)&amp;&amp;(e[i]=t[i]);return e},n.\u0275fac=function(e){return new(e||n)},n.\u0275prov=P({token:n,factory:function(t){return n.\u0275fac(t)}}),n}(),W7=function(n,t){if(&quot;object&quot;==typeof Reflect&amp;&amp;&quot;function&quot;==typeof Reflect.metadata)return Reflect.metadata(n,t)},q7=Number.MAX_SAFE_INTEGER,Y7=function(){function n(t){this.service=t,this.state={}}return n.prototype.transform=function(t,e){if(!(t instanceof Array)){var i=e.id||this.service.defaultId();return this.state[i]?this.state[i].slice:t}var a,l,r=e.totalItems&amp;&amp;e.totalItems!==t.length,s=this.createInstance(t,e),o=s.id,c=s.itemsPerPage,u=this.service.register(s);if(!r&amp;&amp;t instanceof Array){if(this.stateIsIdentical(o,t,a=(s.currentPage-1)*(c=+c||q7),l=a+c))return this.state[o].slice;var p=t.slice(a,l);return this.saveState(o,t,p,a,l),this.service.change.emit(o),p}return u&amp;&amp;this.service.change.emit(o),this.saveState(o,t,t,a,l),t},n.prototype.createInstance=function(t,e){return this.checkConfig(e),{id:null!=e.id?e.id:this.service.defaultId(),itemsPerPage:+e.itemsPerPage||0,currentPage:+e.currentPage||1,totalItems:+e.totalItems||t.length}},n.prototype.checkConfig=function(t){var i=[&quot;itemsPerPage&quot;,&quot;currentPage&quot;].filter(function(r){return!(r in t)});if(0&lt;i.length)throw new Error(&quot;PaginatePipe: Argument is missing the following required properties: &quot;+i.join(&quot;, &quot;))},n.prototype.saveState=function(t,e,i,r,s){this.state[t]={collection:e,size:e.length,slice:i,start:r,end:s}},n.prototype.stateIsIdentical=function(t,e,i,r){var s=this.state[t];return!!s&amp;&amp;!(s.size!==e.length||s.start!==i||s.end!==r)&amp;&amp;s.slice.every(function(a,l){return a===e[i+l]})},(n=function(n,t,e,i){var o,r=arguments.length,s=r&lt;3?t:null===i?i=Object.getOwnPropertyDescriptor(t,e):i;if(&quot;object&quot;==typeof Reflect&amp;&amp;&quot;function&quot;==typeof Reflect.decorate)s=Reflect.decorate(n,t,e,i);else for(var a=n.length-1;a&gt;=0;a--)(o=n[a])&amp;&amp;(s=(r&lt;3?o(s):r&gt;3?o(t,e,s):o(t,e))||s);return r&gt;3&amp;&amp;s&amp;&amp;Object.defineProperty(t,e,s),s}([W7(&quot;design:paramtypes&quot;,[lc])],n)).\u0275fac=function(e){return new(e||n)(_(lc,16))},n.\u0275pipe=at({name:&quot;paginate&quot;,type:n,pure:!1}),n}(),Yn=function(n,t,e,i){var o,r=arguments.length,s=r&lt;3?t:null===i?i=Object.getOwnPropertyDescriptor(t,e):i;if(&quot;object&quot;==typeof Reflect&amp;&amp;&quot;function&quot;==typeof Reflect.decorate)s=Reflect.decorate(n,t,e,i);else for(var a=n.length-1;a&gt;=0;a--)(o=n[a])&amp;&amp;(s=(r&lt;3?o(s):r&gt;3?o(t,e,s):o(t,e))||s);return r&gt;3&amp;&amp;s&amp;&amp;Object.defineProperty(t,e,s),s},sn=function(n,t){if(&quot;object&quot;==typeof Reflect&amp;&amp;&quot;function&quot;==typeof Reflect.metadata)return Reflect.metadata(n,t)};function sy(n){return!!n&amp;&amp;&quot;false&quot;!==n}var K7=function(){function n(){this.maxSize=7,this.previousLabel=&quot;Previous&quot;,this.nextLabel=&quot;Next&quot;,this.screenReaderPaginationLabel=&quot;Pagination&quot;,this.screenReaderPageLabel=&quot;page&quot;,this.screenReaderCurrentLabel=&quot;You&#39;re on page&quot;,this.pageChange=new U,this.pageBoundsCorrection=new U,this._directionLinks=!0,this._autoHide=!1,this._responsive=!1}return Object.defineProperty(n.prototype,&quot;directionLinks&quot;,{get:function(){return this._directionLinks},set:function(t){this._directionLinks=sy(t)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,&quot;autoHide&quot;,{get:function(){return this._autoHide},set:function(t){this._autoHide=sy(t)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,&quot;responsive&quot;,{get:function(){return this._responsive},set:function(t){this._responsive=sy(t)},enumerable:!0,configurable:!0}),n.prototype.trackByIndex=function(t){return t},Yn([Vn(),sn(&quot;design:type&quot;,String)],n.prototype,&quot;id&quot;,void 0),Yn([Vn(),sn(&quot;design:type&quot;,Number)],n.prototype,&quot;maxSize&quot;,void 0),Yn([Vn(),sn(&quot;design:type&quot;,Boolean),sn(&quot;design:paramtypes&quot;,[Boolean])],n.prototype,&quot;directionLinks&quot;,null),Yn([Vn(),sn(&quot;design:type&quot;,Boolean),sn(&quot;design:paramtypes&quot;,[Boolean])],n.prototype,&quot;autoHide&quot;,null),Yn([Vn(),sn(&quot;design:type&quot;,Boolean),sn(&quot;design:paramtypes&quot;,[Boolean])],n.prototype,&quot;responsive&quot;,null),Yn([Vn(),sn(&quot;design:type&quot;,String)],n.prototype,&quot;previousLabel&quot;,void 0),Yn([Vn(),sn(&quot;design:type&quot;,String)],n.prototype,&quot;nextLabel&quot;,void 0),Yn([Vn(),sn(&quot;design:type&quot;,String)],n.prototype,&quot;screenReaderPaginationLabel&quot;,void 0),Yn([Vn(),sn(&quot;design:type&quot;,String)],n.prototype,&quot;screenReaderPageLabel&quot;,void 0),Yn([Vn(),sn(&quot;design:type&quot;,String)],n.prototype,&quot;screenReaderCurrentLabel&quot;,void 0),Yn([Au(),sn(&quot;design:type&quot;,U)],n.prototype,&quot;pageChange&quot;,void 0),Yn([Au(),sn(&quot;design:type&quot;,U)],n.prototype,&quot;pageBoundsCorrection&quot;,void 0),n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ee({type:n,selectors:[[&quot;pagination-controls&quot;]],inputs:{maxSize:&quot;maxSize&quot;,previousLabel:&quot;previousLabel&quot;,nextLabel:&quot;nextLabel&quot;,screenReaderPaginationLabel:&quot;screenReaderPaginationLabel&quot;,screenReaderPageLabel:&quot;screenReaderPageLabel&quot;,screenReaderCurrentLabel:&quot;screenReaderCurrentLabel&quot;,directionLinks:&quot;directionLinks&quot;,autoHide:&quot;autoHide&quot;,responsive:&quot;responsive&quot;,id:&quot;id&quot;},outputs:{pageChange:&quot;pageChange&quot;,pageBoundsCorrection:&quot;pageBoundsCorrection&quot;},decls:3,vars:3,consts:[[3,&quot;id&quot;,&quot;maxSize&quot;,&quot;pageChange&quot;,&quot;pageBoundsCorrection&quot;],[&quot;p&quot;,&quot;paginationApi&quot;],[&quot;class&quot;,&quot;ngx-pagination&quot;,3,&quot;responsive&quot;,4,&quot;ngIf&quot;],[1,&quot;ngx-pagination&quot;],[&quot;class&quot;,&quot;pagination-previous&quot;,3,&quot;disabled&quot;,4,&quot;ngIf&quot;],[1,&quot;small-screen&quot;],[3,&quot;current&quot;,&quot;ellipsis&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;,&quot;ngForTrackBy&quot;],[&quot;class&quot;,&quot;pagination-next&quot;,3,&quot;disabled&quot;,4,&quot;ngIf&quot;],[1,&quot;pagination-previous&quot;],[&quot;tabindex&quot;,&quot;0&quot;,3,&quot;keyup.enter&quot;,&quot;click&quot;,4,&quot;ngIf&quot;],[4,&quot;ngIf&quot;],[&quot;tabindex&quot;,&quot;0&quot;,3,&quot;keyup.enter&quot;,&quot;click&quot;],[1,&quot;show-for-sr&quot;],[1,&quot;pagination-next&quot;]],template:function(e,i){if(1&amp;e&amp;&amp;(d(0,&quot;pagination-template&quot;,0,1),M(&quot;pageChange&quot;,function(o){return i.pageChange.emit(o)})(&quot;pageBoundsCorrection&quot;,function(o){return i.pageBoundsCorrection.emit(o)}),I(2,$7,6,9,&quot;ul&quot;,2),h()),2&amp;e){var r=Ee(1);w(&quot;id&quot;,i.id)(&quot;maxSize&quot;,i.maxSize),y(2),w(&quot;ngIf&quot;,!(i.autoHide&amp;&amp;r.pages.length&lt;=1))}},directives:function(){return[Q7,rt,Fi]},pipes:function(){return[y0]},styles:[&quot;\n.ngx-pagination {\n  margin-left: 0;\n  margin-bottom: 1rem; }\n  .ngx-pagination::before, .ngx-pagination::after {\n    content: &#39; &#39;;\n    display: table; }\n  .ngx-pagination::after {\n    clear: both; }\n  .ngx-pagination li {\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    -ms-user-select: none;\n    margin-right: 0.0625rem;\n    border-radius: 0; }\n  .ngx-pagination li {\n    display: inline-block; }\n  .ngx-pagination a,\n  .ngx-pagination button {\n    color: #0a0a0a; \n    display: block;\n    padding: 0.1875rem 0.625rem;\n    border-radius: 0; }\n    .ngx-pagination a:hover,\n    .ngx-pagination button:hover {\n      background: #e6e6e6; }\n  .ngx-pagination .current {\n    padding: 0.1875rem 0.625rem;\n    background: #2199e8;\n    color: #fefefe;\n    cursor: default; }\n  .ngx-pagination .disabled {\n    padding: 0.1875rem 0.625rem;\n    color: #cacaca;\n    cursor: default; } \n    .ngx-pagination .disabled:hover {\n      background: transparent; }\n  .ngx-pagination a, .ngx-pagination button {\n    cursor: pointer; }\n\n.ngx-pagination .pagination-previous a::before,\n.ngx-pagination .pagination-previous.disabled::before { \n  content: &#39;\xab&#39;;\n  display: inline-block;\n  margin-right: 0.5rem; }\n\n.ngx-pagination .pagination-next a::after,\n.ngx-pagination .pagination-next.disabled::after {\n  content: &#39;\xbb&#39;;\n  display: inline-block;\n  margin-left: 0.5rem; }\n\n.ngx-pagination .show-for-sr {\n  position: absolute !important;\n  width: 1px;\n  height: 1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0); }\n.ngx-pagination .small-screen {\n  display: none; }\n@media screen and (max-width: 601px) {\n  .ngx-pagination.responsive .small-screen {\n    display: inline-block; } \n  .ngx-pagination.responsive li:not(.small-screen):not(.pagination-previous):not(.pagination-next) {\n    display: none; }\n}\n  &quot;],encapsulation:2,changeDetection:0}),n}(),cc=function(n,t,e,i){var o,r=arguments.length,s=r&lt;3?t:null===i?i=Object.getOwnPropertyDescriptor(t,e):i;if(&quot;object&quot;==typeof Reflect&amp;&amp;&quot;function&quot;==typeof Reflect.decorate)s=Reflect.decorate(n,t,e,i);else for(var a=n.length-1;a&gt;=0;a--)(o=n[a])&amp;&amp;(s=(r&lt;3?o(s):r&gt;3?o(t,e,s):o(t,e))||s);return r&gt;3&amp;&amp;s&amp;&amp;Object.defineProperty(t,e,s),s},uc=function(n,t){if(&quot;object&quot;==typeof Reflect&amp;&amp;&quot;function&quot;==typeof Reflect.metadata)return Reflect.metadata(n,t)},Q7=function(){function n(t,e){var i=this;this.service=t,this.changeDetectorRef=e,this.maxSize=7,this.pageChange=new U,this.pageBoundsCorrection=new U,this.pages=[],this.changeSub=this.service.change.subscribe(function(r){i.id===r&amp;&amp;(i.updatePageLinks(),i.changeDetectorRef.markForCheck(),i.changeDetectorRef.detectChanges())})}return n.prototype.ngOnInit=function(){void 0===this.id&amp;&amp;(this.id=this.service.defaultId()),this.updatePageLinks()},n.prototype.ngOnChanges=function(t){this.updatePageLinks()},n.prototype.ngOnDestroy=function(){this.changeSub.unsubscribe()},n.prototype.previous=function(){this.checkValidId(),this.setCurrent(this.getCurrent()-1)},n.prototype.next=function(){this.checkValidId(),this.setCurrent(this.getCurrent()+1)},n.prototype.isFirstPage=function(){return 1===this.getCurrent()},n.prototype.isLastPage=function(){return this.getLastPage()===this.getCurrent()},n.prototype.setCurrent=function(t){this.pageChange.emit(t)},n.prototype.getCurrent=function(){return this.service.getCurrentPage(this.id)},n.prototype.getLastPage=function(){var t=this.service.getInstance(this.id);return t.totalItems&lt;1?1:Math.ceil(t.totalItems/t.itemsPerPage)},n.prototype.getTotalItems=function(){return this.service.getInstance(this.id).totalItems},n.prototype.checkValidId=function(){null==this.service.getInstance(this.id).id&amp;&amp;console.warn(&#39;PaginationControlsDirective: the specified id &quot;&#39;+this.id+&#39;&quot; does not match any registered PaginationInstance&#39;)},n.prototype.updatePageLinks=function(){var t=this,e=this.service.getInstance(this.id),i=this.outOfBoundCorrection(e);i!==e.currentPage?setTimeout(function(){t.pageBoundsCorrection.emit(i),t.pages=t.createPageArray(e.currentPage,e.itemsPerPage,e.totalItems,t.maxSize)}):this.pages=this.createPageArray(e.currentPage,e.itemsPerPage,e.totalItems,this.maxSize)},n.prototype.outOfBoundCorrection=function(t){var e=Math.ceil(t.totalItems/t.itemsPerPage);return e&lt;t.currentPage&amp;&amp;0&lt;e?e:t.currentPage&lt;1?1:t.currentPage},n.prototype.createPageArray=function(t,e,i,r){r=+r;for(var s=[],o=Math.max(Math.ceil(i/e),1),a=Math.ceil(r/2),l=t&lt;=a,c=o-a&lt;t,u=!l&amp;&amp;!c,f=r&lt;o,p=1;p&lt;=o&amp;&amp;p&lt;=r;){var m=this.calculatePageNumber(p,t,r,o);s.push({label:f&amp;&amp;(2===p&amp;&amp;(u||c)||p===r-1&amp;&amp;(u||l))?&quot;...&quot;:m,value:m}),p++}return s},n.prototype.calculatePageNumber=function(t,e,i,r){var s=Math.ceil(i/2);return t===i?r:1===t?t:i&lt;r?r-s&lt;e?r-i+t:s&lt;e?e-s+t:t:t},cc([Vn(),uc(&quot;design:type&quot;,String)],n.prototype,&quot;id&quot;,void 0),cc([Vn(),uc(&quot;design:type&quot;,Number)],n.prototype,&quot;maxSize&quot;,void 0),cc([Au(),uc(&quot;design:type&quot;,U)],n.prototype,&quot;pageChange&quot;,void 0),cc([Au(),uc(&quot;design:type&quot;,U)],n.prototype,&quot;pageBoundsCorrection&quot;,void 0),(n=cc([uc(&quot;design:paramtypes&quot;,[lc,xt])],n)).\u0275fac=function(e){return new(e||n)(_(lc),_(xt))},n.\u0275dir=O({type:n,selectors:[[&quot;pagination-template&quot;],[&quot;&quot;,&quot;pagination-template&quot;,&quot;&quot;]],inputs:{maxSize:&quot;maxSize&quot;,id:&quot;id&quot;},outputs:{pageChange:&quot;pageChange&quot;,pageBoundsCorrection:&quot;pageBoundsCorrection&quot;},exportAs:[&quot;paginationApi&quot;],features:[je]}),n}(),Z7=function(){function n(){}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[lc],imports:[[Ko]]}),n}();let oy=(()=&gt;{class n{transform(e,i){return i&amp;&amp;e?n.filter(e,i):e}static filter(e,i){const r=i.toLowerCase();function s(o,a){for(let l in o)if(null!==o[l]&amp;&amp;null!=o[l]&amp;&amp;(&quot;object&quot;==typeof o[l]&amp;&amp;s(o[l],a)||o[l].toString().toLowerCase().includes(r)))return!0;return!1}return e.filter(function(o){return s(o,i)})}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275pipe=at({name:&quot;filter&quot;,type:n,pure:!1}),n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),J7=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({}),n})(),MA=(()=&gt;{class n{transform(e){var i=new Date(e),r=new Date,s=(i.getMinutes()&lt;10?&quot;0&quot;:&quot;&quot;)+i.getMinutes(),o=i.getHours(),a=i.getMonth()+1,l=i.getDate(),c=i.getFullYear();return i.setHours(0,0,0,0)==r.setHours(0,0,0,0)?l+&quot;.&quot;+a+&quot;.&quot;+c+&quot; &quot;+o+&quot;:&quot;+s:l+&quot;.&quot;+a+&quot;.&quot;+c}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275pipe=at({name:&quot;dateFormate&quot;,type:n,pure:!0}),n})(),X7=(()=&gt;{class n{transform(e){var i=JSON.parse(&quot;&quot;+localStorage.getItem(&quot;uporabnik&quot;));return i&amp;&amp;(i.created.includes(e)||i.joined.includes(e))}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275pipe=at({name:&quot;arrayIncludes&quot;,type:n,pure:!0}),n})();function eG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;ul&quot;,41),d(1,&quot;li&quot;,42),b(2),h(),h()),2&amp;n){const e=t.$implicit;y(2),de(&quot; &quot;,e,&quot; &quot;)}}function tG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;a&quot;,43),M(&quot;click&quot;,function(){_e(e);const r=T().$implicit,s=T();return s.jePovezava()&amp;&amp;s.loadChat(r._id)}),k(1,&quot;i&quot;,44),h()}2&amp;n&amp;&amp;w(&quot;id&quot;,T().$implicit._id)}function nG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;div&quot;,45),d(1,&quot;button&quot;,46),M(&quot;click&quot;,function(){_e(e);const r=T().$implicit;return T().donateEvent(r._id)}),b(2,&quot;Doniraj&quot;),h(),d(3,&quot;button&quot;,47),M(&quot;click&quot;,function(){_e(e);const r=T().$implicit;return T().leaveEvent(r._id)}),b(4,&quot;Odjavi se&quot;),h(),h()}if(2&amp;n){const e=T(2);y(1),w(&quot;disabled&quot;,!e.jePovezava()),y(2),w(&quot;disabled&quot;,!e.jePovezava())}}function iG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;div&quot;,45),d(1,&quot;a&quot;,48),M(&quot;click&quot;,function(){_e(e);const r=T().$implicit;return T().editEvent(r._id)}),b(2,&quot;Uredi&quot;),h(),d(3,&quot;button&quot;,49),M(&quot;click&quot;,function(){_e(e);const r=T().$implicit;return T().deleteEvent(r._id)}),b(4,&quot;Izbri\u0161i &quot;),h(),h()}if(2&amp;n){const e=T(2);y(1),Me(&quot;disabled&quot;,!e.jePovezava()),y(2),w(&quot;disabled&quot;,!e.jePovezava())}}function rG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;div&quot;,45),d(1,&quot;button&quot;,49),M(&quot;click&quot;,function(){_e(e);const r=T().$implicit;return T().deleteEvent(r._id)}),b(2,&quot;Izbri\u0161i &quot;),h(),h()}if(2&amp;n){const e=T(2);y(1),w(&quot;disabled&quot;,!e.jePovezava())}}function sG(n,t){1&amp;n&amp;&amp;k(0,&quot;div&quot;,45)}function oG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;div&quot;,45),d(1,&quot;button&quot;,50),M(&quot;click&quot;,function(){_e(e);const r=T().$implicit;return T().joinEvent(r._id)}),b(2,&quot;Pridru\u017ei se&quot;),h(),h()}if(2&amp;n){const e=T(2);y(1),w(&quot;disabled&quot;,!e.jePovezava())}}function aG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,17),d(1,&quot;div&quot;,18),d(2,&quot;div&quot;,19),d(3,&quot;div&quot;,20),d(4,&quot;div&quot;,21),k(5,&quot;img&quot;,22),h(),d(6,&quot;div&quot;,23),d(7,&quot;div&quot;,24),d(8,&quot;h5&quot;,25),b(9),h(),d(10,&quot;p&quot;,26),d(11,&quot;b&quot;),b(12,&quot;\u010cas dogodka: &quot;),h(),b(13),Ut(14,&quot;dateFormate&quot;),h(),d(15,&quot;p&quot;,26),d(16,&quot;b&quot;),b(17,&quot;Kraj dogodka: &quot;),h(),b(18),h(),d(19,&quot;p&quot;,27),d(20,&quot;b&quot;),b(21,&quot;Vremenska napoved: &quot;),h(),k(22,&quot;span&quot;,28),h(),d(23,&quot;div&quot;,29),I(24,eG,3,1,&quot;ul&quot;,30),h(),d(25,&quot;a&quot;,31),b(26,&quot;Ve\u010d &quot;),k(27,&quot;i&quot;,32),h(),h(),d(28,&quot;div&quot;,33),d(29,&quot;div&quot;,24),b(30),h(),h(),h(),d(31,&quot;div&quot;,34),d(32,&quot;p&quot;,35),d(33,&quot;b&quot;),b(34,&quot;\u0160tevilo oseb: &quot;),h(),b(35),k(36,&quot;i&quot;,36),I(37,tG,2,1,&quot;a&quot;,37),Ut(38,&quot;arrayIncludes&quot;),h(),k(39,&quot;img&quot;,38),I(40,nG,5,2,&quot;div&quot;,39),I(41,iG,5,3,&quot;div&quot;,39),I(42,rG,3,1,&quot;div&quot;,39),I(43,sG,1,0,&quot;div&quot;,39),I(44,oG,3,1,&quot;div&quot;,40),h(),h(),h(),h(),h()),2&amp;n){const e=t.$implicit;w(&quot;ngSwitch&quot;,e.buttons),y(5),vn(&quot;src&quot;,e.eventImage,Nt),y(4),nt(e.title),y(4),nt(ir(14,17,e.date)),y(5),er(&quot;&quot;,e.address,&quot;, &quot;,e.city,&quot;&quot;),y(6),w(&quot;ngForOf&quot;,e.tags),y(1),Ce(&quot;data-bs-target&quot;,&quot;#a&quot;+e._id),y(3),si(&quot;id&quot;,&quot;a&quot;,e._id,&quot;&quot;),y(2),de(&quot; &quot;,e.description,&quot; &quot;),y(5),de(&quot; &quot;,e.participantMax&gt;0?e.users.length+&quot;/&quot;+e.participantMax:e.users.length,&quot; &quot;),y(2),w(&quot;ngIf&quot;,ir(38,19,e._id)),y(2),vn(&quot;src&quot;,e.eventWeather,Nt),y(1),w(&quot;ngSwitchCase&quot;,&quot;joined&quot;),y(1),w(&quot;ngSwitchCase&quot;,&quot;created&quot;),y(1),w(&quot;ngSwitchCase&quot;,&quot;admin&quot;),y(1),w(&quot;ngSwitchCase&quot;,&quot;gost&quot;)}}const lG=function(n,t,e){return{itemsPerPage:n,currentPage:t,totalItems:e}};let dc=(()=&gt;{class n{constructor(e,i,r,s){this.router=e,this.dogodkiService=i,this.uporabnikService=r,this.povezavaStoritev=s,this.dogodki=[],this.page=&quot;all&quot;,this.searchword=&quot;&quot;,this.pageNumber=1,this.totalEvents=0,this.pageSize=10,this.useFilter=!1}ngOnInit(){}ngOnChanges(e){e.dogodki&amp;&amp;this.eventButtons(this.uporabnikService.getLoggedUser(),this.dogodki)}orderBy(e,i){var r=e.target.value,s=1;&quot;-&quot;===r.charAt(0)&amp;&amp;(s=-1,r=r.substring(1)),&quot;title&quot;===r?i.sort((o,a)=&gt;o.title&lt;a.title?-1*s:o.title&gt;a.title?1*s:0):&quot;date&quot;===r&amp;&amp;i.sort((o,a)=&gt;o.date&lt;a.date?-1*s:o.date&gt;a.date?1*s:0)}eventButtons(e,i){i.forEach(&quot;admin&quot;==this.page?r=&gt;{r.buttons=&quot;admin&quot;}:&quot;gost&quot;==this.page?r=&gt;{r.buttons=&quot;gost&quot;}:r=&gt;{r.buttons=&quot;none&quot;;for(var s=0;s&lt;e.created.length;s++)r._id===e.created[s]&amp;&amp;(r.buttons=&quot;created&quot;);for(s=0;s&lt;e.joined.length;s++)r._id===e.joined[s]&amp;&amp;(r.buttons=&quot;joined&quot;)}),this.dogodki=i}eventSetWeather(e){e.forEach(i=&gt;{var r=this.dateDiff(i.date);this.dogodkiService.dogodekVreme(i.coordinates).subscribe(s=&gt;i.eventWeather=`assets/images/weather/${s.daily[r].weather[0].main}.png`)})}dateDiff(e){let i=new Date(e),r=new Date,s=Math.floor((i.getTime()-r.getTime())/1e3/60/60/24)+1;return s=s&gt;7?7:s&lt;0?0:s,s}editEvent(e){this.router.navigate([`/uredi_dogodek/${e}`])}loadChat(e){this.router.navigate([`/klepet/${e}`])}deleteEvent(e){this.dogodkiService.deleteDogodek(e).subscribe(()=&gt;{let i=this.uporabnikService.getLoggedUser();i.created.splice(i.created.indexOf(e),1),this.dogodki.splice(this.dogodki.findIndex(r=&gt;r._id==e),1),this.uporabnikService.setLoggedUser(i),this.eventButtons(this.uporabnikService.getLoggedUser(),this.dogodki)})}joinEvent(e){this.dogodkiService.joinDogodek(e).subscribe(i=&gt;{let r=this.uporabnikService.getLoggedUser(),s=this.dogodki.findIndex(o=&gt;o._id==e);this.dogodki[s]=i,r.joined.push(e),this.uporabnikService.setLoggedUser(r),this.eventButtons(this.uporabnikService.getLoggedUser(),this.dogodki)})}leaveEvent(e){this.dogodkiService.leaveDogodek(e).subscribe(i=&gt;{let r=this.uporabnikService.getLoggedUser();switch(r.joined.splice(r.joined.indexOf(e),1),this.uporabnikService.setLoggedUser(r),this.page){case&quot;joined&quot;:this.dogodki.splice(this.dogodki.findIndex(o=&gt;o._id==i._id),1);break;default:let s=this.dogodki.findIndex(o=&gt;o._id==i._id);this.dogodki[s]=i}this.eventButtons(this.uporabnikService.getLoggedUser(),this.dogodki)})}openNav(){document.getElementById(&quot;main-sidebar-container&quot;).style.marginLeft=&quot;0%&quot;}handlePageChange(e){this.pageNumber=e,this.retrieveEvents()}retrieveEvents(){const e=this.getRequestParams(this.pageNumber,this.pageSize);switch(this.page){case&quot;created&quot;:this.dogodkiService.getUstvarjeniDogodki(e).subscribe(i=&gt;{this.dogodki=i.events,this.totalEvents=i.totalEvents,this.eventButtons(this.uporabnikService.getLoggedUser(),this.dogodki)},i=&gt;{console.log(i)});break;case&quot;joined&quot;:this.dogodkiService.getPridruzeniDogodki(e).subscribe(i=&gt;{this.dogodki=i.events,this.totalEvents=i.totalEvents,this.eventButtons(this.uporabnikService.getLoggedUser(),this.dogodki)},i=&gt;{console.log(i)});break;default:this.useFilter?(this.filters.page=this.pageNumber-1,this.filters.pageSize=this.pageSize?this.pageSize:10,this.dogodkiService.getDogodkiFiltered(this.filters).subscribe(i=&gt;{this.dogodki=i.events,this.totalEvents=i.totalEvents,this.eventButtons(this.uporabnikService.getLoggedUser(),this.dogodki)},i=&gt;{console.log(i)})):this.dogodkiService.getDogodki(e).subscribe(i=&gt;{this.dogodki=i.events,this.totalEvents=i.totalEvents,this.eventButtons(this.uporabnikService.getLoggedUser(),this.dogodki)},i=&gt;{console.log(i)})}}getRequestParams(e,i){let r={};return e&amp;&amp;(r.page=e-1),i&amp;&amp;(r.size=i),r}jePovezava(){return this.povezavaStoritev.jePovezava}donateEvent(e){}}return n.\u0275fac=function(e){return new(e||n)(_(Xe),_($r),_($n),_(Yr))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-seznam-dogodkov&quot;]],inputs:{dogodki:&quot;dogodki&quot;,page:&quot;page&quot;,totalEvents:&quot;totalEvents&quot;,pageSize:&quot;pageSize&quot;,filters:&quot;filters&quot;,useFilter:&quot;useFilter&quot;},features:[je],decls:24,vars:13,consts:[[1,&quot;row&quot;,&quot;mb-2&quot;,&quot;bg-light&quot;,&quot;pt-2&quot;,&quot;pb-2&quot;],[1,&quot;col-12&quot;,&quot;col-sm-6&quot;,&quot;mb-2&quot;,&quot;mb-sm-0&quot;,&quot;d-flex&quot;],[&quot;id&quot;,&quot;filterButton&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#main-sidebar-container&quot;,&quot;aria-controls&quot;,&quot;main-sidebar-container&quot;,1,&quot;btn&quot;,&quot;btn-outline-secondary&quot;,&quot;d-lg-none&quot;,2,&quot;margin-right&quot;,&quot;5px&quot;,3,&quot;click&quot;],[1,&quot;fas&quot;,&quot;fa-bars&quot;],[&quot;id&quot;,&quot;sortBy&quot;,1,&quot;form-select&quot;,&quot;form-control&quot;,&quot;w-75&quot;,&quot;w-md-100&quot;,3,&quot;change&quot;],[&quot;value&quot;,&quot;0&quot;,&quot;selected&quot;,&quot;&quot;],[&quot;value&quot;,&quot;title&quot;],[&quot;value&quot;,&quot;-title&quot;],[&quot;value&quot;,&quot;-date&quot;],[&quot;value&quot;,&quot;date&quot;],[1,&quot;col-12&quot;,&quot;col-sm-6&quot;],[1,&quot;input-group&quot;,&quot;w-75&quot;,&quot;w-md-100&quot;,&quot;float-end&quot;],[&quot;id&quot;,&quot;search&quot;,&quot;type&quot;,&quot;search&quot;,&quot;placeholder&quot;,&quot;I\u0161\u010di&quot;,1,&quot;form-control&quot;,&quot;end-0&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;aria-label&quot;,&quot;Search&quot;,&quot;onclick&quot;,&quot;search()&quot;,1,&quot;border-0&quot;,&quot;bg-transparent&quot;],[1,&quot;fas&quot;,&quot;fa-search&quot;,&quot;ms-2&quot;,&quot;end-0&quot;],[&quot;id&quot;,&quot;neki&quot;,3,&quot;ngSwitch&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[&quot;previousLabel&quot;,&quot;Nazaj&quot;,&quot;nextLabel&quot;,&quot;Naprej&quot;,3,&quot;responsive&quot;,&quot;pageChange&quot;],[&quot;id&quot;,&quot;neki&quot;,3,&quot;ngSwitch&quot;],[1,&quot;row&quot;],[1,&quot;card&quot;,&quot;event&quot;],[1,&quot;row&quot;,&quot;no-gutters&quot;],[1,&quot;col-md-3&quot;],[&quot;alt&quot;,&quot;assets/images/events/timetable.png&quot;,1,&quot;img-fluid&quot;,2,&quot;margin-top&quot;,&quot;10px&quot;,3,&quot;src&quot;],[1,&quot;col-md-6&quot;,&quot;event-body&quot;],[1,&quot;card-body&quot;],[1,&quot;card-title&quot;],[1,&quot;card-text&quot;],[1,&quot;card-text&quot;,&quot;d-md-none&quot;],[&quot;id&quot;,&quot;weather&quot;],[1,&quot;chip-div&quot;],[&quot;class&quot;,&quot;chip-list&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[&quot;role&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;aria-expanded&quot;,&quot;true&quot;,&quot;aria-label&quot;,&quot;Opis dogodka&quot;,1,&quot;btn&quot;,&quot;btn-success&quot;,&quot;text-success&quot;,&quot;border-0&quot;,&quot;mt-2&quot;,&quot;p-0&quot;,&quot;bg-transparent&quot;],[1,&quot;fas&quot;,&quot;fa-angle-down&quot;],[&quot;aria-labelledby&quot;,&quot;headingOne&quot;,1,&quot;collapse&quot;,3,&quot;id&quot;],[1,&quot;col-md-3&quot;,&quot;event-side&quot;,&quot;pt-0&quot;,&quot;pt-md-3&quot;,&quot;p-3&quot;,&quot;m-0&quot;,&quot;bottom-0&quot;],[1,&quot;m-0&quot;,&quot;mt-2&quot;,&quot;mt-md-0&quot;],[1,&quot;fas&quot;,&quot;fa-user-friends&quot;,&quot;me-2&quot;],[&quot;type&quot;,&quot;button&quot;,3,&quot;id&quot;,&quot;click&quot;,4,&quot;ngIf&quot;],[&quot;alt&quot;,&quot;&quot;,1,&quot;img-fluid&quot;,3,&quot;src&quot;],[&quot;class&quot;,&quot;joined-event-side&quot;,4,&quot;ngSwitchCase&quot;],[&quot;class&quot;,&quot;joined-event-side&quot;,4,&quot;ngSwitchDefault&quot;],[1,&quot;chip-list&quot;],[1,&quot;chip&quot;,&quot;me-1&quot;],[&quot;type&quot;,&quot;button&quot;,3,&quot;id&quot;,&quot;click&quot;],[1,&quot;bi&quot;,&quot;bi-chat-left-dots&quot;,&quot;fa-lg&quot;,&quot;mt-2&quot;,2,&quot;color&quot;,&quot;black&quot;],[1,&quot;joined-event-side&quot;],[&quot;type&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-success&quot;,&quot;event-side-button&quot;,&quot;mt-2&quot;,&quot;mt-md-0&quot;,3,&quot;disabled&quot;,&quot;click&quot;],[&quot;type&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-danger&quot;,&quot;event-side-button&quot;,&quot;ms-2&quot;,&quot;mt-2&quot;,&quot;mt-xxl-0&quot;,3,&quot;disabled&quot;,&quot;click&quot;],[&quot;role&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;event-side-button&quot;,&quot;mt-2&quot;,&quot;mt-xxl-0&quot;,3,&quot;click&quot;],[&quot;type&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-danger&quot;,&quot;event-side-button&quot;,&quot;delete-button&quot;,&quot;ms-2&quot;,&quot;mt-2&quot;,&quot;mt-xxl-0&quot;,3,&quot;disabled&quot;,&quot;click&quot;],[&quot;type&quot;,&quot;submit&quot;,1,&quot;btn&quot;,&quot;btn-success&quot;,&quot;event-side-button&quot;,3,&quot;disabled&quot;,&quot;click&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;button&quot;,2),M(&quot;click&quot;,function(){return i.openNav()}),k(3,&quot;i&quot;,3),h(),d(4,&quot;select&quot;,4),M(&quot;change&quot;,function(s){return i.orderBy(s,i.dogodki)}),d(5,&quot;option&quot;,5),b(6,&quot;Razvrsti po&quot;),h(),d(7,&quot;option&quot;,6),b(8,&quot;A-\u017d&quot;),h(),d(9,&quot;option&quot;,7),b(10,&quot;\u017d-A&quot;),h(),d(11,&quot;option&quot;,8),b(12,&quot;Datum padajo\u010de&quot;),h(),d(13,&quot;option&quot;,9),b(14,&quot;Datum nara\u0161\u010dajo\u010de&quot;),h(),h(),h(),d(15,&quot;div&quot;,10),d(16,&quot;div&quot;,11),d(17,&quot;input&quot;,12),M(&quot;ngModelChange&quot;,function(s){return i.searchword=s}),h(),d(18,&quot;button&quot;,13),k(19,&quot;i&quot;,14),h(),h(),h(),h(),I(20,aG,45,21,&quot;div&quot;,15),Ut(21,&quot;paginate&quot;),Ut(22,&quot;filter&quot;),d(23,&quot;pagination-controls&quot;,16),M(&quot;pageChange&quot;,function(s){return i.handlePageChange(s)}),h()),2&amp;e&amp;&amp;(y(17),w(&quot;ngModel&quot;,i.searchword),y(3),w(&quot;ngForOf&quot;,xr(21,3,xr(22,6,i.dogodki,i.searchword),Vw(9,lG,i.pageSize,i.pageNumber,i.totalEvents))),y(3),w(&quot;responsive&quot;,!0))},directives:[IS,RS,Bn,Vi,mi,Fi,K7,Yo,rt,Ju,g0],pipes:[Y7,oy,MA,X7],styles:[&quot;&quot;]}),n})();function cG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,45),k(1,&quot;app-seznam-dogodkov&quot;,46),h()),2&amp;n){const e=T();y(1),w(&quot;dogodki&quot;,e.dogodki)(&quot;totalEvents&quot;,e.totalEvents)(&quot;pageSize&quot;,e.pageSize)(&quot;filters&quot;,e.filters)(&quot;useFilter&quot;,e.filtered)}}let uG=(()=&gt;{class n{constructor(e){this.dogodkiService=e,this.filters={startDate:&quot;&quot;,endDate:&quot;&quot;,lokacija:&quot;&quot;,razdalja:5,lng:0,lat:0,page:0,pageSize:10},this.filtered=!1,this.pageSize=10,this.totalEvents=0}ngOnInit(){this.getDogodki()}getDogodki(){let e={page:0};e.size=this.pageSize?this.pageSize:10,this.dogodkiService.getDogodki(e).subscribe(i=&gt;(this.dogodki=i.events,this.totalEvents=i.totalEvents))}getDogodkiFiltered(){if(&quot;&quot;===this.filters.startDate){var e=new Date(2e3,0,1);this.filters.startDate=e.toDateString()}&quot;&quot;===this.filters.endDate&amp;&amp;(e=new Date(2030,0,1),this.filters.endDate=e.toDateString()),this.filters.page=0,this.filters.pageSize=this.pageSize?this.pageSize:10,console.log(this.filters),&quot;&quot;===this.filters.lokacija?this.dogodkiService.getDogodkiFiltered(this.filters).subscribe(i=&gt;(this.dogodki=i.events,console.log(i),this.totalEvents=i.totalEvents)):this.dogodkiService.dogodekLokacija(this.filters.lokacija).subscribe(i=&gt;{this.filters.lng=i[0].lon,this.filters.lat=i[0].lat,this.dogodkiService.getDogodkiFiltered(this.filters).subscribe(r=&gt;(this.dogodki=r.events,this.totalEvents=r.totalEvents))}),this.filtered=!0}closeNav(){document.getElementById(&quot;main-sidebar-container&quot;).style.marginLeft=&quot;-100%&quot;}}return n.\u0275fac=function(e){return new(e||n)(_($r))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-vsi-dogodki&quot;]],decls:111,vars:17,consts:[[&quot;id&quot;,&quot;main-sidebar-container&quot;,1,&quot;col-12&quot;,&quot;width&quot;,&quot;pull-left&quot;],[1,&quot;main-sidebar&quot;],[1,&quot;row&quot;],[1,&quot;card&quot;,2,&quot;min-height&quot;,&quot;812px&quot;],[1,&quot;card-header&quot;],[&quot;aria-label&quot;,&quot;Zapri Navigacijo&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#main-sidebar-container&quot;,&quot;aria-controls&quot;,&quot;main-sidebar-container&quot;,1,&quot;btn&quot;,&quot;btn-outline-secondary&quot;,&quot;float-end&quot;,3,&quot;click&quot;],[1,&quot;fas&quot;,&quot;fa-bars&quot;],[&quot;id&quot;,&quot;accordionPanelsStayOpenExample&quot;,1,&quot;accordion&quot;],[1,&quot;accordion-item&quot;],[&quot;id&quot;,&quot;panelsStayOpen-headingTwo&quot;,1,&quot;accordion-header&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#panelsStayOpen-collapseTwo&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-controls&quot;,&quot;panelsStayOpen-collapseTwo&quot;,1,&quot;accordion-button&quot;,&quot;collapsed&quot;],[&quot;id&quot;,&quot;panelsStayOpen-collapseTwo&quot;,&quot;aria-labelledby&quot;,&quot;panelsStayOpen-headingTwo&quot;,1,&quot;accordion-collapse&quot;,&quot;collapse&quot;],[1,&quot;accordion-body&quot;],[1,&quot;form-group&quot;],[&quot;for&quot;,&quot;locationInput&quot;,2,&quot;margin-bottom&quot;,&quot;0.5rem&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;name&quot;,&quot;location&quot;,&quot;id&quot;,&quot;locationFilter&quot;,&quot;placeholder&quot;,&quot;Izberi lokacijo&quot;,1,&quot;form-control&quot;,2,&quot;margin-bottom&quot;,&quot;0.5rem&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;for&quot;,&quot;range&quot;,1,&quot;form-label&quot;],[&quot;id&quot;,&quot;rangeSlider&quot;,&quot;type&quot;,&quot;range&quot;,&quot;value&quot;,&quot;5&quot;,&quot;min&quot;,&quot;5&quot;,&quot;max&quot;,&quot;50&quot;,&quot;step&quot;,&quot;5&quot;,&quot;id&quot;,&quot;locationRange&quot;,&quot;oninput&quot;,&quot;this.nextElementSibling.value = this.value&quot;,1,&quot;form-range&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;panelsStayOpen-headingThree&quot;,1,&quot;accordion-header&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#panelsStayOpen-collapseThree&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-controls&quot;,&quot;panelsStayOpen-collapseThree&quot;,1,&quot;accordion-button&quot;,&quot;collapsed&quot;],[&quot;id&quot;,&quot;panelsStayOpen-collapseThree&quot;,&quot;aria-labelledby&quot;,&quot;panelsStayOpen-headingThree&quot;,1,&quot;accordion-collapse&quot;,&quot;collapse&quot;],[&quot;for&quot;,&quot;startDate&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[&quot;appearance&quot;,&quot;fill&quot;,2,&quot;width&quot;,&quot;100%&quot;],[&quot;matInput&quot;,&quot;&quot;,3,&quot;matDatepicker&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;matSuffix&quot;,&quot;&quot;,3,&quot;for&quot;],[&quot;startDate2&quot;,&quot;&quot;],[&quot;for&quot;,&quot;endDate&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[&quot;endDate2&quot;,&quot;&quot;],[&quot;id&quot;,&quot;removeFilters&quot;,3,&quot;click&quot;],[1,&quot;btn&quot;,&quot;btn-danger&quot;,&quot;m-2&quot;,2,&quot;float&quot;,&quot;left&quot;],[&quot;id&quot;,&quot;filterButton&quot;],[1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;m-2&quot;,2,&quot;float&quot;,&quot;right&quot;,3,&quot;click&quot;],[1,&quot;container&quot;,&quot;mt-3&quot;],[1,&quot;row&quot;,&quot;m-0&quot;],[1,&quot;col-lg-3&quot;,&quot;ps-0&quot;,&quot;d-none&quot;,&quot;d-lg-block&quot;],[1,&quot;card&quot;],[&quot;id&quot;,&quot;panelsStayOpen-headingTwo2&quot;,1,&quot;accordion-header&quot;],[&quot;aria-label&quot;,&quot;Kraj Filter&quot;,&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#panelsStayOpen-collapseTwo2&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-controls&quot;,&quot;panelsStayOpen-collapseTwo2&quot;,1,&quot;accordion-button&quot;,&quot;collapsed&quot;],[&quot;id&quot;,&quot;panelsStayOpen-collapseTwo2&quot;,&quot;aria-labelledby&quot;,&quot;panelsStayOpen-headingTwo2&quot;,1,&quot;accordion-collapse&quot;,&quot;collapse&quot;],[&quot;id&quot;,&quot;panelsStayOpen-headingThree2&quot;,1,&quot;accordion-header&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#panelsStayOpen-collapseThree2&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-controls&quot;,&quot;panelsStayOpen-collapseThree2&quot;,1,&quot;accordion-button&quot;,&quot;collapsed&quot;],[&quot;id&quot;,&quot;panelsStayOpen-collapseThree2&quot;,&quot;aria-labelledby&quot;,&quot;panelsStayOpen-headingThree2&quot;,1,&quot;accordion-collapse&quot;,&quot;collapse&quot;],[&quot;startDate&quot;,&quot;&quot;],[&quot;endDate&quot;,&quot;&quot;],[&quot;class&quot;,&quot;col-lg-9 col-md-12&quot;,4,&quot;ngIf&quot;],[1,&quot;col-lg-9&quot;,&quot;col-md-12&quot;],[3,&quot;dogodki&quot;,&quot;totalEvents&quot;,&quot;pageSize&quot;,&quot;filters&quot;,&quot;useFilter&quot;]],template:function(e,i){if(1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),d(3,&quot;div&quot;,3),d(4,&quot;div&quot;,4),d(5,&quot;b&quot;),b(6,&quot;Filter&quot;),h(),d(7,&quot;button&quot;,5),M(&quot;click&quot;,function(){return i.closeNav()}),k(8,&quot;i&quot;,6),h(),h(),d(9,&quot;div&quot;,7),d(10,&quot;div&quot;,8),d(11,&quot;h2&quot;,9),d(12,&quot;button&quot;,10),b(13,&quot; Kraj &quot;),h(),h(),d(14,&quot;div&quot;,11),d(15,&quot;div&quot;,12),d(16,&quot;div&quot;,13),d(17,&quot;label&quot;,14),b(18,&quot;Kraj&quot;),h(),d(19,&quot;input&quot;,15),M(&quot;ngModelChange&quot;,function(s){return i.filters.lokacija=s}),h(),h(),d(20,&quot;label&quot;,16),b(21,&quot;Razdalja&quot;),h(),d(22,&quot;input&quot;,17),M(&quot;ngModelChange&quot;,function(s){return i.filters.razdalja=s}),h(),d(23,&quot;output&quot;),b(24,&quot;5&quot;),h(),b(25,&quot; km &quot;),h(),h(),h(),d(26,&quot;div&quot;,8),d(27,&quot;h2&quot;,18),d(28,&quot;button&quot;,19),b(29,&quot; Datum &quot;),h(),h(),d(30,&quot;div&quot;,20),d(31,&quot;div&quot;,12),d(32,&quot;label&quot;,21),b(33,&quot;Od:&quot;),h(),d(34,&quot;mat-form-field&quot;,22),d(35,&quot;mat-label&quot;),b(36,&quot;Choose a date&quot;),h(),d(37,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.filters.startDate=s}),h(),k(38,&quot;mat-datepicker-toggle&quot;,24),k(39,&quot;mat-datepicker&quot;,null,25),h(),d(41,&quot;label&quot;,26),b(42,&quot;Do:&quot;),h(),d(43,&quot;mat-form-field&quot;,22),d(44,&quot;mat-label&quot;),b(45,&quot;Choose a date&quot;),h(),d(46,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.filters.endDate=s}),h(),k(47,&quot;mat-datepicker-toggle&quot;,24),k(48,&quot;mat-datepicker&quot;,null,27),h(),h(),h(),h(),d(50,&quot;a&quot;,28),M(&quot;click&quot;,function(){return i.getDogodki()}),d(51,&quot;button&quot;,29),b(52,&quot;Po\u010disti&quot;),h(),h(),d(53,&quot;a&quot;,30),d(54,&quot;button&quot;,31),M(&quot;click&quot;,function(){return i.getDogodkiFiltered()}),b(55,&quot;Potrdi&quot;),h(),h(),h(),h(),h(),h(),h(),d(56,&quot;div&quot;,32),d(57,&quot;div&quot;,33),d(58,&quot;div&quot;,34),d(59,&quot;div&quot;,35),d(60,&quot;div&quot;,4),d(61,&quot;b&quot;),b(62,&quot;Filter&quot;),h(),h(),d(63,&quot;div&quot;,7),d(64,&quot;div&quot;,8),d(65,&quot;h2&quot;,36),d(66,&quot;button&quot;,37),b(67,&quot; Kraj &quot;),h(),h(),d(68,&quot;div&quot;,38),d(69,&quot;div&quot;,12),d(70,&quot;div&quot;,13),d(71,&quot;label&quot;,14),b(72,&quot;Kraj&quot;),h(),d(73,&quot;input&quot;,15),M(&quot;ngModelChange&quot;,function(s){return i.filters.lokacija=s}),h(),h(),d(74,&quot;label&quot;,16),b(75,&quot;Razdalja&quot;),h(),d(76,&quot;input&quot;,17),M(&quot;ngModelChange&quot;,function(s){return i.filters.razdalja=s}),h(),d(77,&quot;output&quot;),b(78,&quot;5&quot;),h(),b(79,&quot; km &quot;),h(),h(),h(),d(80,&quot;div&quot;,8),d(81,&quot;h2&quot;,39),d(82,&quot;button&quot;,40),b(83,&quot; Datum &quot;),h(),h(),d(84,&quot;div&quot;,41),d(85,&quot;div&quot;,12),d(86,&quot;label&quot;,21),b(87,&quot;Od:&quot;),h(),d(88,&quot;mat-form-field&quot;,22),d(89,&quot;mat-label&quot;),b(90,&quot;Choose a date&quot;),h(),d(91,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.filters.startDate=s}),h(),k(92,&quot;mat-datepicker-toggle&quot;,24),k(93,&quot;mat-datepicker&quot;,null,42),h(),d(95,&quot;label&quot;,26),b(96,&quot;Do:&quot;),h(),d(97,&quot;mat-form-field&quot;,22),d(98,&quot;mat-label&quot;),b(99,&quot;Choose a date&quot;),h(),d(100,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.filters.endDate=s}),h(),k(101,&quot;mat-datepicker-toggle&quot;,24),k(102,&quot;mat-datepicker&quot;,null,43),h(),h(),h(),h(),d(104,&quot;a&quot;,28),M(&quot;click&quot;,function(){return i.getDogodki()}),d(105,&quot;button&quot;,29),b(106,&quot;Po\u010disti&quot;),h(),h(),d(107,&quot;a&quot;,30),d(108,&quot;button&quot;,31),M(&quot;click&quot;,function(){return i.getDogodkiFiltered()}),b(109,&quot;Potrdi&quot;),h(),h(),h(),h(),h(),I(110,cG,2,5,&quot;div&quot;,44),h(),h()),2&amp;e){const r=Ee(40),s=Ee(49),o=Ee(94),a=Ee(103);y(19),w(&quot;ngModel&quot;,i.filters.lokacija),y(3),w(&quot;ngModel&quot;,i.filters.razdalja),y(15),w(&quot;matDatepicker&quot;,r)(&quot;ngModel&quot;,i.filters.startDate),y(1),w(&quot;for&quot;,r),y(8),w(&quot;matDatepicker&quot;,s)(&quot;ngModel&quot;,i.filters.endDate),y(1),w(&quot;for&quot;,s),y(26),w(&quot;ngModel&quot;,i.filters.lokacija),y(3),w(&quot;ngModel&quot;,i.filters.razdalja),y(15),w(&quot;matDatepicker&quot;,o)(&quot;ngModel&quot;,i.filters.startDate),y(1),w(&quot;for&quot;,o),y(8),w(&quot;matDatepicker&quot;,a)(&quot;ngModel&quot;,i.filters.endDate),y(1),w(&quot;for&quot;,a),y(9),w(&quot;ngIf&quot;,i.dogodki)}},directives:[Bn,Vi,mi,gd,j_,nc,U_,ac,ry,L_,iy,rt,dc],styles:[&quot;&quot;]}),n})();function dG(n,t){1&amp;n&amp;&amp;(d(0,&quot;a&quot;,8),k(1,&quot;i&quot;,9),b(2,&quot; Dodaj nov dogodek &quot;),h())}function hG(n,t){1&amp;n&amp;&amp;(d(0,&quot;a&quot;,10),k(1,&quot;i&quot;,9),b(2,&quot; Dodaj nov dogodek &quot;),h())}function fG(n,t){1&amp;n&amp;&amp;(d(0,&quot;a&quot;,11),k(1,&quot;i&quot;,12),b(2,&quot; Ustvarjeni dogodki &quot;),h())}function pG(n,t){1&amp;n&amp;&amp;(d(0,&quot;a&quot;,13),k(1,&quot;i&quot;,12),b(2,&quot; Ustvarjeni dogodki &quot;),h())}function gG(n,t){1&amp;n&amp;&amp;(d(0,&quot;a&quot;,14),k(1,&quot;i&quot;,15),b(2,&quot; Pridru\u017eeni dogodki &quot;),h())}function mG(n,t){1&amp;n&amp;&amp;(d(0,&quot;a&quot;,16),k(1,&quot;i&quot;,15),b(2,&quot; Pridru\u017eeni dogodki &quot;),h())}let ay=(()=&gt;{class n{constructor(){}ngOnInit(){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-dogodki-sidenav&quot;]],inputs:{selectedPage:&quot;selectedPage&quot;},decls:13,vars:6,consts:[[2,&quot;list-style-type&quot;,&quot;none&quot;],[1,&quot;nav-item&quot;,&quot;mb-1&quot;],[&quot;routerLink&quot;,&quot;/ustvari_dogodek&quot;,&quot;class&quot;,&quot;border nav-link active disabled bg-primary bg-gradient text-white&quot;,&quot;aria-current&quot;,&quot;page&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;normalNavLink&quot;,&quot;&quot;],[&quot;id&quot;,&quot;createdEventsNav&quot;,&quot;style&quot;,&quot;cursor: pointer;&quot;,&quot;routerLink&quot;,&quot;/ustvarjeni_dogodki&quot;,&quot;class&quot;,&quot;border nav-link active disabled bg-primary bg-gradient text-white&quot;,&quot;aria-current&quot;,&quot;page&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;normalNavLink2&quot;,&quot;&quot;],[&quot;id&quot;,&quot;joinedEventsNav&quot;,&quot;style&quot;,&quot;cursor: pointer;&quot;,&quot;routerLink&quot;,&quot;/pridruzeni_dogodki&quot;,&quot;class&quot;,&quot;border nav-link active disabled bg-primary bg-gradient text-white&quot;,&quot;aria-current&quot;,&quot;page&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;normalNavLink3&quot;,&quot;&quot;],[&quot;routerLink&quot;,&quot;/ustvari_dogodek&quot;,&quot;aria-current&quot;,&quot;page&quot;,1,&quot;border&quot;,&quot;nav-link&quot;,&quot;active&quot;,&quot;disabled&quot;,&quot;bg-primary&quot;,&quot;bg-gradient&quot;,&quot;text-white&quot;],[1,&quot;far&quot;,&quot;fa-calendar-plus&quot;],[&quot;routerLink&quot;,&quot;/ustvari_dogodek&quot;,&quot;aria-current&quot;,&quot;page&quot;,1,&quot;border&quot;,&quot;nav-link&quot;],[&quot;id&quot;,&quot;createdEventsNav&quot;,&quot;routerLink&quot;,&quot;/ustvarjeni_dogodki&quot;,&quot;aria-current&quot;,&quot;page&quot;,1,&quot;border&quot;,&quot;nav-link&quot;,&quot;active&quot;,&quot;disabled&quot;,&quot;bg-primary&quot;,&quot;bg-gradient&quot;,&quot;text-white&quot;,2,&quot;cursor&quot;,&quot;pointer&quot;],[1,&quot;fas&quot;,&quot;fa-edit&quot;],[&quot;id&quot;,&quot;createdEventsNav&quot;,&quot;routerLink&quot;,&quot;/ustvarjeni_dogodki&quot;,&quot;aria-current&quot;,&quot;page&quot;,1,&quot;border&quot;,&quot;nav-link&quot;,2,&quot;cursor&quot;,&quot;pointer&quot;],[&quot;id&quot;,&quot;joinedEventsNav&quot;,&quot;routerLink&quot;,&quot;/pridruzeni_dogodki&quot;,&quot;aria-current&quot;,&quot;page&quot;,1,&quot;border&quot;,&quot;nav-link&quot;,&quot;active&quot;,&quot;disabled&quot;,&quot;bg-primary&quot;,&quot;bg-gradient&quot;,&quot;text-white&quot;,2,&quot;cursor&quot;,&quot;pointer&quot;],[1,&quot;far&quot;,&quot;fa-calendar-check&quot;],[&quot;id&quot;,&quot;joinedEventsNav&quot;,&quot;routerLink&quot;,&quot;/pridruzeni_dogodki&quot;,&quot;aria-current&quot;,&quot;page&quot;,1,&quot;border&quot;,&quot;nav-link&quot;,2,&quot;cursor&quot;,&quot;pointer&quot;]],template:function(e,i){if(1&amp;e&amp;&amp;(d(0,&quot;ul&quot;,0),d(1,&quot;li&quot;,1),I(2,dG,3,0,&quot;a&quot;,2),I(3,hG,3,0,&quot;ng-template&quot;,null,3,Nn),h(),d(5,&quot;li&quot;,1),I(6,fG,3,0,&quot;a&quot;,4),I(7,pG,3,0,&quot;ng-template&quot;,null,5,Nn),h(),d(9,&quot;li&quot;,1),I(10,gG,3,0,&quot;a&quot;,6),I(11,mG,3,0,&quot;ng-template&quot;,null,7,Nn),h(),h()),2&amp;e){const r=Ee(4),s=Ee(8),o=Ee(12);y(2),w(&quot;ngIf&quot;,&quot;create&quot;==i.selectedPage)(&quot;ngIfElse&quot;,r),y(4),w(&quot;ngIf&quot;,&quot;created&quot;==i.selectedPage)(&quot;ngIfElse&quot;,s),y(4),w(&quot;ngIf&quot;,&quot;joined&quot;==i.selectedPage)(&quot;ngIfElse&quot;,o)}},directives:[rt,zn],styles:[&quot;&quot;]}),n})();function _G(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,11),k(1,&quot;app-seznam-dogodkov&quot;,12),h()),2&amp;n){const e=T();y(1),w(&quot;dogodki&quot;,e.dogodki)(&quot;page&quot;,&quot;joined&quot;)(&quot;totalEvents&quot;,e.totalEvents)(&quot;pageSize&quot;,e.pageSize)}}function yG(n,t){}let vG=(()=&gt;{class n{constructor(e){this.dogodkiService=e,this.pageSize=10,this.totalEvents=0}ngOnInit(){this.getPridruzeniDogodki()}getPridruzeniDogodki(){let e={page:0};e.size=this.pageSize?this.pageSize:10,this.dogodkiService.getPridruzeniDogodki(e).subscribe(i=&gt;(this.dogodki=i.events,this.totalEvents=i.totalEvents))}}return n.\u0275fac=function(e){return new(e||n)(_($r))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-pridruzeni-dogodki&quot;]],decls:12,vars:3,consts:[[1,&quot;container&quot;,&quot;mt-3&quot;],[1,&quot;row&quot;,&quot;m-0&quot;],[1,&quot;nav&quot;,&quot;nav-pills&quot;,&quot;col-lg-3&quot;,&quot;col-md-12&quot;,&quot;flex-column&quot;,&quot;m-0&quot;,&quot;mb-3&quot;,&quot;p-0&quot;,&quot;pe-lg-2&quot;],[3,&quot;selectedPage&quot;],[&quot;class&quot;,&quot;col-lg-9 col-md-12&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;class&quot;,&quot;col-lg-9 col-md-12&quot;],[&quot;noContent&quot;,&quot;&quot;],[1,&quot;nav&quot;,&quot;m-3&quot;],[&quot;routerLink&quot;,&quot;/ustvari_dogodek&quot;,1,&quot;nav-link&quot;,&quot;link-dark&quot;,&quot;add-event-float&quot;],[1,&quot;far&quot;,&quot;fa-calendar-plus&quot;],[1,&quot;&quot;],[1,&quot;col-lg-9&quot;,&quot;col-md-12&quot;],[3,&quot;dogodki&quot;,&quot;page&quot;,&quot;totalEvents&quot;,&quot;pageSize&quot;]],template:function(e,i){if(1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),k(3,&quot;app-dogodki-sidenav&quot;,3),h(),I(4,_G,2,4,&quot;div&quot;,4),I(5,yG,0,0,&quot;ng-template&quot;,5,6,Nn),d(7,&quot;div&quot;,7),d(8,&quot;a&quot;,8),k(9,&quot;div&quot;,9),d(10,&quot;div&quot;,10),b(11,&quot;Dodaj dogodek&quot;),h(),h(),h(),h(),h()),2&amp;e){const r=Ee(6);y(3),w(&quot;selectedPage&quot;,&quot;joined&quot;),y(1),w(&quot;ngIf&quot;,i.dogodki)(&quot;ngIfElse&quot;,r)}},directives:[ay,rt,zn,dc],styles:[&quot;&quot;]}),n})();function bG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;ul&quot;,8),d(1,&quot;li&quot;,9),d(2,&quot;a&quot;,15),M(&quot;click&quot;,function(){return _e(e),T().goDown()}),b(3,&quot;Kategorije&quot;),h(),h(),h()}}function CG(n,t){1&amp;n&amp;&amp;k(0,&quot;i&quot;,16)}let AA=(()=&gt;{class n{constructor(e,i,r){this.scroller=e,this.router=i,this.povezavaStoritev=r}ngOnInit(){}goDown(){this.scroller.scrollToAnchor(&quot;kategorije&quot;)}isHomeRoute(){return&quot;/&quot;==this.router.url}jePovezava(){return this.povezavaStoritev.jePovezava}}return n.\u0275fac=function(e){return new(e||n)(_(Ng),_(Xe),_(Yr))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-home-navbar&quot;]],decls:18,vars:2,consts:[[1,&quot;navbar&quot;,&quot;navbar-expand-lg&quot;,&quot;navbar-light&quot;,&quot;bg-light&quot;,&quot;static-top&quot;],[1,&quot;container&quot;],[&quot;routerLink&quot;,&quot;&quot;,1,&quot;navbar-brand&quot;,&quot;mt-lg-0&quot;],[&quot;src&quot;,&quot;assets/images/GoodMeetsLogo.png&quot;,&quot;alt&quot;,&quot;Logo&quot;,1,&quot;img-fluid&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#navbarSupportedContent&quot;,&quot;aria-controls&quot;,&quot;navbarSupportedContent&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-label&quot;,&quot;Toggle navigation&quot;,1,&quot;navbar-toggler&quot;,&quot;me-auto&quot;],[1,&quot;navbar-toggler-icon&quot;],[&quot;id&quot;,&quot;navbarSupportedContent&quot;,1,&quot;collapse&quot;,&quot;navbar-collapse&quot;,&quot;mt-2&quot;],[&quot;class&quot;,&quot;navbar-nav&quot;,4,&quot;ngIf&quot;],[1,&quot;navbar-nav&quot;],[1,&quot;nav-item&quot;],[&quot;routerLink&quot;,&quot;/dogodki_gost&quot;,1,&quot;nav-link&quot;,&quot;text-body&quot;],[1,&quot;d-flex&quot;,&quot;align-items-center&quot;],[&quot;class&quot;,&quot;fas fa-exclamation-triangle text-danger me-2&quot;,4,&quot;ngIf&quot;],[&quot;routerLink&quot;,&quot;/login&quot;,&quot;role&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-outline-primary&quot;,&quot;event-side-button&quot;,&quot;me-2&quot;],[&quot;routerLink&quot;,&quot;/signup&quot;,&quot;role&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;event-side-button&quot;,&quot;me-2&quot;],[1,&quot;nav-link&quot;,&quot;text-body&quot;,3,&quot;routerLink&quot;,&quot;click&quot;],[1,&quot;fas&quot;,&quot;fa-exclamation-triangle&quot;,&quot;text-danger&quot;,&quot;me-2&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;nav&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;a&quot;,2),k(3,&quot;img&quot;,3),h(),d(4,&quot;button&quot;,4),k(5,&quot;span&quot;,5),h(),d(6,&quot;div&quot;,6),I(7,bG,4,0,&quot;ul&quot;,7),d(8,&quot;ul&quot;,8),d(9,&quot;li&quot;,9),d(10,&quot;a&quot;,10),b(11,&quot;Dogodki&quot;),h(),h(),h(),h(),d(12,&quot;div&quot;,11),I(13,CG,1,0,&quot;i&quot;,12),d(14,&quot;a&quot;,13),b(15,&quot;Prijava&quot;),h(),d(16,&quot;a&quot;,14),b(17,&quot;Registracija&quot;),h(),h(),h(),h()),2&amp;e&amp;&amp;(y(7),w(&quot;ngIf&quot;,i.isHomeRoute()),y(6),w(&quot;ngIf&quot;,!i.jePovezava()))},directives:[zn,rt],styles:[&quot;&quot;]}),n})(),DG=(()=&gt;{class n{constructor(){}ngOnInit(){}scroll(e){e.scrollIntoView()}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-homepage&quot;]],decls:88,vars:0,consts:[[&quot;id&quot;,&quot;carouselExampleDark&quot;,&quot;data-interval&quot;,&quot;false&quot;,1,&quot;carousel&quot;,&quot;carousel-dark&quot;,&quot;slide&quot;],[1,&quot;carousel-indicators&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-target&quot;,&quot;#carouselExampleDark&quot;,&quot;data-bs-slide-to&quot;,&quot;0&quot;,&quot;aria-current&quot;,&quot;true&quot;,&quot;aria-label&quot;,&quot;Slide 1&quot;,1,&quot;active&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-target&quot;,&quot;#carouselExampleDark&quot;,&quot;data-bs-slide-to&quot;,&quot;1&quot;,&quot;aria-label&quot;,&quot;Slide 2&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-target&quot;,&quot;#carouselExampleDark&quot;,&quot;data-bs-slide-to&quot;,&quot;2&quot;,&quot;aria-label&quot;,&quot;Slide 3&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-target&quot;,&quot;#carouselExampleDark&quot;,&quot;data-bs-slide-to&quot;,&quot;3&quot;,&quot;aria-label&quot;,&quot;Slide 4&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-target&quot;,&quot;#carouselExampleDark&quot;,&quot;data-bs-slide-to&quot;,&quot;4&quot;,&quot;aria-label&quot;,&quot;Slide 5&quot;],[1,&quot;carousel-inner&quot;],[1,&quot;carousel-item&quot;,&quot;active&quot;],[&quot;src&quot;,&quot;assets/images/cover5.jpg&quot;,&quot;alt&quot;,&quot;Slika dru\u017eenja&quot;,1,&quot;d-block&quot;,&quot;w-100&quot;,&quot;img-fluid&quot;],[1,&quot;carousel-item&quot;],[&quot;src&quot;,&quot;assets/images/cover3.jpg&quot;,&quot;alt&quot;,&quot;Slika sporta&quot;,1,&quot;d-block&quot;,&quot;w-100&quot;,&quot;img-fluid&quot;],[&quot;src&quot;,&quot;assets/images/cover4.jpg&quot;,&quot;alt&quot;,&quot;Slika filma&quot;,1,&quot;d-block&quot;,&quot;w-100&quot;,&quot;img-fluid&quot;],[&quot;src&quot;,&quot;assets/images/cover1.jpg&quot;,&quot;alt&quot;,&quot;Slika namiznih iger&quot;,1,&quot;d-block&quot;,&quot;w-100&quot;,&quot;img-fluid&quot;],[&quot;src&quot;,&quot;assets/images/cover2.jpg&quot;,&quot;alt&quot;,&quot;Slika u\u010denja&quot;,1,&quot;d-block&quot;,&quot;w-100&quot;,&quot;img-fluid&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-target&quot;,&quot;#carouselExampleDark&quot;,&quot;data-bs-slide&quot;,&quot;prev&quot;,1,&quot;carousel-control-prev&quot;],[&quot;aria-hidden&quot;,&quot;true&quot;,1,&quot;carousel-control-prev-icon&quot;],[1,&quot;visually-hidden&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-target&quot;,&quot;#carouselExampleDark&quot;,&quot;data-bs-slide&quot;,&quot;next&quot;,1,&quot;carousel-control-next&quot;],[&quot;aria-hidden&quot;,&quot;true&quot;,1,&quot;carousel-control-next-icon&quot;],[&quot;id&quot;,&quot;kategorije&quot;],[1,&quot;container&quot;,&quot;marketing&quot;],[1,&quot;row&quot;],[1,&quot;col-lg-4&quot;],[&quot;src&quot;,&quot;assets/images/meetIcon.png&quot;,&quot;alt&quot;,&quot;meetIcon&quot;,1,&quot;img-fluid&quot;],[1,&quot;btn&quot;,&quot;btn-primary&quot;,3,&quot;click&quot;],[&quot;src&quot;,&quot;assets/images/sportIcon.png&quot;,&quot;alt&quot;,&quot;sportIcon&quot;,1,&quot;img-fluid&quot;],[&quot;src&quot;,&quot;assets/images/movieIcon.png&quot;,&quot;alt&quot;,&quot;movieIcon&quot;,1,&quot;img-fluid&quot;],[&quot;id&quot;,&quot;featureDruzenja&quot;],[1,&quot;featurette-divider&quot;],[1,&quot;row&quot;,&quot;featurette&quot;],[1,&quot;col-md-7&quot;],[1,&quot;featurette-heading&quot;],[1,&quot;lead&quot;,&quot;mt-4&quot;],[1,&quot;col-md-5&quot;],[&quot;src&quot;,&quot;assets/images/calendar.png&quot;,&quot;alt&quot;,&quot;calendarPicture&quot;,1,&quot;img-fluid&quot;],[&quot;featureSport&quot;,&quot;&quot;],[1,&quot;col-md-7&quot;,&quot;order-md-2&quot;],[1,&quot;col-md-5&quot;,&quot;order-md-1&quot;],[&quot;src&quot;,&quot;assets/images/masks.png&quot;,&quot;alt&quot;,&quot;movieIcon&quot;,1,&quot;img-fluid&quot;],[&quot;featureFilm&quot;,&quot;&quot;],[&quot;src&quot;,&quot;assets/images/events/sports.png&quot;,&quot;alt&quot;,&quot;movieIcon&quot;,1,&quot;img-fluid&quot;]],template:function(e,i){if(1&amp;e){const r=Ue();k(0,&quot;app-home-navbar&quot;),d(1,&quot;div&quot;,0),d(2,&quot;div&quot;,1),k(3,&quot;button&quot;,2),k(4,&quot;button&quot;,3),k(5,&quot;button&quot;,4),k(6,&quot;button&quot;,5),k(7,&quot;button&quot;,6),h(),d(8,&quot;div&quot;,7),d(9,&quot;div&quot;,8),k(10,&quot;img&quot;,9),h(),d(11,&quot;div&quot;,10),k(12,&quot;img&quot;,11),h(),d(13,&quot;div&quot;,10),k(14,&quot;img&quot;,12),h(),d(15,&quot;div&quot;,10),k(16,&quot;img&quot;,13),h(),d(17,&quot;div&quot;,10),k(18,&quot;img&quot;,14),h(),h(),d(19,&quot;button&quot;,15),k(20,&quot;span&quot;,16),d(21,&quot;span&quot;,17),b(22,&quot;Previous&quot;),h(),h(),d(23,&quot;button&quot;,18),k(24,&quot;span&quot;,19),d(25,&quot;span&quot;,17),b(26,&quot;Next&quot;),h(),h(),k(27,&quot;div&quot;,20),h(),d(28,&quot;div&quot;,21),d(29,&quot;div&quot;,22),d(30,&quot;div&quot;,23),k(31,&quot;img&quot;,24),d(32,&quot;h2&quot;),b(33,&quot;Dru\u017eenja&quot;),h(),d(34,&quot;p&quot;),b(35,&quot; Udele\u017ei se dru\u017eabnih dogodkov s prijatelji in znanci, ter ustvari nove spomine. &quot;),h(),d(36,&quot;p&quot;),d(37,&quot;a&quot;,25),M(&quot;click&quot;,function(){_e(r);const o=Ee(69);return i.scroll(o)}),b(38,&quot;Preberi ve\u010d \xbb&quot;),h(),h(),h(),d(39,&quot;div&quot;,23),k(40,&quot;img&quot;,26),d(41,&quot;h2&quot;),b(42,&quot;\u0160port&quot;),h(),d(43,&quot;p&quot;),b(44,&quot; Tekmuj v ekipnih in posameznih \u0161portih in se pridobi slavo in \u010dast. &quot;),h(),d(45,&quot;p&quot;),d(46,&quot;a&quot;,25),M(&quot;click&quot;,function(){_e(r);const o=Ee(79);return i.scroll(o)}),b(47,&quot;Preberi ve\u010d \xbb&quot;),h(),h(),h(),d(48,&quot;div&quot;,23),k(49,&quot;img&quot;,27),d(50,&quot;h2&quot;),b(51,&quot;Filmi&quot;),h(),d(52,&quot;p&quot;),b(53,&quot; Privo\u0161\u010dite si ve\u010der gledanja celove\u010dernih filmov v dobri dru\u017ebi. &quot;),h(),d(54,&quot;p&quot;),d(55,&quot;a&quot;,25),M(&quot;click&quot;,function(){_e(r);const o=Ee(79);return i.scroll(o)}),b(56,&quot;Preberi ve\u010d \xbb&quot;),h(),h(),h(),k(57,&quot;div&quot;,28),h(),k(58,&quot;hr&quot;,29),d(59,&quot;div&quot;,30),d(60,&quot;div&quot;,31),d(61,&quot;h2&quot;,32),b(62,&quot;Poi\u0161\u010di in ustvari dogodek &quot;),h(),d(63,&quot;p&quot;,33),b(64,&quot; Se dolgo\u010dasi\u0161 in ne ve\u0161 kaj bi po\u010del? Poi\u0161\u010di dogodek in se ga udele\u017ei, \u010de pa se v nobenem ne najdes, ga ustvari kar sam! &quot;),h(),h(),d(65,&quot;div&quot;,34),k(66,&quot;img&quot;,35),h(),h(),k(67,&quot;hr&quot;,29),d(68,&quot;div&quot;,30,36),d(70,&quot;div&quot;,37),d(71,&quot;h2&quot;,32),b(72,&quot; Te zanimajo zabave in dogodki? &quot;),h(),d(73,&quot;p&quot;,33),b(74,&quot; Pridru\u017ei se dru\u017eenjem po celi Sloveniji in ustvari nove veze in poznanstva. &quot;),h(),h(),d(75,&quot;div&quot;,38),k(76,&quot;img&quot;,39),h(),h(),k(77,&quot;hr&quot;,29),d(78,&quot;div&quot;,30,40),d(80,&quot;div&quot;,31),d(81,&quot;h2&quot;,32),b(82,&quot;Kaj pa \u0161port in ogledi filmov? &quot;),h(),d(83,&quot;p&quot;,33),b(84,&quot; Mogo\u010de pa zabave niso tvoja stvar, si pa zelo tekmovalen in se rad ukvarja\u0161 s \u0161portom ali pa u\u017eiva\u0161 v gledanju celove\u010dernih filmov. &quot;),h(),h(),d(85,&quot;div&quot;,34),k(86,&quot;img&quot;,41),h(),h(),k(87,&quot;hr&quot;,29),h()}},directives:[AA],styles:[&quot;&quot;]}),n})();class wG{}function TA(n=0,t=aa){return(!B_(n)||n&lt;0)&amp;&amp;(n=0),(!t||&quot;function&quot;!=typeof t.schedule)&amp;&amp;(t=aa),new ye(e=&gt;(e.add(t.schedule(EG,n,{subscriber:e,counter:0,period:n})),e))}function EG(n){const{subscriber:t,counter:e,period:i}=n;t.next(e),this.schedule({subscriber:t,counter:e+1,period:i},i)}let SG=(()=&gt;{class n{constructor(e,i){this.http=e,this.shramba=i,this.apiUrl=oa_apiUrl}pridobiKlepet(e){return this.http.get(`${this.apiUrl}/chat/${e}`).pipe(qe(1),Ie(this.obdelajNapako))}dodajSporocilo(e,i){const r=`${this.apiUrl}/chat/${e}`,s={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.put(r,i,s).pipe(qe(1),Ie(this.obdelajNapako))}zbrisiSporocilo(e,i){const r=`${this.apiUrl}/chat/${e}/message/${i}`,s={headers:new Ct({Authorization:`Bearer ${this.shramba.getItem(&quot;zeton&quot;)}`})};return this.http.delete(r,s).pipe(qe(1),Ie(this.obdelajNapako))}obdelajNapako(e){return zr(`Pri\u0161lo je do napake ${e.status} z opisom ${e.error.sporo\u010dilo||e.statusText}`)}}return n.\u0275fac=function(e){return new(e||n)(D(Zo),D(Nd))},n.\u0275prov=P({token:n,factory:n.\u0275fac,providedIn:&quot;root&quot;}),n})(),kG=(()=&gt;{class n{transform(e){var i=new Date(e),r=new Date,o=(i.getMinutes(),i.getMinutes(),i.getMinutes()),a=i.getHours(),l=i.getMonth()+1,c=i.getDate(),u=i.getFullYear(),p=r.getMinutes(),g=r.getHours();return i.setHours(0,0,0,0)==r.setHours(0,0,0,0)?g-a&gt;=2||g-a==1&amp;&amp;p&gt;=o?&quot;aktivnost pred ve\u010d kot 1h&quot;:this.sklanjanje(p&gt;=o?p-o:60-o+p):c+&quot;.&quot;+l+&quot;.&quot;+u}sklanjanje(e){return 0==e?&quot;aktivnost pred manj kot minuto&quot;:1==e?&quot;aktivnost pred 1 minuto&quot;:2==e?&quot;aktivnost pred 2 minutama&quot;:&quot;aktivnost pred &quot;+e+&quot; minutami&quot;}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275pipe=at({name:&quot;pretekliCas&quot;,type:n,pure:!0}),n})();const MG=[&quot;scrollMe&quot;];function AG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,41),k(1,&quot;i&quot;,42),b(2),Ut(3,&quot;pretekliCas&quot;),h()),2&amp;n){const e=T().$implicit;y(2),de(&quot; &quot;,ir(3,1,e.zadnjaAktivnost),&quot; &quot;)}}function TG(n,t){1&amp;n&amp;&amp;(k(0,&quot;i&quot;,43),b(1,&quot; ni aktivnosti &quot;))}function IG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;li&quot;,35),M(&quot;click&quot;,function(){const s=_e(e).$implicit;return T().getDogodekId(s.dogodekId._id)}),k(1,&quot;img&quot;,36),d(2,&quot;div&quot;,37),d(3,&quot;div&quot;,38),b(4),h(),I(5,AG,4,3,&quot;div&quot;,39),I(6,TG,2,0,&quot;ng-template&quot;,null,40,Nn),h(),h()}if(2&amp;n){const e=t.$implicit,i=Ee(7);vn(&quot;id&quot;,e.dogodekId._id),y(1),vn(&quot;src&quot;,e.dogodekId.eventImage,Nt),y(3),nt(e.dogodekId.title),y(1),w(&quot;ngIf&quot;,e.zadnjaAktivnost)(&quot;ngIfElse&quot;,i)}}function xG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,41),k(1,&quot;i&quot;,42),b(2),Ut(3,&quot;pretekliCas&quot;),h()),2&amp;n){const e=T().$implicit;y(2),de(&quot; &quot;,ir(3,1,e.zadnjaAktivnost),&quot; &quot;)}}function RG(n,t){1&amp;n&amp;&amp;(k(0,&quot;i&quot;,43),d(1,&quot;span&quot;,41),b(2,&quot; ni aktivnosti&quot;),h())}function PG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;li&quot;,35),M(&quot;click&quot;,function(){const s=_e(e).$implicit;return T().getDogodekId(s.dogodekId._id)}),d(1,&quot;div&quot;,44),d(2,&quot;div&quot;,45),k(3,&quot;img&quot;,36),h(),d(4,&quot;div&quot;,46),d(5,&quot;div&quot;,37),d(6,&quot;div&quot;,38),b(7),h(),I(8,xG,4,3,&quot;div&quot;,39),I(9,RG,3,0,&quot;ng-template&quot;,null,40,Nn),h(),h(),h(),h()}if(2&amp;n){const e=t.$implicit,i=Ee(10);vn(&quot;id&quot;,e.dogodekId._id),y(3),vn(&quot;src&quot;,e.dogodekId.eventImage,Nt),y(4),nt(e.dogodekId.title),y(1),w(&quot;ngIf&quot;,e.zadnjaAktivnost)(&quot;ngIfElse&quot;,i)}}function OG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;h1&quot;,47),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.izbranPogovor.dogodekId.title,&quot; &quot;)}}function FG(n,t){1&amp;n&amp;&amp;(d(0,&quot;h1&quot;,48),b(1,&quot; Ni izbranega pogovora &quot;),h())}function NG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,57),d(1,&quot;span&quot;,58),d(2,&quot;small&quot;),b(3),Ut(4,&quot;dateFormate&quot;),h(),h(),k(5,&quot;img&quot;,36),h()),2&amp;n){const e=T().$implicit;w(&quot;className&quot;,T(2).myMsg(e.userId._id)?&quot;message-data text-end&quot;:&quot;message-data&quot;),y(3),er(&quot;&quot;,e.userId.uporabniskoIme,&quot; &quot;,ir(4,4,e.datum),&quot; &quot;),y(2),si(&quot;src&quot;,&quot;assets/images/profileAvatars/avatarOptions/profileAvatar&quot;,e.userId.slika,&quot;.png&quot;,Nt)}}function VG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,57),k(1,&quot;img&quot;,36),d(2,&quot;span&quot;,58),d(3,&quot;small&quot;),b(4),Ut(5,&quot;dateFormate&quot;),h(),h(),h()),2&amp;n){const e=T().$implicit;w(&quot;className&quot;,T(2).myMsg(e.userId._id)?&quot;message-data text-end&quot;:&quot;message-data&quot;),y(1),si(&quot;src&quot;,&quot;assets/images/profileAvatars/avatarOptions/profileAvatar&quot;,e.userId.slika,&quot;.png&quot;,Nt),y(3),er(&quot;&quot;,e.userId.uporabniskoIme,&quot; &quot;,ir(5,4,e.datum),&quot;&quot;)}}function LG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;div&quot;,57),b(1),d(2,&quot;a&quot;,59),M(&quot;click&quot;,function(){_e(e);const r=T().$implicit,s=T(2);return s.deleteMessage(s.izbranPogovor._id,r._id)}),k(3,&quot;i&quot;,60),h(),h()}if(2&amp;n){const e=T().$implicit;w(&quot;className&quot;,T(2).myMsg(e.userId._id)?&quot;message other-message float-end&quot;:&quot;message my-message&quot;),y(1),de(&quot; &quot;,e.vsebina,&quot; &quot;)}}function jG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,57),b(1),h()),2&amp;n){const e=T().$implicit;w(&quot;className&quot;,T(2).myMsg(e.userId._id)?&quot;message other-message float-end&quot;:&quot;message my-message&quot;),y(1),de(&quot; &quot;,e.vsebina,&quot; &quot;)}}function BG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;ul&quot;,52),d(1,&quot;li&quot;,53),I(2,NG,6,6,&quot;div&quot;,54),I(3,VG,6,6,&quot;ng-template&quot;,null,55,Nn),I(5,LG,4,2,&quot;div&quot;,54),I(6,jG,2,2,&quot;ng-template&quot;,null,56,Nn),h(),h()),2&amp;n){const e=t.$implicit,i=Ee(4),r=Ee(7),s=T(2);y(2),w(&quot;ngIf&quot;,s.myMsg(e.userId._id))(&quot;ngIfElse&quot;,i),y(3),w(&quot;ngIf&quot;,s.myMsg(e.userId._id))(&quot;ngIfElse&quot;,r)}}function UG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,49,50),I(2,BG,8,4,&quot;ul&quot;,51),h()),2&amp;n){const e=T();y(2),w(&quot;ngForOf&quot;,e.izbranPogovor.sporocila)}}function HG(n,t){1&amp;n&amp;&amp;k(0,&quot;div&quot;,49)}let IA=(()=&gt;{class n{constructor(e,i,r,s){this.location=e,this.pot=i,this.klepetStoritev=r,this.uporabnikService=s,this.chats=[],this.currentUserId=&quot;&quot;,this.eventId=&quot;&quot;,this.selectedChat=!1,this.izbranPogovor=new wG,this.novoSporocilo={vsebina:&quot;&quot;,userId:&quot;&quot;},this.searchword=&quot;&quot;,this.subscription=new ue}pridobiKlepet(){this.klepetStoritev.pridobiKlepet(this.currentUserId).subscribe(e=&gt;{JSON.stringify(e)!==JSON.stringify(this.chats)&amp;&amp;(this.chats=e,this.posodobiKlepet())})}getDogodekId(e){this.eventId=e,e&amp;&amp;this.location.go(`/klepet/${e}`),this.getSelectedChat()}getSelectedChat(){for(let e=0;e&lt;this.chats.length;e++)this.chats[e].dogodekId._id==this.eventId&amp;&amp;(this.izbranPogovor=this.chats[e],this.selectedChat=!0)}myMsg(e){return e==this.currentUserId}addMessage(e){this.novoSporocilo.userId=this.currentUserId,this.klepetStoritev.dodajSporocilo(e,this.novoSporocilo).subscribe(i=&gt;{this.pridobiKlepet()})}posodobiKlepet(){&quot;&quot;!=this.eventId&amp;&amp;this.getDogodekId(this.eventId)}deleteMessage(e,i){this.klepetStoritev.zbrisiSporocilo(e,i).subscribe(()=&gt;{this.pridobiKlepet()})}ngOnInit(){this.currentUserId=this.uporabnikService.getLoggedUser()._id,this.pridobiKlepet();const e=TA(1e4);this.subscription=e.subscribe(()=&gt;this.pridobiKlepet()),this.pot.paramMap.pipe(nn(i=&gt;{let r=(i.get(&quot;idDogodka&quot;)||&quot;&quot;).toString();return this.getDogodekId(r.toString()),&quot;abc&quot;})).subscribe(()=&gt;{})}ngAfterViewChecked(){this.scrollToBottom()}scrollToBottom(){try{this.myScrollContainer.nativeElement.scrollTop=this.myScrollContainer.nativeElement.scrollHeight}catch(e){}}openNav(){document.getElementById(&quot;main-sidebar-container&quot;).style.marginLeft=&quot;0%&quot;}closeNav(){document.getElementById(&quot;main-sidebar-container&quot;).style.marginLeft=&quot;-100%&quot;}}return n.\u0275fac=function(e){return new(e||n)(_(vs),_(Ur),_(SG),_($n))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-klepet&quot;]],viewQuery:function(e,i){if(1&amp;e&amp;&amp;Pt(MG,5),2&amp;e){let r;Pe(r=Oe())&amp;&amp;(i.myScrollContainer=r.first)}},decls:43,vars:15,consts:[[&quot;id&quot;,&quot;main-sidebar-container&quot;,1,&quot;col-12&quot;,&quot;pull-left&quot;,&quot;collapse&quot;],[1,&quot;main-sidebar&quot;],[&quot;id&quot;,&quot;plist&quot;,1,&quot;people-list&quot;],[1,&quot;m-2&quot;],[1,&quot;autocomplete&quot;],[&quot;id&quot;,&quot;searchEventsSide&quot;,&quot;autocomplete&quot;,&quot;off&quot;,&quot;type&quot;,&quot;text&quot;,&quot;placeholder&quot;,&quot;I\u0161\u010di&quot;,1,&quot;autocomplete-text-input&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;searchEventsClearSide&quot;,1,&quot;fas&quot;,&quot;fa-backspace&quot;,&quot;autocomplete-button&quot;,3,&quot;click&quot;],[&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#main-sidebar-container&quot;,&quot;aria-controls&quot;,&quot;main-sidebar-container&quot;,1,&quot;btn&quot;,&quot;btn-outline-secondary&quot;,2,&quot;float&quot;,&quot;right&quot;,&quot;margin-top&quot;,&quot;5px&quot;,3,&quot;click&quot;],[1,&quot;fas&quot;,&quot;fa-bars&quot;],[1,&quot;m-0&quot;],[1,&quot;list-unstyled&quot;,&quot;chat-list&quot;,&quot;m-0&quot;,&quot;p-0&quot;,&quot;overflow-auto&quot;,2,&quot;min-height&quot;,&quot;50em&quot;],[&quot;class&quot;,&quot;clearfix border-bottom stranskiDogodki&quot;,3,&quot;id&quot;,&quot;click&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[1,&quot;container&quot;,&quot;mt-3&quot;],[1,&quot;col&quot;,&quot;col-12&quot;,&quot;flex-fill&quot;,&quot;mb-3&quot;],[1,&quot;card&quot;,&quot;chat-app&quot;,&quot;p-0&quot;,&quot;m-0&quot;],[&quot;id&quot;,&quot;plist&quot;,1,&quot;people-list&quot;,&quot;m-0&quot;,&quot;p-0&quot;,2,&quot;width&quot;,&quot;15rem&quot;],[1,&quot;m-3&quot;,&quot;ms-2&quot;,&quot;me-1&quot;,2,&quot;height&quot;,&quot;3rem&quot;],[&quot;id&quot;,&quot;searchEvents&quot;,&quot;autocomplete&quot;,&quot;off&quot;,&quot;type&quot;,&quot;text&quot;,&quot;placeholder&quot;,&quot;I\u0161\u010di&quot;,1,&quot;autocomplete-text-input&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;searchEventsClear&quot;,1,&quot;fas&quot;,&quot;fa-backspace&quot;,&quot;autocomplete-button&quot;,3,&quot;click&quot;],[1,&quot;m-0&quot;,&quot;p-0&quot;],[1,&quot;list-unstyled&quot;,&quot;chat-list&quot;,&quot;m-0&quot;,&quot;p-0&quot;,&quot;overflow-auto&quot;],[1,&quot;chat&quot;],[1,&quot;chat-header&quot;,&quot;clearfix&quot;,&quot;m-0&quot;,&quot;border-bottom&quot;],[&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#main-sidebar-container&quot;,&quot;aria-controls&quot;,&quot;main-sidebar-container&quot;,1,&quot;btn&quot;,&quot;btn-outline-secondary&quot;,&quot;d-md-none&quot;,2,&quot;float&quot;,&quot;left&quot;,&quot;margin-left&quot;,&quot;10px&quot;,&quot;margin-right&quot;,&quot;5px&quot;,3,&quot;click&quot;],[&quot;class&quot;,&quot;m-3 text-black float-st center&quot;,&quot;style&quot;,&quot;height: 3rem; overflow:hidden;\n                    white-space:nowrap;\n                    -ms-text-overflow:ellipsis;\n                    text-overflow:ellipsis;&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;niPogovora&quot;,&quot;&quot;],[&quot;class&quot;,&quot;chat-history&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;niSelectedChata&quot;,&quot;&quot;],[1,&quot;chat-message&quot;],[&quot;id&quot;,&quot;myForm&quot;,&quot;autocomplete&quot;,&quot;off&quot;,3,&quot;ngSubmit&quot;],[1,&quot;input-group&quot;,&quot;row&quot;,&quot;m-0&quot;,&quot;p-0&quot;],[&quot;id&quot;,&quot;chatMessage&quot;,&quot;type&quot;,&quot;text&quot;,&quot;placeholder&quot;,&quot;Vnesite besedilo...&quot;,&quot;name&quot;,&quot;chatMsg&quot;,1,&quot;form-control&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;chatMsg&quot;,&quot;&quot;],[&quot;type&quot;,&quot;submit&quot;,1,&quot;ms-2&quot;,&quot;p-0&quot;,&quot;col-auto&quot;,&quot;col-sm-auto&quot;,&quot;text-primary&quot;,&quot;align-self-center&quot;,&quot;float-end&quot;,&quot;btn&quot;,&quot;shadow-none&quot;,3,&quot;click&quot;],[1,&quot;fas&quot;,&quot;fa-paper-plane&quot;,&quot;fa-lg&quot;],[1,&quot;clearfix&quot;,&quot;border-bottom&quot;,&quot;stranskiDogodki&quot;,3,&quot;id&quot;,&quot;click&quot;],[&quot;alt&quot;,&quot;avatar&quot;,3,&quot;src&quot;],[1,&quot;about&quot;],[1,&quot;name&quot;],[&quot;class&quot;,&quot;status&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;statusKlepeta&quot;,&quot;&quot;],[1,&quot;status&quot;],[1,&quot;fa&quot;,&quot;fa-circle&quot;,&quot;online&quot;],[1,&quot;fa&quot;,&quot;fa-circle&quot;,&quot;offline&quot;],[1,&quot;row&quot;,&quot;p-0&quot;],[1,&quot;align-self-center&quot;,&quot;col-auto&quot;,&quot;p-0&quot;],[1,&quot;col&quot;,&quot;p-0&quot;],[1,&quot;m-3&quot;,&quot;text-black&quot;,&quot;float-st&quot;,&quot;center&quot;,2,&quot;height&quot;,&quot;3rem&quot;,&quot;overflow&quot;,&quot;hidden&quot;,&quot;white-space&quot;,&quot;nowrap&quot;,&quot;-ms-text-overflow&quot;,&quot;ellipsis&quot;,&quot;text-overflow&quot;,&quot;ellipsis&quot;],[1,&quot;m-3&quot;,&quot;text-black&quot;,&quot;float-st&quot;,&quot;center&quot;,2,&quot;height&quot;,&quot;3rem&quot;],[1,&quot;chat-history&quot;],[&quot;scrollMe&quot;,&quot;&quot;],[&quot;class&quot;,&quot;m-b-0&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[1,&quot;m-b-0&quot;],[1,&quot;clearfix&quot;],[3,&quot;className&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;notMyMsg&quot;,&quot;&quot;],[&quot;brezDelete&quot;,&quot;&quot;],[3,&quot;className&quot;],[1,&quot;message-data-time&quot;],[&quot;role&quot;,&quot;button&quot;,3,&quot;click&quot;],[1,&quot;fas&quot;,&quot;fa-trash-alt&quot;,&quot;text-secondary&quot;]],template:function(e,i){if(1&amp;e){const r=Ue();d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),d(3,&quot;div&quot;,3),d(4,&quot;div&quot;,4),d(5,&quot;input&quot;,5),M(&quot;ngModelChange&quot;,function(o){return i.searchword=o}),h(),d(6,&quot;button&quot;,6),M(&quot;click&quot;,function(){return i.searchword=&quot;&quot;}),h(),h(),d(7,&quot;button&quot;,7),M(&quot;click&quot;,function(){return i.closeNav()}),k(8,&quot;i&quot;,8),h(),h(),k(9,&quot;hr&quot;,9),d(10,&quot;ul&quot;,10),I(11,IG,8,5,&quot;li&quot;,11),Ut(12,&quot;filter&quot;),h(),h(),h(),h(),d(13,&quot;div&quot;,12),d(14,&quot;div&quot;,13),d(15,&quot;div&quot;,14),d(16,&quot;div&quot;,15),d(17,&quot;div&quot;,16),d(18,&quot;div&quot;,4),d(19,&quot;input&quot;,17),M(&quot;ngModelChange&quot;,function(o){return i.searchword=o}),h(),d(20,&quot;button&quot;,18),M(&quot;click&quot;,function(){return i.searchword=&quot;&quot;}),h(),h(),h(),k(21,&quot;hr&quot;,19),d(22,&quot;ul&quot;,20),I(23,PG,11,5,&quot;li&quot;,11),Ut(24,&quot;filter&quot;),h(),h(),d(25,&quot;div&quot;,21),d(26,&quot;div&quot;,22),d(27,&quot;button&quot;,23),M(&quot;click&quot;,function(){return i.openNav()}),k(28,&quot;i&quot;,8),h(),I(29,OG,2,1,&quot;h1&quot;,24),I(30,FG,2,0,&quot;ng-template&quot;,null,25,Nn),h(),I(32,UG,3,1,&quot;div&quot;,26),I(33,HG,1,0,&quot;ng-template&quot;,null,27,Nn),k(35,&quot;hr&quot;,9),d(36,&quot;div&quot;,28),d(37,&quot;form&quot;,29),M(&quot;ngSubmit&quot;,function(){return i.addMessage(i.izbranPogovor._id)}),d(38,&quot;div&quot;,30),d(39,&quot;input&quot;,31,32),M(&quot;ngModelChange&quot;,function(o){return i.novoSporocilo.vsebina=o}),h(),d(41,&quot;button&quot;,33),M(&quot;click&quot;,function(){return _e(r),Ee(40).value=&quot;&quot;}),k(42,&quot;i&quot;,34),h(),h(),h(),h(),h(),h(),h(),h()}if(2&amp;e){const r=Ee(31),s=Ee(34);y(5),w(&quot;ngModel&quot;,i.searchword),y(6),w(&quot;ngForOf&quot;,xr(12,9,i.chats,i.searchword)),y(8),w(&quot;ngModel&quot;,i.searchword),y(4),w(&quot;ngForOf&quot;,xr(24,12,i.chats,i.searchword)),y(6),w(&quot;ngIf&quot;,i.selectedChat)(&quot;ngIfElse&quot;,r),y(3),w(&quot;ngIf&quot;,i.selectedChat)(&quot;ngIfElse&quot;,s),y(7),w(&quot;ngModel&quot;,i.novoSporocilo.vsebina)}},directives:[Bn,Vi,mi,Fi,rt,ta,Jo,gi],pipes:[oy,kG,MA],styles:[&quot;&quot;]}),n})();function zG(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,9),k(1,&quot;app-seznam-dogodkov&quot;,10),h()),2&amp;n){const e=T();y(1),w(&quot;page&quot;,&quot;created&quot;)(&quot;dogodki&quot;,e.dogodki)(&quot;totalEvents&quot;,e.totalEvents)(&quot;pageSize&quot;,e.pageSize)}}let $G=(()=&gt;{class n{constructor(e){this.dogodkiService=e,this.pageSize=10,this.totalEvents=0}ngOnInit(){this.getUstvarjeniDogodki()}getUstvarjeniDogodki(){let e={page:0};e.size=this.pageSize?this.pageSize:10,this.dogodkiService.getUstvarjeniDogodki(e).subscribe(i=&gt;(this.dogodki=i.events,this.totalEvents=i.totalEvents))}}return n.\u0275fac=function(e){return new(e||n)(_($r))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-ustvarjeni-dogodki&quot;]],decls:10,vars:2,consts:[[1,&quot;container&quot;,&quot;mt-3&quot;],[1,&quot;row&quot;,&quot;m-0&quot;],[1,&quot;nav&quot;,&quot;nav-pills&quot;,&quot;col-lg-3&quot;,&quot;col-md-12&quot;,&quot;flex-column&quot;,&quot;m-0&quot;,&quot;mb-3&quot;,&quot;p-0&quot;,&quot;pe-lg-2&quot;],[3,&quot;selectedPage&quot;],[&quot;class&quot;,&quot;col-lg-9 col-md-12&quot;,4,&quot;ngIf&quot;],[1,&quot;nav&quot;,&quot;m-3&quot;],[&quot;routerLink&quot;,&quot;/ustvari_dogodek&quot;,1,&quot;nav-link&quot;,&quot;link-dark&quot;,&quot;add-event-float&quot;],[1,&quot;far&quot;,&quot;fa-calendar-plus&quot;],[1,&quot;&quot;],[1,&quot;col-lg-9&quot;,&quot;col-md-12&quot;],[3,&quot;page&quot;,&quot;dogodki&quot;,&quot;totalEvents&quot;,&quot;pageSize&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),k(3,&quot;app-dogodki-sidenav&quot;,3),h(),I(4,zG,2,4,&quot;div&quot;,4),d(5,&quot;div&quot;,5),d(6,&quot;a&quot;,6),k(7,&quot;div&quot;,7),d(8,&quot;div&quot;,8),b(9,&quot;Dodaj dogodek&quot;),h(),h(),h(),h(),h()),2&amp;e&amp;&amp;(y(3),w(&quot;selectedPage&quot;,&quot;created&quot;),y(1),w(&quot;ngIf&quot;,i.dogodki))},directives:[ay,rt,zn,dc],styles:[&quot;&quot;]}),n})();class xA{constructor(t){this._id=&quot;&quot;,this.title=&quot;&quot;,this.eventImage=&quot;&quot;,this.date=new Date,this.city=&quot;&quot;,this.address=&quot;&quot;,this.coordinates=[0,0],this.tags=[],this.description=&quot;&quot;,this.users=[],this.buttons=&quot;&quot;,this.eventWeather=&quot;&quot;,this.eventImage=&quot;&quot;+t}}let GG=(()=&gt;{class n{constructor(e){this.http=e}getLocation(e,i){return this.http.get(`https://eu1.locationiq.com/v1/reverse.php?key=pk.c8f81be5c2ac6477800cef2f98d2d5af&amp;lat=${e}&amp;lon=${i}&amp;format=json`).pipe(qe(1),Ie(this.obdelajNapako))}obdelajNapako(e){return zr(`Pri\u0161lo je do napake ${e.status} z opisom ${e.error.sporo\u010dilo||e.statusText}`)}}return n.\u0275fac=function(e){return new(e||n)(D(Zo))},n.\u0275prov=P({token:n,factory:n.\u0275fac,providedIn:&quot;root&quot;}),n})();function WG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;a&quot;,2),M(&quot;click&quot;,function(){const s=_e(e).$implicit;return T().changeImg(s)}),k(1,&quot;img&quot;,3),h()}if(2&amp;n){const e=t.$implicit;y(1),si(&quot;src&quot;,&quot;assets/images/events/&quot;,e,&quot;&quot;,Nt)}}let qG=(()=&gt;{class n{constructor(){this.paths=[&quot;barbell.png&quot;,&quot;basketball.png&quot;,&quot;beach.png&quot;,&quot;clapperboard.png&quot;,&quot;fitness.png&quot;,&quot;football.png&quot;,&quot;game-console.png&quot;,&quot;hangout.png&quot;,&quot;hiking (1).png&quot;,&quot;hiking.png&quot;,&quot;masks.png&quot;,&quot;party.png&quot;,&quot;picnic.png&quot;,&quot;poker-cards.png&quot;,&quot;rock.png&quot;,&quot;skiing.png&quot;,&quot;sports.png&quot;,&quot;sport-shoes.png&quot;,&quot;studying.png&quot;,&quot;swimming.png&quot;,&quot;timetable.png&quot;,&quot;volleyball.png&quot;,&quot;walking.png&quot;,&quot;walking-the-dog.png&quot;]}changeImg(e){document.getElementById(&quot;eventImage&quot;).src=`assets/images/events/${e}`,document.getElementById(&quot;changePictureModal&quot;).click()}ngOnInit(){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-izbira-slike&quot;]],decls:2,vars:1,consts:[[1,&quot;&quot;,2,&quot;max-height&quot;,&quot;400px&quot;,&quot;overflow&quot;,&quot;auto&quot;],[&quot;style&quot;,&quot;width: 20px; cursor: pointer;&quot;,3,&quot;click&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[2,&quot;width&quot;,&quot;20px&quot;,&quot;cursor&quot;,&quot;pointer&quot;,3,&quot;click&quot;],[1,&quot;rounded-circle&quot;,&quot;mb-2&quot;,2,&quot;width&quot;,&quot;144px&quot;,&quot;height&quot;,&quot;144px&quot;,3,&quot;src&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),I(1,WG,2,1,&quot;a&quot;,1),h()),2&amp;e&amp;&amp;(y(1),w(&quot;ngForOf&quot;,i.paths))},directives:[Fi],styles:[&quot;&quot;]}),n})(),YG=(()=&gt;{class n{constructor(){this.currentTags=[],this.allTags=[],this.addTagEvent=new U,this.removeTagEvent=new U}getTagValue(){return document.getElementById(&quot;tagInput&quot;).value}resetTagValue(){document.getElementById(&quot;tagInput&quot;).value=null}addTag(){var e,i=null===(e=this.getTagValue())||void 0===e?void 0:e.trim();!i||(this.resetTagValue(),this.addTagEvent.emit(i))}removeTag(e){this.removeTagEvent.emit(e.value)}ngOnInit(){this.autocomplete(document.getElementById(&quot;tagInput&quot;),this.allTags)}autocomplete(e,i){var r;function s(l){!l||(function(l){for(var c=0;c&lt;l.length;c++)l[c].classList.remove(&quot;autocomplete-active&quot;)}(l),r&gt;=l.length&amp;&amp;(r=0),r&lt;0&amp;&amp;(r=l.length-1),0!=l.length&amp;&amp;(l[r].classList.add(&quot;autocomplete-active&quot;),e.value=l[r].textContent))}function a(l){for(var c=document.getElementsByClassName(&quot;autocomplete-items&quot;),u=0;u&lt;c.length;u++)l!=c[u]&amp;&amp;l!=e&amp;&amp;c[u].parentNode.removeChild(c[u])}e.addEventListener(&quot;input&quot;,l=&gt;{var c,u,f=e.value;if(a(),f){r=-1,(c=document.createElement(&quot;DIV&quot;)).setAttribute(&quot;id&quot;,e.id+&quot;autocomplete-list&quot;),c.setAttribute(&quot;class&quot;,&quot;autocomplete-items&quot;),e.parentNode.appendChild(c);var g=0,m=null,C=this.currentTags.map(v=&gt;v.toUpperCase());i.forEach(v=&gt;{if(g&lt;=5){var S=v.split(&quot; &quot;),E=!1,R=&quot;&quot;;S.forEach(F=&gt;{if(F.substr(0,f.length).toUpperCase()==f.toUpperCase()){E=!0;var Q=F.substr(0,f.length);R+=`&lt;strong&gt;${Q}&lt;/strong&gt;`,R+=&quot;&amp;&quot;!=Q?`${F.substr(f.length)} `:&quot; &quot;}else R+=`${F} `}),E||v.substr(0,f.length).toUpperCase()===f.toUpperCase()&amp;&amp;(E=!0,R=`&lt;strong&gt;${v.substr(0,f.length)}&lt;/strong&gt;`+v.substr(f.length,v.length)),E&amp;&amp;!C.includes(v.toUpperCase())&amp;&amp;(g++,(u=document.createElement(&quot;DIV&quot;)).setAttribute(&quot;class&quot;,&quot;autocomplete-item-notlast&quot;),u.innerHTML=R.trim(),u.innerHTML+=`&lt;input type=&#39;hidden&#39; value=&#39;${v}&#39;&gt;`,u.addEventListener(&quot;click&quot;,F=&gt;{e.value=F.path[0].innerText,a()}),m=u,c.appendChild(u))}}),null!=m&amp;&amp;!C.includes(f.trim().toUpperCase())&amp;&amp;((u=document.createElement(&quot;DIV&quot;)).innerHTML=&quot;&lt;b&gt;&quot;+f.trim()+&quot;&lt;/b&gt;&quot;,u.innerHTML+=`&lt;input type=&#39;hidden&#39; value=&#39;${f}&#39;&gt;`,u.addEventListener(&quot;click&quot;,v=&gt;{e.value=v.path[0].innerText,a()}),c.appendChild(u))}}),e.addEventListener(&quot;keydown&quot;,l=&gt;{var c=document.getElementById(e.id+&quot;autocomplete-list&quot;);c&amp;&amp;(c=c.getElementsByTagName(&quot;div&quot;)),40==l.keyCode?(r++,s(c)):38==l.keyCode?(r--,s(c)):(13==l.keyCode||9==l.keyCode)&amp;&amp;(r&gt;-1?c&amp;&amp;(c[r].click(),this.resetTagValue()):c&amp;&amp;c[0]&amp;&amp;(c[0].click(),this.resetTagValue()))}),document.addEventListener(&quot;click&quot;,function(l){a(l.target)})}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-autocomplete&quot;]],inputs:{currentTags:&quot;currentTags&quot;,allTags:&quot;allTags&quot;},outputs:{addTagEvent:&quot;addTagEvent&quot;,removeTagEvent:&quot;removeTagEvent&quot;},decls:3,vars:0,consts:[[1,&quot;autocomplete&quot;],[&quot;id&quot;,&quot;addTagButton&quot;,&quot;aria-label&quot;,&quot;Add Tag&quot;,1,&quot;fa&quot;,&quot;fa-plus&quot;,&quot;autocomplete-button&quot;,3,&quot;click&quot;],[&quot;autocomplete&quot;,&quot;new-password&quot;,&quot;id&quot;,&quot;tagInput&quot;,&quot;type&quot;,&quot;text&quot;,&quot;name&quot;,&quot;myCountry&quot;,&quot;placeholder&quot;,&quot;Oznaka npr. \u0160port&quot;,1,&quot;autocomplete-text-input&quot;,3,&quot;keydown.enter&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;button&quot;,1),M(&quot;click&quot;,function(){return i.addTag()}),h(),d(2,&quot;input&quot;,2),M(&quot;keydown.enter&quot;,function(){return i.addTag()}),h(),h())},styles:[&quot;&quot;]}),n})();function KG(n,t){1&amp;n&amp;&amp;k(0,&quot;img&quot;,66),2&amp;n&amp;&amp;w(&quot;src&quot;,T().dogodek.eventImage,Nt)}function QG(n,t){1&amp;n&amp;&amp;k(0,&quot;img&quot;,67)}function ZG(n,t){1&amp;n&amp;&amp;(d(0,&quot;mat-error&quot;),b(1,&quot; Datum ne sme biti v preteklosti &quot;),h())}function JG(n,t){1&amp;n&amp;&amp;(d(0,&quot;mat-error&quot;),b(1,&quot; Neveljaven datum &quot;),h())}function XG(n,t){if(1&amp;n){const e=Ue();d(0,&quot;li&quot;,68),b(1),d(2,&quot;span&quot;,69),M(&quot;click&quot;,function(r){const o=_e(e).$implicit;return T().removeInitialTag(r,o)}),b(3,&quot;\xd7&quot;),h(),h()}if(2&amp;n){const e=t.$implicit;y(1),de(&quot; &quot;,e,&quot; &quot;)}}function e9(n,t){if(1&amp;n){const e=Ue();d(0,&quot;a&quot;,70),M(&quot;click&quot;,function(){return _e(e),T().addDogodek()}),b(1,&quot;Ustvari dogodek&quot;),h()}2&amp;n&amp;&amp;Me(&quot;disabled&quot;,!T().jePovezava())}function t9(n,t){if(1&amp;n){const e=Ue();d(0,&quot;a&quot;,71),M(&quot;click&quot;,function(){return _e(e),T().updateDogodek()}),b(1,&quot;Shrani&quot;),h()}2&amp;n&amp;&amp;Me(&quot;disabled&quot;,!T().jePovezava())}let RA=(()=&gt;{class n{constructor(e,i,r,s,o,a){this.router=e,this.formBuilder=i,this.dogodkiService=r,this.mapService=s,this.uporabnikService=o,this.povezavaStoritev=a,this.dogodekForm=this.formBuilder.group({spadunk:[&quot;&quot;,[od.required,n=&gt;{let t=new Date;return t.setDate(t.getDate()-1),new Date(n.value),n.value?t&lt;=new Date(n.value)?null:{dateInPast:!0}:{invalidDate:!0}}]]}),this.validated=!1,this.imeDogodka=new pa,this.mestoDogodka=new pa,this.naslovDogodka=new pa,this.opisDogodka=new pa,this.oznakeDogodka=new pa,this.maxStUdelezenihDogodka=new pa,this.dogodek=new xA(&quot;assets/images/events/timetable.png&quot;),this.omejitveDogodka=!0,this.dogodekLokacija={city:this.dogodek.city,address:this.dogodek.address,coordinates:this.dogodek.coordinates},this.allTags=[&quot;\u0160port&quot;,&quot;Zunaj&quot;,&quot;Ekipni \u0161port&quot;,&quot;Piknik&quot;,&quot;Morje&quot;,&quot;Smu\u010danje&quot;,&quot;Bazen&quot;,&quot;Kopanje&quot;,&quot;Sneg&quot;,&quot;U\u010denje&quot;,&quot;\u0160ola&quot;,&quot;Odbojka&quot;,&quot;Rokomet&quot;,&quot;Nogomet&quot;,&quot;Fizika&quot;,&quot;Matematika&quot;,&quot;Film&quot;,&quot;Zabava&quot;,&quot;Tek&quot;,&quot;Hoja&quot;,&quot;Pohod&quot;,&quot;Hrib&quot;,&quot;Gorjanci&quot;,&quot;Sprehod&quot;,&quot;BBQ&quot;,&quot;Plavanje&quot;,&quot;Poletje&quot;,&quot;Zima&quot;,&quot;Rojstni dan&quot;,&quot;50-letnica&quot;,&quot;Koncert&quot;,&quot;Kino&quot;,&quot;Serija&quot;,&quot;Dru\u017eenje&quot;,&quot;Hrana&quot;,&quot;Pija\u010da&quot;,&quot;Po\u010ditnice&quot;,&quot;Nagrada&quot;,&quot;Slovenija&quot;,&quot;Amerika&quot;,&quot;Tujina&quot;,&quot;Namizni nogomet&quot;,&quot;Tenis&quot;,&quot;Namizni tenis&quot;,&quot;Vikend&quot;,&quot;Vikend zabava&quot;,&quot;Dru\u017eabne igre&quot;,&quot;Jahanje&quot;,&quot;Golf&quot;,&quot;Pikado&quot;,&quot;Dirka&quot;,&quot;Gledali\u0161\u010de&quot;,&quot;Stand up&quot;,&quot;Poletje&quot;,&quot;Zima&quot;,&quot;Petek&quot;,&quot;Festival&quot;,&quot;Kulinarika&quot;]}ngOnInit(){var e=this.map,i=&quot;&quot;,r=&quot;&quot;,s=&quot;&quot;,o=&quot;&quot;,a=L.popup();e=L.map(&quot;map&quot;).setView([46.059646,14.505751],13),L.tileLayer(&quot;https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw&quot;,{maxZoom:18,attribution:&#39;Map data &amp;copy; &lt;a href=&quot;https://www.openstreetmap.org/copyright&quot;&gt;OpenStreetMap&lt;/a&gt; contributors, Imagery \xa9 &lt;a href=&quot;https://www.mapbox.com/&quot;&gt;Mapbox&lt;/a&gt;&#39;,id:&quot;mapbox/streets-v11&quot;,tileSize:512,zoomOffset:-1}).addTo(e),e.on(&quot;click&quot;,l=&gt;{this.mapService.getLocation(l.latlng.lat,l.latlng.lng).subscribe(c=&gt;{s=c.address.hasOwnProperty(&quot;road&quot;)?c.address.road:c.address.village,c.address.hasOwnProperty(&quot;house_number&quot;)&amp;&amp;(r=c.address.house_number),c.address.hasOwnProperty(&quot;postcode&quot;)&amp;&amp;(o=c.address.postcode),i=c.address.hasOwnProperty(&quot;city&quot;)?c.address.city:c.address.town,this.dogodek.city=`${o} ${i}`,this.dogodek.address=`${s} ${r}`,this.dogodek.coordinates=[l.latlng.lat,l.latlng.lng],a.setLatLng(l.latlng).setContent(s+&quot; &quot;+r+&quot;, &quot;+o+&quot; &quot;+i).openOn(e)})}),$(&quot;#exampleModal&quot;).on(&quot;shown.bs.modal&quot;,function(){e.setView([46.059646,14.505751],13),setTimeout(function(){e.invalidateSize(!0)},10)})}addDogodek(){!this.validateEvent()||this.dogodkiService.addDogodek(this.dogodek).subscribe(e=&gt;{alert(&quot;Dogodek ustvarjen&quot;);let i=this.uporabnikService.getLoggedUser();i.created.push(e._id),this.uporabnikService.setLoggedUser(i),this.router.navigate([&quot;/ustvarjeni_dogodki&quot;])})}updateDogodek(){!this.validateEvent()||this.dogodkiService.updateDogodek(this.dogodek).subscribe(e=&gt;{alert(&quot;Dogodek posodobljen&quot;),this.router.navigate([&quot;/ustvarjeni_dogodki&quot;])})}validateEvent(){var e=!0;if(this.validated=!0,this.isEmptyOrSpaces(this.dogodek.title)?(this.imeDogodka.message=&quot;Obvezno polje&quot;,this.imeDogodka.valid=!1,e=!1):(this.imeDogodka.message=&quot;&quot;,this.imeDogodka.valid=!0),this.isEmptyOrSpaces(this.dogodek.city)?(this.mestoDogodka.message=&quot;Obvezno polje&quot;,this.mestoDogodka.valid=!1,e=!1):(this.mestoDogodka.message=&quot;&quot;,this.mestoDogodka.valid=!0),this.isEmptyOrSpaces(this.dogodek.address)?(this.naslovDogodka.message=&quot;Obvezno polje&quot;,this.naslovDogodka.valid=!1,e=!1):(this.naslovDogodka.message=&quot;&quot;,this.naslovDogodka.valid=!0),new Date,this.dogodekForm.valid||(alert(&quot;neveljaven datum dogodka&quot;),e=!1),this.validateTags(this.dogodek.tags)||(e=!1),this.omejitveDogodka?this.isNumber(this.dogodek.participantMax)?(this.maxStUdelezenihDogodka.message=&quot;&quot;,this.maxStUdelezenihDogodka.valid=!0):(this.maxStUdelezenihDogodka.message=&quot;Neveljaven vnos&quot;,this.maxStUdelezenihDogodka.valid=!1,e=!1):(this.dogodek.participantMax=0,this.maxStUdelezenihDogodka.message=&quot;&quot;,this.maxStUdelezenihDogodka.valid=!0),this.dogodek.description.length&gt;800?(this.opisDogodka.message=&quot;Najve\u010d 800 znakov&quot;,this.opisDogodka.valid=!1,e=!1):(this.opisDogodka.message=&quot;&quot;,this.opisDogodka.valid=!0),!e)return!1;let r=document.getElementById(&quot;eventImage&quot;);return this.dogodek.eventImage=r.src.substring(r.src.indexOf(&quot;assets/images/events/&quot;),r.src.length),e}validateTags(e){const i=e.map(o=&gt;o.toUpperCase()),r=this.allTags.map(o=&gt;o.toUpperCase()),s=new Set(i);return s.size&lt;3?(this.oznakeDogodka.message=&quot;Vsaj 3 razli\u010dne oznake&quot;,this.oznakeDogodka.valid=!1,!1):s.size!==i.length?(this.oznakeDogodka.message=&quot;Oznake se ne smejo ponavljati&quot;,this.oznakeDogodka.valid=!1,!1):r.some(o=&gt;i.indexOf(o)&gt;=0)?(this.oznakeDogodka.message=&quot;&quot;,this.oznakeDogodka.valid=!0,!0):(this.oznakeDogodka.message=&quot;Vsaj 1 oznaka iz definiranega lista&quot;,this.oznakeDogodka.valid=!1,!1)}isNumber(e){return/^(0|[1-9][0-9]*)$/.test(&quot;&quot;+e)}isEmptyOrSpaces(e){return null===e||null!==e.match(/^ *$/)}resetLocation(){this.dogodek.city=this.dogodekLokacija.city,this.dogodek.address=this.dogodekLokacija.address,this.dogodek.coordinates=this.dogodekLokacija.coordinates}addTag(e){this.dogodek.tags.push(e)}removeTag(e){this.dogodek.tags.splice(this.dogodek.tags.indexOf(e),1)}removeInitialTag(e,i){var r=document.getElementById(&quot;tagsList&quot;);this.removeTag(i),r.removeChild(e.path[1])}jePovezava(){return this.povezavaStoritev.jePovezava}}return n.\u0275fac=function(e){return new(e||n)(_(Xe),_(EU),_($r),_(GG),_($n),_(Yr))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-dogodek-podrobnosti&quot;]],inputs:{action:&quot;action&quot;,dogodek:&quot;dogodek&quot;,omejitveDogodka:&quot;omejitveDogodka&quot;},decls:104,vars:36,consts:[[1,&quot;row&quot;],[1,&quot;border&quot;,&quot;mb-2&quot;],[1,&quot;mb-3&quot;,&quot;mt-2&quot;],[1,&quot;mb-3&quot;],[&quot;for&quot;,&quot;title&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;id&quot;,&quot;title&quot;,&quot;placeholder&quot;,&quot;Ime dogodka&quot;,3,&quot;ngModel&quot;,&quot;classList&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;msgTitle&quot;,1,&quot;invalid-feedback&quot;,&quot;text-start&quot;,&quot;p-0&quot;],[&quot;for&quot;,&quot;eventImage&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[1,&quot;input-group&quot;,&quot;mb-5&quot;],[1,&quot;img-wrapper&quot;],[&quot;class&quot;,&quot;img-responsive rounded-circle&quot;,&quot;id&quot;,&quot;eventImage&quot;,&quot;alt&quot;,&quot;&quot;,3,&quot;src&quot;,4,&quot;ngIf&quot;,&quot;ngIfElse&quot;],[&quot;defaultImage&quot;,&quot;&quot;],[1,&quot;img-overlay&quot;],[&quot;role&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;modal&quot;,&quot;data-bs-target&quot;,&quot;#changePictureModal&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;],[&quot;id&quot;,&quot;changePictureModal&quot;,&quot;tabindex&quot;,&quot;-1&quot;,&quot;role&quot;,&quot;dialog&quot;,&quot;aria-labelledby&quot;,&quot;changePictureModalLabel&quot;,&quot;aria-hidden&quot;,&quot;true&quot;,1,&quot;modal&quot;,&quot;fade&quot;],[&quot;role&quot;,&quot;document&quot;,1,&quot;modal-dialog&quot;],[1,&quot;modal-content&quot;],[1,&quot;modal-header&quot;],[&quot;id&quot;,&quot;changePictureModalLabel&quot;,1,&quot;modal-title&quot;],[1,&quot;modal-body&quot;],[1,&quot;modal-footer&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-dismiss&quot;,&quot;modal&quot;,1,&quot;btn&quot;,&quot;btn-secondary&quot;],[&quot;for&quot;,&quot;city&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[1,&quot;input-group&quot;,&quot;mb-3&quot;,&quot;row&quot;,&quot;m-1&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;disabled&quot;,&quot;&quot;,&quot;placeholder&quot;,&quot;Kraj&quot;,&quot;id&quot;,&quot;city&quot;,&quot;name&quot;,&quot;city&quot;,3,&quot;ngModel&quot;,&quot;classList&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;msgObcina&quot;,1,&quot;invalid-feedback&quot;,&quot;text-start&quot;,&quot;p-0&quot;],[1,&quot;input-group&quot;,&quot;mb-2&quot;,&quot;row&quot;,&quot;m-1&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;disabled&quot;,&quot;&quot;,&quot;placeholder&quot;,&quot;Naslov&quot;,&quot;id&quot;,&quot;address&quot;,3,&quot;ngModel&quot;,&quot;classList&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;modal&quot;,&quot;data-bs-target&quot;,&quot;#exampleModal&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;ms-0&quot;,&quot;ms-sm-2&quot;,&quot;mt-2&quot;,&quot;mt-sm-0&quot;,&quot;col-sm-auto&quot;,&quot;d-none&quot;,&quot;d-sm-flex&quot;,3,&quot;disabled&quot;],[&quot;id&quot;,&quot;msgNaslov&quot;,1,&quot;invalid-feedback&quot;,&quot;p-0&quot;,&quot;text-start&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;modal&quot;,&quot;data-bs-target&quot;,&quot;#exampleModal&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;ms-0&quot;,&quot;ms-sm-2&quot;,&quot;mt-2&quot;,&quot;mt-sm-0&quot;,&quot;col-sm-auto&quot;,&quot;d-sm-none&quot;,&quot;d-block&quot;,3,&quot;disabled&quot;],[&quot;id&quot;,&quot;exampleModal&quot;,&quot;tabindex&quot;,&quot;-1&quot;,&quot;role&quot;,&quot;dialog&quot;,&quot;aria-labelledby&quot;,&quot;exampleModalLabel&quot;,&quot;aria-hidden&quot;,&quot;true&quot;,1,&quot;modal&quot;,&quot;fade&quot;],[&quot;id&quot;,&quot;exampleModalLabel&quot;,1,&quot;modal-title&quot;],[&quot;id&quot;,&quot;map&quot;,2,&quot;height&quot;,&quot;400px&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-dismiss&quot;,&quot;modal&quot;,1,&quot;btn&quot;,&quot;btn-secondary&quot;,3,&quot;click&quot;],[&quot;id&quot;,&quot;saveLocation&quot;,&quot;type&quot;,&quot;button&quot;,&quot;data-bs-dismiss&quot;,&quot;modal&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;],[1,&quot;form-group&quot;,&quot;mb-3&quot;],[&quot;for&quot;,&quot;description&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[&quot;id&quot;,&quot;description&quot;,&quot;rows&quot;,&quot;5&quot;,&quot;placeholder&quot;,&quot;Opis dogodka&quot;,3,&quot;ngModel&quot;,&quot;classList&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;msgDescription&quot;,1,&quot;invalid-feedback&quot;,&quot;text-start&quot;],[&quot;for&quot;,&quot;date&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[1,&quot;input-group&quot;,&quot;mb-3&quot;,&quot;flex-row&quot;],[3,&quot;formGroup&quot;],[&quot;appearance&quot;,&quot;fill&quot;,&quot;aria-disabled&quot;,&quot;true&quot;],[&quot;id&quot;,&quot;date&quot;,&quot;matInput&quot;,&quot;&quot;,&quot;formControlName&quot;,&quot;spadunk&quot;,3,&quot;matDatepicker&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;matSuffix&quot;,&quot;&quot;,3,&quot;for&quot;],[&quot;disabled&quot;,&quot;false&quot;],[&quot;date&quot;,&quot;&quot;],[4,&quot;ngIf&quot;],[&quot;for&quot;,&quot;tagInput&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[3,&quot;currentTags&quot;,&quot;allTags&quot;,&quot;addTagEvent&quot;,&quot;removeTagEvent&quot;],[1,&quot;mb-3&quot;,&quot;mt-4&quot;,&quot;text-start&quot;],[1,&quot;text-start&quot;,&quot;mb-3&quot;],[&quot;id&quot;,&quot;tagsList&quot;,3,&quot;classList&quot;],[&quot;name&quot;,&quot;tag&quot;,&quot;class&quot;,&quot;chip mb-1 me-1&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[&quot;id&quot;,&quot;msgTags&quot;,1,&quot;invalid-feedback&quot;],[&quot;for&quot;,&quot;limitations&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[&quot;id&quot;,&quot;limitations&quot;,1,&quot;mb-3&quot;,&quot;input-group&quot;],[1,&quot;form-check&quot;],[&quot;id&quot;,&quot;limitedParticipants&quot;,&quot;type&quot;,&quot;checkbox&quot;,1,&quot;form-check-input&quot;,3,&quot;checked&quot;,&quot;change&quot;],[&quot;for&quot;,&quot;limitedParticipants&quot;,1,&quot;form-check-label&quot;,&quot;float-start&quot;],[&quot;type&quot;,&quot;number&quot;,&quot;min&quot;,&quot;1&quot;,&quot;id&quot;,&quot;participantsMax&quot;,&quot;placeholder&quot;,&quot;Maksimalno \u0161tevilo udele\u017eenih&quot;,3,&quot;ngModel&quot;,&quot;classList&quot;,&quot;disabled&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;msgParticipantsMax&quot;,1,&quot;invalid-feedback&quot;],[1,&quot;mb-4&quot;],[&quot;id&quot;,&quot;createEvent&quot;,&quot;class&quot;,&quot;btn btn-outline-primary btn-lg btn-block float-end mb-3&quot;,&quot;role&quot;,&quot;button&quot;,3,&quot;disabled&quot;,&quot;click&quot;,4,&quot;ngIf&quot;],[&quot;id&quot;,&quot;saveEvent&quot;,&quot;class&quot;,&quot;btn btn-outline-success btn-lg btn-block float-end mb-3&quot;,&quot;role&quot;,&quot;button&quot;,3,&quot;disabled&quot;,&quot;click&quot;,4,&quot;ngIf&quot;],[&quot;id&quot;,&quot;eventImage&quot;,&quot;alt&quot;,&quot;&quot;,1,&quot;img-responsive&quot;,&quot;rounded-circle&quot;,3,&quot;src&quot;],[&quot;id&quot;,&quot;eventImage&quot;,&quot;src&quot;,&quot;assets/images/events/timetable.png&quot;,&quot;alt&quot;,&quot;&quot;,1,&quot;img-responsive&quot;,&quot;rounded-circle&quot;],[&quot;name&quot;,&quot;tag&quot;,1,&quot;chip&quot;,&quot;mb-1&quot;,&quot;me-1&quot;],[1,&quot;closebtn&quot;,3,&quot;click&quot;],[&quot;id&quot;,&quot;createEvent&quot;,&quot;role&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-outline-primary&quot;,&quot;btn-lg&quot;,&quot;btn-block&quot;,&quot;float-end&quot;,&quot;mb-3&quot;,3,&quot;click&quot;],[&quot;id&quot;,&quot;saveEvent&quot;,&quot;role&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-outline-success&quot;,&quot;btn-lg&quot;,&quot;btn-block&quot;,&quot;float-end&quot;,&quot;mb-3&quot;,3,&quot;click&quot;]],template:function(e,i){if(1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;h4&quot;,2),d(3,&quot;b&quot;),b(4,&quot;Podatki o dogodku&quot;),h(),h(),d(5,&quot;div&quot;,3),d(6,&quot;label&quot;,4),b(7,&quot;Ime dogodka&quot;),h(),d(8,&quot;input&quot;,5),M(&quot;ngModelChange&quot;,function(s){return i.dogodek.title=s}),h(),d(9,&quot;div&quot;,6),b(10),h(),h(),d(11,&quot;label&quot;,7),b(12,&quot;Slika za prikaz dogodka&quot;),h(),d(13,&quot;div&quot;,8),d(14,&quot;div&quot;,9),I(15,KG,1,1,&quot;img&quot;,10),I(16,QG,1,0,&quot;ng-template&quot;,null,11,Nn),d(18,&quot;div&quot;,12),d(19,&quot;a&quot;,13),b(20,&quot;Uredi&quot;),h(),h(),h(),h(),d(21,&quot;div&quot;,14),d(22,&quot;div&quot;,15),d(23,&quot;div&quot;,16),d(24,&quot;div&quot;,17),d(25,&quot;h5&quot;,18),b(26,&quot;Spremeni sliko&quot;),h(),h(),d(27,&quot;div&quot;,19),k(28,&quot;app-izbira-slike&quot;),h(),d(29,&quot;div&quot;,20),d(30,&quot;button&quot;,21),b(31,&quot;Zapri&quot;),h(),h(),h(),h(),h(),d(32,&quot;label&quot;,22),b(33,&quot;Lokacija&quot;),h(),d(34,&quot;div&quot;,23),d(35,&quot;input&quot;,24),M(&quot;ngModelChange&quot;,function(s){return i.dogodek.city=s}),h(),d(36,&quot;div&quot;,25),b(37),h(),h(),d(38,&quot;div&quot;,26),d(39,&quot;input&quot;,27),M(&quot;ngModelChange&quot;,function(s){return i.dogodek.address=s}),h(),d(40,&quot;button&quot;,28),b(41,&quot; Izberi lokacijo &quot;),h(),d(42,&quot;div&quot;,29),b(43),h(),d(44,&quot;button&quot;,30),b(45,&quot; Izberi lokacijo &quot;),h(),h(),d(46,&quot;div&quot;,31),d(47,&quot;div&quot;,15),d(48,&quot;div&quot;,16),d(49,&quot;div&quot;,17),d(50,&quot;h5&quot;,32),b(51,&quot;Izberi lokacijo&quot;),h(),h(),d(52,&quot;div&quot;,19),k(53,&quot;div&quot;,33),h(),d(54,&quot;div&quot;,20),d(55,&quot;button&quot;,34),M(&quot;click&quot;,function(){return i.resetLocation()}),b(56,&quot;Zapri&quot;),h(),d(57,&quot;button&quot;,35),b(58,&quot;Shrani spremembe&quot;),h(),h(),h(),h(),h(),d(59,&quot;div&quot;,36),d(60,&quot;label&quot;,37),b(61,&quot;Opis dogodka&quot;),h(),d(62,&quot;textarea&quot;,38),M(&quot;ngModelChange&quot;,function(s){return i.dogodek.description=s}),h(),d(63,&quot;div&quot;,39),b(64),h(),h(),d(65,&quot;label&quot;,40),b(66,&quot; Pri\u010detek dogodka&quot;),h(),d(67,&quot;div&quot;,41),d(68,&quot;form&quot;,42),d(69,&quot;mat-form-field&quot;,43),d(70,&quot;mat-label&quot;),b(71,&quot;Izberite datum&quot;),h(),d(72,&quot;input&quot;,44),M(&quot;ngModelChange&quot;,function(s){return i.dogodek.date=s}),h(),k(73,&quot;mat-datepicker-toggle&quot;,45),k(74,&quot;mat-datepicker&quot;,46,47),I(76,ZG,2,0,&quot;mat-error&quot;,48),I(77,JG,2,0,&quot;mat-error&quot;,48),h(),h(),h(),d(78,&quot;label&quot;,49),b(79,&quot;Oznake dogodka&quot;),h(),d(80,&quot;div&quot;,41),d(81,&quot;div&quot;),d(82,&quot;app-autocomplete&quot;,50),M(&quot;addTagEvent&quot;,function(s){return i.addTag(s)})(&quot;removeTagEvent&quot;,function(s){return i.removeTag(s)}),h(),h(),h(),d(83,&quot;h5&quot;,51),d(84,&quot;b&quot;),b(85,&quot;Trenutne oznake: &quot;),h(),h(),d(86,&quot;div&quot;,52),d(87,&quot;ul&quot;,53),I(88,XG,4,1,&quot;li&quot;,54),h(),d(89,&quot;div&quot;,55),b(90),h(),h(),d(91,&quot;label&quot;,56),b(92,&quot;Omejitve dogodka&quot;),h(),d(93,&quot;div&quot;,57),d(94,&quot;div&quot;,58),d(95,&quot;input&quot;,59),M(&quot;change&quot;,function(){return i.omejitveDogodka=!i.omejitveDogodka}),h(),d(96,&quot;label&quot;,60),b(97,&quot; Omejeno \u0161tevilo prijavljenih &quot;),h(),h(),h(),d(98,&quot;input&quot;,61),M(&quot;ngModelChange&quot;,function(s){return i.dogodek.participantMax=s}),h(),d(99,&quot;div&quot;,62),b(100),h(),k(101,&quot;hr&quot;,63),I(102,e9,2,2,&quot;a&quot;,64),I(103,t9,2,2,&quot;a&quot;,65),h(),h()),2&amp;e){const r=Ee(17),s=Ee(75);y(8),w(&quot;ngModel&quot;,i.dogodek.title)(&quot;classList&quot;,i.validated?i.imeDogodka.valid?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;),y(2),de(&quot; &quot;,i.imeDogodka.message,&quot; &quot;),y(5),w(&quot;ngIf&quot;,i.dogodek.eventImage)(&quot;ngIfElse&quot;,r),y(4),Me(&quot;disabled&quot;,!i.jePovezava()),y(16),w(&quot;ngModel&quot;,i.dogodek.city)(&quot;classList&quot;,i.validated?i.mestoDogodka.valid?&quot;form-control col-sm-auto is-valid&quot;:&quot;form-control col-sm-auto is-invalid&quot;:&quot;form-control col-sm-auto&quot;),y(2),de(&quot; &quot;,i.mestoDogodka.message,&quot; &quot;),y(2),w(&quot;ngModel&quot;,i.dogodek.address)(&quot;classList&quot;,i.validated?i.naslovDogodka.valid?&quot;form-control col-sm-auto is-valid&quot;:&quot;form-control col-sm-auto is-invalid&quot;:&quot;form-control col-sm-auto&quot;),y(1),w(&quot;disabled&quot;,!i.jePovezava()),y(3),de(&quot; &quot;,i.naslovDogodka.message,&quot; &quot;),y(1),w(&quot;disabled&quot;,!i.jePovezava()),y(18),w(&quot;ngModel&quot;,i.dogodek.description)(&quot;classList&quot;,i.validated?i.opisDogodka.valid?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;),y(2),de(&quot; &quot;,i.opisDogodka.message,&quot; &quot;),y(4),w(&quot;formGroup&quot;,i.dogodekForm),y(4),w(&quot;matDatepicker&quot;,s)(&quot;ngModel&quot;,i.dogodek.date),y(1),w(&quot;for&quot;,s),y(3),w(&quot;ngIf&quot;,i.dogodekForm.get(&quot;spadunk&quot;).hasError(&quot;dateInPast&quot;)),y(1),w(&quot;ngIf&quot;,i.dogodekForm.get(&quot;spadunk&quot;).hasError(&quot;invalidDate&quot;)),y(5),w(&quot;currentTags&quot;,i.dogodek.tags)(&quot;allTags&quot;,i.allTags),y(5),w(&quot;classList&quot;,i.validated?i.oznakeDogodka.valid?&quot;chip-list is-valid&quot;:&quot;chip-list is-invalid&quot;:&quot;chip-list&quot;),y(1),w(&quot;ngForOf&quot;,i.dogodek.tags),y(2),de(&quot; &quot;,i.oznakeDogodka.message,&quot; &quot;),y(5),w(&quot;checked&quot;,i.omejitveDogodka&amp;&amp;0!=i.dogodek.participantMax),y(3),w(&quot;ngModel&quot;,i.dogodek.participantMax)(&quot;classList&quot;,i.validated?i.maxStUdelezenihDogodka.valid?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;)(&quot;disabled&quot;,!i.omejitveDogodka),y(2),de(&quot; &quot;,i.maxStUdelezenihDogodka.message,&quot; &quot;),y(2),w(&quot;ngIf&quot;,&quot;create&quot;==i.action),y(1),w(&quot;ngIf&quot;,&quot;edit&quot;==i.action)}},directives:[Bn,Vi,mi,rt,qG,ta,Jo,Br,j_,nc,U_,ac,_m,ry,L_,iy,YG,Fi,bm,fm,S5],styles:[&quot;#map[_ngcontent-%COMP%]{height:60vh;width:100%;margin:auto}&quot;]}),n})();class pa{constructor(){this.message=&quot;&quot;,this.valid=!0}}let i9=(()=&gt;{class n{constructor(){}ngOnInit(){}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-dogodek-ustvari&quot;]],decls:6,vars:3,consts:[[1,&quot;container&quot;,&quot;mt-3&quot;],[1,&quot;row&quot;,&quot;m-0&quot;],[1,&quot;nav&quot;,&quot;nav-pills&quot;,&quot;col-lg-3&quot;,&quot;col-md-12&quot;,&quot;flex-column&quot;,&quot;m-0&quot;,&quot;mb-3&quot;,&quot;p-0&quot;,&quot;pe-lg-2&quot;],[3,&quot;selectedPage&quot;],[1,&quot;col-lg-9&quot;,&quot;col-md-12&quot;,&quot;text-md-center&quot;],[3,&quot;action&quot;,&quot;omejitveDogodka&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),k(3,&quot;app-dogodki-sidenav&quot;,3),h(),d(4,&quot;div&quot;,4),k(5,&quot;app-dogodek-podrobnosti&quot;,5),h(),h(),h()),2&amp;e&amp;&amp;(y(3),w(&quot;selectedPage&quot;,&quot;create&quot;),y(2),w(&quot;action&quot;,&quot;create&quot;)(&quot;omejitveDogodka&quot;,!1))},directives:[ay,RA],styles:[&quot;&quot;]}),n})(),r9=(()=&gt;{class n{constructor(e,i){this.pot=e,this.dogodkiService=i,this.dogodek=new xA}ngOnInit(){this.pot.paramMap.pipe(nn(e=&gt;{let i=(e.get(&quot;idDogodka&quot;)||&quot;&quot;).toString();return this.dogodkiService.getDogodek(i)})).subscribe(e=&gt;{this.dogodek=e})}}return n.\u0275fac=function(e){return new(e||n)(_(Ur),_($r))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-dogodek-uredi&quot;]],decls:3,vars:3,consts:[[1,&quot;container&quot;,&quot;mt-3&quot;],[1,&quot;row&quot;,&quot;m-0&quot;],[3,&quot;action&quot;,&quot;dogodek&quot;,&quot;omejitveDogodka&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),k(2,&quot;app-dogodek-podrobnosti&quot;,2),h(),h()),2&amp;e&amp;&amp;(y(2),w(&quot;action&quot;,&quot;edit&quot;)(&quot;dogodek&quot;,i.dogodek)(&quot;omejitveDogodka&quot;,i.dogodek.participantMax&gt;0))},directives:[RA],styles:[&quot;&quot;]}),n})(),hc=(()=&gt;{class n{constructor(e,i){this.shramba=e,this.uporabnikService=i}vrniZeton(){return this.shramba.getItem(&quot;zeton&quot;)}shraniZeton(e){this.shramba.removeItem(&quot;zeton&quot;),this.shramba.setItem(&quot;zeton&quot;,e)}vrniUporabnika(){return this.shramba.getItem(&quot;uporabnik&quot;)}shraniUporabnika(e){this.shramba.removeItem(&quot;uporabnik&quot;),this.shramba.setItem(&quot;uporabnik&quot;,JSON.stringify(e))}odjava(){this.shramba.removeItem(&quot;uporabnik&quot;),this.shramba.removeItem(&quot;zeton&quot;)}prijava(e){return this.uporabnikService.prijava(e).pipe(zt(i=&gt;{this.shraniZeton(i.zeton),this.shraniUporabnika(i.uporabnik)}))}registracija(e){return this.uporabnikService.registracija(e).pipe(zt(i=&gt;{this.shraniZeton(i.zeton),this.shraniUporabnika(i.uporabnik)}))}jePrijavljen(){const e=this.vrniZeton();return!!e&amp;&amp;JSON.parse(this.b64Utf8(e.split(&quot;.&quot;)[1])).exp&gt;Date.now()/1e3}vrniTipUporabnika(){if(this.jePrijavljen()){const e=this.vrniZeton();if(e){const{tip:i}=JSON.parse(this.b64Utf8(e.split(&quot;.&quot;)[1]));return{tip:i}}}return null}b64Utf8(e){return decodeURIComponent(Array.prototype.map.call(atob(e),i=&gt;&quot;%&quot;+(&quot;00&quot;+i.charCodeAt(0).toString(16)).slice(-2)).join(&quot;&quot;))}}return n.\u0275fac=function(e){return new(e||n)(D(Nd),D($n))},n.\u0275prov=P({token:n,factory:n.\u0275fac,providedIn:&quot;root&quot;}),n})();function s9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,23),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.emailSporocilo,&quot; &quot;)}}function o9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,23),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.gesloSporocilo,&quot; &quot;)}}let a9=(()=&gt;{class n{constructor(e,i,r,s){this.uporabnikService=e,this.router=i,this.avtentikacijaStoritev=r,this.povezavaStoritev=s,this.prijava={email:&quot;&quot;,geslo:&quot;&quot;},this.emailSporocilo=&quot;Neveljaven email!&quot;,this.gesloSporocilo=&quot;Neveljavno geslo!&quot;,this.emailUstrezno=!1,this.gesloUstrezno=!1,this.emailSpremenjen=!1,this.gesloSpremenjeno=!1,this.zapomniSe=!0,this.autocompleteOption=&quot;on&quot;}ngOnInit(){}preveriPrijavo(){this.emailUstrezno&amp;&amp;this.gesloUstrezno&amp;&amp;this.izvediPrijavo(),!this.emailSpremenjen&amp;&amp;!this.gesloSpremenjeno&amp;&amp;(this.preveriEmail(),this.preveriGeslo())}izvediPrijavo(){this.avtentikacijaStoritev.prijava(this.prijava).subscribe({next:e=&gt;{this.router.navigate(e&amp;&amp;e.uporabnik&amp;&amp;&quot;navaden&quot;==e.uporabnik.tip?[&quot;/dogodki&quot;]:[&quot;/dogodki_admin&quot;])},error:e=&gt;{console.log(e),e&amp;&amp;e.includes(&quot;email&quot;)?(this.emailSporocilo=e,this.emailUstrezno=!1):(this.gesloUstrezno=!1,this.gesloSporocilo=e)}})}preveriEmail(){this.emailSporocilo=&quot;Neveljaven email!&quot;,this.emailSpremenjen=!0,this.emailUstrezno=!!this.validateEmail(this.prijava.email)}preveriGeslo(){this.gesloSporocilo=&quot;Neveljavno geslo!&quot;,this.gesloSpremenjeno=!0,this.gesloUstrezno=!!this.validatePassword(this.prijava.geslo)}changeAutocomplete(){this.zapomniSe=!this.zapomniSe,this.autocompleteOption=this.zapomniSe?&quot;on&quot;:&quot;off&quot;}validateEmail(e){return/^(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(e)}validatePassword(e){return/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])./.test(e)}jePovezava(){return this.povezavaStoritev.jePovezava}}return n.\u0275fac=function(e){return new(e||n)(_($n),_(Xe),_(hc),_(Yr))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-login&quot;]],decls:32,vars:11,consts:[[1,&quot;container&quot;],[1,&quot;row&quot;],[1,&quot;col-sm-9&quot;,&quot;col-md-7&quot;,&quot;col-lg-5&quot;,&quot;col-xl-4&quot;,&quot;mx-auto&quot;],[1,&quot;card&quot;,&quot;border-0&quot;,&quot;shadow&quot;,&quot;rounded-3&quot;,&quot;my-1&quot;,&quot;my-sm-5&quot;],[1,&quot;card-body&quot;,&quot;p-4&quot;,&quot;p-sm-5&quot;],[1,&quot;naslovInLogo&quot;,&quot;w-100&quot;,&quot;p-3&quot;],[&quot;routerLink&quot;,&quot;/&quot;],[&quot;src&quot;,&quot;assets/images/GoodMeetsLogo.png&quot;,&quot;alt&quot;,&quot;GoodMeetsLogo&quot;],[1,&quot;h3&quot;],[3,&quot;autocomplete&quot;,&quot;ngSubmit&quot;],[1,&quot;form-floating&quot;,&quot;mb-3&quot;],[&quot;name&quot;,&quot;email&quot;,&quot;type&quot;,&quot;email&quot;,3,&quot;ngModel&quot;,&quot;className&quot;,&quot;autocomplete&quot;,&quot;ngModelChange&quot;],[&quot;for&quot;,&quot;email&quot;],[&quot;class&quot;,&quot;invalid-feedback&quot;,4,&quot;ngIf&quot;],[&quot;name&quot;,&quot;geslo&quot;,&quot;type&quot;,&quot;password&quot;,3,&quot;ngModel&quot;,&quot;autocomplete&quot;,&quot;className&quot;,&quot;ngModelChange&quot;],[&quot;for&quot;,&quot;floatingPassword&quot;],[1,&quot;form-check&quot;,&quot;mb-3&quot;],[&quot;type&quot;,&quot;checkbox&quot;,1,&quot;form-check-input&quot;,3,&quot;checked&quot;,&quot;change&quot;],[&quot;for&quot;,&quot;rememberPasswordCheck&quot;,1,&quot;form-check-label&quot;],[1,&quot;d-grid&quot;],[&quot;type&quot;,&quot;submit&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;btn-login&quot;,&quot;text-uppercase&quot;,&quot;fw-bold&quot;,3,&quot;disabled&quot;],[1,&quot;mt-3&quot;],[&quot;routerLink&quot;,&quot;/signup&quot;,1,&quot;text-decoration-none&quot;],[1,&quot;invalid-feedback&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),d(3,&quot;div&quot;,3),d(4,&quot;div&quot;,4),d(5,&quot;div&quot;,5),d(6,&quot;a&quot;,6),k(7,&quot;img&quot;,7),h(),d(8,&quot;div&quot;,8),b(9,&quot;Prijava&quot;),h(),h(),d(10,&quot;form&quot;,9),M(&quot;ngSubmit&quot;,function(){return i.preveriPrijavo()}),d(11,&quot;div&quot;,10),d(12,&quot;input&quot;,11),M(&quot;ngModelChange&quot;,function(s){return i.prijava.email=s})(&quot;ngModelChange&quot;,function(){return i.preveriEmail()}),h(),d(13,&quot;label&quot;,12),b(14,&quot;E-naslov&quot;),h(),I(15,s9,2,1,&quot;div&quot;,13),h(),d(16,&quot;div&quot;,10),d(17,&quot;input&quot;,14),M(&quot;ngModelChange&quot;,function(s){return i.prijava.geslo=s})(&quot;ngModelChange&quot;,function(){return i.preveriGeslo()}),h(),d(18,&quot;label&quot;,15),b(19,&quot;Geslo&quot;),h(),I(20,o9,2,1,&quot;div&quot;,13),h(),d(21,&quot;div&quot;,16),d(22,&quot;input&quot;,17),M(&quot;change&quot;,function(){return i.changeAutocomplete()}),h(),d(23,&quot;label&quot;,18),b(24,&quot; Zapomni se me &quot;),h(),h(),d(25,&quot;div&quot;,19),d(26,&quot;button&quot;,20),b(27,&quot; Prijavi se &quot;),h(),d(28,&quot;p&quot;,21),b(29,&quot; \u0160e nima\u0161 ra\u010duna? &quot;),d(30,&quot;a&quot;,22),b(31,&quot;Registriraj se&quot;),h(),h(),h(),h(),h(),h(),h(),h(),h()),2&amp;e&amp;&amp;(y(10),vn(&quot;autocomplete&quot;,i.autocompleteOption),y(2),vn(&quot;autocomplete&quot;,i.autocompleteOption),w(&quot;ngModel&quot;,i.prijava.email)(&quot;className&quot;,i.emailSpremenjen?i.emailUstrezno?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;),y(3),w(&quot;ngIf&quot;,!i.emailUstrezno&amp;&amp;i.emailSpremenjen),y(2),vn(&quot;autocomplete&quot;,i.autocompleteOption),w(&quot;ngModel&quot;,i.prijava.geslo)(&quot;className&quot;,i.gesloSpremenjeno?i.gesloUstrezno?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;),y(3),w(&quot;ngIf&quot;,!i.gesloUstrezno&amp;&amp;i.gesloSpremenjeno),y(2),w(&quot;checked&quot;,i.zapomniSe),y(4),w(&quot;disabled&quot;,!i.jePovezava()))},directives:[zn,ta,Jo,gi,Bn,Vi,mi,rt],styles:[&quot;.btn-login[_ngcontent-%COMP%]{font-size:.9rem;letter-spacing:.05rem;padding:.75rem 1rem}.hr[_ngcontent-%COMP%]{height:2px;width:100%;border-width:0;color:#adadad;background-color:#adadad}.socialMediaBtn[_ngcontent-%COMP%]{border-color:#adadad}.naslovInLogo[_ngcontent-%COMP%]{text-align:center;padding-top:.1rem!important}.loginButton[_ngcontent-%COMP%]:hover{color:#fff}.loginButton[_ngcontent-%COMP%]{text-decoration:none;color:#fff}.containerFull[_ngcontent-%COMP%]{display:table;height:100%;width:100%}.invalid-feedback[_ngcontent-%COMP%]{display:block}&quot;]}),n})();function l9(n,t){1&amp;n&amp;&amp;(d(0,&quot;div&quot;,26),b(1,&quot; Neveljavno ime! &quot;),h())}function c9(n,t){1&amp;n&amp;&amp;(d(0,&quot;div&quot;,26),b(1,&quot; Neveljaven priimek! &quot;),h())}function u9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,26),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.uporabniskoImeSporocilo,&quot; &quot;)}}function d9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,26),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.emailSporocilo,&quot; &quot;)}}function h9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,26),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.prvoGesloSporocilo,&quot; &quot;)}}function f9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,26),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.drugoGesloSporocilo,&quot; &quot;)}}let p9=(()=&gt;{class n{constructor(e,i,r,s){this.uporabnikService=e,this.router=i,this.avtentikacijaStoritev=r,this.povezavaStoritev=s,this.posljiEmail=!1,this.registracija={email:&quot;&quot;,prvoGeslo:&quot;&quot;,drugoGeslo:&quot;&quot;,uporabniskoIme:&quot;&quot;,ime:&quot;&quot;,priimek:&quot;&quot;},this.emailSporocilo=&quot;Neveljaven email!&quot;,this.prvoGesloSporocilo=&quot;Neveljavno geslo!&quot;,this.drugoGesloSporocilo=&quot;Gesli se ne ujemata!&quot;,this.uporabniskoImeSporocilo=&quot;Neveljavno uporabnisko ime!&quot;,this.emailUstrezno=!1,this.gesloUstrezno=!1,this.prvoGesloUstrezno=!1,this.imeUstrezno=!1,this.priimekUstrezno=!1,this.uporabniskoImeUstrezno=!1,this.emailSpremenjen=!1,this.prvoGesloSpremenjeno=!1,this.drugoGesloSpremenjeno=!1,this.imeSpremenjeno=!1,this.priimekSpremenjen=!1,this.uporabniskoImeSpremenjeno=!1}ngOnInit(){}preveriEmail(){this.emailSpremenjen=!0,this.emailUstrezno=!!this.validateEmail(this.registracija.email)}preveriIme(){this.imeSpremenjeno=!0,this.imeUstrezno=&quot;&quot;!=this.registracija.ime}preveriPriimek(){this.priimekSpremenjen=!0,this.priimekUstrezno=&quot;&quot;!=this.registracija.priimek}preveriUporabniskoIme(){this.uporabniskoImeSpremenjeno=!0,this.uporabniskoImeUstrezno=&quot;&quot;!=this.registracija.uporabniskoIme}preveriPrvoGeslo(){this.prvoGesloSpremenjeno=!0,&quot;&quot;!=this.registracija.prvoGeslo&amp;&amp;this.validatePassword(this.registracija.prvoGeslo)?this.prvoGesloUstrezno=!0:(this.gesloUstrezno=!1,this.prvoGesloUstrezno=!1,this.prvoGesloSporocilo=&quot;Vsaj 1 velika in 1 mala \u010drka, ter 1 \u0161tevilka!&quot;),this.drugoGesloSpremenjeno&amp;&amp;this.preveriDrugoGeslo()}preveriDrugoGeslo(){this.drugoGesloSpremenjeno=!0,this.prvoGesloUstrezno?this.registracija.prvoGeslo==this.registracija.drugoGeslo?this.gesloUstrezno=!0:(this.gesloUstrezno=!1,this.drugoGesloSporocilo=&quot;Gesli se ne ujemata!&quot;):this.drugoGesloSporocilo=&quot;Prvo geslo ni pravilne oblike&quot;}ustrezniVnosi(){return this.emailUstrezno&amp;&amp;this.imeUstrezno&amp;&amp;this.priimekUstrezno&amp;&amp;this.uporabniskoImeUstrezno&amp;&amp;this.gesloUstrezno}ponovnoPreveriVseVnose(){this.preveriIme(),this.preveriPriimek(),this.preveriUporabniskoIme(),this.preveriEmail(),this.preveriPrvoGeslo(),this.preveriDrugoGeslo()}izvediRegistracijo(){this.avtentikacijaStoritev.registracija(this.registracija).subscribe({next:e=&gt;{this.router.navigate([&quot;/dogodki&quot;]),this.posljiEmail&amp;&amp;this.posliEmail()},error:e=&gt;{console.log(e),this.drugoGesloSporocilo=e}})}preveriRegistracijo(){this.ustrezniVnosi()?this.uporabnikService.preveriObstojEmail(this.registracija).subscribe({next:e=&gt;{e.length&gt;0&amp;&amp;(this.emailSporocilo=&quot;Vpisan e-mail naslov \u017ee obstaja!&quot;,this.emailUstrezno=!1),this.uporabnikService.preveriObstojUporabniskoIme(this.registracija).subscribe({next:i=&gt;{i.length&gt;0&amp;&amp;(this.uporabniskoImeSporocilo=&quot;Vpisano uporabni\u0161ko ime \u017ee obstaja!&quot;,this.uporabniskoImeUstrezno=!1),this.uporabniskoImeUstrezno&amp;&amp;this.emailUstrezno&amp;&amp;this.izvediRegistracijo()},error:i=&gt;{console.log(i)}})},error:e=&gt;{console.log(e)}}):this.ponovnoPreveriVseVnose()}posliEmail(){this.uporabnikService.posliEmail(this.registracija).subscribe({error:e=&gt;{console.log(e)}})}validateEmail(e){return/^(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(e)}validatePassword(e){return/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])./.test(e)}jePovezava(){return this.povezavaStoritev.jePovezava}}return n.\u0275fac=function(e){return new(e||n)(_($n),_(Xe),_(hc),_(Yr))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-signup&quot;]],decls:55,vars:20,consts:[[1,&quot;container&quot;],[1,&quot;row&quot;],[1,&quot;col-sm-9&quot;,&quot;col-md-7&quot;,&quot;col-lg-5&quot;,&quot;col-xl-4&quot;,&quot;mx-auto&quot;],[1,&quot;card&quot;,&quot;border-0&quot;,&quot;shadow&quot;,&quot;rounded-3&quot;,&quot;my-2&quot;,&quot;my-sm-5&quot;],[1,&quot;card-body&quot;,&quot;p-4&quot;,&quot;p-sm-5&quot;,&quot;paddingOkoliForma&quot;],[1,&quot;naslovInLogo&quot;,&quot;w-100&quot;,&quot;p-3&quot;],[&quot;href&quot;,&quot;/&quot;],[&quot;src&quot;,&quot;assets/images/GoodMeetsLogo.png&quot;,&quot;alt&quot;,&quot;GoodMeetsLogo&quot;],[1,&quot;h3&quot;],[&quot;autocomplete&quot;,&quot;off&quot;,3,&quot;ngSubmit&quot;],[1,&quot;col&quot;],[1,&quot;form-floating&quot;,&quot;mb-3&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;autocomplete&quot;,&quot;nope&quot;,&quot;name&quot;,&quot;ime&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;class&quot;,&quot;invalid-feedback&quot;,4,&quot;ngIf&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;name&quot;,&quot;priimek&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;name&quot;,&quot;uporabniskoIme&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;email&quot;,&quot;name&quot;,&quot;email&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;password&quot;,&quot;name&quot;,&quot;prvoGeslo&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;password&quot;,&quot;name&quot;,&quot;drugoGeslo&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[1,&quot;form-check&quot;,&quot;mb-3&quot;],[&quot;type&quot;,&quot;checkbox&quot;,1,&quot;form-check-input&quot;,3,&quot;checked&quot;,&quot;change&quot;],[&quot;for&quot;,&quot;posliEmailPotrdilo&quot;,1,&quot;form-check-label&quot;],[1,&quot;d-grid&quot;],[&quot;type&quot;,&quot;submit&quot;,1,&quot;mt-1&quot;,&quot;mb-2&quot;,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;btn-login&quot;,&quot;text-uppercase&quot;,&quot;fw-bold&quot;,3,&quot;disabled&quot;],[1,&quot;mt-1&quot;],[&quot;routerLink&quot;,&quot;/login&quot;,1,&quot;text-decoration-none&quot;],[1,&quot;invalid-feedback&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),d(3,&quot;div&quot;,3),d(4,&quot;div&quot;,4),d(5,&quot;div&quot;,5),d(6,&quot;a&quot;,6),k(7,&quot;img&quot;,7),h(),d(8,&quot;div&quot;,8),b(9,&quot;Registracija&quot;),h(),h(),d(10,&quot;form&quot;,9),M(&quot;ngSubmit&quot;,function(){return i.preveriRegistracijo()}),d(11,&quot;div&quot;,1),d(12,&quot;div&quot;,10),d(13,&quot;div&quot;,11),d(14,&quot;input&quot;,12),M(&quot;ngModelChange&quot;,function(s){return i.registracija.ime=s})(&quot;ngModelChange&quot;,function(){return i.preveriIme()}),h(),d(15,&quot;label&quot;),b(16,&quot;Ime&quot;),h(),I(17,l9,2,0,&quot;div&quot;,13),h(),h(),d(18,&quot;div&quot;,10),d(19,&quot;div&quot;,11),d(20,&quot;input&quot;,14),M(&quot;ngModelChange&quot;,function(s){return i.registracija.priimek=s})(&quot;ngModelChange&quot;,function(){return i.preveriPriimek()}),h(),d(21,&quot;label&quot;),b(22,&quot;Priimek&quot;),h(),I(23,c9,2,0,&quot;div&quot;,13),h(),h(),h(),d(24,&quot;div&quot;,11),d(25,&quot;input&quot;,15),M(&quot;ngModelChange&quot;,function(s){return i.registracija.uporabniskoIme=s})(&quot;ngModelChange&quot;,function(){return i.preveriUporabniskoIme()}),h(),d(26,&quot;label&quot;),b(27,&quot;Uporabni\u0161ko ime&quot;),h(),I(28,u9,2,1,&quot;div&quot;,13),h(),d(29,&quot;div&quot;,11),d(30,&quot;input&quot;,16),M(&quot;ngModelChange&quot;,function(s){return i.registracija.email=s})(&quot;ngModelChange&quot;,function(){return i.preveriEmail()}),h(),d(31,&quot;label&quot;),b(32,&quot;E-naslov&quot;),h(),I(33,d9,2,1,&quot;div&quot;,13),h(),d(34,&quot;div&quot;,11),d(35,&quot;input&quot;,17),M(&quot;ngModelChange&quot;,function(s){return i.registracija.prvoGeslo=s})(&quot;ngModelChange&quot;,function(){return i.preveriPrvoGeslo()}),h(),d(36,&quot;label&quot;),b(37,&quot;Geslo&quot;),h(),I(38,h9,2,1,&quot;div&quot;,13),h(),d(39,&quot;div&quot;,11),d(40,&quot;input&quot;,18),M(&quot;ngModelChange&quot;,function(s){return i.registracija.drugoGeslo=s})(&quot;ngModelChange&quot;,function(){return i.preveriDrugoGeslo()}),h(),d(41,&quot;label&quot;),b(42,&quot;Potrditev gesla&quot;),h(),I(43,f9,2,1,&quot;div&quot;,13),h(),d(44,&quot;div&quot;,19),d(45,&quot;input&quot;,20),M(&quot;change&quot;,function(){return i.posljiEmail=!i.posljiEmail}),h(),d(46,&quot;label&quot;,21),b(47,&quot; Po\u0161lji email ob uspe\u0161ni registraciji &quot;),h(),h(),d(48,&quot;div&quot;,22),d(49,&quot;button&quot;,23),b(50,&quot; USTVARI RA\u010cUN &quot;),h(),d(51,&quot;p&quot;,24),b(52,&quot; \u017de ima\u0161 ra\u010dun? &quot;),d(53,&quot;a&quot;,25),b(54,&quot;Prijavi se&quot;),h(),h(),h(),h(),h(),h(),h(),h(),h()),2&amp;e&amp;&amp;(y(14),w(&quot;className&quot;,i.imeSpremenjeno?i.imeUstrezno?&quot;form-control inputRegistration is-valid&quot;:&quot;form-control inputRegistration is-invalid&quot;:&quot;form-control inputRegistration&quot;)(&quot;ngModel&quot;,i.registracija.ime),y(3),w(&quot;ngIf&quot;,!i.imeUstrezno&amp;&amp;i.imeSpremenjeno),y(3),w(&quot;className&quot;,i.priimekSpremenjen?i.priimekUstrezno?&quot;form-control inputRegistration is-valid&quot;:&quot;form-control inputRegistration is-invalid&quot;:&quot;form-control inputRegistration&quot;)(&quot;ngModel&quot;,i.registracija.priimek),y(3),w(&quot;ngIf&quot;,!i.priimekUstrezno&amp;&amp;i.priimekSpremenjen),y(2),w(&quot;className&quot;,i.uporabniskoImeSpremenjeno?i.uporabniskoImeUstrezno?&quot;form-control inputRegistration is-valid&quot;:&quot;form-control inputRegistration is-invalid&quot;:&quot;form-control inputRegistration&quot;)(&quot;ngModel&quot;,i.registracija.uporabniskoIme),y(3),w(&quot;ngIf&quot;,!i.uporabniskoImeUstrezno&amp;&amp;i.uporabniskoImeSpremenjeno),y(2),w(&quot;className&quot;,i.emailSpremenjen?i.emailUstrezno?&quot;form-control inputRegistration is-valid&quot;:&quot;form-control inputRegistration is-invalid&quot;:&quot;form-control inputRegistration&quot;)(&quot;ngModel&quot;,i.registracija.email),y(3),w(&quot;ngIf&quot;,!i.emailUstrezno&amp;&amp;i.emailSpremenjen),y(2),w(&quot;className&quot;,i.prvoGesloSpremenjeno?i.prvoGesloUstrezno?&quot;form-control inputRegistration is-valid&quot;:&quot;form-control inputRegistration is-invalid&quot;:&quot;form-control inputRegistration&quot;)(&quot;ngModel&quot;,i.registracija.prvoGeslo),y(3),w(&quot;ngIf&quot;,!i.prvoGesloUstrezno&amp;&amp;i.prvoGesloSpremenjeno),y(2),w(&quot;className&quot;,i.drugoGesloSpremenjeno?i.gesloUstrezno?&quot;form-control inputRegistration is-valid&quot;:&quot;form-control inputRegistration is-invalid&quot;:&quot;form-control inputRegistration&quot;)(&quot;ngModel&quot;,i.registracija.drugoGeslo),y(3),w(&quot;ngIf&quot;,!i.gesloUstrezno&amp;&amp;i.drugoGesloSpremenjeno),y(2),w(&quot;checked&quot;,i.posljiEmail),y(4),w(&quot;disabled&quot;,!i.jePovezava()))},directives:[ta,Jo,gi,Bn,Vi,mi,rt,zn],styles:[&quot;.btn-login[_ngcontent-%COMP%]{font-size:.9rem;letter-spacing:.05rem;padding:.75rem 1rem}.paddingOkoliForma[_ngcontent-%COMP%]{padding-bottom:1.8rem!important}.naslovInLogo[_ngcontent-%COMP%]{text-align:center;padding-top:.1rem!important}.signupButton[_ngcontent-%COMP%]:hover{color:#fff}.signupButton[_ngcontent-%COMP%]{text-decoration:none;color:#fff}.inputRegistration[_ngcontent-%COMP%]{border:1px solid #ced4da!important;background-color:#fff!important;color:#3e3f3a}.footerLogSign[_ngcontent-%COMP%]{display:table-footer-group;text-align:center;opacity:.5;padding-bottom:1rem}.invalid-feedback[_ngcontent-%COMP%]{display:block}&quot;]}),n})(),g9=(()=&gt;{class n{transform(e){return`assets/images/profileAvatars/avatarOptions/profileAvatar${e}.png`}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275pipe=at({name:&quot;pathSlikeIzIndeksa&quot;,type:n,pure:!0}),n})();function m9(n,t){if(1&amp;n){const e=Ue();d(0,&quot;a&quot;,2),M(&quot;click&quot;,function(){const s=_e(e).$implicit;return T().changeImg(s)}),k(1,&quot;img&quot;,3),Ut(2,&quot;pathSlikeIzIndeksa&quot;),h()}if(2&amp;n){const e=t.$implicit;y(1),vn(&quot;src&quot;,ir(2,1,e),Nt)}}let _9=(()=&gt;{class n{constructor(e){this.uporabnikService=e,this.baseAvatarPath=&quot;profileAvatar&quot;,this.paths=[0,1,2,3,4,5,6,7,8,9,10,11,12,13]}ngOnInit(){}changeImg(e){document.getElementById(&quot;accountSettingsAvatar&quot;).src=`assets/images/profileAvatars/avatarOptions/profileAvatar${e}.png`,document.getElementById(&quot;changePictureModal&quot;).click()}}return n.\u0275fac=function(e){return new(e||n)(_($n))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-izbira-avatar&quot;]],decls:2,vars:1,consts:[[1,&quot;&quot;,2,&quot;max-height&quot;,&quot;400px&quot;,&quot;overflow&quot;,&quot;auto&quot;],[&quot;class&quot;,&quot;m-1&quot;,&quot;style&quot;,&quot;width: 20px; cursor: pointer;&quot;,3,&quot;click&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[1,&quot;m-1&quot;,2,&quot;width&quot;,&quot;20px&quot;,&quot;cursor&quot;,&quot;pointer&quot;,3,&quot;click&quot;],[&quot;id&quot;,&quot;userAvatarSettings&quot;,1,&quot;rounded-circle&quot;,&quot;mb-2&quot;,2,&quot;width&quot;,&quot;144px&quot;,&quot;height&quot;,&quot;144px&quot;,3,&quot;src&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),I(1,m9,3,3,&quot;a&quot;,1),h()),2&amp;e&amp;&amp;(y(1),w(&quot;ngForOf&quot;,i.paths))},directives:[Fi],pipes:[g9],styles:[&quot;&quot;]}),n})(),y9=(()=&gt;{class n{transform(e){return`\u0160e ${e} ${e&gt;=5||0==e?&quot;sekund&quot;:e&gt;=3?&quot;sekunde&quot;:2==e?&quot;sekundi&quot;:&quot;sekunda&quot;} do posodobitve podatkov!`}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275pipe=at({name:&quot;formatirajPreostaliCas&quot;,type:n,pure:!0}),n})();function v9(n,t){1&amp;n&amp;&amp;(d(0,&quot;div&quot;,36),b(1,&quot; Neveljavno ime! &quot;),h())}function b9(n,t){1&amp;n&amp;&amp;(d(0,&quot;div&quot;,36),b(1,&quot; Neveljaven priimek! &quot;),h())}function C9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,36),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.uporabniskoImeSporocilo,&quot; &quot;)}}function D9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,36),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.emailSporocilo,&quot; &quot;)}}function w9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,36),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.prvoGesloSporocilo,&quot; &quot;)}}function E9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,36),b(1),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,e.drugoGesloSporocilo,&quot; &quot;)}}function S9(n,t){if(1&amp;n){const e=Ue();d(0,&quot;button&quot;,37),M(&quot;click&quot;,function(){return _e(e),T().urediShrani()}),b(1),h()}if(2&amp;n){const e=T();y(1),de(&quot; &quot;,e.urediShraniGumb,&quot; &quot;)}}function k9(n,t){if(1&amp;n){const e=Ue();d(0,&quot;button&quot;,38),M(&quot;click&quot;,function(){return _e(e),T().prekliciSpremembe()}),b(1,&quot; PREKLI\u010cI &quot;),h()}}function M9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,39),b(1),Ut(2,&quot;formatirajPreostaliCas&quot;),h()),2&amp;n){const e=T();y(1),de(&quot; &quot;,ir(2,1,e.preostanekCasaZaUpdate),&quot; &quot;)}}let A9=(()=&gt;{class n{constructor(e,i){this.uporabnikService=e,this.router=i,this.uporabnik=new ks,this.kopijaUporabnika=new ks,this.prvoGeslo=&quot;&quot;,this.drugoGeslo=&quot;&quot;,this.urediShraniGumb=&quot;UREDI&quot;,this.vnosOnemogocen=!0,this.spremeniGeslo=!1,this.subscription=new ue,this.odstevanjeDoPosodobitve=!1,this.preostanekCasaZaUpdate=8,this.emailSporocilo=&quot;Neveljaven email!&quot;,this.prvoGesloSporocilo=&quot;Neveljavno geslo!&quot;,this.drugoGesloSporocilo=&quot;Gesli se ne ujemata!&quot;,this.uporabniskoImeSporocilo=&quot;Neveljavno uporabnisko ime!&quot;,this.emailUstrezno=!0,this.gesloUstrezno=!0,this.prvoGesloUstrezno=!0,this.imeUstrezno=!0,this.priimekUstrezno=!0,this.uporabniskoImeUstrezno=!0,this.emailSpremenjen=!1,this.prvoGesloSpremenjeno=!1,this.drugoGesloSpremenjeno=!1,this.imeSpremenjeno=!1,this.priimekSpremenjen=!1,this.uporabniskoImeSpremenjeno=!1}ngOnInit(){this.uporabnik=this.uporabnikService.getLoggedUser(),this.kopijaUporabnika=this.uporabnikService.getLoggedUser()}preveriIme(){this.imeSpremenjeno=!0,this.imeUstrezno=&quot;&quot;!=this.uporabnik.ime}preveriPriimek(){this.priimekSpremenjen=!0,this.priimekUstrezno=&quot;&quot;!=this.uporabnik.priimek}preveriUporabniskoIme(){this.uporabniskoImeSporocilo=&quot;Neveljavno uporabnisko ime!&quot;,this.uporabniskoImeSpremenjeno=!0,this.uporabniskoImeUstrezno=&quot;&quot;!=this.uporabnik.uporabniskoIme}preveriEmail(){this.emailSporocilo=&quot;Neveljaven email!&quot;,this.emailSpremenjen=!0,this.emailUstrezno=!!this.validateEmail(this.uporabnik.email)}preveriPrvoGeslo(){this.prvoGesloSpremenjeno=!0,this.drugoGesloSpremenjeno=!0,&quot;&quot;!=this.prvoGeslo&amp;&amp;this.validatePassword(this.prvoGeslo)?this.prvoGesloUstrezno=!0:(this.gesloUstrezno=!1,this.prvoGesloUstrezno=!1,this.prvoGesloSporocilo=&quot;Vsaj 1 velika in 1 mala \u010drka, ter 1 \u0161tevilka!&quot;),this.drugoGesloSpremenjeno&amp;&amp;this.preveriDrugoGeslo()}preveriDrugoGeslo(){this.prvoGesloSpremenjeno=!0,this.drugoGesloSpremenjeno=!0,this.prvoGesloUstrezno?this.prvoGeslo==this.drugoGeslo?this.gesloUstrezno=!0:(this.gesloUstrezno=!1,this.drugoGesloSporocilo=&quot;Gesli se ne ujemata!&quot;):this.drugoGesloSporocilo=&quot;Prvo geslo ni pravilne oblike&quot;}preveriSpremembnoPodatkov(){this.ustrezniVnosi()?this.uporabnikService.preveriObstojEmail(this.uporabnik).subscribe({next:e=&gt;{0==e.length||!this.emailSpremenjen||this.uporabnik._id==e[0]._id||(this.emailSporocilo=&quot;Vpisan e-mail naslov \u017ee obstaja!&quot;,this.emailUstrezno=!1),this.uporabnikService.preveriObstojUporabniskoIme(this.uporabnik).subscribe({next:i=&gt;{0==i.length||!this.uporabniskoImeSpremenjeno||this.uporabnik._id==i[0]._id||(this.uporabniskoImeSporocilo=&quot;Vpisano uporabni\u0161ko ime \u017ee obstaja!&quot;,this.uporabniskoImeUstrezno=!1),this.uporabniskoImeUstrezno&amp;&amp;this.emailUstrezno&amp;&amp;this.zacniOdstavatiCas()},error:i=&gt;{console.log(i)}})},error:e=&gt;{console.log(e)}}):this.ponovnoPreveriVseVnose()}zacniOdstavatiCas(){this.odstevanjeDoPosodobitve=!0,this.subscription=TA(1e3).subscribe(e=&gt;{this.izpisujPreostanek(this.preostanekCasaZaUpdate)})}izpisujPreostanek(e){this.odstevanjeDoPosodobitve||this.subscription.unsubscribe(),this.preostanekCasaZaUpdate-=1,this.preostanekCasaZaUpdate&lt;=0&amp;&amp;(this.subscription.unsubscribe(),this.posodobiUporabnika())}posodobiUporabnika(){this.spremeniGeslo&amp;&amp;(this.uporabnik.geslo=this.prvoGeslo),console.log(this.uporabnikService.getLoggedUser()),console.log(this.uporabnik),this.uporabnikService.posodobiUporabnika(this.uporabnik).subscribe({next:e=&gt;{console.log(e),null!=e&amp;&amp;(this.uporabnikService.setLoggedUser(e),location.replace(&quot;/dogodki&quot;))},error:e=&gt;{console.log(e)}})}urediShrani(){this.vnosOnemogocen?(this.urediShraniGumb=&quot;SHRANI&quot;,this.vnosOnemogocen=!1):this.aliJeBilaSprememba()?(this.ponovnoPreveriVseVnose(),this.ustrezniVnosi()&amp;&amp;this.preveriSpremembnoPodatkov()):this.prekliciSpremembe()}spremeniGesloChange(){this.spremeniGeslo=!this.spremeniGeslo,this.spremeniGeslo||this.poenostaviGesloInput()}aliJeBilaSprememba(){return this.preveriSprememboSlike()||this.uporabnik.ime!=this.kopijaUporabnika.ime||this.uporabnik.priimek!=this.kopijaUporabnika.priimek||this.uporabnik.uporabniskoIme!=this.kopijaUporabnika.uporabniskoIme||this.uporabnik.email!=this.kopijaUporabnika.email||this.spremeniGeslo}preveriSprememboSlike(){let e=document.getElementById(&quot;accountSettingsAvatar&quot;);var i=this.vrniIndeksSlike(e.src);return i!=this.kopijaUporabnika.slika&amp;&amp;(this.uporabnik.slika=i,!0)}vrniIndeksSlike(e){var i=e.substring(e.length-6,e.length-4);return&quot;r&quot;==i.charAt(0)?parseInt(i.substring(1,2)):parseInt(i)}ustrezniVnosi(){return this.emailUstrezno&amp;&amp;this.imeUstrezno&amp;&amp;this.priimekUstrezno&amp;&amp;this.uporabniskoImeUstrezno&amp;&amp;(!this.spremeniGeslo||this.gesloUstrezno)}prekliciSpremembe(){this.uporabnik=this.uporabnikService.getLoggedUser(),this.poenostaviSlikoUporabnika(),this.vnosOnemogocen=!0,this.urediShraniGumb=&quot;UREDI&quot;,this.spremeniGeslo=!1,this.prvoGeslo=&quot;&quot;,this.drugoGeslo=&quot;&quot;,this.resetPogojev(),this.odstevanjeDoPosodobitve&amp;&amp;(this.odstevanjeDoPosodobitve=!1,this.preostanekCasaZaUpdate=8)}ponovnoPreveriVseVnose(){this.preveriIme(),this.preveriPriimek(),this.preveriUporabniskoIme(),this.preveriEmail(),this.spremeniGeslo&amp;&amp;(this.preveriPrvoGeslo(),this.preveriDrugoGeslo())}poenostaviSlikoUporabnika(){document.getElementById(&quot;accountSettingsAvatar&quot;).src=&quot;assets/images/profileAvatars/avatarOptions/profileAvatar&quot;+this.kopijaUporabnika.slika+&quot;.png&quot;}resetPogojev(){this.emailSporocilo=&quot;Neveljaven email!&quot;,this.prvoGesloSporocilo=&quot;Neveljavno geslo!&quot;,this.drugoGesloSporocilo=&quot;Gesli se ne ujemata!&quot;,this.uporabniskoImeSporocilo=&quot;Neveljavno uporabnisko ime!&quot;,this.emailUstrezno=!0,this.gesloUstrezno=!1,this.prvoGesloUstrezno=!1,this.imeUstrezno=!0,this.priimekUstrezno=!0,this.uporabniskoImeUstrezno=!0,this.emailSpremenjen=!1,this.prvoGesloSpremenjeno=!1,this.drugoGesloSpremenjeno=!1,this.imeSpremenjeno=!1,this.priimekSpremenjen=!1,this.uporabniskoImeSpremenjeno=!1}poenostaviGesloInput(){this.uporabnik.geslo&amp;&amp;(this.uporabnik.geslo=&quot;&quot;),this.prvoGesloSporocilo=&quot;&quot;,this.drugoGesloSporocilo=&quot;&quot;,this.prvoGeslo=&quot;&quot;,this.drugoGeslo=&quot;&quot;,this.prvoGesloSpremenjeno=!1,this.drugoGesloSpremenjeno=!1,this.prvoGesloUstrezno=!1,this.gesloUstrezno=!1}validateEmail(e){return/^(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(e)}validatePassword(e){return/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])./.test(e)}}return n.\u0275fac=function(e){return new(e||n)(_($n),_(Xe))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-account-settings&quot;]],decls:69,vars:32,consts:[[1,&quot;container&quot;],[1,&quot;row&quot;],[1,&quot;col-sm-&quot;,&quot;col-md-11&quot;,&quot;col-lg-10&quot;,&quot;col-xl-9&quot;,&quot;mx-auto&quot;],[1,&quot;card&quot;,&quot;border-0&quot;,&quot;shadow&quot;,&quot;rounded-3&quot;,&quot;my-1&quot;,&quot;my-sm-4&quot;],[1,&quot;card-body&quot;,&quot;p-2&quot;,&quot;p-sm-5&quot;,&quot;pb-2&quot;],[1,&quot;card-title&quot;,&quot;text-center&quot;,&quot;mb-1&quot;,&quot;mb-xl-4&quot;,&quot;fw-light&quot;,&quot;fs-5&quot;],[1,&quot;paddingOkoliContainerja&quot;,&quot;container&quot;],[1,&quot;col-xl-4&quot;,&quot;col-12&quot;,&quot;stolpecAvatar&quot;],[1,&quot;centerPicture&quot;],[1,&quot;d-flex&quot;,&quot;flex-column&quot;,&quot;align-items-center&quot;,&quot;text-center&quot;,&quot;p-lg-1&quot;,&quot;py-4&quot;,&quot;py-lg-3&quot;],[&quot;width&quot;,&quot;160rem&quot;,&quot;id&quot;,&quot;accountSettingsAvatar&quot;,1,&quot;rounded-circle&quot;,&quot;mt-xl-0&quot;,3,&quot;src&quot;],[&quot;role&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;modal&quot;,&quot;data-bs-target&quot;,&quot;#changePictureModal&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;mt-2&quot;,3,&quot;disabled&quot;],[1,&quot;col-xl-8&quot;,&quot;col-12&quot;],[1,&quot;col&quot;],[1,&quot;form-floating&quot;,&quot;mb-3&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;name&quot;,&quot;ime&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;value&quot;,&quot;disabled&quot;,&quot;ngModelChange&quot;],[&quot;class&quot;,&quot;invalid-feedback&quot;,4,&quot;ngIf&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;name&quot;,&quot;priimek&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;disabled&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;name&quot;,&quot;uporabniskoIme&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;disabled&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;email&quot;,&quot;name&quot;,&quot;email&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;disabled&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;checkbox&quot;,1,&quot;form-check-input&quot;,&quot;mb-3&quot;,3,&quot;checked&quot;,&quot;disabled&quot;,&quot;change&quot;],[&quot;for&quot;,&quot;posliEmailPotrdilo&quot;,1,&quot;form-check-label&quot;,&quot;mx-1&quot;],[&quot;type&quot;,&quot;password&quot;,&quot;name&quot;,&quot;prvoGeslo&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;disabled&quot;,&quot;ngModelChange&quot;],[&quot;type&quot;,&quot;password&quot;,&quot;name&quot;,&quot;drugoGeslo&quot;,3,&quot;className&quot;,&quot;ngModel&quot;,&quot;disabled&quot;,&quot;ngModelChange&quot;],[1,&quot;btnSave&quot;],[&quot;class&quot;,&quot;btn btn-primary text-uppercase fw-bold&quot;,3,&quot;click&quot;,4,&quot;ngIf&quot;],[&quot;class&quot;,&quot;btn btn-danger text-uppercase fw-bold ms-2&quot;,3,&quot;click&quot;,4,&quot;ngIf&quot;],[&quot;class&quot;,&quot;row text-danger&quot;,4,&quot;ngIf&quot;],[&quot;id&quot;,&quot;changePictureModal&quot;,&quot;tabindex&quot;,&quot;-1&quot;,&quot;role&quot;,&quot;dialog&quot;,&quot;aria-labelledby&quot;,&quot;changePictureModalLabel&quot;,&quot;aria-hidden&quot;,&quot;true&quot;,1,&quot;modal&quot;,&quot;fade&quot;],[&quot;role&quot;,&quot;document&quot;,1,&quot;modal-dialog&quot;,2,&quot;max-width&quot;,&quot;520px&quot;],[1,&quot;modal-content&quot;],[1,&quot;modal-header&quot;],[&quot;id&quot;,&quot;changePictureModalLabel&quot;,1,&quot;modal-title&quot;],[1,&quot;modal-body&quot;,2,&quot;max-width&quot;,&quot;520px&quot;],[1,&quot;modal-footer&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-dismiss&quot;,&quot;modal&quot;,1,&quot;btn&quot;,&quot;btn-secondary&quot;],[1,&quot;invalid-feedback&quot;],[1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;text-uppercase&quot;,&quot;fw-bold&quot;,3,&quot;click&quot;],[1,&quot;btn&quot;,&quot;btn-danger&quot;,&quot;text-uppercase&quot;,&quot;fw-bold&quot;,&quot;ms-2&quot;,3,&quot;click&quot;],[1,&quot;row&quot;,&quot;text-danger&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),d(3,&quot;div&quot;,3),d(4,&quot;div&quot;,4),d(5,&quot;h5&quot;,5),b(6,&quot; Osebni podatki &quot;),h(),d(7,&quot;form&quot;),d(8,&quot;div&quot;,6),d(9,&quot;div&quot;,1),d(10,&quot;div&quot;,7),d(11,&quot;div&quot;,8),d(12,&quot;div&quot;,9),k(13,&quot;img&quot;,10),d(14,&quot;button&quot;,11),b(15,&quot; SPREMENI&quot;),h(),h(),h(),h(),d(16,&quot;div&quot;,12),d(17,&quot;div&quot;,1),d(18,&quot;div&quot;,13),d(19,&quot;div&quot;,14),d(20,&quot;input&quot;,15),M(&quot;ngModelChange&quot;,function(s){return i.uporabnik.ime=s})(&quot;ngModelChange&quot;,function(){return i.preveriIme()}),h(),d(21,&quot;label&quot;),b(22,&quot;Ime&quot;),h(),I(23,v9,2,0,&quot;div&quot;,16),h(),h(),d(24,&quot;div&quot;,13),d(25,&quot;div&quot;,14),d(26,&quot;input&quot;,17),M(&quot;ngModelChange&quot;,function(s){return i.uporabnik.priimek=s})(&quot;ngModelChange&quot;,function(){return i.preveriPriimek()}),h(),d(27,&quot;label&quot;),b(28,&quot;Priimek&quot;),h(),I(29,b9,2,0,&quot;div&quot;,16),h(),h(),h(),d(30,&quot;div&quot;,14),d(31,&quot;input&quot;,18),M(&quot;ngModelChange&quot;,function(s){return i.uporabnik.uporabniskoIme=s})(&quot;ngModelChange&quot;,function(){return i.preveriUporabniskoIme()}),h(),d(32,&quot;label&quot;),b(33,&quot;Uporabni\u0161ko ime&quot;),h(),I(34,C9,2,1,&quot;div&quot;,16),h(),d(35,&quot;div&quot;,14),d(36,&quot;input&quot;,19),M(&quot;ngModelChange&quot;,function(s){return i.uporabnik.email=s})(&quot;ngModelChange&quot;,function(){return i.preveriEmail()}),h(),d(37,&quot;label&quot;),b(38,&quot;E-naslov&quot;),h(),I(39,D9,2,1,&quot;div&quot;,16),h(),d(40,&quot;input&quot;,20),M(&quot;change&quot;,function(){return i.spremeniGesloChange()}),h(),d(41,&quot;label&quot;,21),b(42,&quot; Spremeni geslo &quot;),h(),d(43,&quot;div&quot;,14),d(44,&quot;input&quot;,22),M(&quot;ngModelChange&quot;,function(s){return i.prvoGeslo=s})(&quot;ngModelChange&quot;,function(){return i.preveriPrvoGeslo()}),h(),d(45,&quot;label&quot;),b(46,&quot;Novo geslo&quot;),h(),I(47,w9,2,1,&quot;div&quot;,16),h(),d(48,&quot;div&quot;,14),d(49,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.drugoGeslo=s})(&quot;ngModelChange&quot;,function(){return i.preveriDrugoGeslo()}),h(),d(50,&quot;label&quot;),b(51,&quot;Potrditev novega gesla&quot;),h(),I(52,E9,2,1,&quot;div&quot;,16),h(),h(),h(),d(53,&quot;div&quot;,1),d(54,&quot;div&quot;,24),I(55,S9,2,1,&quot;button&quot;,25),I(56,k9,2,0,&quot;button&quot;,26),h(),h(),I(57,M9,3,3,&quot;div&quot;,27),h(),h(),h(),h(),h(),h(),d(58,&quot;div&quot;,28),d(59,&quot;div&quot;,29),d(60,&quot;div&quot;,30),d(61,&quot;div&quot;,31),d(62,&quot;h5&quot;,32),b(63,&quot;Spremeni sliko&quot;),h(),h(),d(64,&quot;div&quot;,33),k(65,&quot;app-izbira-avatar&quot;),h(),d(66,&quot;div&quot;,34),d(67,&quot;button&quot;,35),b(68,&quot;Zapri&quot;),h(),h(),h(),h(),h(),h()),2&amp;e&amp;&amp;(y(13),si(&quot;src&quot;,&quot;assets/images/profileAvatars/avatarOptions/profileAvatar&quot;,i.uporabnik.slika,&quot;.png&quot;,Nt),y(1),w(&quot;disabled&quot;,i.vnosOnemogocen||i.odstevanjeDoPosodobitve),y(6),vn(&quot;value&quot;,i.uporabnik.ime),w(&quot;className&quot;,i.imeSpremenjeno?i.imeUstrezno?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;)(&quot;ngModel&quot;,i.uporabnik.ime)(&quot;disabled&quot;,i.vnosOnemogocen||i.odstevanjeDoPosodobitve),y(3),w(&quot;ngIf&quot;,!i.imeUstrezno&amp;&amp;i.imeSpremenjeno),y(3),w(&quot;className&quot;,i.priimekSpremenjen?i.priimekUstrezno?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;)(&quot;ngModel&quot;,i.uporabnik.priimek)(&quot;disabled&quot;,i.vnosOnemogocen||i.odstevanjeDoPosodobitve),y(3),w(&quot;ngIf&quot;,!i.priimekUstrezno&amp;&amp;i.priimekSpremenjen),y(2),w(&quot;className&quot;,i.uporabniskoImeSpremenjeno?i.uporabniskoImeUstrezno?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;)(&quot;ngModel&quot;,i.uporabnik.uporabniskoIme)(&quot;disabled&quot;,i.vnosOnemogocen||i.odstevanjeDoPosodobitve),y(3),w(&quot;ngIf&quot;,!i.uporabniskoImeUstrezno&amp;&amp;i.uporabniskoImeSpremenjeno),y(2),w(&quot;className&quot;,i.emailSpremenjen?i.emailUstrezno?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;)(&quot;ngModel&quot;,i.uporabnik.email)(&quot;disabled&quot;,i.vnosOnemogocen||i.odstevanjeDoPosodobitve),y(3),w(&quot;ngIf&quot;,!i.emailUstrezno&amp;&amp;i.emailSpremenjen),y(1),w(&quot;checked&quot;,i.spremeniGeslo)(&quot;disabled&quot;,i.vnosOnemogocen||i.odstevanjeDoPosodobitve),y(4),w(&quot;className&quot;,i.prvoGesloSpremenjeno?i.prvoGesloUstrezno?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;)(&quot;ngModel&quot;,i.prvoGeslo)(&quot;disabled&quot;,i.vnosOnemogocen||i.odstevanjeDoPosodobitve||!i.spremeniGeslo),y(3),w(&quot;ngIf&quot;,!i.prvoGesloUstrezno&amp;&amp;i.prvoGesloSpremenjeno),y(2),w(&quot;className&quot;,i.drugoGesloSpremenjeno?i.gesloUstrezno?&quot;form-control is-valid&quot;:&quot;form-control is-invalid&quot;:&quot;form-control&quot;)(&quot;ngModel&quot;,i.drugoGeslo)(&quot;disabled&quot;,i.vnosOnemogocen||i.odstevanjeDoPosodobitve||!i.spremeniGeslo),y(3),w(&quot;ngIf&quot;,!i.gesloUstrezno&amp;&amp;i.drugoGesloSpremenjeno),y(3),w(&quot;ngIf&quot;,!i.odstevanjeDoPosodobitve),y(1),w(&quot;ngIf&quot;,!i.vnosOnemogocen),y(1),w(&quot;ngIf&quot;,i.odstevanjeDoPosodobitve))},directives:[ta,Jo,gi,Bn,Vi,mi,rt,_9],pipes:[y9],styles:[&quot;.centerPicture[_ngcontent-%COMP%]{display:block;margin-left:auto;margin-right:auto;width:50%!important;height:50%!important}.btnSave[_ngcontent-%COMP%]{font-size:.9rem;letter-spacing:.05rem;padding:.75rem 1rem;text-align:right}.paddingOkoliContainerja[_ngcontent-%COMP%]{padding-left:.5rem!important;padding-right:.5rem!important}@media screen and (min-width: 1140px){.stolpecAvatar[_ngcontent-%COMP%]{display:flex;align-items:center;padding-bottom:20%}}&quot;]}),n})();function T9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,3),k(1,&quot;app-seznam-dogodkov&quot;,4),h()),2&amp;n){const e=T();y(1),w(&quot;dogodki&quot;,e.dogodki)(&quot;page&quot;,&quot;admin&quot;)(&quot;totalEvents&quot;,e.totalEvents)(&quot;pageSize&quot;,e.pageSize)}}let I9=(()=&gt;{class n{constructor(e){this.dogodkiService=e,this.pageSize=10,this.totalEvents=0}ngOnInit(){this.getDogodki()}getDogodki(){let e={page:0};e.size=this.pageSize?this.pageSize:10,this.dogodkiService.getDogodki(e).subscribe(i=&gt;(this.dogodki=i.events,this.totalEvents=i.totalEvents))}}return n.\u0275fac=function(e){return new(e||n)(_($r))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-dogodki-admin&quot;]],decls:3,vars:1,consts:[[1,&quot;container&quot;,&quot;mt-3&quot;],[1,&quot;row&quot;,&quot;m-0&quot;],[&quot;class&quot;,&quot;col&quot;,4,&quot;ngIf&quot;],[1,&quot;col&quot;],[3,&quot;dogodki&quot;,&quot;page&quot;,&quot;totalEvents&quot;,&quot;pageSize&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),I(2,T9,2,4,&quot;div&quot;,2),h(),h()),2&amp;e&amp;&amp;(y(2),w(&quot;ngIf&quot;,i.dogodki))},directives:[rt,dc],styles:[&quot;&quot;]}),n})();function x9(n,t){if(1&amp;n){const e=Ue();d(0,&quot;div&quot;,11),d(1,&quot;div&quot;,12),k(2,&quot;img&quot;,13),d(3,&quot;div&quot;,14),k(4,&quot;img&quot;,15),d(5,&quot;h5&quot;,16),b(6),h(),d(7,&quot;p&quot;,17),b(8),h(),d(9,&quot;p&quot;,18),b(10),h(),d(11,&quot;p&quot;,19),b(12),h(),h(),d(13,&quot;div&quot;,20),d(14,&quot;button&quot;,21),M(&quot;click&quot;,function(){const s=_e(e).$implicit;return T().deleteUser(s._id)}),b(15,&quot;Odstrani&quot;),h(),h(),h(),h()}if(2&amp;n){const e=t.$implicit;y(4),si(&quot;src&quot;,&quot;/assets/images/profileAvatars/avatarOptions/profileAvatar&quot;,e.slika,&quot;.png&quot;,Nt),y(2),er(&quot;&quot;,e.ime,&quot; &quot;,e.priimek,&quot;&quot;),y(2),nt(e.uporabniskoIme),y(2),nt(e.email),y(2),nt(e._id)}}let R9=(()=&gt;{class n{constructor(e){this.uporabnikiService=e,this.searchword=&quot;&quot;}ngOnInit(){this.getUporabniki()}getUporabniki(){this.uporabnikiService.getUsers().subscribe(e=&gt;this.uporabniki=e)}deleteUser(e){this.uporabnikiService.deleteUser(e).subscribe(()=&gt;this.getUporabniki())}}return n.\u0275fac=function(e){return new(e||n)(_($n))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-uporabniki-admin&quot;]],decls:12,vars:5,consts:[[&quot;rel&quot;,&quot;stylesheet&quot;,&quot;href&quot;,&quot;/assets/stylesheets/adminUporabniki.css&quot;],[1,&quot;container&quot;],[1,&quot;main-body&quot;],[1,&quot;row&quot;,&quot;mt-2&quot;,&quot;mb-2&quot;,&quot;flex-row-reverse&quot;],[&quot;id&quot;,&quot;navSearchAdmin&quot;,1,&quot;form-inline&quot;],[1,&quot;input-group&quot;,&quot;rounded&quot;],[&quot;type&quot;,&quot;search&quot;,&quot;id&quot;,&quot;searchAdmin&quot;,&quot;placeholder&quot;,&quot;I\u0161\u010di&quot;,1,&quot;form-control&quot;,&quot;rounded&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;search-addon&quot;,&quot;onclick&quot;,&quot;search()&quot;,1,&quot;input-group-text&quot;,&quot;border-0&quot;],[1,&quot;fas&quot;,&quot;fa-search&quot;],[1,&quot;row&quot;,&quot;row-cols-1&quot;,&quot;row-cols-sm-2&quot;,&quot;row-cols-md-3&quot;,&quot;row-cols-xl-4&quot;,&quot;gutters-sm&quot;],[&quot;class&quot;,&quot;col mb-3 uporabniki&quot;,4,&quot;ngFor&quot;,&quot;ngForOf&quot;],[1,&quot;col&quot;,&quot;mb-3&quot;,&quot;uporabniki&quot;],[1,&quot;card&quot;],[&quot;src&quot;,&quot;/assets/images/profileAvatars/ozadjeUporabnika.png&quot;,&quot;alt&quot;,&quot;Cover&quot;,1,&quot;card-img-top&quot;],[1,&quot;card-body&quot;,&quot;text-center&quot;],[&quot;alt&quot;,&quot;User&quot;,1,&quot;img-fluid&quot;,&quot;img-thumbnail&quot;,&quot;rounded-circle&quot;,&quot;border-0&quot;,&quot;mb-3&quot;,2,&quot;width&quot;,&quot;100px&quot;,&quot;margin-top&quot;,&quot;-65px&quot;,3,&quot;src&quot;],[&quot;id&quot;,&quot;uporabnikImePriimek&quot;,1,&quot;card-title&quot;],[&quot;id&quot;,&quot;uporabnikUporabniskoIme&quot;,1,&quot;text-secondary&quot;,&quot;mb-1&quot;],[&quot;id&quot;,&quot;uporabnikEmail&quot;,1,&quot;text-secondary&quot;,&quot;mb-1&quot;],[&quot;id&quot;,&quot;uporabnik_id&quot;,1,&quot;text-muted&quot;,&quot;font-size-sm&quot;],[1,&quot;card-footer&quot;],[&quot;type&quot;,&quot;button&quot;,1,&quot;btn&quot;,&quot;btn-danger&quot;,&quot;btn-sm&quot;,&quot;has-icon&quot;,&quot;btn-block&quot;,3,&quot;click&quot;]],template:function(e,i){1&amp;e&amp;&amp;(k(0,&quot;link&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;div&quot;,2),d(3,&quot;div&quot;,3),d(4,&quot;div&quot;,4),d(5,&quot;div&quot;,5),d(6,&quot;input&quot;,6),M(&quot;ngModelChange&quot;,function(s){return i.searchword=s}),h(),d(7,&quot;button&quot;,7),k(8,&quot;i&quot;,8),h(),h(),h(),h(),d(9,&quot;div&quot;,9),I(10,x9,16,6,&quot;div&quot;,10),Ut(11,&quot;filter&quot;),h(),h(),h()),2&amp;e&amp;&amp;(y(6),w(&quot;ngModel&quot;,i.searchword),y(4),w(&quot;ngForOf&quot;,xr(11,2,i.uporabniki,i.searchword)))},directives:[Bn,Vi,mi,Fi],pipes:[oy],styles:[&quot;&quot;]}),n})(),P9=(()=&gt;{class n{constructor(e){this.http=e,this.apiUrl=oa_apiUrl}naloziPodatke(){return this.http.get(`${this.apiUrl}/db/podatki/vnos`).pipe(qe(1),Ie(this.obdelajNapako))}zbrisiPodatke(){return this.http.get(`${this.apiUrl}/db/podatki/odstranitev`).pipe(qe(1),Ie(this.obdelajNapako))}obdelajNapako(e){return zr(`Pri\u0161lo je do napake ${e.status} z opisom ${e.error.sporo\u010dilo||e.statusText}`)}}return n.\u0275fac=function(e){return new(e||n)(D(Zo))},n.\u0275prov=P({token:n,factory:n.\u0275fac,providedIn:&quot;root&quot;}),n})(),O9=(()=&gt;{class n{constructor(e){this.dbStoritev=e}vnesiPodatke(){this.dbStoritev.naloziPodatke().subscribe(()=&gt;{document.querySelector(&quot;#vnosPodatkovSporociloOk&quot;).style.display=&quot;block&quot;,setTimeout(()=&gt;this.vnosSporociloOdstranitev(),3e3)})}odstraniPodatke(){this.dbStoritev.zbrisiPodatke().subscribe(()=&gt;{document.querySelector(&quot;#odstranitevPodatkovSporociloOk&quot;).style.display=&quot;block&quot;,setTimeout(()=&gt;this.odstraniSporociloOdstranitev(),3e3)})}vnosSporociloOdstranitev(){document.querySelector(&quot;#vnosPodatkovSporociloOk&quot;).style.display=&quot;none&quot;}odstraniSporociloOdstranitev(){document.querySelector(&quot;#odstranitevPodatkovSporociloOk&quot;).style.display=&quot;none&quot;}ngOnInit(){}}return n.\u0275fac=function(e){return new(e||n)(_(P9))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-db&quot;]],decls:24,vars:0,consts:[[1,&quot;row&quot;,&quot;mb-3&quot;,&quot;mx-1&quot;],[1,&quot;col-sm-12&quot;,&quot;col-md-6&quot;,&quot;col-lg-2&quot;],[&quot;routerLink&quot;,&quot;/&quot;],[&quot;src&quot;,&quot;assets/images/GoodMeetsLogo.png&quot;,&quot;width&quot;,&quot;100%&quot;],[1,&quot;row&quot;,&quot;mb-1&quot;,&quot;mx-1&quot;],[1,&quot;col-12&quot;],[&quot;id&quot;,&quot;gumbVnosPodatkov&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;text-uppercase&quot;,&quot;fw-bold&quot;,3,&quot;click&quot;],[1,&quot;row&quot;,&quot;mb-4&quot;,&quot;mx-1&quot;],[&quot;id&quot;,&quot;vnosPodatkovSporociloOk&quot;,1,&quot;valid-feedback&quot;],[&quot;id&quot;,&quot;vnosPodatkovSporociloError&quot;,1,&quot;invalid-feedback&quot;],[&quot;id&quot;,&quot;gumbVnosPodatkov&quot;,1,&quot;btn&quot;,&quot;btn-danger&quot;,&quot;text-uppercase&quot;,&quot;fw-bold&quot;,3,&quot;click&quot;],[&quot;id&quot;,&quot;odstranitevPodatkovSporociloOk&quot;,1,&quot;valid-feedback&quot;],[&quot;id&quot;,&quot;odstranitevPodatkovSporociloError&quot;,1,&quot;invalid-feedback&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;div&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;a&quot;,2),k(3,&quot;img&quot;,3),h(),h(),h(),d(4,&quot;div&quot;,4),d(5,&quot;div&quot;,5),d(6,&quot;button&quot;,6),M(&quot;click&quot;,function(){return i.vnesiPodatke()}),b(7,&quot; VNOS ZA\u010cETNIH PODATKOV &quot;),h(),h(),h(),d(8,&quot;div&quot;,7),d(9,&quot;div&quot;,5),d(10,&quot;p&quot;,8),b(11,&quot;Podatki so bili uspe\u0161no vneseni!&quot;),h(),d(12,&quot;p&quot;,9),b(13,&quot;Napaka pri vnosu podatkov!&quot;),h(),h(),h(),d(14,&quot;div&quot;,4),d(15,&quot;div&quot;,5),d(16,&quot;button&quot;,10),M(&quot;click&quot;,function(){return i.odstraniPodatke()}),b(17,&quot; IZBRI\u0160I VSE PODATKE &quot;),h(),h(),h(),d(18,&quot;div&quot;,7),d(19,&quot;div&quot;,5),d(20,&quot;p&quot;,11),b(21,&quot;Podatki so bili uspe\u0161no odstranjeni!&quot;),h(),d(22,&quot;p&quot;,12),b(23,&quot;Napaka pri odstranitvi podatkov!&quot;),h(),h(),h())},directives:[zn],styles:[&quot;&quot;]}),n})();function F9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,39),k(1,&quot;app-seznam-dogodkov&quot;,40),h()),2&amp;n){const e=T();y(1),w(&quot;page&quot;,&quot;gost&quot;)(&quot;dogodki&quot;,e.dogodki)(&quot;totalEvents&quot;,e.totalEvents)(&quot;pageSize&quot;,e.pageSize)(&quot;filters&quot;,e.filters)(&quot;useFilter&quot;,e.filtered)}}let N9=(()=&gt;{class n{constructor(e){this.dogodkiService=e,this.filters={startDate:&quot;&quot;,endDate:&quot;&quot;,lokacija:&quot;&quot;,razdalja:5,lng:0,lat:0,page:0,pageSize:10},this.filtered=!1,this.pageSize=10,this.totalEvents=0}ngOnInit(){this.getDogodki()}getDogodki(){let e={page:0};e.size=this.pageSize?this.pageSize:10,this.dogodkiService.getDogodki(e).subscribe(i=&gt;(this.dogodki=i.events,this.totalEvents=i.totalEvents))}getDogodkiFiltered(){if(&quot;&quot;===this.filters.startDate){var e=new Date(2e3,0,1);this.filters.startDate=e.toDateString()}&quot;&quot;===this.filters.endDate&amp;&amp;(e=new Date(2030,0,1),this.filters.endDate=e.toDateString()),this.filters.page=0,this.filters.pageSize=this.pageSize?this.pageSize:10,console.log(this.filters),&quot;&quot;===this.filters.lokacija?this.dogodkiService.getDogodkiFiltered(this.filters).subscribe(i=&gt;(this.dogodki=i.events,console.log(i),this.totalEvents=i.totalEvents)):this.dogodkiService.dogodekLokacija(this.filters.lokacija).subscribe(i=&gt;{this.filters.lng=i[0].lon,this.filters.lat=i[0].lat,this.dogodkiService.getDogodkiFiltered(this.filters).subscribe(r=&gt;(this.dogodki=r.events,this.totalEvents=r.totalEvents))}),this.filtered=!0}closeNav(){document.getElementById(&quot;main-sidebar-container&quot;).style.marginLeft=&quot;-100%&quot;}}return n.\u0275fac=function(e){return new(e||n)(_($r))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-dogodki-gost&quot;]],decls:112,vars:17,consts:[[&quot;id&quot;,&quot;main-sidebar-container&quot;,1,&quot;col-12&quot;,&quot;width&quot;,&quot;pull-left&quot;],[1,&quot;main-sidebar&quot;],[1,&quot;row&quot;],[1,&quot;card&quot;,2,&quot;min-height&quot;,&quot;812px&quot;],[1,&quot;card-header&quot;],[&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#main-sidebar-container&quot;,&quot;aria-controls&quot;,&quot;main-sidebar-container&quot;,1,&quot;btn&quot;,&quot;btn-outline-secondary&quot;,&quot;float-end&quot;,3,&quot;click&quot;],[1,&quot;fas&quot;,&quot;fa-bars&quot;],[&quot;id&quot;,&quot;accordionPanelsStayOpenExample&quot;,1,&quot;accordion&quot;],[1,&quot;accordion-item&quot;],[&quot;id&quot;,&quot;panelsStayOpen-headingTwo&quot;,1,&quot;accordion-header&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#panelsStayOpen-collapseTwo&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-controls&quot;,&quot;panelsStayOpen-collapseTwo&quot;,1,&quot;accordion-button&quot;,&quot;collapsed&quot;],[&quot;id&quot;,&quot;panelsStayOpen-collapseTwo&quot;,&quot;aria-labelledby&quot;,&quot;panelsStayOpen-headingTwo&quot;,1,&quot;accordion-collapse&quot;,&quot;collapse&quot;],[1,&quot;accordion-body&quot;],[1,&quot;form-group&quot;],[&quot;for&quot;,&quot;locationInput&quot;,2,&quot;margin-bottom&quot;,&quot;0.5rem&quot;],[&quot;type&quot;,&quot;text&quot;,&quot;name&quot;,&quot;location&quot;,&quot;id&quot;,&quot;locationFilter&quot;,&quot;placeholder&quot;,&quot;Izberi lokacijo&quot;,1,&quot;form-control&quot;,2,&quot;margin-bottom&quot;,&quot;0.5rem&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;for&quot;,&quot;range&quot;,1,&quot;form-label&quot;],[&quot;id&quot;,&quot;rangeSlider&quot;,&quot;type&quot;,&quot;range&quot;,&quot;value&quot;,&quot;5&quot;,&quot;min&quot;,&quot;5&quot;,&quot;max&quot;,&quot;50&quot;,&quot;step&quot;,&quot;5&quot;,&quot;id&quot;,&quot;locationRange&quot;,&quot;oninput&quot;,&quot;this.nextElementSibling.value = this.value&quot;,1,&quot;form-range&quot;,3,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;id&quot;,&quot;panelsStayOpen-headingThree&quot;,1,&quot;accordion-header&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#panelsStayOpen-collapseThree&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-controls&quot;,&quot;panelsStayOpen-collapseThree&quot;,1,&quot;accordion-button&quot;,&quot;collapsed&quot;],[&quot;id&quot;,&quot;panelsStayOpen-collapseThree&quot;,&quot;aria-labelledby&quot;,&quot;panelsStayOpen-headingThree&quot;,1,&quot;accordion-collapse&quot;,&quot;collapse&quot;],[&quot;for&quot;,&quot;startDate&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[&quot;appearance&quot;,&quot;fill&quot;,2,&quot;width&quot;,&quot;100%&quot;],[&quot;matInput&quot;,&quot;&quot;,3,&quot;matDatepicker&quot;,&quot;ngModel&quot;,&quot;ngModelChange&quot;],[&quot;matSuffix&quot;,&quot;&quot;,3,&quot;for&quot;],[&quot;startDate2&quot;,&quot;&quot;],[&quot;for&quot;,&quot;endDate&quot;,1,&quot;float-start&quot;,&quot;m-1&quot;],[&quot;endDate2&quot;,&quot;&quot;],[&quot;id&quot;,&quot;removeFilters&quot;,3,&quot;click&quot;],[1,&quot;btn&quot;,&quot;btn-danger&quot;,&quot;m-2&quot;,2,&quot;float&quot;,&quot;left&quot;],[&quot;id&quot;,&quot;filterButton&quot;],[&quot;id&quot;,&quot;confirmFilters&quot;,1,&quot;btn&quot;,&quot;btn-primary&quot;,&quot;m-2&quot;,2,&quot;float&quot;,&quot;right&quot;,3,&quot;click&quot;],[1,&quot;container&quot;,&quot;mt-3&quot;],[1,&quot;row&quot;,&quot;m-0&quot;],[1,&quot;col-lg-3&quot;,&quot;ps-0&quot;,&quot;d-none&quot;,&quot;d-lg-block&quot;],[1,&quot;card&quot;],[&quot;startDate&quot;,&quot;&quot;],[&quot;endDate&quot;,&quot;&quot;],[&quot;class&quot;,&quot;col-lg-9 col-md-12&quot;,4,&quot;ngIf&quot;],[1,&quot;col-lg-9&quot;,&quot;col-md-12&quot;],[3,&quot;page&quot;,&quot;dogodki&quot;,&quot;totalEvents&quot;,&quot;pageSize&quot;,&quot;filters&quot;,&quot;useFilter&quot;]],template:function(e,i){if(1&amp;e&amp;&amp;(k(0,&quot;app-home-navbar&quot;),d(1,&quot;div&quot;,0),d(2,&quot;div&quot;,1),d(3,&quot;div&quot;,2),d(4,&quot;div&quot;,3),d(5,&quot;div&quot;,4),d(6,&quot;b&quot;),b(7,&quot;Filter&quot;),h(),d(8,&quot;button&quot;,5),M(&quot;click&quot;,function(){return i.closeNav()}),k(9,&quot;i&quot;,6),h(),h(),d(10,&quot;div&quot;,7),d(11,&quot;div&quot;,8),d(12,&quot;h2&quot;,9),d(13,&quot;button&quot;,10),b(14,&quot; Kraj &quot;),h(),h(),d(15,&quot;div&quot;,11),d(16,&quot;div&quot;,12),d(17,&quot;div&quot;,13),d(18,&quot;label&quot;,14),b(19,&quot;Kraj&quot;),h(),d(20,&quot;input&quot;,15),M(&quot;ngModelChange&quot;,function(s){return i.filters.lokacija=s}),h(),h(),d(21,&quot;label&quot;,16),b(22,&quot;Razdalja&quot;),h(),d(23,&quot;input&quot;,17),M(&quot;ngModelChange&quot;,function(s){return i.filters.razdalja=s}),h(),d(24,&quot;output&quot;),b(25,&quot;5&quot;),h(),b(26,&quot; km &quot;),h(),h(),h(),d(27,&quot;div&quot;,8),d(28,&quot;h2&quot;,18),d(29,&quot;button&quot;,19),b(30,&quot; Datum &quot;),h(),h(),d(31,&quot;div&quot;,20),d(32,&quot;div&quot;,12),d(33,&quot;label&quot;,21),b(34,&quot;Od:&quot;),h(),d(35,&quot;mat-form-field&quot;,22),d(36,&quot;mat-label&quot;),b(37,&quot;Choose a date&quot;),h(),d(38,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.filters.startDate=s}),h(),k(39,&quot;mat-datepicker-toggle&quot;,24),k(40,&quot;mat-datepicker&quot;,null,25),h(),d(42,&quot;label&quot;,26),b(43,&quot;Do:&quot;),h(),d(44,&quot;mat-form-field&quot;,22),d(45,&quot;mat-label&quot;),b(46,&quot;Choose a date&quot;),h(),d(47,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.filters.endDate=s}),h(),k(48,&quot;mat-datepicker-toggle&quot;,24),k(49,&quot;mat-datepicker&quot;,null,27),h(),h(),h(),h(),d(51,&quot;a&quot;,28),M(&quot;click&quot;,function(){return i.getDogodki()}),d(52,&quot;button&quot;,29),b(53,&quot;Po\u010disti&quot;),h(),h(),d(54,&quot;a&quot;,30),d(55,&quot;button&quot;,31),M(&quot;click&quot;,function(){return i.getDogodkiFiltered()}),b(56,&quot;Potrdi&quot;),h(),h(),h(),h(),h(),h(),h(),d(57,&quot;div&quot;,32),d(58,&quot;div&quot;,33),d(59,&quot;div&quot;,34),d(60,&quot;div&quot;,35),d(61,&quot;div&quot;,4),d(62,&quot;b&quot;),b(63,&quot;Filter&quot;),h(),h(),d(64,&quot;div&quot;,7),d(65,&quot;div&quot;,8),d(66,&quot;h2&quot;,9),d(67,&quot;button&quot;,10),b(68,&quot; Kraj &quot;),h(),h(),d(69,&quot;div&quot;,11),d(70,&quot;div&quot;,12),d(71,&quot;div&quot;,13),d(72,&quot;label&quot;,14),b(73,&quot;Kraj&quot;),h(),d(74,&quot;input&quot;,15),M(&quot;ngModelChange&quot;,function(s){return i.filters.lokacija=s}),h(),h(),d(75,&quot;label&quot;,16),b(76,&quot;Razdalja&quot;),h(),d(77,&quot;input&quot;,17),M(&quot;ngModelChange&quot;,function(s){return i.filters.razdalja=s}),h(),d(78,&quot;output&quot;),b(79,&quot;5&quot;),h(),b(80,&quot; km &quot;),h(),h(),h(),d(81,&quot;div&quot;,8),d(82,&quot;h2&quot;,18),d(83,&quot;button&quot;,19),b(84,&quot; Datum &quot;),h(),h(),d(85,&quot;div&quot;,20),d(86,&quot;div&quot;,12),d(87,&quot;label&quot;,21),b(88,&quot;Od:&quot;),h(),d(89,&quot;mat-form-field&quot;,22),d(90,&quot;mat-label&quot;),b(91,&quot;Choose a date&quot;),h(),d(92,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.filters.startDate=s}),h(),k(93,&quot;mat-datepicker-toggle&quot;,24),k(94,&quot;mat-datepicker&quot;,null,36),h(),d(96,&quot;label&quot;,26),b(97,&quot;Do:&quot;),h(),d(98,&quot;mat-form-field&quot;,22),d(99,&quot;mat-label&quot;),b(100,&quot;Choose a date&quot;),h(),d(101,&quot;input&quot;,23),M(&quot;ngModelChange&quot;,function(s){return i.filters.endDate=s}),h(),k(102,&quot;mat-datepicker-toggle&quot;,24),k(103,&quot;mat-datepicker&quot;,null,37),h(),h(),h(),h(),d(105,&quot;a&quot;,28),M(&quot;click&quot;,function(){return i.getDogodki()}),d(106,&quot;button&quot;,29),b(107,&quot;Po\u010disti&quot;),h(),h(),d(108,&quot;a&quot;,30),d(109,&quot;button&quot;,31),M(&quot;click&quot;,function(){return i.getDogodkiFiltered()}),b(110,&quot;Potrdi&quot;),h(),h(),h(),h(),h(),I(111,F9,2,6,&quot;div&quot;,38),h(),h()),2&amp;e){const r=Ee(41),s=Ee(50),o=Ee(95),a=Ee(104);y(20),w(&quot;ngModel&quot;,i.filters.lokacija),y(3),w(&quot;ngModel&quot;,i.filters.razdalja),y(15),w(&quot;matDatepicker&quot;,r)(&quot;ngModel&quot;,i.filters.startDate),y(1),w(&quot;for&quot;,r),y(8),w(&quot;matDatepicker&quot;,s)(&quot;ngModel&quot;,i.filters.endDate),y(1),w(&quot;for&quot;,s),y(26),w(&quot;ngModel&quot;,i.filters.lokacija),y(3),w(&quot;ngModel&quot;,i.filters.razdalja),y(15),w(&quot;matDatepicker&quot;,o)(&quot;ngModel&quot;,i.filters.startDate),y(1),w(&quot;for&quot;,o),y(8),w(&quot;matDatepicker&quot;,a)(&quot;ngModel&quot;,i.filters.endDate),y(1),w(&quot;for&quot;,a),y(9),w(&quot;ngIf&quot;,i.dogodki)}},directives:[AA,Bn,Vi,mi,gd,j_,nc,U_,ac,ry,L_,iy,rt,dc],styles:[&quot;&quot;]}),n})(),zi=(()=&gt;{class n{constructor(e,i,r){this.avtentikacijaStoritev=e,this.router=i,this.location=r}canActivate(e,i){var r=this.avtentikacijaStoritev.vrniTipUporabnika();return null!=r&amp;&amp;e.data.role==r.tip||(this.location.back(),!1)}}return n.\u0275fac=function(e){return new(e||n)(D(hc),D(Xe),D(vs))},n.\u0275prov=P({token:n,factory:n.\u0275fac,providedIn:&quot;root&quot;}),n})();const V9=[{path:&quot;&quot;,component:DG},{path:&quot;dogodki_gost&quot;,component:N9},{path:&quot;dogodki&quot;,component:uG,canActivate:[zi],data:{role:&quot;navaden&quot;}},{path:&quot;pridruzeni_dogodki&quot;,component:vG,canActivate:[zi],data:{role:&quot;navaden&quot;}},{path:&quot;ustvari_dogodek&quot;,component:i9,canActivate:[zi],data:{role:&quot;navaden&quot;}},{path:&quot;uredi_dogodek/:idDogodka&quot;,component:r9,canActivate:[zi],data:{role:&quot;navaden&quot;}},{path:&quot;ustvarjeni_dogodki&quot;,component:$G,canActivate:[zi],data:{role:&quot;navaden&quot;}},{path:&quot;klepet&quot;,component:IA,canActivate:[zi],data:{role:&quot;navaden&quot;}},{path:&quot;klepet/:idDogodka&quot;,component:IA,canActivate:[zi],data:{role:&quot;navaden&quot;}},{path:&quot;login&quot;,component:a9},{path:&quot;signup&quot;,component:p9},{path:&quot;account_settings&quot;,component:A9,canActivate:[zi],data:{role:&quot;navaden&quot;}},{path:&quot;dogodki_admin&quot;,component:I9,canActivate:[zi],data:{role:&quot;admin&quot;}},{path:&quot;uporabniki_admin&quot;,component:R9,canActivate:[zi],data:{role:&quot;admin&quot;}},{path:&quot;db&quot;,component:O9},{path:&quot;**&quot;,redirectTo:&quot;&quot;}];let L9=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({imports:[[Ko,Gk.forRoot(V9)],Gk]}),n})();const j9=function(){return[&quot;dogodki&quot;]};function B9(n,t){1&amp;n&amp;&amp;(d(0,&quot;a&quot;,18),k(1,&quot;img&quot;,19),h()),2&amp;n&amp;&amp;w(&quot;routerLink&quot;,function(n,t,e){const i=Kt()+n,r=x();return r[i]===re?Ii(r,i,e?t.call(e):t()):function(n,t){return n[t]}(r,i)}(1,j9))}function U9(n,t){1&amp;n&amp;&amp;k(0,&quot;i&quot;,20)}let H9=(()=&gt;{class n{constructor(e,i,r,s){this.router=e,this.uporabnikService=i,this.avtentikacijaStoritev=r,this.povezavaStoritev=s,this.loggedUser=new ks}ngOnInit(){this.loggedUser=this.uporabnikService.getLoggedUser()}isHomeRoute(){return&quot;/&quot;!=this.router.url}izpisUporabnika(){this.avtentikacijaStoritev.odjava()}jePovezava(){return this.povezavaStoritev.jePovezava}}return n.\u0275fac=function(e){return new(e||n)(_(Xe),_($n),_(hc),_(Yr))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-main-navbar&quot;]],decls:27,vars:5,consts:[[1,&quot;navbar&quot;,&quot;navbar-expand-lg&quot;,&quot;navbar-light&quot;,&quot;bg-light&quot;,&quot;static-top&quot;],[1,&quot;container&quot;],[&quot;class&quot;,&quot;navbar-brand&quot;,&quot;style&quot;,&quot;cursor:\n        pointer;&quot;,3,&quot;routerLink&quot;,4,&quot;ngIf&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#navbarSupportedContent&quot;,&quot;aria-controls&quot;,&quot;navbarSupportedContent&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-label&quot;,&quot;Toggle navigation&quot;,1,&quot;navbar-toggler&quot;,&quot;me-auto&quot;],[1,&quot;navbar-toggler-icon&quot;],[&quot;id&quot;,&quot;navbarSupportedContent&quot;,1,&quot;collapse&quot;,&quot;navbar-collapse&quot;,&quot;mt-2&quot;],[1,&quot;navbar-nav&quot;],[1,&quot;nav-item&quot;],[&quot;id&quot;,&quot;myEventsNav&quot;,&quot;routerLink&quot;,&quot;/pridruzeni_dogodki&quot;,1,&quot;nav-link&quot;,&quot;text-body&quot;,&quot;active&quot;,2,&quot;cursor&quot;,&quot;pointer&quot;],[&quot;role&quot;,&quot;button&quot;,&quot;routerLink&quot;,&quot;/klepet&quot;,1,&quot;nav-link&quot;,&quot;text-body&quot;,&quot;active&quot;],[1,&quot;dropdown&quot;,&quot;mt-2&quot;],[&quot;role&quot;,&quot;button&quot;,&quot;id&quot;,&quot;dropdownMenuLink&quot;,&quot;data-bs-toggle&quot;,&quot;dropdown&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,1,&quot;btn&quot;,&quot;btn-light&quot;,&quot;dropdown-toggle&quot;],[&quot;id&quot;,&quot;uporabnikImePriiimek&quot;,2,&quot;text-transform&quot;,&quot;none&quot;],[&quot;alt&quot;,&quot;Profile picture&quot;,&quot;width&quot;,&quot;32&quot;,&quot;height&quot;,&quot;32&quot;,&quot;id&quot;,&quot;userAvatar&quot;,1,&quot;rounded-circle&quot;,&quot;ms-2&quot;,3,&quot;src&quot;],[&quot;class&quot;,&quot;fas fa-exclamation-triangle text-danger ms-2&quot;,4,&quot;ngIf&quot;],[&quot;aria-labelledby&quot;,&quot;dropdownUser1&quot;,1,&quot;dropdown-menu&quot;,&quot;w-100&quot;,&quot;text-small&quot;],[&quot;role&quot;,&quot;button&quot;,&quot;routerLink&quot;,&quot;/account_settings&quot;,1,&quot;dropdown-item&quot;],[&quot;routerLink&quot;,&quot;&quot;,1,&quot;dropdown-item&quot;,3,&quot;click&quot;],[1,&quot;navbar-brand&quot;,2,&quot;cursor&quot;,&quot;pointer&quot;,3,&quot;routerLink&quot;],[&quot;src&quot;,&quot;assets/images/GoodMeetsLogo.png&quot;,&quot;alt&quot;,&quot;Logo&quot;,1,&quot;img-fluid&quot;],[1,&quot;fas&quot;,&quot;fa-exclamation-triangle&quot;,&quot;text-danger&quot;,&quot;ms-2&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;nav&quot;,0),d(1,&quot;div&quot;,1),I(2,B9,2,2,&quot;a&quot;,2),d(3,&quot;button&quot;,3),k(4,&quot;span&quot;,4),h(),d(5,&quot;div&quot;,5),d(6,&quot;ul&quot;,6),d(7,&quot;li&quot;,7),d(8,&quot;a&quot;,8),b(9,&quot;Moji dogodki&quot;),h(),h(),d(10,&quot;li&quot;,7),d(11,&quot;a&quot;,9),b(12,&quot;Klepet&quot;),h(),h(),h(),h(),d(13,&quot;div&quot;,10),d(14,&quot;a&quot;,11),d(15,&quot;span&quot;,12),b(16),h(),k(17,&quot;img&quot;,13),h(),I(18,U9,1,0,&quot;i&quot;,14),d(19,&quot;ul&quot;,15),d(20,&quot;li&quot;),d(21,&quot;a&quot;,16),b(22,&quot;Nastavitve&quot;),h(),h(),k(23,&quot;li&quot;),d(24,&quot;li&quot;),d(25,&quot;a&quot;,17),M(&quot;click&quot;,function(){return i.izpisUporabnika()}),b(26,&quot;Izpis&quot;),h(),h(),h(),h(),h(),h()),2&amp;e&amp;&amp;(y(2),w(&quot;ngIf&quot;,i.isHomeRoute()),y(14),er(&quot;&quot;,i.loggedUser.ime,&quot; &quot;,i.loggedUser.priimek,&quot;&quot;),y(1),si(&quot;src&quot;,&quot;assets/images/profileAvatars/avatarOptions/profileAvatar&quot;,i.loggedUser.slika,&quot;.png&quot;,Nt),y(1),w(&quot;ngIf&quot;,!i.jePovezava()))},directives:[rt,zn],styles:[&quot;&quot;]}),n})();function z9(n,t){1&amp;n&amp;&amp;k(0,&quot;i&quot;,18)}let $9=(()=&gt;{class n{constructor(e,i,r){this.uporabnikService=e,this.avtentikacijaStoritev=i,this.povezavaStoritev=r,this.loggedUser=new ks}ngOnInit(){this.loggedUser=this.uporabnikService.getLoggedUser()}izpisUporabnika(){this.avtentikacijaStoritev.odjava()}jePovezava(){return this.povezavaStoritev.jePovezava}}return n.\u0275fac=function(e){return new(e||n)(_($n),_(hc),_(Yr))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-admin-main-navbar&quot;]],decls:24,vars:4,consts:[[1,&quot;navbar&quot;,&quot;navbar-expand-lg&quot;,&quot;navbar-light&quot;,&quot;bg-light&quot;,&quot;static-top&quot;],[1,&quot;container&quot;],[1,&quot;navbar-brand&quot;,&quot;mt-2&quot;,&quot;mt-lg-0&quot;],[&quot;src&quot;,&quot;/assets/images/goodMeetsLogoAdmin.png&quot;,&quot;alt&quot;,&quot;Logo&quot;,1,&quot;img-fluid&quot;],[&quot;type&quot;,&quot;button&quot;,&quot;data-bs-toggle&quot;,&quot;collapse&quot;,&quot;data-bs-target&quot;,&quot;#navbarSupportedContent&quot;,&quot;aria-controls&quot;,&quot;navbarSupportedContent&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,&quot;aria-label&quot;,&quot;Toggle navigation&quot;,1,&quot;navbar-toggler&quot;,&quot;me-auto&quot;],[1,&quot;navbar-toggler-icon&quot;],[&quot;id&quot;,&quot;navbarSupportedContent&quot;,1,&quot;collapse&quot;,&quot;navbar-collapse&quot;],[1,&quot;navbar-nav&quot;],[1,&quot;nav-item&quot;],[&quot;routerLink&quot;,&quot;/dogodki_admin&quot;,1,&quot;nav-link&quot;,&quot;text-body&quot;,&quot;active&quot;],[&quot;routerLink&quot;,&quot;/uporabniki_admin&quot;,1,&quot;nav-link&quot;,&quot;text-body&quot;,&quot;active&quot;],[1,&quot;dropdown&quot;],[&quot;href&quot;,&quot;#&quot;,&quot;role&quot;,&quot;button&quot;,&quot;id&quot;,&quot;dropdownMenuLink&quot;,&quot;data-bs-toggle&quot;,&quot;dropdown&quot;,&quot;aria-expanded&quot;,&quot;false&quot;,1,&quot;btn&quot;,&quot;btn-light&quot;,&quot;dropdown-toggle&quot;],[&quot;id&quot;,&quot;uporabnikImePriiimek&quot;],[&quot;alt&quot;,&quot;Profile picture&quot;,&quot;width&quot;,&quot;32&quot;,&quot;height&quot;,&quot;32&quot;,&quot;id&quot;,&quot;userAvatar&quot;,1,&quot;rounded-circle&quot;,&quot;ms-2&quot;,3,&quot;src&quot;],[&quot;class&quot;,&quot;fas fa-exclamation-triangle text-danger ms-2&quot;,4,&quot;ngIf&quot;],[&quot;aria-labelledby&quot;,&quot;dropdownUser1&quot;,1,&quot;dropdown-menu&quot;,&quot;w-100&quot;,&quot;text-small&quot;],[&quot;routerLink&quot;,&quot;&quot;,1,&quot;dropdown-item&quot;,3,&quot;click&quot;],[1,&quot;fas&quot;,&quot;fa-exclamation-triangle&quot;,&quot;text-danger&quot;,&quot;ms-2&quot;]],template:function(e,i){1&amp;e&amp;&amp;(d(0,&quot;nav&quot;,0),d(1,&quot;div&quot;,1),d(2,&quot;a&quot;,2),k(3,&quot;img&quot;,3),h(),d(4,&quot;button&quot;,4),k(5,&quot;span&quot;,5),h(),d(6,&quot;div&quot;,6),d(7,&quot;ul&quot;,7),d(8,&quot;li&quot;,8),d(9,&quot;a&quot;,9),b(10,&quot;DOGODKI&quot;),h(),h(),d(11,&quot;li&quot;,8),d(12,&quot;a&quot;,10),b(13,&quot;UPORABNIKI&quot;),h(),h(),h(),h(),d(14,&quot;div&quot;,11),d(15,&quot;a&quot;,12),d(16,&quot;span&quot;,13),b(17),h(),k(18,&quot;img&quot;,14),h(),I(19,z9,1,0,&quot;i&quot;,15),d(20,&quot;ul&quot;,16),d(21,&quot;li&quot;),d(22,&quot;a&quot;,17),M(&quot;click&quot;,function(){return i.izpisUporabnika()}),b(23,&quot;Izpis&quot;),h(),h(),h(),h(),h(),h()),2&amp;e&amp;&amp;(y(17),er(&quot;&quot;,i.loggedUser.ime,&quot; &quot;,i.loggedUser.priimek,&quot;&quot;),y(1),si(&quot;src&quot;,&quot;assets/images/profileAvatars/avatarOptions/profileAvatar&quot;,i.loggedUser.slika,&quot;.png&quot;,Nt),y(1),w(&quot;ngIf&quot;,!i.jePovezava()))},directives:[zn,rt],styles:[&quot;&quot;]}),n})();function G9(n,t){1&amp;n&amp;&amp;k(0,&quot;app-main-navbar&quot;)}function W9(n,t){1&amp;n&amp;&amp;k(0,&quot;app-admin-main-navbar&quot;)}function q9(n,t){if(1&amp;n&amp;&amp;(d(0,&quot;div&quot;,2),d(1,&quot;footer&quot;,3),d(2,&quot;div&quot;,4),d(3,&quot;div&quot;,5),d(4,&quot;small&quot;),b(5),h(),h(),h(),h(),h()),2&amp;n){const e=T();y(5),de(&quot; \xa9 &quot;,e.getYear(),&quot; GoodMeets &quot;)}}let Y9=(()=&gt;{class n{constructor(e,i){this.router=e,this.povezavaStoritev=i}ngOnInit(){}showMainNavbar(){return!(&quot;/&quot;==this.router.url||&quot;/login&quot;==this.router.url||&quot;/signup&quot;==this.router.url||&quot;/dogodki_gost&quot;==this.router.url||&quot;/dogodki_admin&quot;==this.router.url||&quot;/uporabniki_admin&quot;==this.router.url||&quot;/db&quot;==this.router.url)}showAdminNavbar(){return&quot;/dogodki_admin&quot;==this.router.url||&quot;/uporabniki_admin&quot;==this.router.url}getYear(){return(new Date).getFullYear()}notLogOrReg(){return!(&quot;/login&quot;==this.router.url||&quot;/signup&quot;==this.router.url||&quot;/db&quot;==this.router.url)}ifHomeRoute(){return&quot;/&quot;==this.router.url}jePovezava(){return this.povezavaStoritev.jePovezava}}return n.\u0275fac=function(e){return new(e||n)(_(Xe),_(Yr))},n.\u0275cmp=ee({type:n,selectors:[[&quot;app-ogrodje&quot;]],decls:5,vars:3,consts:[[4,&quot;ngIf&quot;],[&quot;class&quot;,&quot;container&quot;,4,&quot;ngIf&quot;],[1,&quot;container&quot;],[1,&quot;mt-5&quot;],[1,&quot;row&quot;],[1,&quot;col-12&quot;,&quot;d-flex&quot;,&quot;mb-3&quot;]],template:function(e,i){1&amp;e&amp;&amp;(I(0,G9,1,0,&quot;app-main-navbar&quot;,0),I(1,W9,1,0,&quot;app-admin-main-navbar&quot;,0),d(2,&quot;main&quot;),k(3,&quot;router-outlet&quot;),I(4,q9,6,1,&quot;div&quot;,1),h()),2&amp;e&amp;&amp;(w(&quot;ngIf&quot;,i.showMainNavbar()),y(1),w(&quot;ngIf&quot;,i.showAdminNavbar()),y(3),w(&quot;ngIf&quot;,i.notLogOrReg()))},directives:[rt,Um,H9,$9],styles:[&quot;&quot;]}),n})();const Bs=new ye(cr);class J9{constructor(t,e){this.delay=t,this.scheduler=e}call(t,e){return e.subscribe(new ly(t,this.delay,this.scheduler))}}class ly extends xe{constructor(t,e,i){super(t),this.delay=e,this.scheduler=i,this.queue=[],this.active=!1,this.errored=!1}static dispatch(t){const e=t.source,i=e.queue,r=t.scheduler,s=t.destination;for(;i.length&gt;0&amp;&amp;i[0].time-r.now()&lt;=0;)i.shift().notification.observe(s);if(i.length&gt;0){const o=Math.max(0,i[0].time-r.now());this.schedule(t,o)}else this.unsubscribe(),e.active=!1}_schedule(t){this.active=!0,this.destination.add(t.schedule(ly.dispatch,this.delay,{source:this,destination:this.destination,scheduler:t}))}scheduleNotification(t){if(!0===this.errored)return;const e=this.scheduler,i=new X9(e.now()+this.delay,t);this.queue.push(i),!1===this.active&amp;&amp;this._schedule(e)}_next(t){this.scheduleNotification(un.createNext(t))}_error(t){this.errored=!0,this.queue=[],this.destination.error(t),this.unsubscribe()}_complete(){this.scheduleNotification(un.createComplete()),this.unsubscribe()}}class X9{constructor(t,e){this.time=t,this.notification=e}}const fc=&quot;Service workers are disabled or not supported by this browser&quot;;class Ch{constructor(t){if(this.serviceWorker=t,t){const i=gr(t,&quot;controllerchange&quot;).pipe(pe(()=&gt;t.controller)),s=_d(vd(()=&gt;G(t.controller)),i);this.worker=s.pipe(cn(u=&gt;!!u)),this.registration=this.worker.pipe(nn(()=&gt;t.getRegistration()));const c=gr(t,&quot;message&quot;).pipe(pe(u=&gt;u.data)).pipe(cn(u=&gt;u&amp;&amp;u.type)).pipe(Th(new ie));c.connect(),this.events=c}else this.worker=this.events=this.registration=vd(()=&gt;zr(new Error(&quot;Service workers are disabled or not supported by this browser&quot;)))}postMessage(t,e){return this.worker.pipe(rn(1),zt(i=&gt;{i.postMessage(Object.assign({action:t},e))})).toPromise().then(()=&gt;{})}postMessageWithStatus(t,e,i){const r=this.waitForStatus(i),s=this.postMessage(t,e);return Promise.all([r,s]).then(()=&gt;{})}generateNonce(){return Math.round(1e7*Math.random())}eventsOfType(t){return this.events.pipe(cn(i=&gt;i.type===t))}nextEventOfType(t){return this.eventsOfType(t).pipe(rn(1))}waitForStatus(t){return this.eventsOfType(&quot;STATUS&quot;).pipe(cn(e=&gt;e.nonce===t),rn(1),pe(e=&gt;{if(!e.status)throw new Error(e.error)})).toPromise()}get isEnabled(){return!!this.serviceWorker}}let tW=(()=&gt;{class n{constructor(e){if(this.sw=e,this.subscriptionChanges=new ie,!e.isEnabled)return this.messages=Bs,this.notificationClicks=Bs,void(this.subscription=Bs);this.messages=this.sw.eventsOfType(&quot;PUSH&quot;).pipe(pe(r=&gt;r.data)),this.notificationClicks=this.sw.eventsOfType(&quot;NOTIFICATION_CLICK&quot;).pipe(pe(r=&gt;r.data)),this.pushManager=this.sw.registration.pipe(pe(r=&gt;r.pushManager));const i=this.pushManager.pipe(nn(r=&gt;r.getSubscription()));this.subscription=Ci(i,this.subscriptionChanges)}get isEnabled(){return this.sw.isEnabled}requestSubscription(e){if(!this.sw.isEnabled)return Promise.reject(new Error(fc));const i={userVisibleOnly:!0};let r=this.decodeBase64(e.serverPublicKey.replace(/_/g,&quot;/&quot;).replace(/-/g,&quot;+&quot;)),s=new Uint8Array(new ArrayBuffer(r.length));for(let o=0;o&lt;r.length;o++)s[o]=r.charCodeAt(o);return i.applicationServerKey=s,this.pushManager.pipe(nn(o=&gt;o.subscribe(i)),rn(1)).toPromise().then(o=&gt;(this.subscriptionChanges.next(o),o))}unsubscribe(){return this.sw.isEnabled?this.subscription.pipe(rn(1),nn(i=&gt;{if(null===i)throw new Error(&quot;Not subscribed to push notifications.&quot;);return i.unsubscribe().then(r=&gt;{if(!r)throw new Error(&quot;Unsubscribe failed!&quot;);this.subscriptionChanges.next(null)})})).toPromise():Promise.reject(new Error(fc))}decodeBase64(e){return atob(e)}}return n.\u0275fac=function(e){return new(e||n)(D(Ch))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})(),nW=(()=&gt;{class n{constructor(e){if(this.sw=e,!e.isEnabled)return this.available=Bs,this.activated=Bs,void(this.unrecoverable=Bs);this.available=this.sw.eventsOfType(&quot;UPDATE_AVAILABLE&quot;),this.activated=this.sw.eventsOfType(&quot;UPDATE_ACTIVATED&quot;),this.unrecoverable=this.sw.eventsOfType(&quot;UNRECOVERABLE_STATE&quot;)}get isEnabled(){return this.sw.isEnabled}checkForUpdate(){if(!this.sw.isEnabled)return Promise.reject(new Error(fc));const e=this.sw.generateNonce();return this.sw.postMessageWithStatus(&quot;CHECK_FOR_UPDATES&quot;,{statusNonce:e},e)}activateUpdate(){if(!this.sw.isEnabled)return Promise.reject(new Error(fc));const e=this.sw.generateNonce();return this.sw.postMessageWithStatus(&quot;ACTIVATE_UPDATE&quot;,{statusNonce:e},e)}}return n.\u0275fac=function(e){return new(e||n)(D(Ch))},n.\u0275prov=P({token:n,factory:n.\u0275fac}),n})();class cy{}const PA=new j(&quot;NGSW_REGISTER_SCRIPT&quot;);function iW(n,t,e,i){return()=&gt;{if(!Fg(i)||!(&quot;serviceWorker&quot;in navigator)||!1===e.enabled)return;let s;if(navigator.serviceWorker.addEventListener(&quot;controllerchange&quot;,()=&gt;{null!==navigator.serviceWorker.controller&amp;&amp;navigator.serviceWorker.controller.postMessage({action:&quot;INITIALIZE&quot;})}),&quot;function&quot;==typeof e.registrationStrategy)s=e.registrationStrategy();else{const[a,...l]=(e.registrationStrategy||&quot;registerWhenStable:30000&quot;).split(&quot;:&quot;);switch(a){case&quot;registerImmediately&quot;:s=G(null);break;case&quot;registerWithDelay&quot;:s=OA(+l[0]||0);break;case&quot;registerWhenStable&quot;:s=l[0]?Ci(FA(n),OA(+l[0])):FA(n);break;default:throw new Error(`Unknown ServiceWorker registration strategy: ${e.registrationStrategy}`)}}n.get(Y).runOutsideAngular(()=&gt;s.pipe(rn(1)).subscribe(()=&gt;navigator.serviceWorker.register(t,{scope:e.scope}).catch(a=&gt;console.error(&quot;Service worker registration failed with:&quot;,a))))}}function OA(n){return G(null).pipe(function(n,t=aa){const i=function(n){return n instanceof Date&amp;&amp;!isNaN(+n)}(n)?+n-t.now():Math.abs(n);return r=&gt;r.lift(new J9(i,t))}(n))}function FA(n){return n.get(Pr).isStable.pipe(cn(e=&gt;e))}function rW(n,t){return new Ch(Fg(t)&amp;&amp;!1!==n.enabled?navigator.serviceWorker:void 0)}let sW=(()=&gt;{class n{static register(e,i={}){return{ngModule:n,providers:[{provide:PA,useValue:e},{provide:cy,useValue:i},{provide:Ch,useFactory:rW,deps:[cy,Rr]},{provide:zo,useFactory:iW,deps:[ke,PA,cy,Rr],multi:!0}]}}}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n}),n.\u0275inj=me({providers:[tW,nW]}),n})(),oW=(()=&gt;{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=ve({type:n,bootstrap:[Y9]}),n.\u0275inj=me({providers:[{provide:kM,useValue:&quot;sl-SL&quot;}],imports:[[Wg,PB,L9,DU,HS,k8,O7,U5,$8,J7,Z7,sW.register(&quot;ngsw-worker.js&quot;,{enabled:true,registrationStrategy:&quot;registerWhenStable:30000&quot;})]]}),n})();(function(){if(vE)throw new Error(&quot;Cannot enable prod mode after platform setup.&quot;);yE=!1})(),cB().bootstrapModule(oW).catch(n=&gt;console.error(n))}},_a=&gt;{_a(_a.s=633)}]);</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>query</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bBUG\b and was detected 2 times, the first in the element starting with: &quot;            // Workaround a Safari bug, see&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>bug</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bDB\b and was detected 22 times, the first in the element starting with: &quot;            this.cacheNamePrefix = &#39;db&#39;;&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>db</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bFROM\b and was detected 55 times, the first in the element starting with: &quot;    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>FROM</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bLATER\b and was detected 3 times, the first in the element starting with: &quot;                        // The request needs to be revalidated if the current time is later than the expiration&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>later</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bQUERY\b and was detected in the element starting with: &quot;                    // Query for all currently active clients, and list the client IDs. This may skip some clients&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>Query</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bSELECT\b and was detected in the element starting with: &quot;                    // Select all of the previously cached resources. These are cached unhashed resources&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>Select</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bTODO\b and was detected 10 times, the first in the element starting with: &quot;                        // TODO: handle case where the URL has parameters already (unlikely for assets).&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>TODO</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bUSER\b and was detected in the element starting with: &quot;                        // Among other cases, this can happen when the user clears all data through the DevTools,&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>user</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/ngsw-worker.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bWHERE\b and was detected 5 times, the first in the element starting with: &quot;                            // Proceed forward to the default `handleFetch` behavior, where&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (402 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/ngsw-worker.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Service-Worker: script
Connection: keep-alive
Sec-Fetch-Dest: serviceworker
Sec-Fetch-Mode: same-origin
Sec-Fetch-Site: same-origin
Pragma: no-cache
Cache-Control: no-cache

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (400 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sun, 02 Jan 2022 13:58:35 GMT
ETag: W/&quot;2482f-17e1b15b731&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 149551
Date: Sat, 08 Jan 2022 23:37:53 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (149551 bytes)</summary>
				
				<pre><code>(function () {
    &#39;use strict&#39;;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator[&quot;throw&quot;](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A wrapper around `CacheStorage` to allow interacting with caches more easily and consistently by:
     * - Adding a `name` property to all opened caches, which can be used to easily perform other
     *   operations that require the cache name.
     * - Name-spacing cache names to avoid conflicts with other caches on the same domain.
     */
    class NamedCacheStorage {
        constructor(original, cacheNamePrefix) {
            this.original = original;
            this.cacheNamePrefix = cacheNamePrefix;
        }
        delete(cacheName) {
            return this.original.delete(`${this.cacheNamePrefix}:${cacheName}`);
        }
        has(cacheName) {
            return this.original.has(`${this.cacheNamePrefix}:${cacheName}`);
        }
        keys() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.original.keys();
                const ownCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                return ownCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        match(request, options) {
            return this.original.match(request, options);
        }
        open(cacheName) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.original.open(`${this.cacheNamePrefix}:${cacheName}`);
                return Object.assign(cache, { name: cacheName });
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Adapts the service worker to its runtime environment.
     *
     * Mostly, this is used to mock out identifiers which are otherwise read
     * from the global scope.
     */
    class Adapter {
        constructor(scopeUrl, caches) {
            this.scopeUrl = scopeUrl;
            const parsedScopeUrl = this.parseUrl(this.scopeUrl);
            // Determine the origin from the registration scope. This is used to differentiate between
            // relative and absolute URLs.
            this.origin = parsedScopeUrl.origin;
            // Use the baseHref in the cache name prefix to avoid clash of cache names for SWs with
            // different scopes on the same domain.
            this.caches = new NamedCacheStorage(caches, `ngsw:${parsedScopeUrl.path}`);
        }
        /**
         * Wrapper around the `Request` constructor.
         */
        newRequest(input, init) {
            return new Request(input, init);
        }
        /**
         * Wrapper around the `Response` constructor.
         */
        newResponse(body, init) {
            return new Response(body, init);
        }
        /**
         * Wrapper around the `Headers` constructor.
         */
        newHeaders(headers) {
            return new Headers(headers);
        }
        /**
         * Test if a given object is an instance of `Client`.
         */
        isClient(source) {
            return (source instanceof Client);
        }
        /**
         * Read the current UNIX time in milliseconds.
         */
        get time() {
            return Date.now();
        }
        /**
         * Get a normalized representation of a URL such as those found in the ServiceWorker&#39;s `ngsw.json`
         * configuration.
         *
         * More specifically:
         * 1. Resolve the URL relative to the ServiceWorker&#39;s scope.
         * 2. If the URL is relative to the ServiceWorker&#39;s own origin, then only return the path part.
         *    Otherwise, return the full URL.
         *
         * @param url The raw request URL.
         * @return A normalized representation of the URL.
         */
        normalizeUrl(url) {
            // Check the URL&#39;s origin against the ServiceWorker&#39;s.
            const parsed = this.parseUrl(url, this.scopeUrl);
            return (parsed.origin === this.origin ? parsed.path : url);
        }
        /**
         * Parse a URL into its different parts, such as `origin`, `path` and `search`.
         */
        parseUrl(url, relativeTo) {
            // Workaround a Safari bug, see
            // https://github.com/angular/angular/issues/31061#issuecomment-503637978
            const parsed = !relativeTo ? new URL(url) : new URL(url, relativeTo);
            return { origin: parsed.origin, path: parsed.pathname, search: parsed.search };
        }
        /**
         * Wait for a given amount of time before completing a Promise.
         */
        timeout(ms) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; resolve(), ms);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An error returned in rejected promises if the given key is not found in the table.
     */
    class NotFound {
        constructor(table, key) {
            this.table = table;
            this.key = key;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * An implementation of a `Database` that uses the `CacheStorage` API to serialize
     * state within mock `Response` objects.
     */
    class CacheDatabase {
        constructor(adapter) {
            this.adapter = adapter;
            this.cacheNamePrefix = &#39;db&#39;;
            this.tables = new Map();
        }
        &#39;delete&#39;(name) {
            if (this.tables.has(name)) {
                this.tables.delete(name);
            }
            return this.adapter.caches.delete(`${this.cacheNamePrefix}:${name}`);
        }
        list() {
            return __awaiter(this, void 0, void 0, function* () {
                const prefix = `${this.cacheNamePrefix}:`;
                const allCacheNames = yield this.adapter.caches.keys();
                const dbCacheNames = allCacheNames.filter(name =&gt; name.startsWith(prefix));
                // Return the un-prefixed table names, so they can be used with other `CacheDatabase` methods
                // (for example, for opening/deleting a table).
                return dbCacheNames.map(name =&gt; name.slice(prefix.length));
            });
        }
        open(name, cacheQueryOptions) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.tables.has(name)) {
                    const cache = yield this.adapter.caches.open(`${this.cacheNamePrefix}:${name}`);
                    const table = new CacheTable(name, cache, this.adapter, cacheQueryOptions);
                    this.tables.set(name, table);
                }
                return this.tables.get(name);
            });
        }
    }
    /**
     * A `Table` backed by a `Cache`.
     */
    class CacheTable {
        constructor(name, cache, adapter, cacheQueryOptions) {
            this.name = name;
            this.cache = cache;
            this.adapter = adapter;
            this.cacheQueryOptions = cacheQueryOptions;
            this.cacheName = this.cache.name;
        }
        request(key) {
            return this.adapter.newRequest(&#39;/&#39; + key);
        }
        &#39;delete&#39;(key) {
            return this.cache.delete(this.request(key), this.cacheQueryOptions);
        }
        keys() {
            return this.cache.keys().then(requests =&gt; requests.map(req =&gt; req.url.substr(1)));
        }
        read(key) {
            return this.cache.match(this.request(key), this.cacheQueryOptions).then(res =&gt; {
                if (res === undefined) {
                    return Promise.reject(new NotFound(this.name, key));
                }
                return res.json();
            });
        }
        write(key, value) {
            return this.cache.put(this.request(key), this.adapter.newResponse(JSON.stringify(value)));
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var UpdateCacheStatus = /*@__PURE__*/ (function (UpdateCacheStatus) {
        UpdateCacheStatus[UpdateCacheStatus[&quot;NOT_CACHED&quot;] = 0] = &quot;NOT_CACHED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED_BUT_UNUSED&quot;] = 1] = &quot;CACHED_BUT_UNUSED&quot;;
        UpdateCacheStatus[UpdateCacheStatus[&quot;CACHED&quot;] = 2] = &quot;CACHED&quot;;
        return UpdateCacheStatus;
    })({});

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class SwCriticalError extends Error {
        constructor() {
            super(...arguments);
            this.isCritical = true;
        }
    }
    function errorToString(error) {
        if (error instanceof Error) {
            return `${error.message}\n${error.stack}`;
        }
        else {
            return `${error}`;
        }
    }
    class SwUnrecoverableStateError extends SwCriticalError {
        constructor() {
            super(...arguments);
            this.isUnrecoverableState = true;
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Compute the SHA1 of the given string
     *
     * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
     *
     * WARNING: this function has not been designed not tested with security in mind.
     *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.
     *
     * Borrowed from @angular/compiler/src/i18n/digest.ts
     */
    function sha1(str) {
        const utf8 = str;
        const words32 = stringToWords32(utf8, Endian.Big);
        return _sha1(words32, utf8.length * 8);
    }
    function sha1Binary(buffer) {
        const words32 = arrayBufferToWords32(buffer, Endian.Big);
        return _sha1(words32, buffer.byteLength * 8);
    }
    function _sha1(words32, len) {
        const w = [];
        let [a, b, c, d, e] = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
        words32[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
        words32[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
        for (let i = 0; i &lt; words32.length; i += 16) {
            const [h0, h1, h2, h3, h4] = [a, b, c, d, e];
            for (let j = 0; j &lt; 80; j++) {
                if (j &lt; 16) {
                    w[j] = words32[i + j];
                }
                else {
                    w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
                }
                const [f, k] = fk(j, b, c, d);
                const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);
                [e, d, c, b, a] = [d, c, rol32(b, 30), a, temp];
            }
            [a, b, c, d, e] = [add32(a, h0), add32(b, h1), add32(c, h2), add32(d, h3), add32(e, h4)];
        }
        return byteStringToHexString(words32ToByteString([a, b, c, d, e]));
    }
    function add32(a, b) {
        return add32to64(a, b)[1];
    }
    function add32to64(a, b) {
        const low = (a &amp; 0xffff) + (b &amp; 0xffff);
        const high = (a &gt;&gt;&gt; 16) + (b &gt;&gt;&gt; 16) + (low &gt;&gt;&gt; 16);
        return [high &gt;&gt;&gt; 16, (high &lt;&lt; 16) | (low &amp; 0xffff)];
    }
    // Rotate a 32b number left `count` position
    function rol32(a, count) {
        return (a &lt;&lt; count) | (a &gt;&gt;&gt; (32 - count));
    }
    var Endian = /*@__PURE__*/ (function (Endian) {
        Endian[Endian[&quot;Little&quot;] = 0] = &quot;Little&quot;;
        Endian[Endian[&quot;Big&quot;] = 1] = &quot;Big&quot;;
        return Endian;
    })({});
    function fk(index, b, c, d) {
        if (index &lt; 20) {
            return [(b &amp; c) | (~b &amp; d), 0x5a827999];
        }
        if (index &lt; 40) {
            return [b ^ c ^ d, 0x6ed9eba1];
        }
        if (index &lt; 60) {
            return [(b &amp; c) | (b &amp; d) | (c &amp; d), 0x8f1bbcdc];
        }
        return [b ^ c ^ d, 0xca62c1d6];
    }
    function stringToWords32(str, endian) {
        const size = (str.length + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(str, i * 4, endian);
        }
        return words32;
    }
    function arrayBufferToWords32(buffer, endian) {
        const size = (buffer.byteLength + 3) &gt;&gt;&gt; 2;
        const words32 = [];
        const view = new Uint8Array(buffer);
        for (let i = 0; i &lt; size; i++) {
            words32[i] = wordAt(view, i * 4, endian);
        }
        return words32;
    }
    function byteAt(str, index) {
        if (typeof str === &#39;string&#39;) {
            return index &gt;= str.length ? 0 : str.charCodeAt(index) &amp; 0xff;
        }
        else {
            return index &gt;= str.byteLength ? 0 : str[index] &amp; 0xff;
        }
    }
    function wordAt(str, index, endian) {
        let word = 0;
        if (endian === Endian.Big) {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; (24 - 8 * i);
            }
        }
        else {
            for (let i = 0; i &lt; 4; i++) {
                word += byteAt(str, index + i) &lt;&lt; 8 * i;
            }
        }
        return word;
    }
    function words32ToByteString(words32) {
        return words32.reduce((str, word) =&gt; str + word32ToByteString(word), &#39;&#39;);
    }
    function word32ToByteString(word) {
        let str = &#39;&#39;;
        for (let i = 0; i &lt; 4; i++) {
            str += String.fromCharCode((word &gt;&gt;&gt; 8 * (3 - i)) &amp; 0xff);
        }
        return str;
    }
    function byteStringToHexString(str) {
        let hex = &#39;&#39;;
        for (let i = 0; i &lt; str.length; i++) {
            const b = byteAt(str, i);
            hex += (b &gt;&gt;&gt; 4).toString(16) + (b &amp; 0x0f).toString(16);
        }
        return hex.toLowerCase();
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * A group of assets that are cached in a `Cache` and managed by a given policy.
     *
     * Concrete classes derive from this base and specify the exact caching policy.
     */
    class AssetGroup {
        constructor(scope, adapter, idle, config, hashes, db, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.idle = idle;
            this.config = config;
            this.hashes = hashes;
            this.db = db;
            /**
             * A deduplication cache, to make sure the SW never makes two network requests
             * for the same resource at once. Managed by `fetchAndCacheOnce`.
             */
            this.inFlightRequests = new Map();
            /**
             * Normalized resource URLs.
             */
            this.urls = [];
            /**
             * Regular expression patterns.
             */
            this.patterns = [];
            this.name = config.name;
            // Normalize the config&#39;s URLs to take the ServiceWorker&#39;s scope into account.
            this.urls = config.urls.map(url =&gt; adapter.normalizeUrl(url));
            // Patterns in the config are regular expressions disguised as strings. Breathe life into them.
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            // This is the primary cache, which holds all of the cached requests for this group. If a
            // resource isn&#39;t in this cache, it hasn&#39;t been fetched yet.
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            // This is the metadata table, which holds specific information for each cached URL, such as
            // the timestamp of when it was added to the cache.
            this.metadata =
                this.db.open(`${cacheNamePrefix}:${config.name}:meta`, config.cacheQueryOptions);
        }
        cacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const meta = yield this.metadata;
                const req = this.adapter.newRequest(url);
                const res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res === undefined) {
                    return UpdateCacheStatus.NOT_CACHED;
                }
                try {
                    const data = yield meta.read(req.url);
                    if (!data.used) {
                        return UpdateCacheStatus.CACHED_BUT_UNUSED;
                    }
                }
                catch (_) {
                    // Error on the side of safety and assume cached.
                }
                return UpdateCacheStatus.CACHED;
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, metadata] = yield Promise.all([
                    this.cache,
                    this.metadata,
                ]);
                return [cache.name, metadata.cacheName];
            });
        }
        /**
         * Process a request for a given resource and return it, or return null if it&#39;s not available.
         */
        handleFetch(req, _event) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Either the request matches one of the known resource URLs, one of the patterns for
                // dynamically matched URLs, or neither. Determine which is the case for this request in
                // order to decide how to handle it.
                if (this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url))) {
                    // This URL matches a known resource. Either it&#39;s been cached already or it&#39;s missing, in
                    // which case it needs to be loaded from the network.
                    // Open the cache to check whether this resource is present.
                    const cache = yield this.cache;
                    // Look for a cached response. If one exists, it can be used to resolve the fetch
                    // operation.
                    const cachedResponse = yield cache.match(req, this.config.cacheQueryOptions);
                    if (cachedResponse !== undefined) {
                        // A response has already been cached (which presumably matches the hash for this
                        // resource). Check whether it&#39;s safe to serve this resource from cache.
                        if (this.hashes.has(url)) {
                            // This resource has a hash, and thus is versioned by the manifest. It&#39;s safe to return
                            // the response.
                            return cachedResponse;
                        }
                        else {
                            // This resource has no hash, and yet exists in the cache. Check how old this request is
                            // to make sure it&#39;s still usable.
                            if (yield this.needToRevalidate(req, cachedResponse)) {
                                this.idle.schedule(`revalidate(${cache.name}): ${req.url}`, () =&gt; __awaiter(this, void 0, void 0, function* () {
                                    yield this.fetchAndCacheOnce(req);
                                }));
                            }
                            // In either case (revalidation or not), the cached response must be good.
                            return cachedResponse;
                        }
                    }
                    // No already-cached response exists, so attempt a fetch/cache operation. The original request
                    // may specify things like credential inclusion, but for assets these are not honored in order
                    // to avoid issues with opaque responses. The SW requests the data itself.
                    const res = yield this.fetchAndCacheOnce(this.adapter.newRequest(req.url));
                    // If this is successful, the response needs to be cloned as it might be used to respond to
                    // multiple fetch operations at the same time.
                    return res.clone();
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Some resources are cached without a hash, meaning that their expiration is controlled
         * by HTTP caching headers. Check whether the given request/response pair is still valid
         * per the caching headers.
         */
        needToRevalidate(req, res) {
            return __awaiter(this, void 0, void 0, function* () {
                // Three different strategies apply here:
                // 1) The request has a Cache-Control header, and thus expiration needs to be based on its age.
                // 2) The request has an Expires header, and expiration is based on the current timestamp.
                // 3) The request has no applicable caching headers, and must be revalidated.
                if (res.headers.has(&#39;Cache-Control&#39;)) {
                    // Figure out if there is a max-age directive in the Cache-Control header.
                    const cacheControl = res.headers.get(&#39;Cache-Control&#39;);
                    const cacheDirectives = cacheControl
                        // Directives are comma-separated within the Cache-Control header value.
                        .split(&#39;,&#39;)
                        // Make sure each directive doesn&#39;t have extraneous whitespace.
                        .map(v =&gt; v.trim())
                        // Some directives have values (like maxage and s-maxage)
                        .map(v =&gt; v.split(&#39;=&#39;));
                    // Lowercase all the directive names.
                    cacheDirectives.forEach(v =&gt; v[0] = v[0].toLowerCase());
                    // Find the max-age directive, if one exists.
                    const maxAgeDirective = cacheDirectives.find(v =&gt; v[0] === &#39;max-age&#39;);
                    const cacheAge = maxAgeDirective ? maxAgeDirective[1] : undefined;
                    if (!cacheAge) {
                        // No usable TTL defined. Must assume that the response is stale.
                        return true;
                    }
                    try {
                        const maxAge = 1000 * parseInt(cacheAge);
                        // Determine the origin time of this request. If the SW has metadata on the request (which
                        // it
                        // should), it will have the time the request was added to the cache. If it doesn&#39;t for some
                        // reason, the request may have a Date header which will serve the same purpose.
                        let ts;
                        try {
                            // Check the metadata table. If a timestamp is there, use it.
                            const metaTable = yield this.metadata;
                            ts = (yield metaTable.read(req.url)).ts;
                        }
                        catch (_a) {
                            // Otherwise, look for a Date header.
                            const date = res.headers.get(&#39;Date&#39;);
                            if (date === null) {
                                // Unable to determine when this response was created. Assume that it&#39;s stale, and
                                // revalidate it.
                                return true;
                            }
                            ts = Date.parse(date);
                        }
                        const age = this.adapter.time - ts;
                        return age &lt; 0 || age &gt; maxAge;
                    }
                    catch (_b) {
                        // Assume stale.
                        return true;
                    }
                }
                else if (res.headers.has(&#39;Expires&#39;)) {
                    // Determine if the expiration time has passed.
                    const expiresStr = res.headers.get(&#39;Expires&#39;);
                    try {
                        // The request needs to be revalidated if the current time is later than the expiration
                        // time, if it parses correctly.
                        return this.adapter.time &gt; Date.parse(expiresStr);
                    }
                    catch (_c) {
                        // The expiration date failed to parse, so revalidate as a precaution.
                        return true;
                    }
                }
                else {
                    // No way to evaluate staleness, so assume the response is already stale.
                    return true;
                }
            });
        }
        /**
         * Fetch the complete state of a cached resource, or return null if it&#39;s not found.
         */
        fetchFromCacheOnly(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                const metaTable = yield this.metadata;
                // Lookup the response in the cache.
                const request = this.adapter.newRequest(url);
                const response = yield cache.match(request, this.config.cacheQueryOptions);
                if (response === undefined) {
                    // It&#39;s not found, return null.
                    return null;
                }
                // Next, lookup the cached metadata.
                let metadata = undefined;
                try {
                    metadata = yield metaTable.read(request.url);
                }
                catch (_a) {
                    // Do nothing, not found. This shouldn&#39;t happen, but it can be handled.
                }
                // Return both the response and any available metadata.
                return { response, metadata };
            });
        }
        /**
         * Lookup all resources currently stored in the cache which have no associated hash.
         */
        unhashedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                const cache = yield this.cache;
                // Start with the set of all cached requests.
                return (yield cache.keys())
                    // Normalize their URLs.
                    .map(request =&gt; this.adapter.normalizeUrl(request.url))
                    // Exclude the URLs which have hashes.
                    .filter(url =&gt; !this.hashes.has(url));
            });
        }
        /**
         * Fetch the given resource from the network, and cache it if able.
         */
        fetchAndCacheOnce(req, used = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // The `inFlightRequests` map holds information about which caching operations are currently
                // underway for known resources. If this request appears there, another &quot;thread&quot; is already
                // in the process of caching it, and this work should not be duplicated.
                if (this.inFlightRequests.has(req.url)) {
                    // There is a caching operation already in progress for this request. Wait for it to
                    // complete, and hopefully it will have yielded a useful response.
                    return this.inFlightRequests.get(req.url);
                }
                // No other caching operation is being attempted for this resource, so it will be owned here.
                // Go to the network and get the correct version.
                const fetchOp = this.fetchFromNetwork(req);
                // Save this operation in `inFlightRequests` so any other &quot;thread&quot; attempting to cache it
                // will block on this chain instead of duplicating effort.
                this.inFlightRequests.set(req.url, fetchOp);
                // Make sure this attempt is cleaned up properly on failure.
                try {
                    // Wait for a response. If this fails, the request will remain in `inFlightRequests`
                    // indefinitely.
                    const res = yield fetchOp;
                    // It&#39;s very important that only successful responses are cached. Unsuccessful responses
                    // should never be cached as this can completely break applications.
                    if (!res.ok) {
                        throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${req.url} returned response ${res.status} ${res.statusText}`);
                    }
                    try {
                        // This response is safe to cache (as long as it&#39;s cloned). Wait until the cache operation
                        // is complete.
                        const cache = yield this.cache;
                        yield cache.put(req, res.clone());
                        // If the request is not hashed, update its metadata, especially the timestamp. This is
                        // needed for future determination of whether this cached response is stale or not.
                        if (!this.hashes.has(this.adapter.normalizeUrl(req.url))) {
                            // Metadata is tracked for requests that are unhashed.
                            const meta = { ts: this.adapter.time, used };
                            const metaTable = yield this.metadata;
                            yield metaTable.write(req.url, meta);
                        }
                        return res;
                    }
                    catch (err) {
                        // Among other cases, this can happen when the user clears all data through the DevTools,
                        // but the SW is still running and serving another tab. In that case, trying to write to the
                        // caches throws an `Entry was not found` error.
                        // If this happens the SW can no longer work correctly. This situation is unrecoverable.
                        throw new SwCriticalError(`Failed to update the caches for request to &#39;${req.url}&#39; (fetchAndCacheOnce): ${errorToString(err)}`);
                    }
                }
                finally {
                    // Finally, it can be removed from `inFlightRequests`. This might result in a double-remove
                    // if some other chain was already making this request too, but that won&#39;t hurt anything.
                    this.inFlightRequests.delete(req.url);
                }
            });
        }
        fetchFromNetwork(req, redirectLimit = 3) {
            return __awaiter(this, void 0, void 0, function* () {
                // Make a cache-busted request for the resource.
                const res = yield this.cacheBustedFetchFromNetwork(req);
                // Check for redirected responses, and follow the redirects.
                if (res[&#39;redirected&#39;] &amp;&amp; !!res.url) {
                    // If the redirect limit is exhausted, fail with an error.
                    if (redirectLimit === 0) {
                        throw new SwCriticalError(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${res.url}`);
                    }
                    // Unwrap the redirect directly.
                    return this.fetchFromNetwork(this.adapter.newRequest(res.url), redirectLimit - 1);
                }
                return res;
            });
        }
        /**
         * Load a particular asset from the network, accounting for hash validation.
         */
        cacheBustedFetchFromNetwork(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // If a hash is available for this resource, then compare the fetched version with the
                // canonical hash. Otherwise, the network version will have to be trusted.
                if (this.hashes.has(url)) {
                    // It turns out this resource does have a hash. Look it up. Unless the fetched version
                    // matches this hash, it&#39;s invalid and the whole manifest may need to be thrown out.
                    const canonicalHash = this.hashes.get(url);
                    // Ideally, the resource would be requested with cache-busting to guarantee the SW gets
                    // the freshest version. However, doing this would eliminate any chance of the response
                    // being in the HTTP cache. Given that the browser has recently actively loaded the page,
                    // it&#39;s likely that many of the responses the SW needs to cache are in the HTTP cache and
                    // are fresh enough to use. In the future, this could be done by setting cacheMode to
                    // *only* check the browser cache for a cached version of the resource, when cacheMode is
                    // fully supported. For now, the resource is fetched directly, without cache-busting, and
                    // if the hash test fails a cache-busted request is tried before concluding that the
                    // resource isn&#39;t correct. This gives the benefit of acceleration via the HTTP cache
                    // without the risk of stale data, at the expense of a duplicate request in the event of
                    // a stale response.
                    // Fetch the resource from the network (possibly hitting the HTTP cache).
                    let response = yield this.safeFetch(req);
                    // Decide whether a cache-busted request is necessary. A cache-busted request is necessary
                    // only if the request was successful but the hash of the retrieved contents does not match
                    // the canonical hash from the manifest.
                    let makeCacheBustedRequest = response.ok;
                    if (makeCacheBustedRequest) {
                        // The request was successful. A cache-busted request is only necessary if the hashes
                        // don&#39;t match.
                        // (Make sure to clone the response so it can be used later if it proves to be valid.)
                        const fetchedHash = sha1Binary(yield response.clone().arrayBuffer());
                        makeCacheBustedRequest = (fetchedHash !== canonicalHash);
                    }
                    // Make a cache busted request to the network, if necessary.
                    if (makeCacheBustedRequest) {
                        // Hash failure, the version that was retrieved under the default URL did not have the
                        // hash expected. This could be because the HTTP cache got in the way and returned stale
                        // data, or because the version on the server really doesn&#39;t match. A cache-busting
                        // request will differentiate these two situations.
                        // TODO: handle case where the URL has parameters already (unlikely for assets).
                        const cacheBustReq = this.adapter.newRequest(this.cacheBust(req.url));
                        response = yield this.safeFetch(cacheBustReq);
                        // If the response was successful, check the contents against the canonical hash.
                        if (response.ok) {
                            // Hash the contents.
                            // (Make sure to clone the response so it can be used later if it proves to be valid.)
                            const cacheBustedHash = sha1Binary(yield response.clone().arrayBuffer());
                            // If the cache-busted version doesn&#39;t match, then the manifest is not an accurate
                            // representation of the server&#39;s current set of files, and the SW should give up.
                            if (canonicalHash !== cacheBustedHash) {
                                throw new SwCriticalError(`Hash mismatch (cacheBustedFetchFromNetwork): ${req.url}: expected ${canonicalHash}, got ${cacheBustedHash} (after cache busting)`);
                            }
                        }
                    }
                    // At this point, `response` is either successful with a matching hash or is unsuccessful.
                    // Before returning it, check whether it failed with a 404 status. This would signify an
                    // unrecoverable state.
                    if (!response.ok &amp;&amp; (response.status === 404)) {
                        throw new SwUnrecoverableStateError(`Failed to retrieve hashed resource from the server. (AssetGroup: ${this.config.name} | URL: ${url})`);
                    }
                    // Return the response (successful or unsuccessful).
                    return response;
                }
                else {
                    // This URL doesn&#39;t exist in our hash database, so it must be requested directly.
                    return this.safeFetch(req);
                }
            });
        }
        /**
         * Possibly update a resource, if it&#39;s expired and needs to be updated. A no-op otherwise.
         */
        maybeUpdate(updateFrom, req, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const url = this.adapter.normalizeUrl(req.url);
                // Check if this resource is hashed and already exists in the cache of a prior version.
                if (this.hashes.has(url)) {
                    const hash = this.hashes.get(url);
                    // Check the caches of prior versions, using the hash to ensure the correct version of
                    // the resource is loaded.
                    const res = yield updateFrom.lookupResourceWithHash(url, hash);
                    // If a previously cached version was available, copy it over to this cache.
                    if (res !== null) {
                        // Copy to this cache.
                        yield cache.put(req, res);
                        // No need to do anything further with this resource, it&#39;s now cached properly.
                        return true;
                    }
                }
                // No up-to-date version of this resource could be found.
                return false;
            });
        }
        /**
         * Construct a cache-busting URL for a given URL.
         */
        cacheBust(url) {
            return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + &#39;ngsw-cache-bust=&#39; + Math.random();
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(&#39;&#39;, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }
    /**
     * An `AssetGroup` that prefetches all of its resources during initialization.
     */
    class PrefetchAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Cache all known resources serially. As this reduce proceeds, each Promise waits
                // on the last before starting the fetch/cache operation for the next request. Any
                // errors cause fall-through to the final Promise which rejects.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    // If an update source is available.
                    if (updateFrom !== undefined &amp;&amp; (yield this.maybeUpdate(updateFrom, req, cache))) {
                        return;
                    }
                    // Otherwise, go to the network and hopefully cache the response (if successful).
                    yield this.fetchAndCacheOnce(req, false);
                }), Promise.resolve());
                // Handle updating of unknown (unhashed) resources. This is only possible if there&#39;s
                // a source to update from.
                if (updateFrom !== undefined) {
                    const metaTable = yield this.metadata;
                    // Select all of the previously cached resources. These are cached unhashed resources
                    // from previous versions of the app, in any asset group.
                    yield (yield updateFrom.previouslyCachedResources())
                        // First, narrow down the set of resources to those which are handled by this group.
                        // Either it&#39;s a known URL, or it matches a given pattern.
                        .filter(url =&gt; this.urls.indexOf(url) !== -1 || this.patterns.some(pattern =&gt; pattern.test(url)))
                        // Finally, process each resource in turn.
                        .reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        const req = this.adapter.newRequest(url);
                        // It&#39;s possible that the resource in question is already cached. If so,
                        // continue to the next one.
                        const alreadyCached = ((yield cache.match(req, this.config.cacheQueryOptions)) !== undefined);
                        if (alreadyCached) {
                            return;
                        }
                        // Get the most recent old version of the resource.
                        const res = yield updateFrom.lookupResourceWithoutHash(url);
                        if (res === null || res.metadata === undefined) {
                            // Unexpected, but not harmful.
                            return;
                        }
                        // Write it into the cache. It may already be expired, but it can still serve
                        // traffic until it&#39;s updated (stale-while-revalidate approach).
                        yield cache.put(req, res.response);
                        yield metaTable.write(req.url, Object.assign(Object.assign({}, res.metadata), { used: false }));
                    }), Promise.resolve());
                }
            });
        }
    }
    class LazyAssetGroup extends AssetGroup {
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                // No action necessary if no update source is available - resources managed in this group
                // are all lazily loaded, so there&#39;s nothing to initialize.
                if (updateFrom === undefined) {
                    return;
                }
                // Open the cache which actually holds requests.
                const cache = yield this.cache;
                // Loop through the listed resources, caching any which are available.
                yield this.urls.reduce((previous, url) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on all previous operations to complete.
                    yield previous;
                    // Construct the Request for this url.
                    const req = this.adapter.newRequest(url);
                    // First, check the cache to see if there is already a copy of this resource.
                    const alreadyCached = (yield cache.match(req, this.config.cacheQueryOptions)) !== undefined;
                    // If the resource is in the cache already, it can be skipped.
                    if (alreadyCached) {
                        return;
                    }
                    const updated = yield this.maybeUpdate(updateFrom, req, cache);
                    if (this.config.updateMode === &#39;prefetch&#39; &amp;&amp; !updated) {
                        // If the resource was not updated, either it was not cached before or
                        // the previously cached version didn&#39;t match the updated hash. In that
                        // case, prefetch update mode dictates that the resource will be updated,
                        // except if it was not previously utilized. Check the status of the
                        // cached resource to see.
                        const cacheStatus = yield updateFrom.recentCacheStatus(url);
                        // If the resource is not cached, or was cached but unused, then it will be
                        // loaded lazily.
                        if (cacheStatus !== UpdateCacheStatus.CACHED) {
                            return;
                        }
                        // Update from the network.
                        yield this.fetchAndCacheOnce(req, false);
                    }
                }), Promise.resolve());
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Manages an instance of `LruState` and moves URLs to the head of the
     * chain when requested.
     */
    class LruList {
        constructor(state) {
            if (state === undefined) {
                state = {
                    head: null,
                    tail: null,
                    map: {},
                    count: 0,
                };
            }
            this.state = state;
        }
        /**
         * The current count of URLs in the list.
         */
        get size() {
            return this.state.count;
        }
        /**
         * Remove the tail.
         */
        pop() {
            // If there is no tail, return null.
            if (this.state.tail === null) {
                return null;
            }
            const url = this.state.tail;
            this.remove(url);
            // This URL has been successfully evicted.
            return url;
        }
        remove(url) {
            const node = this.state.map[url];
            if (node === undefined) {
                return false;
            }
            // Special case if removing the current head.
            if (this.state.head === url) {
                // The node is the current head. Special case the removal.
                if (node.next === null) {
                    // This is the only node. Reset the cache to be empty.
                    this.state.head = null;
                    this.state.tail = null;
                    this.state.map = {};
                    this.state.count = 0;
                    return true;
                }
                // There is at least one other node. Make the next node the new head.
                const next = this.state.map[node.next];
                next.previous = null;
                this.state.head = next.url;
                node.next = null;
                delete this.state.map[url];
                this.state.count--;
                return true;
            }
            // The node is not the head, so it has a previous. It may or may not be the tail.
            // If it is not, then it has a next. First, grab the previous node.
            const previous = this.state.map[node.previous];
            // Fix the forward pointer to skip over node and go directly to node.next.
            previous.next = node.next;
            // node.next may or may not be set. If it is, fix the back pointer to skip over node.
            // If it&#39;s not set, then this node happened to be the tail, and the tail needs to be
            // updated to point to the previous node (removing the tail).
            if (node.next !== null) {
                // There is a next node, fix its back pointer to skip this node.
                this.state.map[node.next].previous = node.previous;
            }
            else {
                // There is no next node - the accessed node must be the tail. Move the tail pointer.
                this.state.tail = node.previous;
            }
            node.next = null;
            node.previous = null;
            delete this.state.map[url];
            // Count the removal.
            this.state.count--;
            return true;
        }
        accessed(url) {
            // When a URL is accessed, its node needs to be moved to the head of the chain.
            // This is accomplished in two steps:
            //
            // 1) remove the node from its position within the chain.
            // 2) insert the node as the new head.
            //
            // Sometimes, a URL is accessed which has not been seen before. In this case, step 1 can
            // be skipped completely (which will grow the chain by one). Of course, if the node is
            // already the head, this whole operation can be skipped.
            if (this.state.head === url) {
                // The URL is already in the head position, accessing it is a no-op.
                return;
            }
            // Look up the node in the map, and construct a new entry if it&#39;s
            const node = this.state.map[url] || { url, next: null, previous: null };
            // Step 1: remove the node from its position within the chain, if it is in the chain.
            if (this.state.map[url] !== undefined) {
                this.remove(url);
            }
            // Step 2: insert the node at the head of the chain.
            // First, check if there&#39;s an existing head node. If there is, it has previous: null.
            // Its previous pointer should be set to the node we&#39;re inserting.
            if (this.state.head !== null) {
                this.state.map[this.state.head].previous = url;
            }
            // The next pointer of the node being inserted gets set to the old head, before the head
            // pointer is updated to this node.
            node.next = this.state.head;
            // The new head is the new node.
            this.state.head = url;
            // If there is no tail, then this is the first node, and is both the head and the tail.
            if (this.state.tail === null) {
                this.state.tail = url;
            }
            // Set the node in the map of nodes (if the URL has been seen before, this is a no-op)
            // and count the insertion.
            this.state.map[url] = node;
            this.state.count++;
        }
    }
    /**
     * A group of cached resources determined by a set of URL patterns which follow a LRU policy
     * for caching.
     */
    class DataGroup {
        constructor(scope, adapter, config, db, debugHandler, cacheNamePrefix) {
            this.scope = scope;
            this.adapter = adapter;
            this.config = config;
            this.db = db;
            this.debugHandler = debugHandler;
            /**
             * Tracks the LRU state of resources in this cache.
             */
            this._lru = null;
            this.patterns = config.patterns.map(pattern =&gt; new RegExp(pattern));
            this.cache = adapter.caches.open(`${cacheNamePrefix}:${config.name}:cache`);
            this.lruTable = this.db.open(`${cacheNamePrefix}:${config.name}:lru`, config.cacheQueryOptions);
            this.ageTable = this.db.open(`${cacheNamePrefix}:${config.name}:age`, config.cacheQueryOptions);
        }
        /**
         * Lazily initialize/load the LRU chain.
         */
        lru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    const table = yield this.lruTable;
                    try {
                        this._lru = new LruList(yield table.read(&#39;lru&#39;));
                    }
                    catch (_a) {
                        this._lru = new LruList();
                    }
                }
                return this._lru;
            });
        }
        /**
         * Sync the LRU chain to non-volatile storage.
         */
        syncLru() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._lru === null) {
                    return;
                }
                const table = yield this.lruTable;
                try {
                    return table.write(&#39;lru&#39;, this._lru.state);
                }
                catch (err) {
                    // Writing lru cache table failed. This could be a result of a full storage.
                    // Continue serving clients as usual.
                    this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).syncLru()`);
                    // TODO: Better detect/handle full storage; e.g. using
                    // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                }
            });
        }
        /**
         * Process a fetch event and return a `Response` if the resource is covered by this group,
         * or `null` otherwise.
         */
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Do nothing
                if (!this.patterns.some(pattern =&gt; pattern.test(req.url))) {
                    return null;
                }
                // Lazily initialize the LRU cache.
                const lru = yield this.lru();
                // The URL matches this cache. First, check whether this is a mutating request or not.
                switch (req.method) {
                    case &#39;OPTIONS&#39;:
                        // Don&#39;t try to cache this - it&#39;s non-mutating, but is part of a mutating request.
                        // Most likely SWs don&#39;t even see this, but this guard is here just in case.
                        return null;
                    case &#39;GET&#39;:
                    case &#39;HEAD&#39;:
                        // Handle the request with whatever strategy was selected.
                        switch (this.config.strategy) {
                            case &#39;freshness&#39;:
                                return this.handleFetchWithFreshness(req, event, lru);
                            case &#39;performance&#39;:
                                return this.handleFetchWithPerformance(req, event, lru);
                            default:
                                throw new Error(`Unknown strategy: ${this.config.strategy}`);
                        }
                    default:
                        // This was a mutating request. Assume the cache for this URL is no longer valid.
                        const wasCached = lru.remove(req.url);
                        // If there was a cached entry, remove it.
                        if (wasCached) {
                            yield this.clearCacheForUrl(req.url);
                        }
                        // Sync the LRU chain to non-volatile storage.
                        yield this.syncLru();
                        // Finally, fall back on the network.
                        return this.safeFetch(req);
                }
            });
        }
        handleFetchWithPerformance(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                let res = null;
                // Check the cache first. If the resource exists there (and is not expired), the cached
                // version can be used.
                const fromCache = yield this.loadFromCache(req, lru);
                if (fromCache !== null) {
                    res = fromCache.res;
                    // Check the age of the resource.
                    if (this.config.refreshAheadMs !== undefined &amp;&amp; fromCache.age &gt;= this.config.refreshAheadMs) {
                        event.waitUntil(this.safeCacheResponse(req, this.safeFetch(req), lru));
                    }
                }
                if (res !== null) {
                    return res;
                }
                // No match from the cache. Go to the network. Note that this is not an &#39;await&#39;
                // call, networkFetch is the actual Promise. This is due to timeout handling.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                res = yield timeoutFetch;
                // Since fetch() will always return a response, undefined indicates a timeout.
                if (res === undefined) {
                    // The request timed out. Return a Gateway Timeout error.
                    res = this.adapter.newResponse(null, { status: 504, statusText: &#39;Gateway Timeout&#39; });
                    // Cache the network response eventually.
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru));
                }
                else {
                    // The request completed in time, so cache it inline with the response flow.
                    yield this.safeCacheResponse(req, res, lru);
                }
                return res;
            });
        }
        handleFetchWithFreshness(req, event, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Start with a network fetch.
                const [timeoutFetch, networkFetch] = this.networkFetchWithTimeout(req);
                let res;
                // If that fetch errors, treat it as a timed out request.
                try {
                    res = yield timeoutFetch;
                }
                catch (_a) {
                    res = undefined;
                }
                // If the network fetch times out or errors, fall back on the cache.
                if (res === undefined) {
                    event.waitUntil(this.safeCacheResponse(req, networkFetch, lru, true));
                    // Ignore the age, the network response will be cached anyway due to the
                    // behavior of freshness.
                    const fromCache = yield this.loadFromCache(req, lru);
                    res = (fromCache !== null) ? fromCache.res : null;
                }
                else {
                    yield this.safeCacheResponse(req, res, lru, true);
                }
                // Either the network fetch didn&#39;t time out, or the cache yielded a usable response.
                // In either case, use it.
                if (res !== null) {
                    return res;
                }
                // No response in the cache. No choice but to fall back on the full network fetch.
                return networkFetch;
            });
        }
        networkFetchWithTimeout(req) {
            // If there is a timeout configured, race a timeout Promise with the network fetch.
            // Otherwise, just fetch from the network directly.
            if (this.config.timeoutMs !== undefined) {
                const networkFetch = this.scope.fetch(req);
                const safeNetworkFetch = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_a) {
                        return this.adapter.newResponse(null, {
                            status: 504,
                            statusText: &#39;Gateway Timeout&#39;,
                        });
                    }
                }))();
                const networkFetchUndefinedError = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        return yield networkFetch;
                    }
                    catch (_b) {
                        return undefined;
                    }
                }))();
                // Construct a Promise&lt;undefined&gt; for the timeout.
                const timeout = this.adapter.timeout(this.config.timeoutMs);
                // Race that with the network fetch. This will either be a Response, or `undefined`
                // in the event that the request errored or timed out.
                return [Promise.race([networkFetchUndefinedError, timeout]), safeNetworkFetch];
            }
            else {
                const networkFetch = this.safeFetch(req);
                // Do a plain fetch.
                return [networkFetch, networkFetch];
            }
        }
        safeCacheResponse(req, resOrPromise, lru, okToCacheOpaque) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield resOrPromise;
                    try {
                        yield this.cacheResponse(req, res, lru, okToCacheOpaque);
                    }
                    catch (err) {
                        // Saving the API response failed. This could be a result of a full storage.
                        // Since this data is cached lazily and temporarily, continue serving clients as usual.
                        this.debugHandler.log(err, `DataGroup(${this.config.name}@${this.config.version}).safeCacheResponse(${req.url}, status: ${res.status})`);
                        // TODO: Better detect/handle full storage; e.g. using
                        // [navigator.storage](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorStorage/storage).
                    }
                }
                catch (_a) {
                    // Request failed
                    // TODO: Handle this error somehow?
                }
            });
        }
        loadFromCache(req, lru) {
            return __awaiter(this, void 0, void 0, function* () {
                // Look for a response in the cache. If one exists, return it.
                const cache = yield this.cache;
                let res = yield cache.match(req, this.config.cacheQueryOptions);
                if (res !== undefined) {
                    // A response was found in the cache, but its age is not yet known. Look it up.
                    try {
                        const ageTable = yield this.ageTable;
                        const age = this.adapter.time - (yield ageTable.read(req.url)).age;
                        // If the response is young enough, use it.
                        if (age &lt;= this.config.maxAge) {
                            // Successful match from the cache. Use the response, after marking it as having
                            // been accessed.
                            lru.accessed(req.url);
                            return { res, age };
                        }
                        // Otherwise, or if there was an error, assume the response is expired, and evict it.
                    }
                    catch (_a) {
                        // Some error getting the age for the response. Assume it&#39;s expired.
                    }
                    lru.remove(req.url);
                    yield this.clearCacheForUrl(req.url);
                    // TODO: avoid duplicate in event of network timeout, maybe.
                    yield this.syncLru();
                }
                return null;
            });
        }
        /**
         * Operation for caching the response from the server. This has to happen all
         * at once, so that the cache and LRU tracking remain in sync. If the network request
         * completes before the timeout, this logic will be run inline with the response flow.
         * If the request times out on the server, an error will be returned but the real network
         * request will still be running in the background, to be cached when it completes.
         */
        cacheResponse(req, res, lru, okToCacheOpaque = false) {
            return __awaiter(this, void 0, void 0, function* () {
                // Only cache successful responses.
                if (!(res.ok || (okToCacheOpaque &amp;&amp; res.type === &#39;opaque&#39;))) {
                    return;
                }
                // If caching this response would make the cache exceed its maximum size, evict something
                // first.
                if (lru.size &gt;= this.config.maxSize) {
                    // The cache is too big, evict something.
                    const evictedUrl = lru.pop();
                    if (evictedUrl !== null) {
                        yield this.clearCacheForUrl(evictedUrl);
                    }
                }
                // TODO: evaluate for possible race conditions during flaky network periods.
                // Mark this resource as having been accessed recently. This ensures it won&#39;t be evicted
                // until enough other resources are requested that it falls off the end of the LRU chain.
                lru.accessed(req.url);
                // Store the response in the cache (cloning because the browser will consume
                // the body during the caching operation).
                yield (yield this.cache).put(req, res.clone());
                // Store the age of the cache.
                const ageTable = yield this.ageTable;
                yield ageTable.write(req.url, { age: this.adapter.time });
                // Sync the LRU chain to non-volatile storage.
                yield this.syncLru();
            });
        }
        /**
         * Delete all of the saved state which this group uses to track resources.
         */
        cleanup() {
            return __awaiter(this, void 0, void 0, function* () {
                // Remove both the cache and the database entries which track LRU stats.
                yield Promise.all([
                    this.cache.then(cache =&gt; this.adapter.caches.delete(cache.name)),
                    this.ageTable.then(table =&gt; this.db.delete(table.name)),
                    this.lruTable.then(table =&gt; this.db.delete(table.name)),
                ]);
            });
        }
        /**
         * Return a list of the names of all caches used by this group.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable, lruTable] = yield Promise.all([
                    this.cache,
                    this.ageTable,
                    this.lruTable,
                ]);
                return [cache.name, ageTable.cacheName, lruTable.cacheName];
            });
        }
        /**
         * Clear the state of the cache for a particular resource.
         *
         * This doesn&#39;t remove the resource from the LRU table, that is assumed to have
         * been done already. This clears the GET and HEAD versions of the request from
         * the cache itself, as well as the metadata stored in the age table.
         */
        clearCacheForUrl(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const [cache, ageTable] = yield Promise.all([this.cache, this.ageTable]);
                yield Promise.all([
                    cache.delete(this.adapter.newRequest(url, { method: &#39;GET&#39; }), this.config.cacheQueryOptions),
                    cache.delete(this.adapter.newRequest(url, { method: &#39;HEAD&#39; }), this.config.cacheQueryOptions),
                    ageTable.delete(url),
                ]);
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return this.scope.fetch(req);
                }
                catch (_a) {
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const BACKWARDS_COMPATIBILITY_NAVIGATION_URLS = [
        { positive: true, regex: &#39;^/.*$&#39; },
        { positive: false, regex: &#39;^/.*\\.[^/]*$&#39; },
        { positive: false, regex: &#39;^/.*__&#39; },
    ];
    /**
     * A specific version of the application, identified by a unique manifest
     * as determined by its hash.
     *
     * Each `AppVersion` can be thought of as a published version of the app
     * that can be installed as an update to any previously installed versions.
     */
    class AppVersion {
        constructor(scope, adapter, database, idle, debugHandler, manifest, manifestHash) {
            this.scope = scope;
            this.adapter = adapter;
            this.database = database;
            this.debugHandler = debugHandler;
            this.manifest = manifest;
            this.manifestHash = manifestHash;
            /**
             * A Map of absolute URL paths (`/foo.txt`) to the known hash of their contents (if available).
             */
            this.hashTable = new Map();
            /**
             * The normalized URL to the file that serves as the index page to satisfy navigation requests.
             * Usually this is `/index.html`.
             */
            this.indexUrl = this.adapter.normalizeUrl(this.manifest.index);
            /**
             * Tracks whether the manifest has encountered any inconsistencies.
             */
            this._okay = true;
            // The hashTable within the manifest is an Object - convert it to a Map for easier lookups.
            Object.keys(manifest.hashTable).forEach(url =&gt; {
                this.hashTable.set(adapter.normalizeUrl(url), manifest.hashTable[url]);
            });
            // Process each `AssetGroup` declared in the manifest. Each declared group gets an `AssetGroup`
            // instance created for it, of a type that depends on the configuration mode.
            const assetCacheNamePrefix = `${manifestHash}:assets`;
            this.assetGroups = (manifest.assetGroups || []).map(config =&gt; {
                // Check the caching mode, which determines when resources will be fetched/updated.
                switch (config.installMode) {
                    case &#39;prefetch&#39;:
                        return new PrefetchAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                    case &#39;lazy&#39;:
                        return new LazyAssetGroup(scope, adapter, idle, config, this.hashTable, database, assetCacheNamePrefix);
                }
            });
            // Process each `DataGroup` declared in the manifest.
            this.dataGroups =
                (manifest.dataGroups || [])
                    .map(config =&gt; new DataGroup(scope, adapter, config, database, debugHandler, `${config.version}:data`));
            // This keeps backwards compatibility with app versions without navigation urls.
            // Fix: https://github.com/angular/angular/issues/27209
            manifest.navigationUrls = manifest.navigationUrls || BACKWARDS_COMPATIBILITY_NAVIGATION_URLS;
            // Create `include`/`exclude` RegExps for the `navigationUrls` declared in the manifest.
            const includeUrls = manifest.navigationUrls.filter(spec =&gt; spec.positive);
            const excludeUrls = manifest.navigationUrls.filter(spec =&gt; !spec.positive);
            this.navigationUrls = {
                include: includeUrls.map(spec =&gt; new RegExp(spec.regex)),
                exclude: excludeUrls.map(spec =&gt; new RegExp(spec.regex)),
            };
        }
        get okay() {
            return this._okay;
        }
        /**
         * Fully initialize this version of the application. If this Promise resolves successfully, all
         * required
         * data has been safely downloaded.
         */
        initializeFully(updateFrom) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Fully initialize each asset group, in series. Starts with an empty Promise,
                    // and waits for the previous groups to have been initialized before initializing
                    // the next one in turn.
                    yield this.assetGroups.reduce((previous, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                        // Wait for the previous groups to complete initialization. If there is a
                        // failure, this will throw, and each subsequent group will throw, until the
                        // whole sequence fails.
                        yield previous;
                        // Initialize this group.
                        return group.initializeFully(updateFrom);
                    }), Promise.resolve());
                }
                catch (err) {
                    this._okay = false;
                    throw err;
                }
            });
        }
        handleFetch(req, event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Check the request against each `AssetGroup` in sequence. If an `AssetGroup` can&#39;t handle the
                // request,
                // it will return `null`. Thus, the first non-null response is the SW&#39;s answer to the request.
                // So reduce
                // the group list, keeping track of a possible response. If there is one, it gets passed
                // through, and if
                // not the next group is consulted to produce a candidate response.
                const asset = yield this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Wait on the previous potential response. If it&#39;s not null, it should just be passed
                    // through.
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    // No response has been found yet. Maybe this group will have one.
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // The result of the above is the asset response, if there is any, or null otherwise. Return the
                // asset
                // response if there was one. If not, check with the data caching groups.
                if (asset !== null) {
                    return asset;
                }
                // Perform the same reduction operation as above, but this time processing
                // the data caching groups.
                const data = yield this.dataGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const resp = yield potentialResponse;
                    if (resp !== null) {
                        return resp;
                    }
                    return group.handleFetch(req, event);
                }), Promise.resolve(null));
                // If the data caching group returned a response, go with it.
                if (data !== null) {
                    return data;
                }
                // Next, check if this is a navigation request for a route. Detect circular
                // navigations by checking if the request URL is the same as the index URL.
                if (this.adapter.normalizeUrl(req.url) !== this.indexUrl &amp;&amp; this.isNavigationRequest(req)) {
                    if (this.manifest.navigationRequestStrategy === &#39;freshness&#39;) {
                        // For navigation requests the freshness was configured. The request will always go trough
                        // the network and fallback to default `handleFetch` behavior in case of failure.
                        try {
                            return yield this.scope.fetch(req);
                        }
                        catch (_a) {
                            // Navigation request failed - application is likely offline.
                            // Proceed forward to the default `handleFetch` behavior, where
                            // `indexUrl` will be requested and it should be available in the cache.
                        }
                    }
                    // This was a navigation request. Re-enter `handleFetch` with a request for
                    // the URL.
                    return this.handleFetch(this.adapter.newRequest(this.indexUrl), event);
                }
                return null;
            });
        }
        /**
         * Determine whether the request is a navigation request.
         * Takes into account: Request mode, `Accept` header, `navigationUrls` patterns.
         */
        isNavigationRequest(req) {
            if (req.mode !== &#39;navigate&#39;) {
                return false;
            }
            if (!this.acceptsTextHtml(req)) {
                return false;
            }
            const urlPrefix = this.scope.registration.scope.replace(/\/$/, &#39;&#39;);
            const url = req.url.startsWith(urlPrefix) ? req.url.substr(urlPrefix.length) : req.url;
            const urlWithoutQueryOrHash = url.replace(/[?#].*$/, &#39;&#39;);
            return this.navigationUrls.include.some(regex =&gt; regex.test(urlWithoutQueryOrHash)) &amp;&amp;
                !this.navigationUrls.exclude.some(regex =&gt; regex.test(urlWithoutQueryOrHash));
        }
        /**
         * Check this version for a given resource with a particular hash.
         */
        lookupResourceWithHash(url, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                // Verify that this version has the requested resource cached. If not,
                // there&#39;s no point in trying.
                if (!this.hashTable.has(url)) {
                    return null;
                }
                // Next, check whether the resource has the correct hash. If not, any cached
                // response isn&#39;t usable.
                if (this.hashTable.get(url) !== hash) {
                    return null;
                }
                const cacheState = yield this.lookupResourceWithoutHash(url);
                return cacheState &amp;&amp; cacheState.response;
            });
        }
        /**
         * Check this version for a given resource regardless of its hash.
         */
        lookupResourceWithoutHash(url) {
            // Limit the search to asset groups, and only scan the cache, don&#39;t
            // load resources from the network.
            return this.assetGroups.reduce((potentialResponse, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                const resp = yield potentialResponse;
                if (resp !== null) {
                    return resp;
                }
                // fetchFromCacheOnly() avoids any network fetches, and returns the
                // full set of cache data, not just the Response.
                return group.fetchFromCacheOnly(url);
            }), Promise.resolve(null));
        }
        /**
         * List all unhashed resources from all asset groups.
         */
        previouslyCachedResources() {
            return this.assetGroups.reduce((resources, group) =&gt; __awaiter(this, void 0, void 0, function* () { return (yield resources).concat(yield group.unhashedResources()); }), Promise.resolve([]));
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.assetGroups.reduce((current, group) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const status = yield current;
                    if (status === UpdateCacheStatus.CACHED) {
                        return status;
                    }
                    const groupStatus = yield group.cacheStatus(url);
                    if (groupStatus === UpdateCacheStatus.NOT_CACHED) {
                        return status;
                    }
                    return groupStatus;
                }), Promise.resolve(UpdateCacheStatus.NOT_CACHED));
            });
        }
        /**
         * Return a list of the names of all caches used by this version.
         */
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const allGroupCacheNames = yield Promise.all([
                    ...this.assetGroups.map(group =&gt; group.getCacheNames()),
                    ...this.dataGroups.map(group =&gt; group.getCacheNames()),
                ]);
                return [].concat(...allGroupCacheNames);
            });
        }
        /**
         * Get the opaque application data which was provided with the manifest.
         */
        get appData() {
            return this.manifest.appData || null;
        }
        /**
         * Check whether a request accepts `text/html` (based on the `Accept` header).
         */
        acceptsTextHtml(req) {
            const accept = req.headers.get(&#39;Accept&#39;);
            if (accept === null) {
                return false;
            }
            const values = accept.split(&#39;,&#39;);
            return values.some(value =&gt; value.trim().toLowerCase() === &#39;text/html&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const SW_VERSION = &#39;12.2.15&#39;;
    const DEBUG_LOG_BUFFER_SIZE = 100;
    class DebugHandler {
        constructor(driver, adapter) {
            this.driver = driver;
            this.adapter = adapter;
            // There are two debug log message arrays. debugLogA records new debugging messages.
            // Once it reaches DEBUG_LOG_BUFFER_SIZE, the array is moved to debugLogB and a new
            // array is assigned to debugLogA. This ensures that insertion to the debug log is
            // always O(1) no matter the number of logged messages, and that the total number
            // of messages in the log never exceeds 2 * DEBUG_LOG_BUFFER_SIZE.
            this.debugLogA = [];
            this.debugLogB = [];
        }
        handleFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                const [state, versions, idle] = yield Promise.all([
                    this.driver.debugState(),
                    this.driver.debugVersions(),
                    this.driver.debugIdleState(),
                ]);
                const msgState = `NGSW Debug Info:

Driver version: ${SW_VERSION}
Driver state: ${state.state} (${state.why})
Latest manifest hash: ${state.latestHash || &#39;none&#39;}
Last update check: ${this.since(state.lastUpdateCheck)}`;
                const msgVersions = versions
                    .map(version =&gt; `=== Version ${version.hash} ===

Clients: ${version.clients.join(&#39;, &#39;)}`)
                    .join(&#39;\n\n&#39;);
                const msgIdle = `=== Idle Task Queue ===
Last update tick: ${this.since(idle.lastTrigger)}
Last update run: ${this.since(idle.lastRun)}
Task queue:
${idle.queue.map(v =&gt; &#39; * &#39; + v).join(&#39;\n&#39;)}

Debug log:
${this.formatDebugLog(this.debugLogB)}
${this.formatDebugLog(this.debugLogA)}
`;
                return this.adapter.newResponse(`${msgState}

${msgVersions}

${msgIdle}`, { headers: this.adapter.newHeaders({ &#39;Content-Type&#39;: &#39;text/plain&#39; }) });
            });
        }
        since(time) {
            if (time === null) {
                return &#39;never&#39;;
            }
            let age = this.adapter.time - time;
            const days = Math.floor(age / 86400000);
            age = age % 86400000;
            const hours = Math.floor(age / 3600000);
            age = age % 3600000;
            const minutes = Math.floor(age / 60000);
            age = age % 60000;
            const seconds = Math.floor(age / 1000);
            const millis = age % 1000;
            return &#39;&#39; + (days &gt; 0 ? `${days}d` : &#39;&#39;) + (hours &gt; 0 ? `${hours}h` : &#39;&#39;) +
                (minutes &gt; 0 ? `${minutes}m` : &#39;&#39;) + (seconds &gt; 0 ? `${seconds}s` : &#39;&#39;) +
                (millis &gt; 0 ? `${millis}u` : &#39;&#39;);
        }
        log(value, context = &#39;&#39;) {
            // Rotate the buffers if debugLogA has grown too large.
            if (this.debugLogA.length === DEBUG_LOG_BUFFER_SIZE) {
                this.debugLogB = this.debugLogA;
                this.debugLogA = [];
            }
            // Convert errors to string for logging.
            if (typeof value !== &#39;string&#39;) {
                value = this.errorToString(value);
            }
            // Log the message.
            this.debugLogA.push({ value, time: this.adapter.time, context });
        }
        errorToString(err) {
            return `${err.name}(${err.message}, ${err.stack})`;
        }
        formatDebugLog(log) {
            return log.map(entry =&gt; `[${this.since(entry.time)}] ${entry.value} ${entry.context}`)
                .join(&#39;\n&#39;);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    class IdleScheduler {
        constructor(adapter, delay, maxDelay, debug) {
            this.adapter = adapter;
            this.delay = delay;
            this.maxDelay = maxDelay;
            this.debug = debug;
            this.queue = [];
            this.scheduled = null;
            this.empty = Promise.resolve();
            this.emptyResolve = null;
            this.lastTrigger = null;
            this.lastRun = null;
            this.oldestScheduledAt = null;
        }
        trigger() {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                this.lastTrigger = this.adapter.time;
                if (this.queue.length === 0) {
                    return;
                }
                if (this.scheduled !== null) {
                    this.scheduled.cancel = true;
                }
                const scheduled = {
                    cancel: false,
                };
                this.scheduled = scheduled;
                // Ensure that no task remains pending for longer than `this.maxDelay` ms.
                const now = this.adapter.time;
                const maxDelay = Math.max(0, ((_a = this.oldestScheduledAt) !== null &amp;&amp; _a !== void 0 ? _a : now) + this.maxDelay - now);
                const delay = Math.min(maxDelay, this.delay);
                yield this.adapter.timeout(delay);
                if (scheduled.cancel) {
                    return;
                }
                this.scheduled = null;
                yield this.execute();
            });
        }
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                this.lastRun = this.adapter.time;
                while (this.queue.length &gt; 0) {
                    const queue = this.queue;
                    this.queue = [];
                    yield queue.reduce((previous, task) =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield previous;
                        try {
                            yield task.run();
                        }
                        catch (err) {
                            this.debug.log(err, `while running idle task ${task.desc}`);
                        }
                    }), Promise.resolve());
                }
                if (this.emptyResolve !== null) {
                    this.emptyResolve();
                    this.emptyResolve = null;
                }
                this.empty = Promise.resolve();
                this.oldestScheduledAt = null;
            });
        }
        schedule(desc, run) {
            this.queue.push({ desc, run });
            if (this.emptyResolve === null) {
                this.empty = new Promise(resolve =&gt; {
                    this.emptyResolve = resolve;
                });
            }
            if (this.oldestScheduledAt === null) {
                this.oldestScheduledAt = this.adapter.time;
            }
        }
        get size() {
            return this.queue.length;
        }
        get taskDescriptions() {
            return this.queue.map(task =&gt; task.desc);
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function hashManifest(manifest) {
        return sha1(JSON.stringify(manifest));
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function isMsgCheckForUpdates(msg) {
        return msg.action === &#39;CHECK_FOR_UPDATES&#39;;
    }
    function isMsgActivateUpdate(msg) {
        return msg.action === &#39;ACTIVATE_UPDATE&#39;;
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const IDLE_DELAY = 5000;
    const MAX_IDLE_DELAY = 30000;
    const SUPPORTED_CONFIG_VERSION = 1;
    const NOTIFICATION_OPTION_NAMES = [
        &#39;actions&#39;, &#39;badge&#39;, &#39;body&#39;, &#39;data&#39;, &#39;dir&#39;, &#39;icon&#39;, &#39;image&#39;, &#39;lang&#39;, &#39;renotify&#39;,
        &#39;requireInteraction&#39;, &#39;silent&#39;, &#39;tag&#39;, &#39;timestamp&#39;, &#39;title&#39;, &#39;vibrate&#39;
    ];
    var DriverReadyState = /*@__PURE__*/ (function (DriverReadyState) {
        // The SW is operating in a normal mode, responding to all traffic.
        DriverReadyState[DriverReadyState[&quot;NORMAL&quot;] = 0] = &quot;NORMAL&quot;;
        // The SW does not have a clean installation of the latest version of the app, but older
        // cached versions are safe to use so long as they don&#39;t try to fetch new dependencies.
        // This is a degraded state.
        DriverReadyState[DriverReadyState[&quot;EXISTING_CLIENTS_ONLY&quot;] = 1] = &quot;EXISTING_CLIENTS_ONLY&quot;;
        // The SW has decided that caching is completely unreliable, and is forgoing request
        // handling until the next restart.
        DriverReadyState[DriverReadyState[&quot;SAFE_MODE&quot;] = 2] = &quot;SAFE_MODE&quot;;
        return DriverReadyState;
    })({});
    class Driver {
        constructor(scope, adapter, db) {
            // Set up all the event handlers that the SW needs.
            this.scope = scope;
            this.adapter = adapter;
            this.db = db;
            /**
             * Tracks the current readiness condition under which the SW is operating. This controls
             * whether the SW attempts to respond to some or all requests.
             */
            this.state = DriverReadyState.NORMAL;
            this.stateMessage = &#39;(nominal)&#39;;
            /**
             * Tracks whether the SW is in an initialized state or not. Before initialization,
             * it&#39;s not legal to respond to requests.
             */
            this.initialized = null;
            /**
             * Maps client IDs to the manifest hash of the application version being used to serve
             * them. If a client ID is not present here, it has not yet been assigned a version.
             *
             * If a ManifestHash appears here, it is also present in the `versions` map below.
             */
            this.clientVersionMap = new Map();
            /**
             * Maps manifest hashes to instances of `AppVersion` for those manifests.
             */
            this.versions = new Map();
            /**
             * The latest version fetched from the server.
             *
             * Valid after initialization has completed.
             */
            this.latestHash = null;
            this.lastUpdateCheck = null;
            /**
             * Whether there is a check for updates currently scheduled due to navigation.
             */
            this.scheduledNavUpdateCheck = false;
            /**
             * Keep track of whether we have logged an invalid `only-if-cached` request.
             * (See `.onFetch()` for details.)
             */
            this.loggedInvalidOnlyIfCachedRequest = false;
            this.ngswStatePath = this.adapter.parseUrl(&#39;ngsw/state&#39;, this.scope.registration.scope).path;
            // A promise resolving to the control DB table.
            this.controlTable = this.db.open(&#39;control&#39;);
            // The install event is triggered when the service worker is first installed.
            this.scope.addEventListener(&#39;install&#39;, (event) =&gt; {
                // SW code updates are separate from application updates, so code updates are
                // almost as straightforward as restarting the SW. Because of this, it&#39;s always
                // safe to skip waiting until application tabs are closed, and activate the new
                // SW version immediately.
                event.waitUntil(this.scope.skipWaiting());
            });
            // The activate event is triggered when this version of the service worker is
            // first activated.
            this.scope.addEventListener(&#39;activate&#39;, (event) =&gt; {
                event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                    // As above, it&#39;s safe to take over from existing clients immediately, since the new SW
                    // version will continue to serve the old application.
                    yield this.scope.clients.claim();
                    // Once all clients have been taken over, we can delete caches used by old versions of
                    // `@angular/service-worker`, which are no longer needed. This can happen in the background.
                    this.idle.schedule(&#39;activate: cleanup-old-sw-caches&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        try {
                            yield this.cleanupOldSwCaches();
                        }
                        catch (err) {
                            // Nothing to do - cleanup failed. Just log it.
                            this.debugger.log(err, &#39;cleanupOldSwCaches @ activate: cleanup-old-sw-caches&#39;);
                        }
                    }));
                }))());
                // Rather than wait for the first fetch event, which may not arrive until
                // the next time the application is loaded, the SW takes advantage of the
                // activation event to schedule initialization. However, if this were run
                // in the context of the &#39;activate&#39; event, waitUntil() here would cause fetch
                // events to block until initialization completed. Thus, the SW does a
                // postMessage() to itself, to schedule a new event loop iteration with an
                // entirely separate event context. The SW will be kept alive by waitUntil()
                // within that separate context while initialization proceeds, while at the
                // same time the activation event is allowed to resolve and traffic starts
                // being served.
                if (this.scope.registration.active !== null) {
                    this.scope.registration.active.postMessage({ action: &#39;INITIALIZE&#39; });
                }
            });
            // Handle the fetch, message, and push events.
            this.scope.addEventListener(&#39;fetch&#39;, (event) =&gt; this.onFetch(event));
            this.scope.addEventListener(&#39;message&#39;, (event) =&gt; this.onMessage(event));
            this.scope.addEventListener(&#39;push&#39;, (event) =&gt; this.onPush(event));
            this.scope.addEventListener(&#39;notificationclick&#39;, (event) =&gt; this.onClick(event));
            // The debugger generates debug pages in response to debugging requests.
            this.debugger = new DebugHandler(this, this.adapter);
            // The IdleScheduler will execute idle tasks after a given delay.
            this.idle = new IdleScheduler(this.adapter, IDLE_DELAY, MAX_IDLE_DELAY, this.debugger);
        }
        /**
         * The handler for fetch events.
         *
         * This is the transition point between the synchronous event handler and the
         * asynchronous execution that eventually resolves for respondWith() and waitUntil().
         */
        onFetch(event) {
            const req = event.request;
            const scopeUrl = this.scope.registration.scope;
            const requestUrlObj = this.adapter.parseUrl(req.url, scopeUrl);
            if (req.headers.has(&#39;ngsw-bypass&#39;) || /[?&amp;]ngsw-bypass(?:[=&amp;]|$)/i.test(requestUrlObj.search)) {
                return;
            }
            // The only thing that is served unconditionally is the debug page.
            if (requestUrlObj.path === this.ngswStatePath) {
                // Allow the debugger to handle the request, but don&#39;t affect SW state in any other way.
                event.respondWith(this.debugger.handleFetch(req));
                return;
            }
            // If the SW is in a broken state where it&#39;s not safe to handle requests at all,
            // returning causes the request to fall back on the network. This is preferred over
            // `respondWith(fetch(req))` because the latter still shows in DevTools that the
            // request was handled by the SW.
            if (this.state === DriverReadyState.SAFE_MODE) {
                // Even though the worker is in safe mode, idle tasks still need to happen so
                // things like update checks, etc. can take place.
                event.waitUntil(this.idle.trigger());
                return;
            }
            // Although &quot;passive mixed content&quot; (like images) only produces a warning without a
            // ServiceWorker, fetching it via a ServiceWorker results in an error. Let such requests be
            // handled by the browser, since handling with the ServiceWorker would fail anyway.
            // See https://github.com/angular/angular/issues/23012#issuecomment-376430187 for more details.
            if (requestUrlObj.origin.startsWith(&#39;http:&#39;) &amp;&amp; scopeUrl.startsWith(&#39;https:&#39;)) {
                // Still, log the incident for debugging purposes.
                this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${req.url})`);
                return;
            }
            // When opening DevTools in Chrome, a request is made for the current URL (and possibly related
            // resources, e.g. scripts) with `cache: &#39;only-if-cached&#39;` and `mode: &#39;no-cors&#39;`. These request
            // will eventually fail, because `only-if-cached` is only allowed to be used with
            // `mode: &#39;same-origin&#39;`.
            // This is likely a bug in Chrome DevTools. Avoid handling such requests.
            // (See also https://github.com/angular/angular/issues/22362.)
            // TODO(gkalpak): Remove once no longer necessary (i.e. fixed in Chrome DevTools).
            if (req.cache === &#39;only-if-cached&#39; &amp;&amp; req.mode !== &#39;same-origin&#39;) {
                // Log the incident only the first time it happens, to avoid spamming the logs.
                if (!this.loggedInvalidOnlyIfCachedRequest) {
                    this.loggedInvalidOnlyIfCachedRequest = true;
                    this.debugger.log(`Ignoring invalid request: &#39;only-if-cached&#39; can be set only with &#39;same-origin&#39; mode`, `Driver.fetch(${req.url}, cache: ${req.cache}, mode: ${req.mode})`);
                }
                return;
            }
            // Past this point, the SW commits to handling the request itself. This could still
            // fail (and result in `state` being set to `SAFE_MODE`), but even in that case the
            // SW will still deliver a response.
            event.respondWith(this.handleFetch(event));
        }
        /**
         * The handler for message events.
         */
        onMessage(event) {
            // Ignore message events when the SW is in safe mode, for now.
            if (this.state === DriverReadyState.SAFE_MODE) {
                return;
            }
            // If the message doesn&#39;t have the expected signature, ignore it.
            const data = event.data;
            if (!data || !data.action) {
                return;
            }
            event.waitUntil((() =&gt; __awaiter(this, void 0, void 0, function* () {
                // Initialization is the only event which is sent directly from the SW to itself, and thus
                // `event.source` is not a `Client`. Handle it here, before the check for `Client` sources.
                if (data.action === &#39;INITIALIZE&#39;) {
                    return this.ensureInitialized(event);
                }
                // Only messages from true clients are accepted past this point.
                // This is essentially a typecast.
                if (!this.adapter.isClient(event.source)) {
                    return;
                }
                // Handle the message and keep the SW alive until it&#39;s handled.
                yield this.ensureInitialized(event);
                yield this.handleMessage(data, event.source);
            }))());
        }
        onPush(msg) {
            // Push notifications without data have no effect.
            if (!msg.data) {
                return;
            }
            // Handle the push and keep the SW alive until it&#39;s handled.
            msg.waitUntil(this.handlePush(msg.data.json()));
        }
        onClick(event) {
            // Handle the click event and keep the SW alive until it&#39;s handled.
            event.waitUntil(this.handleClick(event.notification, event.action));
        }
        ensureInitialized(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // Since the SW may have just been started, it may or may not have been initialized already.
                // `this.initialized` will be `null` if initialization has not yet been attempted, or will be a
                // `Promise` which will resolve (successfully or unsuccessfully) if it has.
                if (this.initialized !== null) {
                    return this.initialized;
                }
                // Initialization has not yet been attempted, so attempt it. This should only ever happen once
                // per SW instantiation.
                try {
                    this.initialized = this.initialize();
                    yield this.initialized;
                }
                catch (error) {
                    // If initialization fails, the SW needs to enter a safe state, where it declines to respond
                    // to network requests.
                    this.state = DriverReadyState.SAFE_MODE;
                    this.stateMessage = `Initialization failed due to error: ${errorToString(error)}`;
                    throw error;
                }
                finally {
                    // Regardless if initialization succeeded, background tasks still need to happen.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        handleMessage(msg, from) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isMsgCheckForUpdates(msg)) {
                    const action = (() =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }))();
                    yield this.reportStatus(from, action, msg.statusNonce);
                }
                else if (isMsgActivateUpdate(msg)) {
                    yield this.reportStatus(from, this.updateClient(from), msg.statusNonce);
                }
            });
        }
        handlePush(data) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.broadcast({
                    type: &#39;PUSH&#39;,
                    data,
                });
                if (!data.notification || !data.notification.title) {
                    return;
                }
                const desc = data.notification;
                let options = {};
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; desc.hasOwnProperty(name))
                    .forEach(name =&gt; options[name] = desc[name]);
                yield this.scope.registration.showNotification(desc[&#39;title&#39;], options);
            });
        }
        handleClick(notification, action) {
            var _a, _b, _c;
            return __awaiter(this, void 0, void 0, function* () {
                notification.close();
                const options = {};
                // The filter uses `name in notification` because the properties are on the prototype so
                // hasOwnProperty does not work here
                NOTIFICATION_OPTION_NAMES.filter(name =&gt; name in notification)
                    .forEach(name =&gt; options[name] = notification[name]);
                const notificationAction = action === &#39;&#39; || action === undefined ? &#39;default&#39; : action;
                const onActionClick = (_b = (_a = notification === null || notification === void 0 ? void 0 : notification.data) === null || _a === void 0 ? void 0 : _a.onActionClick) === null || _b === void 0 ? void 0 : _b[notificationAction];
                const urlToOpen = new URL((_c = onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.url) !== null &amp;&amp; _c !== void 0 ? _c : &#39;&#39;, this.scope.registration.scope).href;
                switch (onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick.operation) {
                    case &#39;openWindow&#39;:
                        yield this.scope.clients.openWindow(urlToOpen);
                        break;
                    case &#39;focusLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                    case &#39;navigateLastFocusedOrOpen&#39;: {
                        let matchingClient = yield this.getLastFocusedMatchingClient(this.scope);
                        if (matchingClient) {
                            matchingClient = yield matchingClient.navigate(urlToOpen);
                            yield (matchingClient === null || matchingClient === void 0 ? void 0 : matchingClient.focus());
                        }
                        else {
                            yield this.scope.clients.openWindow(urlToOpen);
                        }
                        break;
                    }
                }
                yield this.broadcast({
                    type: &#39;NOTIFICATION_CLICK&#39;,
                    data: { action, notification: options },
                });
            });
        }
        getLastFocusedMatchingClient(scope) {
            return __awaiter(this, void 0, void 0, function* () {
                const windowClients = yield scope.clients.matchAll({ type: &#39;window&#39; });
                // As per the spec windowClients are `sorted in the most recently focused order`
                return windowClients[0];
            });
        }
        reportStatus(client, promise, nonce) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = { type: &#39;STATUS&#39;, nonce, status: true };
                try {
                    yield promise;
                    client.postMessage(response);
                }
                catch (e) {
                    client.postMessage(Object.assign(Object.assign({}, response), { status: false, error: e.toString() }));
                }
            });
        }
        updateClient(client) {
            return __awaiter(this, void 0, void 0, function* () {
                // Figure out which version the client is on. If it&#39;s not on the latest,
                // it needs to be moved.
                const existing = this.clientVersionMap.get(client.id);
                if (existing === this.latestHash) {
                    // Nothing to do, this client is already on the latest version.
                    return;
                }
                // Switch the client over.
                let previous = undefined;
                // Look up the application data associated with the existing version. If there
                // isn&#39;t any, fall back on using the hash.
                if (existing !== undefined) {
                    const existingVersion = this.versions.get(existing);
                    previous = this.mergeHashWithAppData(existingVersion.manifest, existing);
                }
                // Set the current version used by the client, and sync the mapping to disk.
                this.clientVersionMap.set(client.id, this.latestHash);
                yield this.sync();
                // Notify the client about this activation.
                const current = this.versions.get(this.latestHash);
                const notice = {
                    type: &#39;UPDATE_ACTIVATED&#39;,
                    previous,
                    current: this.mergeHashWithAppData(current.manifest, this.latestHash),
                };
                client.postMessage(notice);
            });
        }
        handleFetch(event) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Ensure the SW instance has been initialized.
                    yield this.ensureInitialized(event);
                }
                catch (_a) {
                    // Since the SW is already committed to responding to the currently active request,
                    // respond with a network fetch.
                    return this.safeFetch(event.request);
                }
                // On navigation requests, check for new updates.
                if (event.request.mode === &#39;navigate&#39; &amp;&amp; !this.scheduledNavUpdateCheck) {
                    this.scheduledNavUpdateCheck = true;
                    this.idle.schedule(&#39;check-updates-on-navigation&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        this.scheduledNavUpdateCheck = false;
                        yield this.checkForUpdate();
                    }));
                }
                // Decide which version of the app to use to serve this request. This is asynchronous as in
                // some cases, a record will need to be written to disk about the assignment that is made.
                const appVersion = yield this.assignVersion(event);
                let res = null;
                try {
                    if (appVersion !== null) {
                        try {
                            // Handle the request. First try the AppVersion. If that doesn&#39;t work, fall back on the
                            // network.
                            res = yield appVersion.handleFetch(event.request, event);
                        }
                        catch (err) {
                            if (err.isUnrecoverableState) {
                                yield this.notifyClientsAboutUnrecoverableState(appVersion, err.message);
                            }
                            if (err.isCritical) {
                                // Something went wrong with handling the request from this version.
                                this.debugger.log(err, `Driver.handleFetch(version: ${appVersion.manifestHash})`);
                                yield this.versionFailed(appVersion, err);
                                return this.safeFetch(event.request);
                            }
                            throw err;
                        }
                    }
                    // The response will be `null` only if no `AppVersion` can be assigned to the request or if
                    // the assigned `AppVersion`&#39;s manifest doesn&#39;t specify what to do about the request.
                    // In that case, just fall back on the network.
                    if (res === null) {
                        return this.safeFetch(event.request);
                    }
                    // The `AppVersion` returned a usable response, so return it.
                    return res;
                }
                finally {
                    // Trigger the idle scheduling system. The Promise returned by `trigger()` will resolve after
                    // a specific amount of time has passed. If `trigger()` hasn&#39;t been called again by then (e.g.
                    // on a subsequent request), the idle task queue will be drained and the `Promise` won&#39;t
                    // be resolved until that operation is complete as well.
                    event.waitUntil(this.idle.trigger());
                }
            });
        }
        /**
         * Attempt to quickly reach a state where it&#39;s safe to serve responses.
         */
        initialize() {
            return __awaiter(this, void 0, void 0, function* () {
                // On initialization, all of the serialized state is read out of the &#39;control&#39;
                // table. This includes:
                // - map of hashes to manifests of currently loaded application versions
                // - map of client IDs to their pinned versions
                // - record of the most recently fetched manifest hash
                //
                // If these values don&#39;t exist in the DB, then this is the either the first time
                // the SW has run or the DB state has been wiped or is inconsistent. In that case,
                // load a fresh copy of the manifest and reset the state from scratch.
                const table = yield this.controlTable;
                // Attempt to load the needed state from the DB. If this fails, the catch {} block
                // will populate these variables with freshly constructed values.
                let manifests, assignments, latest;
                try {
                    // Read them from the DB simultaneously.
                    [manifests, assignments, latest] = yield Promise.all([
                        table.read(&#39;manifests&#39;),
                        table.read(&#39;assignments&#39;),
                        table.read(&#39;latest&#39;),
                    ]);
                    // Make sure latest manifest is correctly installed. If not (e.g. corrupted data),
                    // it could stay locked in EXISTING_CLIENTS_ONLY or SAFE_MODE state.
                    if (!this.versions.has(latest.latest) &amp;&amp; !manifests.hasOwnProperty(latest.latest)) {
                        this.debugger.log(`Missing manifest for latest version hash ${latest.latest}`, &#39;initialize: read from DB&#39;);
                        throw new Error(`Missing manifest for latest hash ${latest.latest}`);
                    }
                    // Successfully loaded from saved state. This implies a manifest exists, so
                    // the update check needs to happen in the background.
                    this.idle.schedule(&#39;init post-load (update)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                        yield this.checkForUpdate();
                    }));
                }
                catch (_) {
                    // Something went wrong. Try to start over by fetching a new manifest from the
                    // server and building up an empty initial state.
                    const manifest = yield this.fetchLatestManifest();
                    const hash = hashManifest(manifest);
                    manifests = { [hash]: manifest };
                    assignments = {};
                    latest = { latest: hash };
                    // Save the initial state to the DB.
                    yield Promise.all([
                        table.write(&#39;manifests&#39;, manifests),
                        table.write(&#39;assignments&#39;, assignments),
                        table.write(&#39;latest&#39;, latest),
                    ]);
                }
                // At this point, either the state has been loaded successfully, or fresh state
                // with a new copy of the manifest has been produced. At this point, the `Driver`
                // can have its internals hydrated from the state.
                // Schedule cleaning up obsolete caches in the background.
                this.idle.schedule(&#39;init post-load (cleanup)&#39;, () =&gt; __awaiter(this, void 0, void 0, function* () {
                    yield this.cleanupCaches();
                }));
                // Initialize the `versions` map by setting each hash to a new `AppVersion` instance
                // for that manifest.
                Object.keys(manifests).forEach((hash) =&gt; {
                    const manifest = manifests[hash];
                    // If the manifest is newly initialized, an AppVersion may have already been
                    // created for it.
                    if (!this.versions.has(hash)) {
                        this.versions.set(hash, new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash));
                    }
                });
                // Map each client ID to its associated hash. Along the way, verify that the hash
                // is still valid for that client ID. It should not be possible for a client to
                // still be associated with a hash that was since removed from the state.
                Object.keys(assignments).forEach((clientId) =&gt; {
                    const hash = assignments[clientId];
                    if (this.versions.has(hash)) {
                        this.clientVersionMap.set(clientId, hash);
                    }
                    else {
                        this.clientVersionMap.set(clientId, latest.latest);
                        this.debugger.log(`Unknown version ${hash} mapped for client ${clientId}, using latest instead`, `initialize: map assignments`);
                    }
                });
                // Set the latest version.
                this.latestHash = latest.latest;
                // Finally, assert that the latest version is in fact loaded.
                if (!this.versions.has(latest.latest)) {
                    throw new Error(`Invariant violated (initialize): latest hash ${latest.latest} has no known manifest`);
                }
                // Finally, wait for the scheduling of initialization of all versions in the
                // manifest. Ordinarily this just schedules the initializations to happen during
                // the next idle period, but in development mode this might actually wait for the
                // full initialization.
                // If any of these initializations fail, versionFailed() will be called either
                // synchronously or asynchronously to handle the failure and re-map clients.
                yield Promise.all(Object.keys(manifests).map((hash) =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        // Attempt to schedule or initialize this version. If this operation is
                        // successful, then initialization either succeeded or was scheduled. If
                        // it fails, then full initialization was attempted and failed.
                        yield this.scheduleInitialization(this.versions.get(hash));
                    }
                    catch (err) {
                        this.debugger.log(err, `initialize: schedule init of ${hash}`);
                        return false;
                    }
                })));
            });
        }
        lookupVersionByHash(hash, debugName = &#39;lookupVersionByHash&#39;) {
            // The version should exist, but check just in case.
            if (!this.versions.has(hash)) {
                throw new Error(`Invariant violated (${debugName}): want AppVersion for ${hash} but not loaded`);
            }
            return this.versions.get(hash);
        }
        /**
         * Decide which version of the manifest to use for the event.
         */
        assignVersion(event) {
            return __awaiter(this, void 0, void 0, function* () {
                // First, check whether the event has a (non empty) client ID. If it does, the version may
                // already be associated.
                //
                // NOTE: For navigation requests, we care about the `resultingClientId`. If it is undefined or
                //       the empty string (which is the case for sub-resource requests), we look at `clientId`.
                const clientId = event.resultingClientId || event.clientId;
                if (clientId) {
                    // Check if there is an assigned client id.
                    if (this.clientVersionMap.has(clientId)) {
                        // There is an assignment for this client already.
                        const hash = this.clientVersionMap.get(clientId);
                        let appVersion = this.lookupVersionByHash(hash, &#39;assignVersion&#39;);
                        // Ordinarily, this client would be served from its assigned version. But, if this
                        // request is a navigation request, this client can be updated to the latest
                        // version immediately.
                        if (this.state === DriverReadyState.NORMAL &amp;&amp; hash !== this.latestHash &amp;&amp;
                            appVersion.isNavigationRequest(event.request)) {
                            // Update this client to the latest version immediately.
                            if (this.latestHash === null) {
                                throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                            }
                            const client = yield this.scope.clients.get(clientId);
                            if (client) {
                                yield this.updateClient(client);
                            }
                            appVersion = this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                        }
                        // TODO: make sure the version is valid.
                        return appVersion;
                    }
                    else {
                        // This is the first time this client ID has been seen. Whether the SW is in a
                        // state to handle new clients depends on the current readiness state, so check
                        // that first.
                        if (this.state !== DriverReadyState.NORMAL) {
                            // It&#39;s not safe to serve new clients in the current state. It&#39;s possible that
                            // this is an existing client which has not been mapped yet (see below) but
                            // even if that is the case, it&#39;s invalid to make an assignment to a known
                            // invalid version, even if that assignment was previously implicit. Return
                            // undefined here to let the caller know that no assignment is possible at
                            // this time.
                            return null;
                        }
                        // It&#39;s safe to handle this request. Two cases apply. Either:
                        // 1) the browser assigned a client ID at the time of the navigation request, and
                        //    this is truly the first time seeing this client, or
                        // 2) a navigation request came previously from the same client, but with no client
                        //    ID attached. Browsers do this to avoid creating a client under the origin in
                        //    the event the navigation request is just redirected.
                        //
                        // In case 1, the latest version can safely be used.
                        // In case 2, the latest version can be used, with the assumption that the previous
                        // navigation request was answered under the same version. This assumption relies
                        // on the fact that it&#39;s unlikely an update will come in between the navigation
                        // request and requests for subsequent resources on that page.
                        // First validate the current state.
                        if (this.latestHash === null) {
                            throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                        }
                        // Pin this client ID to the current latest version, indefinitely.
                        this.clientVersionMap.set(clientId, this.latestHash);
                        yield this.sync();
                        // Return the latest `AppVersion`.
                        return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                    }
                }
                else {
                    // No client ID was associated with the request. This must be a navigation request
                    // for a new client. First check that the SW is accepting new clients.
                    if (this.state !== DriverReadyState.NORMAL) {
                        return null;
                    }
                    // Serve it with the latest version, and assume that the client will actually get
                    // associated with that version on the next request.
                    // First validate the current state.
                    if (this.latestHash === null) {
                        throw new Error(`Invariant violated (assignVersion): latestHash was null`);
                    }
                    // Return the latest `AppVersion`.
                    return this.lookupVersionByHash(this.latestHash, &#39;assignVersion&#39;);
                }
            });
        }
        fetchLatestManifest(ignoreOfflineError = false) {
            return __awaiter(this, void 0, void 0, function* () {
                const res = yield this.safeFetch(this.adapter.newRequest(&#39;ngsw.json?ngsw-cache-bust=&#39; + Math.random()));
                if (!res.ok) {
                    if (res.status === 404) {
                        yield this.deleteAllCaches();
                        yield this.scope.registration.unregister();
                    }
                    else if ((res.status === 503 || res.status === 504) &amp;&amp; ignoreOfflineError) {
                        return null;
                    }
                    throw new Error(`Manifest fetch failed! (status: ${res.status})`);
                }
                this.lastUpdateCheck = this.adapter.time;
                return res.json();
            });
        }
        deleteAllCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheNames = yield this.adapter.caches.keys();
                yield Promise.all(cacheNames.map(name =&gt; this.adapter.caches.delete(name)));
            });
        }
        /**
         * Schedule the SW&#39;s attempt to reach a fully prefetched state for the given AppVersion
         * when the SW is not busy and has connectivity. This returns a Promise which must be
         * awaited, as under some conditions the AppVersion might be initialized immediately.
         */
        scheduleInitialization(appVersion) {
            return __awaiter(this, void 0, void 0, function* () {
                const initialize = () =&gt; __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield appVersion.initializeFully();
                    }
                    catch (err) {
                        this.debugger.log(err, `initializeFully for ${appVersion.manifestHash}`);
                        yield this.versionFailed(appVersion, err);
                    }
                });
                // TODO: better logic for detecting localhost.
                if (this.scope.registration.scope.indexOf(&#39;://localhost&#39;) &gt; -1) {
                    return initialize();
                }
                this.idle.schedule(`initialization(${appVersion.manifestHash})`, initialize);
            });
        }
        versionFailed(appVersion, err) {
            return __awaiter(this, void 0, void 0, function* () {
                // This particular AppVersion is broken. First, find the manifest hash.
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                // The specified version is broken and new clients should not be served from it. However, it is
                // deemed even riskier to switch the existing clients to a different version or to the network.
                // Therefore, we keep clients on their current version (even if broken) and ensure that no new
                // clients will be assigned to it.
                // TODO: notify affected apps.
                // The action taken depends on whether the broken manifest is the active (latest) or not.
                // - If the broken version is not the latest, no further action is necessary, since new clients
                //   will be assigned to the latest version anyway.
                // - If the broken version is the latest, the SW cannot accept new clients (but can continue to
                //   service old ones).
                if (this.latestHash === brokenHash) {
                    // The latest manifest is broken. This means that new clients are at the mercy of the network,
                    // but caches continue to be valid for previous versions. This is unfortunate but unavoidable.
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to: ${errorToString(err)}`;
                }
            });
        }
        setupUpdate(manifest, hash) {
            return __awaiter(this, void 0, void 0, function* () {
                const newVersion = new AppVersion(this.scope, this.adapter, this.db, this.idle, this.debugger, manifest, hash);
                // Firstly, check if the manifest version is correct.
                if (manifest.configVersion !== SUPPORTED_CONFIG_VERSION) {
                    yield this.deleteAllCaches();
                    yield this.scope.registration.unregister();
                    throw new Error(`Invalid config version: expected ${SUPPORTED_CONFIG_VERSION}, got ${manifest.configVersion}.`);
                }
                // Cause the new version to become fully initialized. If this fails, then the
                // version will not be available for use.
                yield newVersion.initializeFully(this);
                // Install this as an active version of the app.
                this.versions.set(hash, newVersion);
                // Future new clients will use this hash as the latest version.
                this.latestHash = hash;
                // If we are in `EXISTING_CLIENTS_ONLY` mode (meaning we didn&#39;t have a clean copy of the last
                // latest version), we can now recover to `NORMAL` mode and start accepting new clients.
                if (this.state === DriverReadyState.EXISTING_CLIENTS_ONLY) {
                    this.state = DriverReadyState.NORMAL;
                    this.stateMessage = &#39;(nominal)&#39;;
                }
                yield this.sync();
                yield this.notifyClientsAboutUpdate(newVersion);
            });
        }
        checkForUpdate() {
            return __awaiter(this, void 0, void 0, function* () {
                let hash = &#39;(unknown)&#39;;
                try {
                    const manifest = yield this.fetchLatestManifest(true);
                    if (manifest === null) {
                        // Client or server offline. Unable to check for updates at this time.
                        // Continue to service clients (existing and new).
                        this.debugger.log(&#39;Check for update aborted. (Client or server offline.)&#39;);
                        return false;
                    }
                    hash = hashManifest(manifest);
                    // Check whether this is really an update.
                    if (this.versions.has(hash)) {
                        return false;
                    }
                    yield this.setupUpdate(manifest, hash);
                    return true;
                }
                catch (err) {
                    this.debugger.log(err, `Error occurred while updating to manifest ${hash}`);
                    this.state = DriverReadyState.EXISTING_CLIENTS_ONLY;
                    this.stateMessage = `Degraded due to failed initialization: ${errorToString(err)}`;
                    return false;
                }
            });
        }
        /**
         * Synchronize the existing state to the underlying database.
         */
        sync() {
            return __awaiter(this, void 0, void 0, function* () {
                const table = yield this.controlTable;
                // Construct a serializable map of hashes to manifests.
                const manifests = {};
                this.versions.forEach((version, hash) =&gt; {
                    manifests[hash] = version.manifest;
                });
                // Construct a serializable map of client ids to version hashes.
                const assignments = {};
                this.clientVersionMap.forEach((hash, clientId) =&gt; {
                    assignments[clientId] = hash;
                });
                // Record the latest entry. Since this is a sync which is necessarily happening after
                // initialization, latestHash should always be valid.
                const latest = {
                    latest: this.latestHash,
                };
                // Synchronize all of these.
                yield Promise.all([
                    table.write(&#39;manifests&#39;, manifests),
                    table.write(&#39;assignments&#39;, assignments),
                    table.write(&#39;latest&#39;, latest),
                ]);
            });
        }
        cleanupCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    // Query for all currently active clients, and list the client IDs. This may skip some clients
                    // in the browser back-forward cache, but not much can be done about that.
                    const activeClients = new Set((yield this.scope.clients.matchAll()).map(client =&gt; client.id));
                    // A simple list of client IDs that the SW has kept track of. Subtracting `activeClients` from
                    // this list will result in the set of client IDs which are being tracked but are no longer
                    // used in the browser, and thus can be cleaned up.
                    const knownClients = Array.from(this.clientVersionMap.keys());
                    // Remove clients in the `clientVersionMap` that are no longer active.
                    const obsoleteClients = knownClients.filter(id =&gt; !activeClients.has(id));
                    obsoleteClients.forEach(id =&gt; this.clientVersionMap.delete(id));
                    // Next, determine the set of versions which are still used. All others can be removed.
                    const usedVersions = new Set(this.clientVersionMap.values());
                    // Collect all obsolete versions by filtering out used versions from the set of all versions.
                    const obsoleteVersions = Array.from(this.versions.keys())
                        .filter(version =&gt; !usedVersions.has(version) &amp;&amp; version !== this.latestHash);
                    // Remove all the versions which are no longer used.
                    obsoleteVersions.forEach(version =&gt; this.versions.delete(version));
                    // Commit all the changes to the saved state.
                    yield this.sync();
                    // Delete all caches that are no longer needed.
                    const allCaches = yield this.adapter.caches.keys();
                    const usedCaches = new Set(yield this.getCacheNames());
                    const cachesToDelete = allCaches.filter(name =&gt; !usedCaches.has(name));
                    yield Promise.all(cachesToDelete.map(name =&gt; this.adapter.caches.delete(name)));
                }
                catch (err) {
                    // Oh well? Not much that can be done here. These caches will be removed on the next attempt
                    // or when the SW revs its format version, which happens from time to time.
                    this.debugger.log(err, &#39;cleanupCaches&#39;);
                }
            });
        }
        /**
         * Delete caches that were used by older versions of `@angular/service-worker` to avoid running
         * into storage quota limitations imposed by browsers.
         * (Since at this point the SW has claimed all clients, it is safe to remove those caches.)
         */
        cleanupOldSwCaches() {
            return __awaiter(this, void 0, void 0, function* () {
                // This is an exceptional case, where we need to interact with caches that would not be
                // generated by this ServiceWorker (but by old versions of it). Use the native `CacheStorage`
                // directly.
                const caches = this.adapter.caches.original;
                const cacheNames = yield caches.keys();
                const oldSwCacheNames = cacheNames.filter(name =&gt; /^ngsw:(?!\/)/.test(name));
                yield Promise.all(oldSwCacheNames.map(name =&gt; caches.delete(name)));
            });
        }
        /**
         * Determine if a specific version of the given resource is cached anywhere within the SW,
         * and fetch it if so.
         */
        lookupResourceWithHash(url, hash) {
            return Array
                // Scan through the set of all cached versions, valid or otherwise. It&#39;s safe to do such
                // lookups even for invalid versions as the cached version of a resource will have the
                // same hash regardless.
                .from(this.versions.values())
                // Reduce the set of versions to a single potential result. At any point along the
                // reduction, if a response has already been identified, then pass it through, as no
                // future operation could change the response. If no response has been found yet, keep
                // checking versions until one is or until all versions have been exhausted.
                .reduce((prev, version) =&gt; __awaiter(this, void 0, void 0, function* () {
                // First, check the previous result. If a non-null result has been found already, just
                // return it.
                if ((yield prev) !== null) {
                    return prev;
                }
                // No result has been found yet. Try the next `AppVersion`.
                return version.lookupResourceWithHash(url, hash);
            }), Promise.resolve(null));
        }
        lookupResourceWithoutHash(url) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.lookupResourceWithoutHash(url) : null;
            });
        }
        previouslyCachedResources() {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const version = this.versions.get(this.latestHash);
                return version ? version.previouslyCachedResources() : [];
            });
        }
        recentCacheStatus(url) {
            return __awaiter(this, void 0, void 0, function* () {
                const version = this.versions.get(this.latestHash);
                return version ? version.recentCacheStatus(url) : UpdateCacheStatus.NOT_CACHED;
            });
        }
        mergeHashWithAppData(manifest, hash) {
            return {
                hash,
                appData: manifest.appData,
            };
        }
        notifyClientsAboutUnrecoverableState(appVersion, reason) {
            return __awaiter(this, void 0, void 0, function* () {
                const broken = Array.from(this.versions.entries()).find(([hash, version]) =&gt; version === appVersion);
                if (broken === undefined) {
                    // This version is no longer in use anyway, so nobody cares.
                    return;
                }
                const brokenHash = broken[0];
                const affectedClients = Array.from(this.clientVersionMap.entries())
                    .filter(([clientId, hash]) =&gt; hash === brokenHash)
                    .map(([clientId]) =&gt; clientId);
                yield Promise.all(affectedClients.map((clientId) =&gt; __awaiter(this, void 0, void 0, function* () {
                    const client = yield this.scope.clients.get(clientId);
                    if (client) {
                        client.postMessage({ type: &#39;UNRECOVERABLE_STATE&#39;, reason });
                    }
                })));
            });
        }
        notifyClientsAboutUpdate(next) {
            return __awaiter(this, void 0, void 0, function* () {
                yield this.initialized;
                const clients = yield this.scope.clients.matchAll();
                yield Promise.all(clients.map((client) =&gt; __awaiter(this, void 0, void 0, function* () {
                    // Firstly, determine which version this client is on.
                    const version = this.clientVersionMap.get(client.id);
                    if (version === undefined) {
                        // Unmapped client - assume it&#39;s the latest.
                        return;
                    }
                    if (version === this.latestHash) {
                        // Client is already on the latest version, no need for a notification.
                        return;
                    }
                    const current = this.versions.get(version);
                    // Send a notice.
                    const notice = {
                        type: &#39;UPDATE_AVAILABLE&#39;,
                        current: this.mergeHashWithAppData(current.manifest, version),
                        available: this.mergeHashWithAppData(next.manifest, this.latestHash),
                    };
                    client.postMessage(notice);
                })));
            });
        }
        broadcast(msg) {
            return __awaiter(this, void 0, void 0, function* () {
                const clients = yield this.scope.clients.matchAll();
                clients.forEach(client =&gt; {
                    client.postMessage(msg);
                });
            });
        }
        debugState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    state: DriverReadyState[this.state],
                    why: this.stateMessage,
                    latestHash: this.latestHash,
                    lastUpdateCheck: this.lastUpdateCheck,
                };
            });
        }
        debugVersions() {
            return __awaiter(this, void 0, void 0, function* () {
                // Build list of versions.
                return Array.from(this.versions.keys()).map(hash =&gt; {
                    const version = this.versions.get(hash);
                    const clients = Array.from(this.clientVersionMap.entries())
                        .filter(([clientId, version]) =&gt; version === hash)
                        .map(([clientId, version]) =&gt; clientId);
                    return {
                        hash,
                        manifest: version.manifest,
                        clients,
                        status: &#39;&#39;,
                    };
                });
            });
        }
        debugIdleState() {
            return __awaiter(this, void 0, void 0, function* () {
                return {
                    queue: this.idle.taskDescriptions,
                    lastTrigger: this.idle.lastTrigger,
                    lastRun: this.idle.lastRun,
                };
            });
        }
        safeFetch(req) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    return yield this.scope.fetch(req);
                }
                catch (err) {
                    this.debugger.log(err, `Driver.fetch(${req.url})`);
                    return this.adapter.newResponse(null, {
                        status: 504,
                        statusText: &#39;Gateway Timeout&#39;,
                    });
                }
            });
        }
        getCacheNames() {
            return __awaiter(this, void 0, void 0, function* () {
                const controlTable = yield this.controlTable;
                const appVersions = Array.from(this.versions.values());
                const appVersionCacheNames = yield Promise.all(appVersions.map(version =&gt; version.getCacheNames()));
                return [controlTable.cacheName].concat(...appVersionCacheNames);
            });
        }
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const scope = self;
    const adapter = new Adapter(scope.registration.scope, self.caches);
    new Driver(scope, adapter, new CacheDatabase(adapter));

}());
</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>where</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
										<li><details>
												<summary>
													<span class="request-method-n-url">GET http://localhost:3000/polyfills.45aa6b15effea4b4c287.js</span>
												</summary>
												
<table class="alerts-table">
	<tr>
		<th scope="row">Alert tags</th>
		<td>
			<ul class="alert-tags-list">
				<li>
					<span><a href="https://owasp.org/Top10/A01_2021-Broken_Access_Control/">OWASP_2021_A01</a></span> 
				</li>
				<li>
					<span><a href="https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure.html">OWASP_2017_A03</a></span> 
				</li>
			</ul>
		</td>
	</tr>
	<tr>
		<th scope="row">Alert description</th>
		<td> 
<p>The response appears to contain suspicious comments which may help an attacker. Note: Matches made within script blocks or files are against the entire content not only comments.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Other info</th>
		<td> 
<p>The following pattern was used: \bSELECT\b and was detected in the element starting with: &quot;&quot;use strict&quot;;(self.webpackChunkgood_meets=self.webpackChunkgood_meets||[]).push([[429],{277:()=&gt;{!function(e){const n=e.performa&quot;, see evidence field for the suspicious comment/snippet.</p>
 </td>
	</tr>
	<tr>
		<th scope="row">Request</th>
		<td><details open="open">
				<summary>Request line and header section (377 bytes)</summary>
				
				<pre><code>GET http://localhost:3000/polyfills.45aa6b15effea4b4c287.js HTTP/1.1
Host: localhost:3000
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0
Accept: */*
Accept-Language: sl,en-GB;q=0.7,en;q=0.3
Connection: keep-alive
Referer: https://localhost:3000/
Sec-Fetch-Dest: script
Sec-Fetch-Mode: no-cors
Sec-Fetch-Site: same-origin

</code></pre>
				
				
			</details> <details class="request-body" open="open">
				<summary>Request body (0 bytes)</summary>
				
				<pre><code></code></pre>
				
				
			</details></td>
	</tr>
	<tr>
		<th scope="row">Response</th>
		<td><details open="open">
				<summary>Status line and header section (398 bytes)</summary>
				
				<pre><code>HTTP/1.1 200 OK
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Accept-Ranges: bytes
Cache-Control: public, max-age=0
Last-Modified: Sat, 08 Jan 2022 17:37:48 GMT
ETag: W/&quot;90cc-17e3ac49546&quot;
Content-Type: application/javascript; charset=UTF-8
Content-Length: 37068
Date: Sat, 08 Jan 2022 23:37:51 GMT
Connection: keep-alive
Keep-Alive: timeout=5

</code></pre>
				
				
			</details> <details class="response-body">
				<summary>Response body (37068 bytes)</summary>
				
				<pre><code>&quot;use strict&quot;;(self.webpackChunkgood_meets=self.webpackChunkgood_meets||[]).push([[429],{277:()=&gt;{!function(e){const n=e.performance;function i(I){n&amp;&amp;n.mark&amp;&amp;n.mark(I)}function r(I,p){n&amp;&amp;n.measure&amp;&amp;n.measure(I,p)}i(&quot;Zone&quot;);const c=e.__Zone_symbol_prefix||&quot;__zone_symbol__&quot;;function u(I){return c+I}const f=!0===e[u(&quot;forceDuplicateZoneCheck&quot;)];if(e.Zone){if(f||&quot;function&quot;!=typeof e.Zone.__symbol__)throw new Error(&quot;Zone already loaded.&quot;);return e.Zone}let _=(()=&gt;{class I{constructor(t,o){this._parent=t,this._name=o?o.name||&quot;unnamed&quot;:&quot;&lt;root&gt;&quot;,this._properties=o&amp;&amp;o.properties||{},this._zoneDelegate=new T(this,this._parent&amp;&amp;this._parent._zoneDelegate,o)}static assertZonePatched(){if(e.Promise!==J.ZoneAwarePromise)throw new Error(&quot;Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)&quot;)}static get root(){let t=I.current;for(;t.parent;)t=t.parent;return t}static get current(){return G.zone}static get currentTask(){return te}static __load_patch(t,o,g=!1){if(J.hasOwnProperty(t)){if(!g&amp;&amp;f)throw Error(&quot;Already loaded patch: &quot;+t)}else if(!e[&quot;__Zone_disable_&quot;+t]){const P=&quot;Zone:&quot;+t;i(P),J[t]=o(e,I,le),r(P,P)}}get parent(){return this._parent}get name(){return this._name}get(t){const o=this.getZoneWith(t);if(o)return o._properties[t]}getZoneWith(t){let o=this;for(;o;){if(o._properties.hasOwnProperty(t))return o;o=o._parent}return null}fork(t){if(!t)throw new Error(&quot;ZoneSpec required!&quot;);return this._zoneDelegate.fork(this,t)}wrap(t,o){if(&quot;function&quot;!=typeof t)throw new Error(&quot;Expecting function got: &quot;+t);const g=this._zoneDelegate.intercept(this,t,o),P=this;return function(){return P.runGuarded(g,this,arguments,o)}}run(t,o,g,P){G={parent:G,zone:this};try{return this._zoneDelegate.invoke(this,t,o,g,P)}finally{G=G.parent}}runGuarded(t,o=null,g,P){G={parent:G,zone:this};try{try{return this._zoneDelegate.invoke(this,t,o,g,P)}catch(K){if(this._zoneDelegate.handleError(this,K))throw K}}finally{G=G.parent}}runTask(t,o,g){if(t.zone!=this)throw new Error(&quot;A task can only be run in the zone of creation! (Creation: &quot;+(t.zone||z).name+&quot;; Execution: &quot;+this.name+&quot;)&quot;);if(t.state===j&amp;&amp;(t.type===R||t.type===M))return;const P=t.state!=X;P&amp;&amp;t._transitionTo(X,O),t.runCount++;const K=te;te=t,G={parent:G,zone:this};try{t.type==M&amp;&amp;t.data&amp;&amp;!t.data.isPeriodic&amp;&amp;(t.cancelFn=void 0);try{return this._zoneDelegate.invokeTask(this,t,o,g)}catch(l){if(this._zoneDelegate.handleError(this,l))throw l}}finally{t.state!==j&amp;&amp;t.state!==Y&amp;&amp;(t.type==R||t.data&amp;&amp;t.data.isPeriodic?P&amp;&amp;t._transitionTo(O,X):(t.runCount=0,this._updateTaskCount(t,-1),P&amp;&amp;t._transitionTo(j,X,j))),G=G.parent,te=K}}scheduleTask(t){if(t.zone&amp;&amp;t.zone!==this){let g=this;for(;g;){if(g===t.zone)throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${t.zone.name}`);g=g.parent}}t._transitionTo(q,j);const o=[];t._zoneDelegates=o,t._zone=this;try{t=this._zoneDelegate.scheduleTask(this,t)}catch(g){throw t._transitionTo(Y,q,j),this._zoneDelegate.handleError(this,g),g}return t._zoneDelegates===o&amp;&amp;this._updateTaskCount(t,1),t.state==q&amp;&amp;t._transitionTo(O,q),t}scheduleMicroTask(t,o,g,P){return this.scheduleTask(new m(v,t,o,g,P,void 0))}scheduleMacroTask(t,o,g,P,K){return this.scheduleTask(new m(M,t,o,g,P,K))}scheduleEventTask(t,o,g,P,K){return this.scheduleTask(new m(R,t,o,g,P,K))}cancelTask(t){if(t.zone!=this)throw new Error(&quot;A task can only be cancelled in the zone of creation! (Creation: &quot;+(t.zone||z).name+&quot;; Execution: &quot;+this.name+&quot;)&quot;);t._transitionTo(A,O,X);try{this._zoneDelegate.cancelTask(this,t)}catch(o){throw t._transitionTo(Y,A),this._zoneDelegate.handleError(this,o),o}return this._updateTaskCount(t,-1),t._transitionTo(j,A),t.runCount=0,t}_updateTaskCount(t,o){const g=t._zoneDelegates;-1==o&amp;&amp;(t._zoneDelegates=null);for(let P=0;P&lt;g.length;P++)g[P]._updateTaskCount(t.type,o)}}return I.__symbol__=u,I})();const y={name:&quot;&quot;,onHasTask:(I,p,t,o)=&gt;I.hasTask(t,o),onScheduleTask:(I,p,t,o)=&gt;I.scheduleTask(t,o),onInvokeTask:(I,p,t,o,g,P)=&gt;I.invokeTask(t,o,g,P),onCancelTask:(I,p,t,o)=&gt;I.cancelTask(t,o)};class T{constructor(p,t,o){this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=p,this._parentDelegate=t,this._forkZS=o&amp;&amp;(o&amp;&amp;o.onFork?o:t._forkZS),this._forkDlgt=o&amp;&amp;(o.onFork?t:t._forkDlgt),this._forkCurrZone=o&amp;&amp;(o.onFork?this.zone:t._forkCurrZone),this._interceptZS=o&amp;&amp;(o.onIntercept?o:t._interceptZS),this._interceptDlgt=o&amp;&amp;(o.onIntercept?t:t._interceptDlgt),this._interceptCurrZone=o&amp;&amp;(o.onIntercept?this.zone:t._interceptCurrZone),this._invokeZS=o&amp;&amp;(o.onInvoke?o:t._invokeZS),this._invokeDlgt=o&amp;&amp;(o.onInvoke?t:t._invokeDlgt),this._invokeCurrZone=o&amp;&amp;(o.onInvoke?this.zone:t._invokeCurrZone),this._handleErrorZS=o&amp;&amp;(o.onHandleError?o:t._handleErrorZS),this._handleErrorDlgt=o&amp;&amp;(o.onHandleError?t:t._handleErrorDlgt),this._handleErrorCurrZone=o&amp;&amp;(o.onHandleError?this.zone:t._handleErrorCurrZone),this._scheduleTaskZS=o&amp;&amp;(o.onScheduleTask?o:t._scheduleTaskZS),this._scheduleTaskDlgt=o&amp;&amp;(o.onScheduleTask?t:t._scheduleTaskDlgt),this._scheduleTaskCurrZone=o&amp;&amp;(o.onScheduleTask?this.zone:t._scheduleTaskCurrZone),this._invokeTaskZS=o&amp;&amp;(o.onInvokeTask?o:t._invokeTaskZS),this._invokeTaskDlgt=o&amp;&amp;(o.onInvokeTask?t:t._invokeTaskDlgt),this._invokeTaskCurrZone=o&amp;&amp;(o.onInvokeTask?this.zone:t._invokeTaskCurrZone),this._cancelTaskZS=o&amp;&amp;(o.onCancelTask?o:t._cancelTaskZS),this._cancelTaskDlgt=o&amp;&amp;(o.onCancelTask?t:t._cancelTaskDlgt),this._cancelTaskCurrZone=o&amp;&amp;(o.onCancelTask?this.zone:t._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;const g=o&amp;&amp;o.onHasTask;(g||t&amp;&amp;t._hasTaskZS)&amp;&amp;(this._hasTaskZS=g?o:y,this._hasTaskDlgt=t,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=p,o.onScheduleTask||(this._scheduleTaskZS=y,this._scheduleTaskDlgt=t,this._scheduleTaskCurrZone=this.zone),o.onInvokeTask||(this._invokeTaskZS=y,this._invokeTaskDlgt=t,this._invokeTaskCurrZone=this.zone),o.onCancelTask||(this._cancelTaskZS=y,this._cancelTaskDlgt=t,this._cancelTaskCurrZone=this.zone))}fork(p,t){return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,p,t):new _(p,t)}intercept(p,t,o){return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,p,t,o):t}invoke(p,t,o,g,P){return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,p,t,o,g,P):t.apply(o,g)}handleError(p,t){return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,p,t)}scheduleTask(p,t){let o=t;if(this._scheduleTaskZS)this._hasTaskZS&amp;&amp;o._zoneDelegates.push(this._hasTaskDlgtOwner),o=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,p,t),o||(o=t);else if(t.scheduleFn)t.scheduleFn(t);else{if(t.type!=v)throw new Error(&quot;Task is missing scheduleFn.&quot;);d(t)}return o}invokeTask(p,t,o,g){return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,p,t,o,g):t.callback.apply(o,g)}cancelTask(p,t){let o;if(this._cancelTaskZS)o=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,p,t);else{if(!t.cancelFn)throw Error(&quot;Task is not cancelable&quot;);o=t.cancelFn(t)}return o}hasTask(p,t){try{this._hasTaskZS&amp;&amp;this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,p,t)}catch(o){this.handleError(p,o)}}_updateTaskCount(p,t){const o=this._taskCounts,g=o[p],P=o[p]=g+t;if(P&lt;0)throw new Error(&quot;More tasks executed then were scheduled.&quot;);0!=g&amp;&amp;0!=P||this.hasTask(this.zone,{microTask:o.microTask&gt;0,macroTask:o.macroTask&gt;0,eventTask:o.eventTask&gt;0,change:p})}}class m{constructor(p,t,o,g,P,K){if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state=&quot;notScheduled&quot;,this.type=p,this.source=t,this.data=g,this.scheduleFn=P,this.cancelFn=K,!o)throw new Error(&quot;callback is not defined&quot;);this.callback=o;const l=this;this.invoke=p===R&amp;&amp;g&amp;&amp;g.useG?m.invokeTask:function(){return m.invokeTask.call(e,l,this,arguments)}}static invokeTask(p,t,o){p||(p=this),re++;try{return p.runCount++,p.zone.runTask(p,t,o)}finally{1==re&amp;&amp;L(),re--}}get zone(){return this._zone}get state(){return this._state}cancelScheduleRequest(){this._transitionTo(j,q)}_transitionTo(p,t,o){if(this._state!==t&amp;&amp;this._state!==o)throw new Error(`${this.type} &#39;${this.source}&#39;: can not transition to &#39;${p}&#39;, expecting state &#39;${t}&#39;${o?&quot; or &#39;&quot;+o+&quot;&#39;&quot;:&quot;&quot;}, was &#39;${this._state}&#39;.`);this._state=p,p==j&amp;&amp;(this._zoneDelegates=null)}toString(){return this.data&amp;&amp;void 0!==this.data.handleId?this.data.handleId.toString():Object.prototype.toString.call(this)}toJSON(){return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}}const S=u(&quot;setTimeout&quot;),D=u(&quot;Promise&quot;),Z=u(&quot;then&quot;);let E,B=[],V=!1;function d(I){if(0===re&amp;&amp;0===B.length)if(E||e[D]&amp;&amp;(E=e[D].resolve(0)),E){let p=E[Z];p||(p=E.then),p.call(E,L)}else e[S](L,0);I&amp;&amp;B.push(I)}function L(){if(!V){for(V=!0;B.length;){const I=B;B=[];for(let p=0;p&lt;I.length;p++){const t=I[p];try{t.zone.runTask(t,null,null)}catch(o){le.onUnhandledError(o)}}}le.microtaskDrainDone(),V=!1}}const z={name:&quot;NO ZONE&quot;},j=&quot;notScheduled&quot;,q=&quot;scheduling&quot;,O=&quot;scheduled&quot;,X=&quot;running&quot;,A=&quot;canceling&quot;,Y=&quot;unknown&quot;,v=&quot;microTask&quot;,M=&quot;macroTask&quot;,R=&quot;eventTask&quot;,J={},le={symbol:u,currentZoneFrame:()=&gt;G,onUnhandledError:F,microtaskDrainDone:F,scheduleMicroTask:d,showUncaughtError:()=&gt;!_[u(&quot;ignoreConsoleErrorUncaughtError&quot;)],patchEventTarget:()=&gt;[],patchOnProperties:F,patchMethod:()=&gt;F,bindArguments:()=&gt;[],patchThen:()=&gt;F,patchMacroTask:()=&gt;F,patchEventPrototype:()=&gt;F,isIEOrEdge:()=&gt;!1,getGlobalObjects:()=&gt;{},ObjectDefineProperty:()=&gt;F,ObjectGetOwnPropertyDescriptor:()=&gt;{},ObjectCreate:()=&gt;{},ArraySlice:()=&gt;[],patchClass:()=&gt;F,wrapWithCurrentZone:()=&gt;F,filterProperties:()=&gt;[],attachOriginToPatched:()=&gt;F,_redefineProperty:()=&gt;F,patchCallbacks:()=&gt;F};let G={parent:null,zone:new _(null,null)},te=null,re=0;function F(){}r(&quot;Zone&quot;,&quot;Zone&quot;),e.Zone=_}(&quot;undefined&quot;!=typeof window&amp;&amp;window||&quot;undefined&quot;!=typeof self&amp;&amp;self||global);const ue=Object.getOwnPropertyDescriptor,he=Object.defineProperty,de=Object.getPrototypeOf,Be=Object.create,ut=Array.prototype.slice,Se=&quot;addEventListener&quot;,Oe=&quot;removeEventListener&quot;,Ze=Zone.__symbol__(Se),Ie=Zone.__symbol__(Oe),se=&quot;true&quot;,ie=&quot;false&quot;,ke=Zone.__symbol__(&quot;&quot;);function Le(e,n){return Zone.current.wrap(e,n)}function Me(e,n,i,r,c){return Zone.current.scheduleMacroTask(e,n,i,r,c)}const x=Zone.__symbol__,Pe=&quot;undefined&quot;!=typeof window,pe=Pe?window:void 0,$=Pe&amp;&amp;pe||&quot;object&quot;==typeof self&amp;&amp;self||global,ht=[null];function Ae(e,n){for(let i=e.length-1;i&gt;=0;i--)&quot;function&quot;==typeof e[i]&amp;&amp;(e[i]=Le(e[i],n+&quot;_&quot;+i));return e}function Fe(e){return!e||!1!==e.writable&amp;&amp;!(&quot;function&quot;==typeof e.get&amp;&amp;void 0===e.set)}const Ue=&quot;undefined&quot;!=typeof WorkerGlobalScope&amp;&amp;self instanceof WorkerGlobalScope,Re=!(&quot;nw&quot;in $)&amp;&amp;void 0!==$.process&amp;&amp;&quot;[object process]&quot;==={}.toString.call($.process),je=!Re&amp;&amp;!Ue&amp;&amp;!(!Pe||!pe.HTMLElement),We=void 0!==$.process&amp;&amp;&quot;[object process]&quot;==={}.toString.call($.process)&amp;&amp;!Ue&amp;&amp;!(!Pe||!pe.HTMLElement),Ce={},qe=function(e){if(!(e=e||$.event))return;let n=Ce[e.type];n||(n=Ce[e.type]=x(&quot;ON_PROPERTY&quot;+e.type));const i=this||e.target||$,r=i[n];let c;if(je&amp;&amp;i===pe&amp;&amp;&quot;error&quot;===e.type){const u=e;c=r&amp;&amp;r.call(this,u.message,u.filename,u.lineno,u.colno,u.error),!0===c&amp;&amp;e.preventDefault()}else c=r&amp;&amp;r.apply(this,arguments),null!=c&amp;&amp;!c&amp;&amp;e.preventDefault();return c};function Xe(e,n,i){let r=ue(e,n);if(!r&amp;&amp;i&amp;&amp;ue(i,n)&amp;&amp;(r={enumerable:!0,configurable:!0}),!r||!r.configurable)return;const c=x(&quot;on&quot;+n+&quot;patched&quot;);if(e.hasOwnProperty(c)&amp;&amp;e[c])return;delete r.writable,delete r.value;const u=r.get,f=r.set,_=n.substr(2);let y=Ce[_];y||(y=Ce[_]=x(&quot;ON_PROPERTY&quot;+_)),r.set=function(T){let m=this;!m&amp;&amp;e===$&amp;&amp;(m=$),m&amp;&amp;(m[y]&amp;&amp;m.removeEventListener(_,qe),f&amp;&amp;f.apply(m,ht),&quot;function&quot;==typeof T?(m[y]=T,m.addEventListener(_,qe,!1)):m[y]=null)},r.get=function(){let T=this;if(!T&amp;&amp;e===$&amp;&amp;(T=$),!T)return null;const m=T[y];if(m)return m;if(u){let S=u&amp;&amp;u.call(this);if(S)return r.set.call(this,S),&quot;function&quot;==typeof T.removeAttribute&amp;&amp;T.removeAttribute(n),S}return null},he(e,n,r),e[c]=!0}function Ye(e,n,i){if(n)for(let r=0;r&lt;n.length;r++)Xe(e,&quot;on&quot;+n[r],i);else{const r=[];for(const c in e)&quot;on&quot;==c.substr(0,2)&amp;&amp;r.push(c);for(let c=0;c&lt;r.length;c++)Xe(e,r[c],i)}}const ne=x(&quot;originalInstance&quot;);function ve(e){const n=$[e];if(!n)return;$[x(e)]=n,$[e]=function(){const c=Ae(arguments,e);switch(c.length){case 0:this[ne]=new n;break;case 1:this[ne]=new n(c[0]);break;case 2:this[ne]=new n(c[0],c[1]);break;case 3:this[ne]=new n(c[0],c[1],c[2]);break;case 4:this[ne]=new n(c[0],c[1],c[2],c[3]);break;default:throw new Error(&quot;Arg list too long.&quot;)}},ae($[e],n);const i=new n(function(){});let r;for(r in i)&quot;XMLHttpRequest&quot;===e&amp;&amp;&quot;responseBlob&quot;===r||function(c){&quot;function&quot;==typeof i[c]?$[e].prototype[c]=function(){return this[ne][c].apply(this[ne],arguments)}:he($[e].prototype,c,{set:function(u){&quot;function&quot;==typeof u?(this[ne][c]=Le(u,e+&quot;.&quot;+c),ae(this[ne][c],u)):this[ne][c]=u},get:function(){return this[ne][c]}})}(r);for(r in n)&quot;prototype&quot;!==r&amp;&amp;n.hasOwnProperty(r)&amp;&amp;($[e][r]=n[r])}function ce(e,n,i){let r=e;for(;r&amp;&amp;!r.hasOwnProperty(n);)r=de(r);!r&amp;&amp;e[n]&amp;&amp;(r=e);const c=x(n);let u=null;if(r&amp;&amp;(!(u=r[c])||!r.hasOwnProperty(c))&amp;&amp;(u=r[c]=r[n],Fe(r&amp;&amp;ue(r,n)))){const _=i(u,c,n);r[n]=function(){return _(this,arguments)},ae(r[n],u)}return u}function _t(e,n,i){let r=null;function c(u){const f=u.data;return f.args[f.cbIdx]=function(){u.invoke.apply(this,arguments)},r.apply(f.target,f.args),u}r=ce(e,n,u=&gt;function(f,_){const y=i(f,_);return y.cbIdx&gt;=0&amp;&amp;&quot;function&quot;==typeof _[y.cbIdx]?Me(y.name,_[y.cbIdx],y,c):u.apply(f,_)})}function ae(e,n){e[x(&quot;OriginalDelegate&quot;)]=n}let $e=!1,He=!1;function mt(){if($e)return He;$e=!0;try{const e=pe.navigator.userAgent;(-1!==e.indexOf(&quot;MSIE &quot;)||-1!==e.indexOf(&quot;Trident/&quot;)||-1!==e.indexOf(&quot;Edge/&quot;))&amp;&amp;(He=!0)}catch(e){}return He}Zone.__load_patch(&quot;ZoneAwarePromise&quot;,(e,n,i)=&gt;{const r=Object.getOwnPropertyDescriptor,c=Object.defineProperty,f=i.symbol,_=[],y=!0===e[f(&quot;DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION&quot;)],T=f(&quot;Promise&quot;),m=f(&quot;then&quot;);i.onUnhandledError=l=&gt;{if(i.showUncaughtError()){const s=l&amp;&amp;l.rejection;s?console.error(&quot;Unhandled Promise rejection:&quot;,s instanceof Error?s.message:s,&quot;; Zone:&quot;,l.zone.name,&quot;; Task:&quot;,l.task&amp;&amp;l.task.source,&quot;; Value:&quot;,s,s instanceof Error?s.stack:void 0):console.error(l)}},i.microtaskDrainDone=()=&gt;{for(;_.length;){const l=_.shift();try{l.zone.runGuarded(()=&gt;{throw l.throwOriginal?l.rejection:l})}catch(s){Z(s)}}};const D=f(&quot;unhandledPromiseRejectionHandler&quot;);function Z(l){i.onUnhandledError(l);try{const s=n[D];&quot;function&quot;==typeof s&amp;&amp;s.call(this,l)}catch(s){}}function B(l){return l&amp;&amp;l.then}function V(l){return l}function E(l){return t.reject(l)}const d=f(&quot;state&quot;),L=f(&quot;value&quot;),z=f(&quot;finally&quot;),j=f(&quot;parentPromiseValue&quot;),q=f(&quot;parentPromiseState&quot;),X=null,A=!0,Y=!1;function M(l,s){return a=&gt;{try{G(l,s,a)}catch(h){G(l,!1,h)}}}const le=f(&quot;currentTaskTrace&quot;);function G(l,s,a){const h=function(){let l=!1;return function(a){return function(){l||(l=!0,a.apply(null,arguments))}}}();if(l===a)throw new TypeError(&quot;Promise resolved with itself&quot;);if(l[d]===X){let w=null;try{(&quot;object&quot;==typeof a||&quot;function&quot;==typeof a)&amp;&amp;(w=a&amp;&amp;a.then)}catch(C){return h(()=&gt;{G(l,!1,C)})(),l}if(s!==Y&amp;&amp;a instanceof t&amp;&amp;a.hasOwnProperty(d)&amp;&amp;a.hasOwnProperty(L)&amp;&amp;a[d]!==X)re(a),G(l,a[d],a[L]);else if(s!==Y&amp;&amp;&quot;function&quot;==typeof w)try{w.call(a,h(M(l,s)),h(M(l,!1)))}catch(C){h(()=&gt;{G(l,!1,C)})()}else{l[d]=s;const C=l[L];if(l[L]=a,l[z]===z&amp;&amp;s===A&amp;&amp;(l[d]=l[q],l[L]=l[j]),s===Y&amp;&amp;a instanceof Error){const k=n.currentTask&amp;&amp;n.currentTask.data&amp;&amp;n.currentTask.data.__creationTrace__;k&amp;&amp;c(a,le,{configurable:!0,enumerable:!1,writable:!0,value:k})}for(let k=0;k&lt;C.length;)F(l,C[k++],C[k++],C[k++],C[k++]);if(0==C.length&amp;&amp;s==Y){l[d]=0;let k=a;try{throw new Error(&quot;Uncaught (in promise): &quot;+function(l){return l&amp;&amp;l.toString===Object.prototype.toString?(l.constructor&amp;&amp;l.constructor.name||&quot;&quot;)+&quot;: &quot;+JSON.stringify(l):l?l.toString():Object.prototype.toString.call(l)}(a)+(a&amp;&amp;a.stack?&quot;\n&quot;+a.stack:&quot;&quot;))}catch(b){k=b}y&amp;&amp;(k.throwOriginal=!0),k.rejection=a,k.promise=l,k.zone=n.current,k.task=n.currentTask,_.push(k),i.scheduleMicroTask()}}}return l}const te=f(&quot;rejectionHandledHandler&quot;);function re(l){if(0===l[d]){try{const s=n[te];s&amp;&amp;&quot;function&quot;==typeof s&amp;&amp;s.call(this,{rejection:l[L],promise:l})}catch(s){}l[d]=Y;for(let s=0;s&lt;_.length;s++)l===_[s].promise&amp;&amp;_.splice(s,1)}}function F(l,s,a,h,w){re(l);const C=l[d],k=C?&quot;function&quot;==typeof h?h:V:&quot;function&quot;==typeof w?w:E;s.scheduleMicroTask(&quot;Promise.then&quot;,()=&gt;{try{const b=l[L],N=!!a&amp;&amp;z===a[z];N&amp;&amp;(a[j]=b,a[q]=C);const H=s.run(k,void 0,N&amp;&amp;k!==E&amp;&amp;k!==V?[]:[b]);G(a,!0,H)}catch(b){G(a,!1,b)}},a)}const p=function(){};class t{static toString(){return&quot;function ZoneAwarePromise() { [native code] }&quot;}static resolve(s){return G(new this(null),A,s)}static reject(s){return G(new this(null),Y,s)}static race(s){let a,h,w=new this((b,N)=&gt;{a=b,h=N});function C(b){a(b)}function k(b){h(b)}for(let b of s)B(b)||(b=this.resolve(b)),b.then(C,k);return w}static all(s){return t.allWithCallback(s)}static allSettled(s){return(this&amp;&amp;this.prototype instanceof t?this:t).allWithCallback(s,{thenCallback:h=&gt;({status:&quot;fulfilled&quot;,value:h}),errorCallback:h=&gt;({status:&quot;rejected&quot;,reason:h})})}static allWithCallback(s,a){let h,w,C=new this((H,U)=&gt;{h=H,w=U}),k=2,b=0;const N=[];for(let H of s){B(H)||(H=this.resolve(H));const U=b;try{H.then(Q=&gt;{N[U]=a?a.thenCallback(Q):Q,k--,0===k&amp;&amp;h(N)},Q=&gt;{a?(N[U]=a.errorCallback(Q),k--,0===k&amp;&amp;h(N)):w(Q)})}catch(Q){w(Q)}k++,b++}return k-=2,0===k&amp;&amp;h(N),C}constructor(s){const a=this;if(!(a instanceof t))throw new Error(&quot;Must be an instanceof Promise.&quot;);a[d]=X,a[L]=[];try{s&amp;&amp;s(M(a,A),M(a,Y))}catch(h){G(a,!1,h)}}get[Symbol.toStringTag](){return&quot;Promise&quot;}get[Symbol.species](){return t}then(s,a){let h=this.constructor[Symbol.species];(!h||&quot;function&quot;!=typeof h)&amp;&amp;(h=this.constructor||t);const w=new h(p),C=n.current;return this[d]==X?this[L].push(C,w,s,a):F(this,C,w,s,a),w}catch(s){return this.then(null,s)}finally(s){let a=this.constructor[Symbol.species];(!a||&quot;function&quot;!=typeof a)&amp;&amp;(a=t);const h=new a(p);h[z]=z;const w=n.current;return this[d]==X?this[L].push(w,h,s,s):F(this,w,h,s,s),h}}t.resolve=t.resolve,t.reject=t.reject,t.race=t.race,t.all=t.all;const o=e[T]=e.Promise;e.Promise=t;const g=f(&quot;thenPatched&quot;);function P(l){const s=l.prototype,a=r(s,&quot;then&quot;);if(a&amp;&amp;(!1===a.writable||!a.configurable))return;const h=s.then;s[m]=h,l.prototype.then=function(w,C){return new t((b,N)=&gt;{h.call(this,b,N)}).then(w,C)},l[g]=!0}return i.patchThen=P,o&amp;&amp;(P(o),ce(e,&quot;fetch&quot;,l=&gt;function(l){return function(s,a){let h=l.apply(s,a);if(h instanceof t)return h;let w=h.constructor;return w[g]||P(w),h}}(l))),Promise[n.__symbol__(&quot;uncaughtPromiseErrors&quot;)]=_,t}),Zone.__load_patch(&quot;toString&quot;,e=&gt;{const n=Function.prototype.toString,i=x(&quot;OriginalDelegate&quot;),r=x(&quot;Promise&quot;),c=x(&quot;Error&quot;),u=function(){if(&quot;function&quot;==typeof this){const T=this[i];if(T)return&quot;function&quot;==typeof T?n.call(T):Object.prototype.toString.call(T);if(this===Promise){const m=e[r];if(m)return n.call(m)}if(this===Error){const m=e[c];if(m)return n.call(m)}}return n.call(this)};u[i]=n,Function.prototype.toString=u;const f=Object.prototype.toString;Object.prototype.toString=function(){return&quot;function&quot;==typeof Promise&amp;&amp;this instanceof Promise?&quot;[object Promise]&quot;:f.call(this)}});let me=!1;if(&quot;undefined&quot;!=typeof window)try{const e=Object.defineProperty({},&quot;passive&quot;,{get:function(){me=!0}});window.addEventListener(&quot;test&quot;,e,e),window.removeEventListener(&quot;test&quot;,e,e)}catch(e){me=!1}const Et={useG:!0},ee={},Ke={},Je=new RegExp(&quot;^&quot;+ke+&quot;(\\w+)(true|false)$&quot;),xe=x(&quot;propagationStopped&quot;);function Qe(e,n){const i=(n?n(e):e)+ie,r=(n?n(e):e)+se,c=ke+i,u=ke+r;ee[e]={},ee[e][ie]=c,ee[e][se]=u}function Tt(e,n,i){const r=i&amp;&amp;i.add||Se,c=i&amp;&amp;i.rm||Oe,u=i&amp;&amp;i.listeners||&quot;eventListeners&quot;,f=i&amp;&amp;i.rmAll||&quot;removeAllListeners&quot;,_=x(r),y=&quot;.&quot;+r+&quot;:&quot;,S=function(E,d,L){if(E.isRemoved)return;const z=E.callback;&quot;object&quot;==typeof z&amp;&amp;z.handleEvent&amp;&amp;(E.callback=q=&gt;z.handleEvent(q),E.originalDelegate=z),E.invoke(E,d,[L]);const j=E.options;j&amp;&amp;&quot;object&quot;==typeof j&amp;&amp;j.once&amp;&amp;d[c].call(d,L.type,E.originalDelegate?E.originalDelegate:E.callback,j)},D=function(E){if(!(E=E||e.event))return;const d=this||E.target||e,L=d[ee[E.type][ie]];if(L)if(1===L.length)S(L[0],d,E);else{const z=L.slice();for(let j=0;j&lt;z.length&amp;&amp;(!E||!0!==E[xe]);j++)S(z[j],d,E)}},Z=function(E){if(!(E=E||e.event))return;const d=this||E.target||e,L=d[ee[E.type][se]];if(L)if(1===L.length)S(L[0],d,E);else{const z=L.slice();for(let j=0;j&lt;z.length&amp;&amp;(!E||!0!==E[xe]);j++)S(z[j],d,E)}};function B(E,d){if(!E)return!1;let L=!0;d&amp;&amp;void 0!==d.useG&amp;&amp;(L=d.useG);const z=d&amp;&amp;d.vh;let j=!0;d&amp;&amp;void 0!==d.chkDup&amp;&amp;(j=d.chkDup);let q=!1;d&amp;&amp;void 0!==d.rt&amp;&amp;(q=d.rt);let O=E;for(;O&amp;&amp;!O.hasOwnProperty(r);)O=de(O);if(!O&amp;&amp;E[r]&amp;&amp;(O=E),!O||O[_])return!1;const X=d&amp;&amp;d.eventNameToString,A={},Y=O[_]=O[r],v=O[x(c)]=O[c],M=O[x(u)]=O[u],R=O[x(f)]=O[f];let J;function le(s,a){return!me&amp;&amp;&quot;object&quot;==typeof s&amp;&amp;s?!!s.capture:me&amp;&amp;a?&quot;boolean&quot;==typeof s?{capture:s,passive:!0}:s?&quot;object&quot;==typeof s&amp;&amp;!1!==s.passive?Object.assign(Object.assign({},s),{passive:!0}):s:{passive:!0}:s}d&amp;&amp;d.prepend&amp;&amp;(J=O[x(d.prepend)]=O[d.prepend]);const p=L?function(s){if(!A.isExisting)return Y.call(A.target,A.eventName,A.capture?Z:D,A.options)}:function(s){return Y.call(A.target,A.eventName,s.invoke,A.options)},t=L?function(s){if(!s.isRemoved){const a=ee[s.eventName];let h;a&amp;&amp;(h=a[s.capture?se:ie]);const w=h&amp;&amp;s.target[h];if(w)for(let C=0;C&lt;w.length;C++)if(w[C]===s){w.splice(C,1),s.isRemoved=!0,0===w.length&amp;&amp;(s.allRemoved=!0,s.target[h]=null);break}}if(s.allRemoved)return v.call(s.target,s.eventName,s.capture?Z:D,s.options)}:function(s){return v.call(s.target,s.eventName,s.invoke,s.options)},g=d&amp;&amp;d.diff?d.diff:function(s,a){const h=typeof a;return&quot;function&quot;===h&amp;&amp;s.callback===a||&quot;object&quot;===h&amp;&amp;s.originalDelegate===a},P=Zone[x(&quot;UNPATCHED_EVENTS&quot;)],K=e[x(&quot;PASSIVE_EVENTS&quot;)],l=function(s,a,h,w,C=!1,k=!1){return function(){const b=this||e;let N=arguments[0];d&amp;&amp;d.transferEventName&amp;&amp;(N=d.transferEventName(N));let H=arguments[1];if(!H)return s.apply(this,arguments);if(Re&amp;&amp;&quot;uncaughtException&quot;===N)return s.apply(this,arguments);let U=!1;if(&quot;function&quot;!=typeof H){if(!H.handleEvent)return s.apply(this,arguments);U=!0}if(z&amp;&amp;!z(s,H,b,arguments))return;const Q=me&amp;&amp;!!K&amp;&amp;-1!==K.indexOf(N),oe=le(arguments[2],Q);if(P)for(let _e=0;_e&lt;P.length;_e++)if(N===P[_e])return Q?s.call(b,N,H,oe):s.apply(this,arguments);const Ge=!!oe&amp;&amp;(&quot;boolean&quot;==typeof oe||oe.capture),st=!(!oe||&quot;object&quot;!=typeof oe)&amp;&amp;oe.once,At=Zone.current;let ze=ee[N];ze||(Qe(N,X),ze=ee[N]);const it=ze[Ge?se:ie];let De,ye=b[it],ct=!1;if(ye){if(ct=!0,j)for(let _e=0;_e&lt;ye.length;_e++)if(g(ye[_e],H))return}else ye=b[it]=[];const at=b.constructor.name,lt=Ke[at];lt&amp;&amp;(De=lt[N]),De||(De=at+a+(X?X(N):N)),A.options=oe,st&amp;&amp;(A.options.once=!1),A.target=b,A.capture=Ge,A.eventName=N,A.isExisting=ct;const be=L?Et:void 0;be&amp;&amp;(be.taskData=A);const fe=At.scheduleEventTask(De,H,be,h,w);return A.target=null,be&amp;&amp;(be.taskData=null),st&amp;&amp;(oe.once=!0),!me&amp;&amp;&quot;boolean&quot;==typeof fe.options||(fe.options=oe),fe.target=b,fe.capture=Ge,fe.eventName=N,U&amp;&amp;(fe.originalDelegate=H),k?ye.unshift(fe):ye.push(fe),C?b:void 0}};return O[r]=l(Y,y,p,t,q),J&amp;&amp;(O.prependListener=l(J,&quot;.prependListener:&quot;,function(s){return J.call(A.target,A.eventName,s.invoke,A.options)},t,q,!0)),O[c]=function(){const s=this||e;let a=arguments[0];d&amp;&amp;d.transferEventName&amp;&amp;(a=d.transferEventName(a));const h=arguments[2],w=!!h&amp;&amp;(&quot;boolean&quot;==typeof h||h.capture),C=arguments[1];if(!C)return v.apply(this,arguments);if(z&amp;&amp;!z(v,C,s,arguments))return;const k=ee[a];let b;k&amp;&amp;(b=k[w?se:ie]);const N=b&amp;&amp;s[b];if(N)for(let H=0;H&lt;N.length;H++){const U=N[H];if(g(U,C))return N.splice(H,1),U.isRemoved=!0,0===N.length&amp;&amp;(U.allRemoved=!0,s[b]=null,&quot;string&quot;==typeof a)&amp;&amp;(s[ke+&quot;ON_PROPERTY&quot;+a]=null),U.zone.cancelTask(U),q?s:void 0}return v.apply(this,arguments)},O[u]=function(){const s=this||e;let a=arguments[0];d&amp;&amp;d.transferEventName&amp;&amp;(a=d.transferEventName(a));const h=[],w=et(s,X?X(a):a);for(let C=0;C&lt;w.length;C++){const k=w[C];h.push(k.originalDelegate?k.originalDelegate:k.callback)}return h},O[f]=function(){const s=this||e;let a=arguments[0];if(a){d&amp;&amp;d.transferEventName&amp;&amp;(a=d.transferEventName(a));const h=ee[a];if(h){const k=s[h[ie]],b=s[h[se]];if(k){const N=k.slice();for(let H=0;H&lt;N.length;H++){const U=N[H];this[c].call(this,a,U.originalDelegate?U.originalDelegate:U.callback,U.options)}}if(b){const N=b.slice();for(let H=0;H&lt;N.length;H++){const U=N[H];this[c].call(this,a,U.originalDelegate?U.originalDelegate:U.callback,U.options)}}}}else{const h=Object.keys(s);for(let w=0;w&lt;h.length;w++){const k=Je.exec(h[w]);let b=k&amp;&amp;k[1];b&amp;&amp;&quot;removeListener&quot;!==b&amp;&amp;this[f].call(this,b)}this[f].call(this,&quot;removeListener&quot;)}if(q)return this},ae(O[r],Y),ae(O[c],v),R&amp;&amp;ae(O[f],R),M&amp;&amp;ae(O[u],M),!0}let V=[];for(let E=0;E&lt;n.length;E++)V[E]=B(n[E],i);return V}function et(e,n){if(!n){const u=[];for(let f in e){const _=Je.exec(f);let y=_&amp;&amp;_[1];if(y&amp;&amp;(!n||y===n)){const T=e[f];if(T)for(let m=0;m&lt;T.length;m++)u.push(T[m])}}return u}let i=ee[n];i||(Qe(n),i=ee[n]);const r=e[i[ie]],c=e[i[se]];return r?c?r.concat(c):r.slice():c?c.slice():[]}function gt(e,n){const i=e.Event;i&amp;&amp;i.prototype&amp;&amp;n.patchMethod(i.prototype,&quot;stopImmediatePropagation&quot;,r=&gt;function(c,u){c[xe]=!0,r&amp;&amp;r.apply(c,u)})}function yt(e,n,i,r,c){const u=Zone.__symbol__(r);if(n[u])return;const f=n[u]=n[r];n[r]=function(_,y,T){return y&amp;&amp;y.prototype&amp;&amp;c.forEach(function(m){const S=`${i}.${r}::`+m,D=y.prototype;if(D.hasOwnProperty(m)){const Z=e.ObjectGetOwnPropertyDescriptor(D,m);Z&amp;&amp;Z.value?(Z.value=e.wrapWithCurrentZone(Z.value,S),e._redefineProperty(y.prototype,m,Z)):D[m]&amp;&amp;(D[m]=e.wrapWithCurrentZone(D[m],S))}else D[m]&amp;&amp;(D[m]=e.wrapWithCurrentZone(D[m],S))}),f.call(n,_,y,T)},e.attachOriginToPatched(n[r],f)}const Ve=[&quot;absolutedeviceorientation&quot;,&quot;afterinput&quot;,&quot;afterprint&quot;,&quot;appinstalled&quot;,&quot;beforeinstallprompt&quot;,&quot;beforeprint&quot;,&quot;beforeunload&quot;,&quot;devicelight&quot;,&quot;devicemotion&quot;,&quot;deviceorientation&quot;,&quot;deviceorientationabsolute&quot;,&quot;deviceproximity&quot;,&quot;hashchange&quot;,&quot;languagechange&quot;,&quot;message&quot;,&quot;mozbeforepaint&quot;,&quot;offline&quot;,&quot;online&quot;,&quot;paint&quot;,&quot;pageshow&quot;,&quot;pagehide&quot;,&quot;popstate&quot;,&quot;rejectionhandled&quot;,&quot;storage&quot;,&quot;unhandledrejection&quot;,&quot;unload&quot;,&quot;userproximity&quot;,&quot;vrdisplayconnected&quot;,&quot;vrdisplaydisconnected&quot;,&quot;vrdisplaypresentchange&quot;],wt=[&quot;encrypted&quot;,&quot;waitingforkey&quot;,&quot;msneedkey&quot;,&quot;mozinterruptbegin&quot;,&quot;mozinterruptend&quot;],tt=[&quot;load&quot;],nt=[&quot;blur&quot;,&quot;error&quot;,&quot;focus&quot;,&quot;load&quot;,&quot;resize&quot;,&quot;scroll&quot;,&quot;messageerror&quot;],Dt=[&quot;bounce&quot;,&quot;finish&quot;,&quot;start&quot;],rt=[&quot;loadstart&quot;,&quot;progress&quot;,&quot;abort&quot;,&quot;error&quot;,&quot;load&quot;,&quot;progress&quot;,&quot;timeout&quot;,&quot;loadend&quot;,&quot;readystatechange&quot;],Ee=[&quot;upgradeneeded&quot;,&quot;complete&quot;,&quot;abort&quot;,&quot;success&quot;,&quot;error&quot;,&quot;blocked&quot;,&quot;versionchange&quot;,&quot;close&quot;],St=[&quot;close&quot;,&quot;error&quot;,&quot;open&quot;,&quot;message&quot;],Ot=[&quot;error&quot;,&quot;message&quot;],Te=[&quot;abort&quot;,&quot;animationcancel&quot;,&quot;animationend&quot;,&quot;animationiteration&quot;,&quot;auxclick&quot;,&quot;beforeinput&quot;,&quot;blur&quot;,&quot;cancel&quot;,&quot;canplay&quot;,&quot;canplaythrough&quot;,&quot;change&quot;,&quot;compositionstart&quot;,&quot;compositionupdate&quot;,&quot;compositionend&quot;,&quot;cuechange&quot;,&quot;click&quot;,&quot;close&quot;,&quot;contextmenu&quot;,&quot;curechange&quot;,&quot;dblclick&quot;,&quot;drag&quot;,&quot;dragend&quot;,&quot;dragenter&quot;,&quot;dragexit&quot;,&quot;dragleave&quot;,&quot;dragover&quot;,&quot;drop&quot;,&quot;durationchange&quot;,&quot;emptied&quot;,&quot;ended&quot;,&quot;error&quot;,&quot;focus&quot;,&quot;focusin&quot;,&quot;focusout&quot;,&quot;gotpointercapture&quot;,&quot;input&quot;,&quot;invalid&quot;,&quot;keydown&quot;,&quot;keypress&quot;,&quot;keyup&quot;,&quot;load&quot;,&quot;loadstart&quot;,&quot;loadeddata&quot;,&quot;loadedmetadata&quot;,&quot;lostpointercapture&quot;,&quot;mousedown&quot;,&quot;mouseenter&quot;,&quot;mouseleave&quot;,&quot;mousemove&quot;,&quot;mouseout&quot;,&quot;mouseover&quot;,&quot;mouseup&quot;,&quot;mousewheel&quot;,&quot;orientationchange&quot;,&quot;pause&quot;,&quot;play&quot;,&quot;playing&quot;,&quot;pointercancel&quot;,&quot;pointerdown&quot;,&quot;pointerenter&quot;,&quot;pointerleave&quot;,&quot;pointerlockchange&quot;,&quot;mozpointerlockchange&quot;,&quot;webkitpointerlockerchange&quot;,&quot;pointerlockerror&quot;,&quot;mozpointerlockerror&quot;,&quot;webkitpointerlockerror&quot;,&quot;pointermove&quot;,&quot;pointout&quot;,&quot;pointerover&quot;,&quot;pointerup&quot;,&quot;progress&quot;,&quot;ratechange&quot;,&quot;reset&quot;,&quot;resize&quot;,&quot;scroll&quot;,&quot;seeked&quot;,&quot;seeking&quot;,&quot;select&quot;,&quot;selectionchange&quot;,&quot;selectstart&quot;,&quot;show&quot;,&quot;sort&quot;,&quot;stalled&quot;,&quot;submit&quot;,&quot;suspend&quot;,&quot;timeupdate&quot;,&quot;volumechange&quot;,&quot;touchcancel&quot;,&quot;touchmove&quot;,&quot;touchstart&quot;,&quot;touchend&quot;,&quot;transitioncancel&quot;,&quot;transitionend&quot;,&quot;waiting&quot;,&quot;wheel&quot;].concat([&quot;webglcontextrestored&quot;,&quot;webglcontextlost&quot;,&quot;webglcontextcreationerror&quot;],[&quot;autocomplete&quot;,&quot;autocompleteerror&quot;],[&quot;toggle&quot;],[&quot;afterscriptexecute&quot;,&quot;beforescriptexecute&quot;,&quot;DOMContentLoaded&quot;,&quot;freeze&quot;,&quot;fullscreenchange&quot;,&quot;mozfullscreenchange&quot;,&quot;webkitfullscreenchange&quot;,&quot;msfullscreenchange&quot;,&quot;fullscreenerror&quot;,&quot;mozfullscreenerror&quot;,&quot;webkitfullscreenerror&quot;,&quot;msfullscreenerror&quot;,&quot;readystatechange&quot;,&quot;visibilitychange&quot;,&quot;resume&quot;],Ve,[&quot;beforecopy&quot;,&quot;beforecut&quot;,&quot;beforepaste&quot;,&quot;copy&quot;,&quot;cut&quot;,&quot;paste&quot;,&quot;dragstart&quot;,&quot;loadend&quot;,&quot;animationstart&quot;,&quot;search&quot;,&quot;transitionrun&quot;,&quot;transitionstart&quot;,&quot;webkitanimationend&quot;,&quot;webkitanimationiteration&quot;,&quot;webkitanimationstart&quot;,&quot;webkittransitionend&quot;],[&quot;activate&quot;,&quot;afterupdate&quot;,&quot;ariarequest&quot;,&quot;beforeactivate&quot;,&quot;beforedeactivate&quot;,&quot;beforeeditfocus&quot;,&quot;beforeupdate&quot;,&quot;cellchange&quot;,&quot;controlselect&quot;,&quot;dataavailable&quot;,&quot;datasetchanged&quot;,&quot;datasetcomplete&quot;,&quot;errorupdate&quot;,&quot;filterchange&quot;,&quot;layoutcomplete&quot;,&quot;losecapture&quot;,&quot;move&quot;,&quot;moveend&quot;,&quot;movestart&quot;,&quot;propertychange&quot;,&quot;resizeend&quot;,&quot;resizestart&quot;,&quot;rowenter&quot;,&quot;rowexit&quot;,&quot;rowsdelete&quot;,&quot;rowsinserted&quot;,&quot;command&quot;,&quot;compassneedscalibration&quot;,&quot;deactivate&quot;,&quot;help&quot;,&quot;mscontentzoom&quot;,&quot;msmanipulationstatechanged&quot;,&quot;msgesturechange&quot;,&quot;msgesturedoubletap&quot;,&quot;msgestureend&quot;,&quot;msgesturehold&quot;,&quot;msgesturestart&quot;,&quot;msgesturetap&quot;,&quot;msgotpointercapture&quot;,&quot;msinertiastart&quot;,&quot;mslostpointercapture&quot;,&quot;mspointercancel&quot;,&quot;mspointerdown&quot;,&quot;mspointerenter&quot;,&quot;mspointerhover&quot;,&quot;mspointerleave&quot;,&quot;mspointermove&quot;,&quot;mspointerout&quot;,&quot;mspointerover&quot;,&quot;mspointerup&quot;,&quot;pointerout&quot;,&quot;mssitemodejumplistitemremoved&quot;,&quot;msthumbnailclick&quot;,&quot;stop&quot;,&quot;storagecommit&quot;]);function ot(e,n,i){if(!i||0===i.length)return n;const r=i.filter(u=&gt;u.target===e);if(!r||0===r.length)return n;const c=r[0].ignoreProperties;return n.filter(u=&gt;-1===c.indexOf(u))}function W(e,n,i,r){e&amp;&amp;Ye(e,ot(e,n,i),r)}Zone.__load_patch(&quot;util&quot;,(e,n,i)=&gt;{i.patchOnProperties=Ye,i.patchMethod=ce,i.bindArguments=Ae,i.patchMacroTask=_t;const r=n.__symbol__(&quot;BLACK_LISTED_EVENTS&quot;),c=n.__symbol__(&quot;UNPATCHED_EVENTS&quot;);e[c]&amp;&amp;(e[r]=e[c]),e[r]&amp;&amp;(n[r]=n[c]=e[r]),i.patchEventPrototype=gt,i.patchEventTarget=Tt,i.isIEOrEdge=mt,i.ObjectDefineProperty=he,i.ObjectGetOwnPropertyDescriptor=ue,i.ObjectCreate=Be,i.ArraySlice=ut,i.patchClass=ve,i.wrapWithCurrentZone=Le,i.filterProperties=ot,i.attachOriginToPatched=ae,i._redefineProperty=Object.defineProperty,i.patchCallbacks=yt,i.getGlobalObjects=()=&gt;({globalSources:Ke,zoneSymbolEventNames:ee,eventNames:Te,isBrowser:je,isMix:We,isNode:Re,TRUE_STR:se,FALSE_STR:ie,ZONE_SYMBOL_PREFIX:ke,ADD_EVENT_LISTENER_STR:Se,REMOVE_EVENT_LISTENER_STR:Oe})});const Ne=x(&quot;zoneTask&quot;);function ge(e,n,i,r){let c=null,u=null;i+=r;const f={};function _(T){const m=T.data;return m.args[0]=function(){return T.invoke.apply(this,arguments)},m.handleId=c.apply(e,m.args),T}function y(T){return u.call(e,T.data.handleId)}c=ce(e,n+=r,T=&gt;function(m,S){if(&quot;function&quot;==typeof S[0]){const D={isPeriodic:&quot;Interval&quot;===r,delay:&quot;Timeout&quot;===r||&quot;Interval&quot;===r?S[1]||0:void 0,args:S},Z=S[0];S[0]=function(){try{return Z.apply(this,arguments)}finally{D.isPeriodic||(&quot;number&quot;==typeof D.handleId?delete f[D.handleId]:D.handleId&amp;&amp;(D.handleId[Ne]=null))}};const B=Me(n,S[0],D,_,y);if(!B)return B;const V=B.data.handleId;return&quot;number&quot;==typeof V?f[V]=B:V&amp;&amp;(V[Ne]=B),V&amp;&amp;V.ref&amp;&amp;V.unref&amp;&amp;&quot;function&quot;==typeof V.ref&amp;&amp;&quot;function&quot;==typeof V.unref&amp;&amp;(B.ref=V.ref.bind(V),B.unref=V.unref.bind(V)),&quot;number&quot;==typeof V||V?V:B}return T.apply(e,S)}),u=ce(e,i,T=&gt;function(m,S){const D=S[0];let Z;&quot;number&quot;==typeof D?Z=f[D]:(Z=D&amp;&amp;D[Ne],Z||(Z=D)),Z&amp;&amp;&quot;string&quot;==typeof Z.type?&quot;notScheduled&quot;!==Z.state&amp;&amp;(Z.cancelFn&amp;&amp;Z.data.isPeriodic||0===Z.runCount)&amp;&amp;(&quot;number&quot;==typeof D?delete f[D]:D&amp;&amp;(D[Ne]=null),Z.zone.cancelTask(Z)):T.apply(e,S)})}Zone.__load_patch(&quot;legacy&quot;,e=&gt;{const n=e[Zone.__symbol__(&quot;legacyPatch&quot;)];n&amp;&amp;n()}),Zone.__load_patch(&quot;queueMicrotask&quot;,(e,n,i)=&gt;{i.patchMethod(e,&quot;queueMicrotask&quot;,r=&gt;function(c,u){n.current.scheduleMicroTask(&quot;queueMicrotask&quot;,u[0])})}),Zone.__load_patch(&quot;timers&quot;,e=&gt;{const n=&quot;set&quot;,i=&quot;clear&quot;;ge(e,n,i,&quot;Timeout&quot;),ge(e,n,i,&quot;Interval&quot;),ge(e,n,i,&quot;Immediate&quot;)}),Zone.__load_patch(&quot;requestAnimationFrame&quot;,e=&gt;{ge(e,&quot;request&quot;,&quot;cancel&quot;,&quot;AnimationFrame&quot;),ge(e,&quot;mozRequest&quot;,&quot;mozCancel&quot;,&quot;AnimationFrame&quot;),ge(e,&quot;webkitRequest&quot;,&quot;webkitCancel&quot;,&quot;AnimationFrame&quot;)}),Zone.__load_patch(&quot;blocking&quot;,(e,n)=&gt;{const i=[&quot;alert&quot;,&quot;prompt&quot;,&quot;confirm&quot;];for(let r=0;r&lt;i.length;r++)ce(e,i[r],(u,f,_)=&gt;function(y,T){return n.current.run(u,e,T,_)})}),Zone.__load_patch(&quot;EventTarget&quot;,(e,n,i)=&gt;{(function(e,n){n.patchEventPrototype(e,n)})(e,i),function(e,n){if(Zone[n.symbol(&quot;patchEventTarget&quot;)])return;const{eventNames:i,zoneSymbolEventNames:r,TRUE_STR:c,FALSE_STR:u,ZONE_SYMBOL_PREFIX:f}=n.getGlobalObjects();for(let y=0;y&lt;i.length;y++){const T=i[y],D=f+(T+u),Z=f+(T+c);r[T]={},r[T][u]=D,r[T][c]=Z}const _=e.EventTarget;_&amp;&amp;_.prototype&amp;&amp;n.patchEventTarget(e,[_&amp;&amp;_.prototype])}(e,i);const r=e.XMLHttpRequestEventTarget;r&amp;&amp;r.prototype&amp;&amp;i.patchEventTarget(e,[r.prototype])}),Zone.__load_patch(&quot;MutationObserver&quot;,(e,n,i)=&gt;{ve(&quot;MutationObserver&quot;),ve(&quot;WebKitMutationObserver&quot;)}),Zone.__load_patch(&quot;IntersectionObserver&quot;,(e,n,i)=&gt;{ve(&quot;IntersectionObserver&quot;)}),Zone.__load_patch(&quot;FileReader&quot;,(e,n,i)=&gt;{ve(&quot;FileReader&quot;)}),Zone.__load_patch(&quot;on_property&quot;,(e,n,i)=&gt;{!function(e,n){if(Re&amp;&amp;!We||Zone[e.symbol(&quot;patchEvents&quot;)])return;const i=&quot;undefined&quot;!=typeof WebSocket,r=n.__Zone_ignore_on_properties;if(je){const f=window,_=function(){try{const e=pe.navigator.userAgent;if(-1!==e.indexOf(&quot;MSIE &quot;)||-1!==e.indexOf(&quot;Trident/&quot;))return!0}catch(e){}return!1}()?[{target:f,ignoreProperties:[&quot;error&quot;]}]:[];W(f,Te.concat([&quot;messageerror&quot;]),r&amp;&amp;r.concat(_),de(f)),W(Document.prototype,Te,r),void 0!==f.SVGElement&amp;&amp;W(f.SVGElement.prototype,Te,r),W(Element.prototype,Te,r),W(HTMLElement.prototype,Te,r),W(HTMLMediaElement.prototype,wt,r),W(HTMLFrameSetElement.prototype,Ve.concat(nt),r),W(HTMLBodyElement.prototype,Ve.concat(nt),r),W(HTMLFrameElement.prototype,tt,r),W(HTMLIFrameElement.prototype,tt,r);const y=f.HTMLMarqueeElement;y&amp;&amp;W(y.prototype,Dt,r);const T=f.Worker;T&amp;&amp;W(T.prototype,Ot,r)}const c=n.XMLHttpRequest;c&amp;&amp;W(c.prototype,rt,r);const u=n.XMLHttpRequestEventTarget;u&amp;&amp;W(u&amp;&amp;u.prototype,rt,r),&quot;undefined&quot;!=typeof IDBIndex&amp;&amp;(W(IDBIndex.prototype,Ee,r),W(IDBRequest.prototype,Ee,r),W(IDBOpenDBRequest.prototype,Ee,r),W(IDBDatabase.prototype,Ee,r),W(IDBTransaction.prototype,Ee,r),W(IDBCursor.prototype,Ee,r)),i&amp;&amp;W(WebSocket.prototype,St,r)}(i,e)}),Zone.__load_patch(&quot;customElements&quot;,(e,n,i)=&gt;{!function(e,n){const{isBrowser:i,isMix:r}=n.getGlobalObjects();(i||r)&amp;&amp;e.customElements&amp;&amp;&quot;customElements&quot;in e&amp;&amp;n.patchCallbacks(n,e.customElements,&quot;customElements&quot;,&quot;define&quot;,[&quot;connectedCallback&quot;,&quot;disconnectedCallback&quot;,&quot;adoptedCallback&quot;,&quot;attributeChangedCallback&quot;])}(e,i)}),Zone.__load_patch(&quot;XHR&quot;,(e,n)=&gt;{!function(T){const m=T.XMLHttpRequest;if(!m)return;const S=m.prototype;let Z=S[Ze],B=S[Ie];if(!Z){const v=T.XMLHttpRequestEventTarget;if(v){const M=v.prototype;Z=M[Ze],B=M[Ie]}}const V=&quot;readystatechange&quot;,E=&quot;scheduled&quot;;function d(v){const M=v.data,R=M.target;R[u]=!1,R[_]=!1;const J=R[c];Z||(Z=R[Ze],B=R[Ie]),J&amp;&amp;B.call(R,V,J);const le=R[c]=()=&gt;{if(R.readyState===R.DONE)if(!M.aborted&amp;&amp;R[u]&amp;&amp;v.state===E){const te=R[n.__symbol__(&quot;loadfalse&quot;)];if(0!==R.status&amp;&amp;te&amp;&amp;te.length&gt;0){const re=v.invoke;v.invoke=function(){const F=R[n.__symbol__(&quot;loadfalse&quot;)];for(let I=0;I&lt;F.length;I++)F[I]===v&amp;&amp;F.splice(I,1);!M.aborted&amp;&amp;v.state===E&amp;&amp;re.call(v)},te.push(v)}else v.invoke()}else!M.aborted&amp;&amp;!1===R[u]&amp;&amp;(R[_]=!0)};return Z.call(R,V,le),R[i]||(R[i]=v),A.apply(R,M.args),R[u]=!0,v}function L(){}function z(v){const M=v.data;return M.aborted=!0,Y.apply(M.target,M.args)}const j=ce(S,&quot;open&quot;,()=&gt;function(v,M){return v[r]=0==M[2],v[f]=M[1],j.apply(v,M)}),O=x(&quot;fetchTaskAborting&quot;),X=x(&quot;fetchTaskScheduling&quot;),A=ce(S,&quot;send&quot;,()=&gt;function(v,M){if(!0===n.current[X]||v[r])return A.apply(v,M);{const R={target:v,url:v[f],isPeriodic:!1,args:M,aborted:!1},J=Me(&quot;XMLHttpRequest.send&quot;,L,R,d,z);v&amp;&amp;!0===v[_]&amp;&amp;!R.aborted&amp;&amp;J.state===E&amp;&amp;J.invoke()}}),Y=ce(S,&quot;abort&quot;,()=&gt;function(v,M){const R=function(v){return v[i]}(v);if(R&amp;&amp;&quot;string&quot;==typeof R.type){if(null==R.cancelFn||R.data&amp;&amp;R.data.aborted)return;R.zone.cancelTask(R)}else if(!0===n.current[O])return Y.apply(v,M)})}(e);const i=x(&quot;xhrTask&quot;),r=x(&quot;xhrSync&quot;),c=x(&quot;xhrListener&quot;),u=x(&quot;xhrScheduled&quot;),f=x(&quot;xhrURL&quot;),_=x(&quot;xhrErrorBeforeScheduled&quot;)}),Zone.__load_patch(&quot;geolocation&quot;,e=&gt;{e.navigator&amp;&amp;e.navigator.geolocation&amp;&amp;function(e,n){const i=e.constructor.name;for(let r=0;r&lt;n.length;r++){const c=n[r],u=e[c];if(u){if(!Fe(ue(e,c)))continue;e[c]=(_=&gt;{const y=function(){return _.apply(this,Ae(arguments,i+&quot;.&quot;+c))};return ae(y,_),y})(u)}}}(e.navigator.geolocation,[&quot;getCurrentPosition&quot;,&quot;watchPosition&quot;])}),Zone.__load_patch(&quot;PromiseRejectionEvent&quot;,(e,n)=&gt;{function i(r){return function(c){et(e,r).forEach(f=&gt;{const _=e.PromiseRejectionEvent;if(_){const y=new _(r,{promise:c.promise,reason:c.rejection});f.invoke(y)}})}}e.PromiseRejectionEvent&amp;&amp;(n[x(&quot;unhandledPromiseRejectionHandler&quot;)]=i(&quot;unhandledrejection&quot;),n[x(&quot;rejectionHandledHandler&quot;)]=i(&quot;rejectionhandled&quot;))})},435:(we,ue,he)=&gt;{he(277)}},we=&gt;{we(we.s=435)}]);</code></pre>
				
				
			</details></td>
	</tr>
	
	
	<tr>
		<th scope="row">Evidence</th>
		<td><pre><code>select</code></pre></td>
	</tr>
	<tr>
		<th scope="row">Solution</th>
		<td> 
<p>Remove all comments that return information that may help an attacker and fix any underlying problems they refer to.</p>
 </td>
	</tr>
</table>

											</details></li>
									</ol>
								</li>
								
							</ol>
						</li>
						
					</ol>
				</li>
				  
			</ol>
		</section>

		<section id="appendix" class="appendix">
			<h2>Appendix</h2>

			<section id="alert-types" class="alert-types">
				<h3>Alert types</h3>
				<p class="alert-types-intro">This section contains additional information on the types of alerts in the report.</p>
				<ol>
					<li
						id="alert-type-0">
						<h4>Cross-Domain JavaScript Source File Inclusion</h4>
						<table class="alert-types-table">
							<tr>
								<th scope="row">Source</th>
								<td>
									
									   <span>raised by a passive scanner</span> <span>(<a
										href="https://www.zaproxy.org/docs/alerts/10017/">Cross-Domain JavaScript Source File Inclusion</a>)
									</span>   
								</td>
							</tr>
							<tr>
								<th scope="row">CWE ID</th>
								<td><a
									href="https://cwe.mitre.org/data/definitions/829.html">829</a></td>
							</tr>
							<tr>
								<th scope="row">WASC ID</th>
								<td>15</td>
							</tr>
							
						</table>
					</li>
					<li
						id="alert-type-1">
						<h4>Timestamp Disclosure - Unix</h4>
						<table class="alert-types-table">
							<tr>
								<th scope="row">Source</th>
								<td>
									
									   <span>raised by a passive scanner</span> <span>(<a
										href="https://www.zaproxy.org/docs/alerts/10096/">Timestamp Disclosure</a>)
									</span>   
								</td>
							</tr>
							<tr>
								<th scope="row">CWE ID</th>
								<td><a
									href="https://cwe.mitre.org/data/definitions/200.html">200</a></td>
							</tr>
							<tr>
								<th scope="row">WASC ID</th>
								<td>13</td>
							</tr>
							<tr>
								<th scope="row">Reference</th>
								<td>
									<ol>
										<li><a
											href="http://projects.webappsec.org/w/page/13246936/Information%20Leakage">http://projects.webappsec.org/w/page/13246936/Information%20Leakage</a></li>
									</ol>
								</td>
							</tr>
						</table>
					</li>
					<li
						id="alert-type-2">
						<h4>Information Disclosure - Sensitive Information in URL</h4>
						<table class="alert-types-table">
							<tr>
								<th scope="row">Source</th>
								<td>
									
									   <span>raised by a passive scanner</span> <span>(<a
										href="https://www.zaproxy.org/docs/alerts/10024/">Information Disclosure - Sensitive Information in URL</a>)
									</span>   
								</td>
							</tr>
							<tr>
								<th scope="row">CWE ID</th>
								<td><a
									href="https://cwe.mitre.org/data/definitions/200.html">200</a></td>
							</tr>
							<tr>
								<th scope="row">WASC ID</th>
								<td>13</td>
							</tr>
							
						</table>
					</li>
					<li
						id="alert-type-3">
						<h4>Information Disclosure - Suspicious Comments</h4>
						<table class="alert-types-table">
							<tr>
								<th scope="row">Source</th>
								<td>
									
									   <span>raised by a passive scanner</span> <span>(<a
										href="https://www.zaproxy.org/docs/alerts/10027/">Information Disclosure - Suspicious Comments</a>)
									</span>   
								</td>
							</tr>
							<tr>
								<th scope="row">CWE ID</th>
								<td><a
									href="https://cwe.mitre.org/data/definitions/200.html">200</a></td>
							</tr>
							<tr>
								<th scope="row">WASC ID</th>
								<td>13</td>
							</tr>
							
						</table>
					</li>
				</ol>
			</section>
		</section>
		 
	</main>
</body>
</html>



